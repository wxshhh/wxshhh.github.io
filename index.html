<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>从入门到入土</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="中国科学技术大学软件工程在读">
<meta property="og:type" content="website">
<meta property="og:title" content="从入门到入土">
<meta property="og:url" content="http://wxshhh.github.io/index.html">
<meta property="og:site_name" content="从入门到入土">
<meta property="og:description" content="中国科学技术大学软件工程在读">
<meta property="og:locale">
<meta property="article:author" content="wxshhh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="从入门到入土" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">从入门到入土</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wxshhh.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-【考研】考研奋斗日程记录！" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%80%83%E7%A0%94%E5%A5%8B%E6%96%97%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%81/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.751Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%80%83%E7%A0%94/">考研</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%80%83%E7%A0%94%E5%A5%8B%E6%96%97%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%81/">【考研】考研冲冲冲！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h1><blockquote>
<p>十月计划</p>
<p><strong>数学</strong></p>
<table>
<thead>
<tr>
<th align="left">时限</th>
<th>具体内容</th>
<th>计划日期</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数二真题</td>
<td>结束十七堂课或者在十七堂课还没更新的时候刷<br />从 21 年真题练手<br />先做奇数年：11、13、15、19<br />再做偶数年：12、14、16、20<br />一遍过后二刷，针对<strong>重点题和错题</strong><br />留 17（简单）、18（难）两年最后模拟<br />再之后可以参考张宇&#x2F;李正元真题解析进行三刷</td>
<td>每天一篇，月底前近十年全部刷完</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">武忠祥十七堂课</td>
<td>做完卷子以后，针对错题较多的专题，看武忠祥十七堂课进行查漏补缺</td>
<td>做完真题后视情况看</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">每日一题</td>
<td></td>
<td>抽空就做</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>408</strong></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>具体内容</th>
<th>计划日期</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>OS 三轮</td>
<td>边部充思维导图，边过第三轮单科书</td>
<td>十号之前解决</td>
<td></td>
</tr>
<tr>
<td>计组三轮</td>
<td>同上</td>
<td>一天 1 ~ 2 小节，25 号之前解决</td>
<td></td>
</tr>
<tr>
<td>DS 三轮</td>
<td>同上</td>
<td>过快一点，月底拿下</td>
<td></td>
</tr>
</tbody></table>
<p>英语</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>具体内容</th>
<th>计划日期计划日期</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>单词词组</td>
<td>每天单词&#x2F;词组 x 400，过完这轮词组继续过单词</td>
<td>一直背到考研前</td>
<td></td>
</tr>
<tr>
<td>英二真题</td>
<td>一天 1~2 篇阅读或完型或七选五和翻译</td>
<td>3 ~ 4 天一套，先做着</td>
<td></td>
</tr>
<tr>
<td>作文</td>
<td>看王江涛作文书</td>
<td>月底前开始准备</td>
<td></td>
</tr>
</tbody></table>
<p>政治</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>具体内容</th>
<th>计划日期</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>毛中特强化</td>
<td>一天 1 ~ 2 小节</td>
<td>25 号左右结束</td>
<td></td>
</tr>
<tr>
<td>思修强化</td>
<td>同上</td>
<td>月底争取结束</td>
<td></td>
</tr>
<tr>
<td>小程序</td>
<td>边看课边做小程序</td>
<td>跟强化课同步</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h1 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h1><blockquote>
<p>九月总结：</p>
<ul>
<li><p>数学</p>
<ol>
<li>回顾线代讲义 √</li>
<li>660 线代（比较简单，快快刷完） √</li>
<li>880 综合题（基础题错题软件原因之前做的丢了，880 大题还是挺有难度，还有好多题只是做完了但是感觉还没有吃透）  √</li>
<li>每日一题 （冲刺 120 分里有些题还是挺好的，需要抽空回顾） √</li>
<li>高数辅导讲义例题回顾了差不多一半，后面的没坚持下去</li>
</ol>
</li>
<li><p>408</p>
<ol>
<li>OS 二轮 √</li>
<li>计组和 OS 知识点总结 没抽出空做（可能是懒） ×</li>
<li>计网 差不多按计划结束 √</li>
<li>王道强化：计网、OS √</li>
<li>每日一题 云记把原来记录丢了以后就没再坚持 ×</li>
</ol>
</li>
<li><p>英语</p>
<ol>
<li><p>每日单词，一直有坚持 √</p>
</li>
<li><p>真题，英一做到 16 年，之后再没做，转做了英二（除了作文其他都刷）</p>
</li>
</ol>
</li>
<li><p>政治</p>
<ol>
<li>马原强化（学的有点快，知识点还是有点模糊） √</li>
<li>史纲强化（要记得东西好多，好多都没记住） √</li>
<li>刷对应小程序 √</li>
</ol>
</li>
</ul>
<p>整体上按计划稳步推进！</p>
</blockquote>
<blockquote>
<p>九月计划：</p>
<ul>
<li>数学（早上 8：00 ~ 12：00）<ol>
<li>回顾复盘线代讲义知识点和例题（3 ~ 5 天）</li>
<li>660 线代部分（3 ~ 5 天）</li>
<li>补完 660 线代部分以后开始刷 880（按上个月计划刷基础篇错题和重点题和综合篇的题）</li>
<li>每天留一个小时做每日一题以及回顾高数讲义例题</li>
</ol>
</li>
<li>408（下午 2：00 ~ 5&#x2F;6：00）<ol>
<li>OS 二轮（还剩 5 小节， 差不多 3 ~ 5 天拿下）</li>
<li>计组知识点总结（剩第二章、第三章、第四章）</li>
<li>过完 OS 二轮、计组知识点整理好以后，开始计网（共约30小节，一天 2 ~ 3 小节，20 号之前解决）</li>
<li>剩下的时间整理各科笔记，再抽空看看王道强化课</li>
<li>坚持每日一题</li>
</ol>
</li>
<li>英语<ul>
<li>每天 300 个单词</li>
<li>真题每天一篇 + 看唐迟讲解，月底差不多过完英一第一轮</li>
</ul>
</li>
<li>政治（晚上八点以后）<ul>
<li>徐涛强化班 马原每天 2 ~ 3 课</li>
<li>政治刷题小程序刷响应的题</li>
</ul>
</li>
</ul>
<p>九月，冲冲冲！</p>
</blockquote>
<h3 id="9-13-10-3"><a href="#9-13-10-3" class="headerlink" title="9.13 ~ 10.3"></a>9.13 ~ 10.3</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>880 所有章节综合题部分全部刷完</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>计网二轮过完</li>
<li>计网强化课（传输层、网络层大题）</li>
<li>操作系统大题（进程同步与互斥、页式存储管理与虚拟存储器、文件系统大题）</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>每天单词 x 400</li>
<li>真题 英二 2015、2014、2013</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>徐涛 马原强化班 + 小程序 1000 题 结束</li>
<li>徐涛 史纲强化班 + 小程序 1000 题 结束</li>
</ol>
<h3 id="9-10、9-11、9-12"><a href="#9-10、9-11、9-12" class="headerlink" title="9.10、9.11、9.12"></a>9.10、9.11、9.12</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 剩下线代部分全部做完</li>
<li>880 重点题 第一章 函数、极限、连续</li>
<li>每日一题 函数</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>计网</p>
<ul>
<li><p>3.4 流量控制和可靠传输</p>
<ul>
<li>滑动窗口：停等协议、后退 N 帧协议、选择重传协议</li>
</ul>
</li>
<li><p>3.5 介质访问控制</p>
<ul>
<li>信道划分：FDM、TDM、WDM、CDM</li>
<li>随机访问：ALOHA 协议、CSMA 协议、CSMA&#x2F;CD 协议、CSMA&#x2F;CA 协议</li>
<li>轮询访问</li>
</ul>
</li>
<li><p>3.6 局域网</p>
<ul>
<li><p>局域网概念</p>
</li>
<li><p>以太网 和 IEEE 802.3</p>
</li>
<li><p>WLAN 和 IEEE 802.11</p>
</li>
<li><p>令牌环网 和 IEEE 802.5</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>每日一题</p>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 300 x 3</li>
<li>真题<ul>
<li>2015Text4</li>
<li>2016Text1</li>
<li>2016Text2</li>
</ul>
</li>
</ol>
<h3 id="9-8、9-9"><a href="#9-8、9-9" class="headerlink" title="9.8、9.9"></a>9.8、9.9</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 线代部分：308 ~ 390</li>
<li>每日一题：二重积分</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>计算机网络二轮<ul>
<li>2.1 通信基础、2.2 介质传输、2.3 物理层设备、3.1 链路层功能、3.2 组帧、3.3 差错控制</li>
</ul>
</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 300 x 2</li>
<li>真题 <ul>
<li>2015Text2 能否在没有逮捕令的情况下搜查嫌犯手机内容（错两个）</li>
<li>2015Text3 自然杂志新添加了统计审查（错一个）</li>
</ul>
</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>徐涛强化班 唯物史观刚开始<ul>
<li>社会存在</li>
<li>社会意识</li>
</ul>
</li>
<li>小程序刷 1000 题</li>
</ol>
<h3 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 线代部分：276 ~ 307</li>
<li>每日一题：二重积分</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>计算机网络二轮<ul>
<li>1.1 计算机网络概念</li>
<li>1.2 计算机网络体系与参考模型</li>
</ul>
</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 300</li>
<li>真题 2015Text1 一个例子给王室成员的警示（错一个）</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li><p>小程序刷 1000 题</p>
</li>
<li><p>徐涛强化 三小节</p>
<ul>
<li>认识</li>
<li>实践</li>
<li>真理与价值</li>
</ul>
</li>
</ol>
<h3 id="9-6"><a href="#9-6" class="headerlink" title="9.6"></a>9.6</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>回顾线代辅导讲义<ul>
<li>矩阵</li>
</ul>
</li>
<li>每日一题</li>
<li>回顾高数笔记</li>
</ol>
<p>明天起开始刷 660 线代部分<del>和 880 的高数部分</del></p>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>操作系统二轮<ul>
<li>5.2 IO 核心子系统</li>
</ul>
</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 200</li>
<li>真题 2014Text4 缺乏文学素养的教育和 “问题的核心” （错一个）</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>小程序刷题</li>
<li>徐涛马原强化<ul>
<li><strong>认识的来源：实践</strong></li>
<li>认识的本质</li>
<li>认识的过程</li>
<li>认识的规律</li>
</ul>
</li>
</ol>
<h3 id="9-4、9-5"><a href="#9-4、9-5" class="headerlink" title="9.4、9.5"></a>9.4、9.5</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>回顾线代辅导讲义<ul>
<li>行列式</li>
<li>矩阵</li>
</ul>
</li>
<li>回顾高数辅导讲义<ul>
<li>微分方程解法</li>
</ul>
</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>操作系统二轮 5.1 IO 概述</p>
</li>
<li><p>每日一题</p>
</li>
<li><p>计组知识点总结</p>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 200 x 2</li>
<li>真题<ul>
<li>2014 Text2 新设立的一些企业家资助的科学奖项（错两个）</li>
<li>2014 Text3 美国法律专业的问题和解决方法（错一个）</li>
</ul>
</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>徐涛马原强化课<ul>
<li>12 质量互变规律<ul>
<li>质、量、度</li>
<li>质变、量变</li>
</ul>
</li>
<li>13 否定之否定<ul>
<li>自我否定</li>
<li>扬弃</li>
<li>两次否定</li>
<li>螺旋上升</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="9-1、9-2、9-3"><a href="#9-1、9-2、9-3" class="headerlink" title="9.1、9.2、9.3"></a>9.1、9.2、9.3</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>回顾线代辅导讲义例题</li>
<li>每日一题</li>
<li>回顾高数辅导讲义例题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>OS 4.1 文件系统基础、4.2 文件系统实现（文件这一章有难度）</li>
<li>每日一题</li>
<li>王道操作系统强化课第一节（暂时感觉用处不大，还是继续啃王道书吧）</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 300 x 3</li>
<li>真题<ul>
<li>2013 Text3 人类光明的前途（错一个）</li>
<li>2013 Text4 亚利桑那州法案违反联邦权威（错一个，近十年 top3 难）</li>
<li>2014 Text1 对失业者领取救济金设限（错两个）</li>
</ul>
</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>马原徐涛强化<ul>
<li>总论和哲学基本问题</li>
<li>唯物论——物质观</li>
<li>唯物论——意识观</li>
<li>辩证法的两大总特征</li>
<li>辩证法五队范畴</li>
</ul>
</li>
<li>小程序断断续续刷题</li>
</ol>
<h1 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h1><blockquote>
<p>八月总结：</p>
<ul>
<li>数学<ul>
<li>600 刷完：√</li>
<li>660 复盘：×</li>
<li>坚持每日一题：√</li>
<li>线性代数强化（十讲）：√</li>
<li>回顾强化班高数辅导讲义例题：√</li>
</ul>
</li>
<li>408<ul>
<li>计组二轮：√</li>
<li>计组笔记：整理中</li>
<li>OS 二轮：复习中，已过半</li>
<li>每日一题：√</li>
</ul>
</li>
<li>英语<ul>
<li>每日单词：√ （6240&#x2F;6642，差不多结束）</li>
<li>阅读真题：√ （到 2013年Text2）</li>
</ul>
</li>
</ul>
<p>总体按计划稳步推进，但是效率还是不够高，浪费了很多时间</p>
<ul>
<li>早起以后光看新闻热搜了！</li>
<li>睡太迟或者没睡着导致第二天没状态，还要补觉</li>
<li>浪费很多时间在刷 知乎 和 b站上</li>
</ul>
</blockquote>
<blockquote>
<p>八月计划：</p>
<ul>
<li>数学（每天 4 - 5 个小时）<ol>
<li><p>八月中下旬（20号之前）刷完 660</p>
</li>
<li><p>20 号左右进行一次 660 的复盘整理，之后开始刷 880（重做画星号的题，同时做还没做的题）</p>
<p> （计划有变，880 先放一放，先把线代强化过了，预计十天解决）</p>
</li>
<li><p>坚持每日一题</p>
</li>
<li><p>刷题同时回顾强化班讲的例题</p>
</li>
</ol>
</li>
<li>408 （每天 3 - 4 个小时）<ol>
<li>计组约 20 小节，每天过 1 - 2 小节，月中下旬结束计组二轮复习。（复习过程中整理计组笔记）</li>
<li>计组复习结束后开始操作系统二轮复习，操作系统约 20 小节，同样每天 1 - 2 小节，在看计组中相对应的章节时回顾计组的内容。（同样边复习边整理笔记）</li>
<li>坚持刷每日一题。</li>
</ol>
</li>
<li>英语<ol>
<li>单词每天 300 个，差不多月底过完这一轮。</li>
<li>英一阅读真题每天一篇，看完后看唐迟视频或者自己翻译原文，到月底差不多进行到 2014 年。</li>
</ol>
</li>
</ul>
<p>每周周末坚持进行周末复盘！</p>
<p>八月，冲冲冲！</p>
</blockquote>
<h3 id="8-30"><a href="#8-30" class="headerlink" title="8.30"></a>8.30</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>线性代数强化 第八讲<ul>
<li>线性方程公共解的两种题型</li>
<li>线性方程同解<ul>
<li>$r(A)&#x3D;r(B)$</li>
<li>$AA^Tx&#x3D;0$ 与 $Ax&#x3D;0$ 通解</li>
</ul>
</li>
<li>方程组的应用<ul>
<li>$AX&#x3D;B$，求 $X$</li>
</ul>
</li>
<li>特征值和特征向量的求法（具体和抽象两种）<ul>
<li>三角矩阵：$λ_i&#x3D;a_{ii}$</li>
<li>$r(A)&#x3D;1$：$λ_1&#x3D;tr(A),λ_i&#x3D;0 \ (i≠1)$</li>
</ul>
</li>
<li>矩阵 $A$ 的特征值及其逆、伴随矩阵等等的特征值之间的关系</li>
</ul>
</li>
<li>每日一题</li>
<li>回顾高数辅导讲义<ul>
<li>定积分相关证明题<ul>
<li>$f(x)&#x3D;\int_0^x f^&#96;(t)dt$</li>
<li>拉格朗日</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>每日一题</li>
<li>操作系统二轮 3.2 虚拟内存管理<ul>
<li>请求分页管理方式（页表机制、缺页中断机构、地址变换机构）</li>
<li><strong>页面置换算法</strong><ul>
<li>OPT</li>
<li>FIFO</li>
<li>LRU（选择题技巧）</li>
<li>CLOCK</li>
</ul>
</li>
<li>页面分配策略<ul>
<li>固定分配局部置换</li>
<li>可变分配全局置换</li>
<li>可变分配局部置换（最优）</li>
</ul>
</li>
<li>抖动</li>
<li><strong>地址翻译</strong>（<strong>重中之重</strong>）</li>
</ul>
</li>
<li>计组笔记整理 3.7 虚拟存储器（与 OS 对应整理）</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 300</li>
<li>2013Text1 对快速消费产业的批评（全 √）<ul>
<li>否定 + 比较级 &#x3D; 最高级</li>
<li>dirt-cheap 非常便宜</li>
<li>feverish 发烧的，<strong>极度兴奋的，狂热的</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>小程序刷题：马原和史纲 day1</li>
</ol>
<h3 id="8-25、8-26、8-27、8-28"><a href="#8-25、8-26、8-27、8-28" class="headerlink" title="8.25、8.26、8.27、8.28"></a>8.25、8.26、8.27、8.28</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>线性代数强化 第四讲~第七讲</p>
<ul>
<li><p>正交矩阵  $AA^T&#x3D;E$</p>
</li>
<li><p>向量的线性相关与线性无关证明<br>  $$<br>  k_1 \alpha_1 + k_2 \alpha_2 +…+k_s \alpha_s&#x3D;0<br>  $$</p>
<ul>
<li>同乘或重组</li>
<li>求秩</li>
<li>反证法</li>
</ul>
</li>
<li><p>线性表出（联系齐次方程组）</p>
</li>
<li><p>极大无关组</p>
</li>
<li><p>重要定理</p>
<ul>
<li><strong>部分相关，整体相关</strong></li>
<li><strong>低维无关，高维无关</strong></li>
<li><strong>多被少表多相关，少被多表少无关</strong></li>
<li>……</li>
</ul>
</li>
<li><p>向量的秩</p>
</li>
<li><p>求解齐次和非齐次线性方程组（解的结构）</p>
</li>
<li><p>有解判定定理</p>
</li>
<li><p><strong>齐次方程组基础解系线性无关向量个数</strong>：$n-r(A)$</p>
</li>
</ul>
</li>
<li><p>每日一题</p>
<ul>
<li>$\int {ln(1+e^x) \over e^x} dx$</li>
<li><strong>区间再现法</strong></li>
</ul>
</li>
<li><p>回顾高数辅导讲义</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>每日一题</li>
<li>操作系统 <ul>
<li><strong>2.3 进程同步（核心！）</strong><ul>
<li>临界资源</li>
<li>同步与互斥</li>
<li>实现临界区互斥：单标志法、双标志法先检查、双标志法后检查、Pterson 算法</li>
<li>中断屏蔽方法、硬件指令方法（TestAndSet、Swap）</li>
<li>信号量</li>
<li>管程</li>
</ul>
</li>
<li><strong>2.4 死锁（重要！）</strong><ul>
<li>概念</li>
<li>产生原因</li>
<li>产生条件（互斥条件、不剥夺条件、请求并保持条件、循环等待条件）</li>
<li>处理策略<ul>
<li>死锁预防（破坏四个死锁产生条件）</li>
<li>死锁避免（银行家算法，避开不安全序列）</li>
<li>死锁检测与解除（资源图法）</li>
</ul>
</li>
</ul>
</li>
<li><strong>3.1内存管理概念（核心！）重点关注页式存储管理</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 300 x 4</li>
<li>真题<ul>
<li>2011Text4 父母受名流养孩子影响而对养孩子产生误解 （错两个）</li>
<li>2012Text1 peer pressure（全对）</li>
<li>2012Text2 Entergy 公司不讲信用（错一个）</li>
<li>2012Text3 科学证明的过程（错一个）</li>
</ul>
</li>
</ol>
<h3 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>李永乐线性代数强化第三讲<ul>
<li><p>矩阵的初等变换（<strong>左行右列</strong>）</p>
</li>
<li><p>特数矩阵的 n 次方</p>
<ul>
<li>秩为一（分解成一个行向量和一个列向量相乘）</li>
<li>三角矩阵且对角线元素为零</li>
<li>相似矩阵</li>
</ul>
</li>
<li><p>伴随矩阵</p>
<ul>
<li><p>$AA^{\star}&#x3D;|A|E$</p>
</li>
<li><p>矩阵的秩与其伴随矩阵秩的关系</p>
</li>
</ul>
</li>
<li><p>可逆矩阵</p>
<ul>
<li><p>$r(A) &#x3D; n \ |A|&#x3D;0$​</p>
</li>
<li><p>单位矩阵变换</p>
</li>
</ul>
</li>
</ul>
</li>
<li>高数辅导讲义例题回顾（不定积分的计算）</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>操作系统 2.2 处理机调度<ul>
<li>调度的概念、类型</li>
<li>调度算法的性能指标</li>
<li>典型的调度算法</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 300</li>
<li>真题 2011Text3 传统付款媒体的转变 （错 1 个，主旨题）</li>
</ol>
<h3 id="8-23"><a href="#8-23" class="headerlink" title="8.23"></a>8.23</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>李永乐线性代数强化第二讲</p>
<ul>
<li><p>证 $|A|&#x3D;0$ 的各种方法</p>
<ul>
<li>$r(A)&lt;n$</li>
<li>齐次方程组 $Ax&#x3D;0$ 有非零解</li>
<li>反证法，假设 $|A|≠0$</li>
<li>0 是 $A$ 的特征值</li>
<li>$|A|&#x3D;-|A|$（行列式是一个数）</li>
</ul>
</li>
<li><p>克拉默法则及其推论</p>
<ul>
<li>齐次方程组系数行列式不等于0 &lt;&#x3D;&gt; 方程只有零解</li>
<li>齐次方程组系数行列式等于0     &lt;&#x3D;&gt; 方程有非零解</li>
</ul>
</li>
<li><p>代数余子式求和</p>
<p>  $A_{ij}$ 的取值与 $a_{ij}$ 无关</p>
</li>
<li><p>矩阵乘法没有交换律，也不能乱消</p>
</li>
<li><p>伴随矩阵：代数余子式所构成的矩阵<br>  $$<br>  AA^{\ast}&#x3D;|A|E<br>  $$</p>
</li>
<li><p>2 阶矩阵的伴随矩阵：主对角元素互换，副对角元素变号</p>
</li>
<li><p>$A_{n\times m}, ; B_{m \times n},;AB&#x3D;O;$, 则有 $r(A)+r(B)\le m$​</p>
</li>
<li><p>n 阶分块矩阵、分块矩阵的逆</p>
</li>
<li><p>$\alpha^{T}\alpha$，$\alpha\alpha^T$​</p>
</li>
</ul>
</li>
<li><p>回顾周末做的阶段测试卷错题</p>
</li>
<li><p>回顾高数讲义，不定积分例题</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ul>
<li><p>操作系统（来到了操作系统的核心章节 进程管理）</p>
<p>  2.1 进程与线程</p>
<ul>
<li>进程的概念、特征</li>
<li>进程的状态（创建、就绪、运行、阻塞、结束）、状态切换</li>
<li>进程控制</li>
<li>进程组织、进程通信（共享存储、消息传递、管道通信）</li>
<li>线程的概念</li>
</ul>
</li>
</ul>
<blockquote>
<p>英语</p>
</blockquote>
<ul>
<li>墨墨单词 x 300</li>
<li>真题 2011Text2 高管没有找好下家的情况下跳槽（全对！）</li>
</ul>
<h3 id="8-21"><a href="#8-21" class="headerlink" title="8.21"></a>8.21</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>李永乐线性代数强化第一讲</li>
<li>高数辅导讲义例题回顾</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>操作系统 第一章 计算机系统概述</li>
<li>计组  第一章 总结</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 300</li>
<li>真题 2011Text1 纽约爱乐乐团新任指挥（错2，词汇！unpretentious）</li>
</ol>
<h3 id="8-17、8-18、8-19、8-20"><a href="#8-17、8-18、8-19、8-20" class="headerlink" title="8.17、8.18、8.19、8.20"></a>8.17、8.18、8.19、8.20</h3><blockquote>
<p>高数</p>
</blockquote>
<ol>
<li>660 541-610（660 高数部分，拿下）</li>
<li>每日一题（有空就做）</li>
<li>高数辅导讲义回顾（第二章 一元函数微分学 结束）</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>舒服计组</p>
<ul>
<li><p>第七章 IO系统 结束（计组二轮，拿下！）</p>
</li>
<li><p>整理第七章知识点</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 300 x 4</p>
</li>
<li><p>真题 2010Text1（错 2）、真题 2010Text2（错 3）、真题 2010Text3（错 2）、真题 2010Text4（错 1）</p>
<p> 真题从 2010 开始分英语一和英语二后，英语一题目难度感觉有明显的提升了（好多第一遍读不懂）</p>
</li>
</ol>
<h3 id="8-16"><a href="#8-16" class="headerlink" title="8.16"></a>8.16</h3><blockquote>
<p>高数</p>
</blockquote>
<ol>
<li><p>660 518-541 </p>
<p> 导数定义相关的题</p>
</li>
<li><p>每日一题 </p>
<p> 两道求解微分方程的题</p>
</li>
<li><p>回顾高数辅导讲义</p>
<ul>
<li><p>极值点和拐点的充分条件、必要条件</p>
</li>
<li><p>渐近线、曲率</p>
</li>
<li><p>一堆导数应用相关题目</p>
<p>  连续性、可导性、极值点、拐点、渐近线、方程的根、证明函数不等式</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>数据结构应用题</p>
<p> 用给定数组中的元素建堆，并根据堆排序从小到大输出元素</p>
</li>
<li><p>舒服计组</p>
<ul>
<li><p>6.4 总线标准</p>
<p>  ISA、EISA、、VEAS、PCI、PCI-Express、AGP、RS-232C、USB……</p>
</li>
<li><p>整理 第六章 总线 知识点</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 150</li>
<li>词根词缀 x 30min</li>
<li>真题 2009Text4 新英格兰人追求智慧（错一个）</li>
</ol>
<h3 id="8-13、8-14"><a href="#8-13、8-14" class="headerlink" title="8.13、8.14"></a>8.13、8.14</h3><blockquote>
<p>高数</p>
</blockquote>
<ol>
<li><p>660 491-517</p>
<ul>
<li><strong>函数在某点处连续不能说明在该点的去心邻域内连续</strong></li>
</ul>
</li>
<li><p>每日一题</p>
<p> 可分离变量的微分方程求通解</p>
</li>
<li><p>辅导讲义回顾</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><strong>链路层功能</strong>：物理地址寻址、数据封装成帧、流量控制、差错检验、数据的校验重发等</li>
<li><strong>RAM 引脚</strong>一般包括数据线、地址线、片选端和读写控制线</li>
</ul>
</li>
<li><p>死亡计组</p>
<ul>
<li><p>继续整理第五章知识点 √</p>
</li>
<li><p>6.1 总线概述</p>
<ul>
<li><p>总线的基本概念</p>
<p>  总线猝发性传输：在一个总线周期内传输存储地址连续的多个数据字的总线传输方式。（连续地址的数据传输时只需要传送第一个数据所在的地址）</p>
</li>
<li><p>总线的分类</p>
</li>
<li><p>总线的结构</p>
</li>
<li><p>总线的性能指标</p>
</li>
</ul>
</li>
<li><p>6.2 总线仲裁不考跳过</p>
</li>
<li><p>6.3 总线操作和定时</p>
<ul>
<li><p>总线的传输周期</p>
</li>
<li><p>同步定时方式</p>
</li>
<li><p>异步定时方式</p>
<p>  不互锁方式、半互锁方式、全互锁方式</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>单词 x 300</p>
</li>
<li><p>真题 2009Text1 新习惯的形成有利于创造力（错 1 个）</p>
<p> 真题 2009Text2 基因检测和存在的问题（错 2 个）</p>
</li>
</ol>
<h3 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 476-490<ul>
<li>用极坐标方程求旋转体表面积、体积</li>
<li>$\int {1 \over 1+sin^2x}dx$​</li>
<li><strong>遇到 $F(x)f(x)$​ 的往 ${[F^&#96;(x)]}^2$​​​ 上想</strong>，注意观察结构</li>
<li>计算计算计算！</li>
<li>$\int_0^1 x {arcsinx \over (x+1)^{1 \over 2}}dx$​</li>
</ul>
</li>
<li>回顾高数讲义<ul>
<li>连续、可导、可微的关系</li>
<li>隐函数求导公式、反函数求导公式</li>
<li>高阶导数（3 个）</li>
<li>给定极限式判断导函数是否存在类问题</li>
<li>$f(x)&#x3D;\phi(x)|x-a|$ 在 $x&#x3D;a$ 处可导的充要条件</li>
<li>函数与其绝对值函数之间可导性的关系</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>数据结构应用题</p>
<p> 求各个排序第一躺排序后的结果</p>
</li>
<li><p>死亡计组</p>
<ul>
<li>指令流水线三道大题（整体难度不打）<ul>
<li>对某单元操作后单元内的内容</li>
<li>流水线执行 n 条指令所需要的时钟周期</li>
<li>条件转移指令地址偏移量 <code>offset</code> 值的计算</li>
<li>与 Cache 相结合</li>
</ul>
</li>
<li>回顾整理第五章知识点</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 400</li>
<li>真题 2008Text4（错 2 个）</li>
</ol>
<h3 id="8-11"><a href="#8-11" class="headerlink" title="8.11"></a>8.11</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 461-475 积分和不定积分<ul>
<li>$\int {dx \over \sqrt{(x-a)(b-x)}}$​​​</li>
</ul>
</li>
<li>每日一题  抽水做工</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>每日一题</li>
<li>死亡计组<ul>
<li>5.4 控制器的功能和原理<ul>
<li>硬布线控制器</li>
<li>微程序控制器</li>
<li>二者对比</li>
</ul>
</li>
<li>5.5 指令流水线<ul>
<li>$t&#x3D;(k+n-1)*T$</li>
<li>时空图</li>
<li>资源冲突、数据冲突（旁路技术）、控制冲突</li>
<li>性能指标（吞吐率、加速比、效率）</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题 2008Text3 美国人的身高到达极限（错一个）</li>
</ol>
<h3 id="8-10"><a href="#8-10" class="headerlink" title="8.10"></a>8.10</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 446-460<ul>
<li>用泰勒展开求高阶导数</li>
<li>变上限积分想办法先换元再求导（没有条件创造条件）</li>
<li>注意细节处理！</li>
</ul>
</li>
<li>回顾 880 错题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>死亡计组 开始第五章 CPU</p>
<ul>
<li><p>5.1 CPU 的功能和基本结构</p>
<ul>
<li><p>运算器（ALU、暂存寄存器、ACC、通用寄存器组、PSW、移位器、计数器）</p>
</li>
<li><p>控制器（PC、IR、指令译码器、MAR、MDR、时序系统、微操作信号发生器）</p>
</li>
<li><p>对程序员不透明的寄存器：MAR、MDR、PC、PSW、通用寄存器组</p>
</li>
</ul>
</li>
<li><p>5.2 指令执行过程</p>
<ul>
<li>指令周期、机器周期（CPU 周期）、时钟周期</li>
<li>取指周期、间指周期、执行周期、中断周期</li>
</ul>
</li>
<li><p>5.3 数据通路的功能和基本结构 （两道大题）</p>
<ul>
<li>根据给出的要求指出指令功能及信号</li>
<li>程序员可见寄存器</li>
<li>设置暂存寄存器的目的（单总线结构）</li>
<li>三态门</li>
<li>线路连接（还是考察指令的执行流程）</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 400</p>
</li>
<li><p>真题 2008Text2 一种新的论文出版方式（错两个）</p>
<p> $In\ general\ routine\ of\ every\ day$</p>
</li>
</ol>
<h3 id="8-8"><a href="#8-8" class="headerlink" title="8.8"></a>8.8</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 426-445 正式开始 660 高数2阶<ul>
<li>用拉格朗日求极限时注意 $\xi$ 的取值，不要想当然的带 1</li>
</ul>
</li>
<li>每日一题<ul>
<li>心形线的面积</li>
<li>闸门受水压力</li>
</ul>
</li>
<li>回顾 880 错题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<p> <code>TODO</code> 移码取相反数后什么时候会溢出？</p>
</li>
<li><p>死亡计组</p>
<ul>
<li>指令寻址的大题</li>
<li>CISC 和 RISC</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 400</li>
<li>真题 2008Text1 女性压力 （拿下！）</li>
</ol>
<h3 id="8-7"><a href="#8-7" class="headerlink" title="8.7"></a>8.7</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660 252-275 （基础篇高数部分拿下）</p>
<ul>
<li>积分区间相同，被积函数越大，积分值越大</li>
<li>$\int sec^3 \theta d\theta$​</li>
</ul>
</li>
<li><p>每日一题</p>
<p> 求曲线围成区域面积及旋转体体积</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><strong>OSI 参考模型上三层：会话层、表示层、应用层</strong></li>
</ul>
</li>
<li><p>数据结构应用题</p>
<ul>
<li><strong>二分查找判定树</strong></li>
<li>查找关键字的比较次数</li>
<li>平均查找长度</li>
</ul>
</li>
<li><p>计组</p>
<ul>
<li><p>Cache 和虚拟存储器结合的大题一道（2016真题 easy）</p>
</li>
<li><p>4.1 指令格式</p>
<ul>
<li>拓展操作码技术</li>
</ul>
</li>
<li><p>4.2 指令寻址方式</p>
<ul>
<li>各寻址方式特点</li>
<li>有效地址计算</li>
<li>区分相对寻址、基址寻址、变址寻址</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 100</li>
</ol>
<h3 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h3><p>昨天 utools 玩了半天，今天期待了好久的 fexcil 上架了，感觉又能研究半天！</p>
<blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660 234-251</p>
<ul>
<li>隐函数求导公式</li>
<li>偏导连续 &#x3D;&#x3D;》可微 &#x3D;&#x3D;》偏导存在</li>
<li>给抽象函数的问题可以优先考虑<strong>特殊函数法</strong></li>
<li>一般情况下，二元极限低次比高次为无穷，同次相比极限不存在，高次比低次极限存在</li>
</ul>
</li>
<li><p>错题回顾 880</p>
<ul>
<li>$\lim\limits_{n \to \infty}a^{1 \over n}&#x3D;1$</li>
<li>界值定理</li>
<li>数列极限类题目用夹逼定理求极限（先斩后奏）</li>
</ul>
</li>
<li><p>每日一题<br> $$<br> I&#x3D;\int_{1}^{+\infty}{dx \over e^{1+x} + e^{3-x}}<br> $$</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><p><strong>$O(n)$​ 是指执行时间与 $n^2$​ 成正比</strong></p>
</li>
<li><p>网络拓扑结构中，<strong>星型网络具有一定集中控制功能</strong>，因为端用户之间的通信必须经过中心站</p>
</li>
<li><p>十进制转二进制别忘了<strong>符号位</strong>！</p>
</li>
</ul>
</li>
<li><p>数据结构应用题 散列查找</p>
<ul>
<li>绘图画出表格，给出<strong>关键字和索引地址</strong></li>
<li><strong>装填因子</strong>：哈希表中元素个数 &#x2F; 哈希表表长</li>
<li><strong>查找不成功平均长度</strong>：从 0 到 n 每个地址都要过一遍！</li>
<li><strong>拉链法空节点不算一次查找，而线性探测法算</strong> 🧡</li>
</ul>
</li>
<li><p>死亡计组</p>
<ul>
<li><p>回顾两道 Cache 大题，新做一道</p>
<ul>
<li><strong>Cache 行标记项：有效位、脏位、替换控制位、标记位</strong></li>
</ul>
</li>
<li><p>3.7 虚拟存储器</p>
<p>  重点掌握<strong>从虚拟地址到物理地址的映射</strong>、<strong>快表的查询</strong>、<strong>物理地址在 Cache 中的划分</strong>，做了两道大题，都还ok，难度没有纯 Cache 的大</p>
<ul>
<li><p>页式虚拟存储器（页表、快表、快表-Cache多级存储系统）</p>
</li>
<li><p>段式虚拟存储器</p>
</li>
<li><p>段页式虚拟存储器</p>
</li>
<li><p>Cache 与 快表的区别</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题 2007Text4  企业重视数据安全（错 1 个）</li>
</ol>
<h3 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660 211-233</p>
<ul>
<li><p>判断给定二元函数连续、可导、可微的方法</p>
</li>
<li><p>判断二元极限是否存在（放缩、设 k）</p>
</li>
<li><p>微分算子法求特解</p>
</li>
<li><p>齐次方程<strong>线性无关特解</strong>$y_1,y_2$​，$y&#x3D;C_1y_1+C_2y_2$​</p>
</li>
</ul>
</li>
<li><p>错题回顾</p>
<ul>
<li>证明 $f(x)$ 可以写成一个奇函数和一个偶函数的和</li>
<li>多项式和的极限（定积分、夹逼定理）</li>
<li>多项式乘积的极限（取对数、夹逼定理）</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><p><strong>数据有序</strong>的顺序表中才可以用折半查找法</p>
</li>
<li><p><strong>键盘和计算机之间的通信是全双工的</strong>（显示终端代有键盘，键盘输入字符到内存，内存信息可以送到屏幕显示，两个过程可以同时进行）</p>
</li>
<li><p>一次性请求所有资源：预防死锁</p>
<p>  强占其他进程已占资源：解除死锁</p>
<p>  提高进程优先级：解除死锁</p>
<p>  采用资源分配拒绝策略（银行家算法）：避免死锁</p>
</li>
</ul>
</li>
<li><p>计组 Cache两道真题</p>
<ul>
<li>Cache 的总容量</li>
<li>xxx 对应 Cache 的行号</li>
<li>二维数组按行访问和按列访问的访问命中率</li>
<li>时钟周期、带宽</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题2007Text3（全对，拿下！）<ul>
<li>技巧<ul>
<li>有 may 的 90% √</li>
<li>有比较级的很有可能是错的</li>
</ul>
</li>
<li>词汇<ul>
<li>fair play：公平竞争</li>
<li>pink slip：解雇信、辞退信</li>
<li>outweigh：比……重要、比……有价值</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 208-210<ul>
<li><strong>曲线质心公式</strong>和<strong>封闭区域质心公式</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
</li>
<li><p>计组</p>
<p> 继续啃高速缓存，做了课后小题，但是感觉理解还是不到位（Cache 和 主存的映射）</p>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 400</li>
</ol>
<h3 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 191-207<ul>
<li>$F(x)&#x3D;\int_0^xf(t)dt$ 一定连续！</li>
<li>$f(x)$​ 为周期函数，$F(x)$​ 也为周期函数的充要条件是 $\int_0^Tf(x)dx&#x3D;0$​ </li>
<li>积分 $\int_{-\infty}^{+\infty}f(x)dx$ 存在判定</li>
<li>极坐标下的弧长公式</li>
</ul>
</li>
<li>武忠祥每日一题<ul>
<li>反常积分敛散性：定义、P 积分、比较法</li>
</ul>
</li>
<li>回顾高数辅导讲义例题（求极限）</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><strong>转发器</strong>实现物理层的连接，对衰弱的信号放大整形或再生，起拓展网段的作用</li>
<li><strong>网桥</strong>通过 MAC 地址寻址，<strong>路由器</strong>通过 IP 地址寻址</li>
<li>网络层以上的中继系统统称为<strong>网关</strong></li>
<li><strong>重定位</strong>是实现多道程序在内存中同时运行的基础</li>
<li>中断方式的特点：CPU 与 外设并行工作，传送与主程序串行工作</li>
</ul>
</li>
<li><p>数据结构应用题</p>
<ul>
<li>关键路径</li>
<li>Dijkstra 算法</li>
</ul>
</li>
<li><p>计组</p>
<ul>
<li><p>3.5 双端口 RAM 及多模块存储器</p>
<ul>
<li><p>双端口 RAM</p>
</li>
<li><p>多体并行存储器</p>
<p>  高位交叉编址：$t&#x3D;mT$</p>
<p>  低位交叉编址：$t&#x3D;T+(m-1)r$</p>
</li>
</ul>
</li>
<li><p>3.6 高速缓冲存储器（映射方式没弄明白，明天继续啃）</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题 2007Text2  IQ测试并不是很合理（全对，拿下！）</li>
</ol>
<h3 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660  174-190</p>
<ul>
<li><p>原函数存在定理（3 条）</p>
</li>
<li><p>$f(x)$ 在 $(a,b)$ 上可积的充分条件（3 条）——》 <strong>有无穷积不了</strong></p>
</li>
<li><p>比较定理（2 条）（<strong>可积不一定连续！</strong>）</p>
</li>
<li><p>可以记的结论：<br>  $$<br>  \int_{0}^{\pi\over2}{sinx \over x} &lt; \int_{0}^{\pi\over2}{tanx \over x} &lt; 1<br>  $$</p>
</li>
</ul>
</li>
<li><p>没顾得上每日一题和回顾高数讲义</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li>STMP 协议用于控制<strong>邮件发送及中转方式</strong>，POP3 及 IMAP 协议用于控制<strong>接受邮件</strong></li>
</ul>
</li>
<li><p>数据结构应用题</p>
<ul>
<li>图的邻接矩阵、邻接表、Prim 算法、Kruskal 算法</li>
<li>由邻接矩阵画图，并求关键路径</li>
</ul>
</li>
<li><p>计组（正式进入第三章 存储系统）</p>
<ul>
<li><p>3.1 存储器概述</p>
<ul>
<li><p>存储器分类（层次、存储介质、存取方式、信息可保存性）</p>
<p>  注意区分<strong>顺序存取存储器</strong>和<strong>直接存取存储器</strong></p>
</li>
<li><p>存储器性能指标（存储容量、单位成本、存储速度）</p>
<p>  注意区分<strong>存取时间</strong>与<strong>存取周期</strong></p>
</li>
</ul>
</li>
<li><p>3.2 存储器的层次化结构</p>
<ul>
<li><p>Cache-主存：</p>
<p>  解决 CPU 和主存速度不匹配问题，对所有程序员透明</p>
</li>
<li><p>主存辅存：</p>
<p>  解决存储容量问题，对应用程序员透明</p>
</li>
</ul>
</li>
<li><p>3.3 半导体随机存储器</p>
<ul>
<li>SRAM</li>
<li>DRAM</li>
<li>只读存储器</li>
</ul>
</li>
<li><p>3.4 主存储器与 CPU 的连接</p>
<ul>
<li>位拓展法</li>
<li>字拓展法</li>
<li>字位拓展法</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题 2007Text1 Pracice make perfect （错 3 个啊啊啊，中套了）</li>
</ol>
<h1 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h1><h3 id="7-30、7-31"><a href="#7-30、7-31" class="headerlink" title="7.30、7.31"></a>7.30、7.31</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660 138-173</p>
<ul>
<li><p>有界性的三个判定条件</p>
</li>
<li><p>$f(x)$ 与 $|f(x)|$ 可导性的关系</p>
</li>
<li><p>单调性判定（凹凸性）</p>
</li>
</ul>
</li>
<li><p>每日一题 x 4</p>
<ul>
<li>变积分函数能积出来就先积出来</li>
</ul>
</li>
<li><p>整理笔记</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li>两台主机建立好 TCP 连接，发送 TCP 段时返回的确认号是指期望收到的序号，如果中间有丢失，则确认号一直停留在期望收到的序号。</li>
<li>在以太网中，访问一个主机中的一个进程需要使用：IP 地址和传输层协议端口号（套接字）</li>
<li>容量 <code>64K x 8bit</code> 的意义</li>
</ul>
</li>
<li><p>数据结构应用题</p>
<ul>
<li>队列</li>
<li>BST、AVL、哈夫曼树</li>
</ul>
</li>
<li><p>计组 浮点数的表示与运算（两天时间啃下来弄明白）</p>
<ul>
<li><p>规格化浮点数目的：提高运算精度，充分利用位数的有效位数</p>
</li>
<li><p>原码规格化：</p>
<ul>
<li>正数：最大 0.111…1，最小 0.100…0</li>
<li>负数：最大 1.100…0，最小 1.111…1</li>
</ul>
</li>
<li><p>补码规格化：</p>
<ul>
<li>正数：最大 0.111…1，最小 0.100…0</li>
<li>负数：最大 1.011…1，最小 1.000…0（-1）</li>
</ul>
</li>
<li><p><strong>当浮点数基数为 2 时，原码规格化的尾数最高位一定是1，补码规格化的尾数的最高位最高位一定与符号位相反</strong></p>
</li>
<li><p><strong>当基数为 4 时，原码规格化形式尾数最高两位至少有一个 1</strong></p>
</li>
<li><p>IEEE 754（重点掌握🧡）</p>
</li>
<li><p>浮点数加减法</p>
<ol>
<li>对阶</li>
<li>尾数求和</li>
<li>规格化</li>
<li>舍入（右规和对阶）</li>
<li>溢出判断</li>
</ol>
</li>
<li><p>浮点数类型转换</p>
<p>  $char-&gt;int-&gt;long-&gt;double$ ：从前到后范围和精度都从小到大，转换过程没有损失</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ul>
<li>墨墨单词 x 350</li>
<li>真题 2006Text4 传递虚假幸福的广告遍地的时代开始涌现出消极的艺术作品</li>
</ul>
<h3 id="7-29"><a href="#7-29" class="headerlink" title="7.29"></a>7.29</h3><blockquote>
<p>数学（8：30—12：00）</p>
</blockquote>
<ol>
<li>660 121-137 函数、极限</li>
<li>武忠祥每日一题 x 2</li>
</ol>
<blockquote>
<p>408 </p>
</blockquote>
<ol>
<li>每日一题<ul>
<li>$average_access_time &#x3D; t_{cache} * p + t_{memory} * (1-p)$，其中 p 是 Cache 命中率。</li>
</ul>
</li>
<li>数据结构算法题<ul>
<li>使用时间复杂度 $O(n)$，空间复杂度 $O(1)$，完成顺序表指定元素的删除：交换删除元素与数组末尾元素的值，同时减小数组的长度（双指针）</li>
</ul>
</li>
<li>计组<ul>
<li>C 语言数据类型转换<ul>
<li>有符号数和无符号数：强制类类型转换的结果保持位值不变，<strong>仅改变了解释这些位的方式</strong>。</li>
<li>大字长变量向小字长变量：<strong>高位截断，低位赋值</strong>。</li>
<li>小字长变量向大字长变量：<strong>位值相等，高位拓展为原数字的符号位</strong>。（char 类型转 int 高位补 0）</li>
</ul>
</li>
<li>数据的存储和排列<ul>
<li>大端和小端方式</li>
<li>数据按边界对其</li>
</ul>
</li>
<li>课后习题，没来得急更正</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 350</li>
<li>真题 2006 Text2：莎士比亚小镇 （错 1 个）</li>
</ol>
<h3 id="7-28"><a href="#7-28" class="headerlink" title="7.28"></a>7.28</h3><blockquote>
<p>数学（8：30—12：00、2：30—3：00）</p>
</blockquote>
<ol>
<li><p>660 101-120 二重积分</p>
<ul>
<li>积分区域关于点对称的考虑把 x、y平移</li>
<li>极坐标表示的二重积分交换积分次序🧡</li>
</ul>
</li>
<li><p>武忠祥每日一题</p>
<ul>
<li><p>$\int\sqrt{1-sinx}dx &#x3D; \int\sqrt{sin^2{x \over 2}+cos^2{x \over 2}+2sin{x \over 2}cos{x \over 2}}$ （也可以直接有理化）</p>
</li>
<li><p>能换元的先换元</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>408（3：00—3：30，状态不好）</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><p>ICMP：主机与路由器之间传递控制信息。</p>
<p>  应用：PING、traceroute</p>
</li>
<li><p>SPOOLING（假脱机技术）：数据传入设备，设备忙则暂存数据，闲了再读取数据<strong>（空间换时间）</strong></p>
</li>
<li><p>虚拟存储技术：由程序的局部性原理，只将一部分程序调入内存，需要时再调入需要部分的程序。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 350</p>
</li>
<li><p>英语真题 2006 Text1（错 1 个，再读加搜词后改正）</p>
</li>
</ol>
<h3 id="7-27"><a href="#7-27" class="headerlink" title="7.27"></a>7.27</h3><blockquote>
<p> 数学（8：30 — 12：00、14：00—15：00）</p>
</blockquote>
<ol>
<li><p>660 85-100 多元函数微分学</p>
</li>
<li><p>武忠祥每日一题 x 2</p>
<ul>
<li>$ln(1+\sqrt{1+x^2})$ 、$ln {1-x \over 1+x}$ 、$e^x-1 \over e^x + 1$ 都是奇函数</li>
</ul>
</li>
<li><p>整理高数讲义知识点和题目</p>
</li>
</ol>
<blockquote>
<p>408（15：00—18：30）</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><strong>虚电路服务的目的地址仅在建立连接的时候使用</strong>，建立连接之后每个分组用长度较短的虚电路号</li>
<li>最佳置换算法（OPT）是指缺页率最小的算法，因为过于理想无法实现，仅用于与其他算法作比较</li>
</ul>
</li>
<li><p>数据结构应用题整理</p>
</li>
<li><p>计组</p>
<ul>
<li><p>2.1 数制与码制</p>
</li>
<li><p>2.2 定点数的表示与运算</p>
<p>  只看了定点数的表示、移位运算、加减运算，乘除考的不多且比较麻烦，暂时不打算看，留到最后吧</p>
<p>  <img src="/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%80%83%E7%A0%94%E5%A5%8B%E6%96%97%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%81/image-20210801162714005.png" alt="image-20210801162714005"></p>
<ul>
<li><strong>移码就是补码符号位不变其他位取反</strong></li>
<li><strong>逻辑位移都添0</strong></li>
<li><strong>算术位移原码添0，反码添1，补码左移添0，右移添1</strong></li>
<li>补码顶点加减运算判断溢出：<strong>单符号位、双符号位、一符号位一进位</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语 （20：40—22：00）</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 300</p>
</li>
<li><p>英语真题 2005 Text4（错 1 个）</p>
</li>
</ol>
<h3 id="7-24"><a href="#7-24" class="headerlink" title="7.24"></a>7.24</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660  62-72 </p>
<ul>
<li><p>不定积分计算</p>
</li>
<li><p>不定积分的应用（好多东西都忘了）</p>
<p>  不定积分求旋转体体积关于 x、y 轴堆成可以用微元法分析，关于其他轴对称直接用公式：$V &#x3D; 2\pi\iint r(x,y)d\sigma$）</p>
<p>  旋转体侧面积：$S &#x3D; 2\pi\int_{a}^{b} f(x)ds$ </p>
</li>
<li><p>分段函数求积分时注意积分区间！</p>
</li>
</ul>
</li>
<li><p>武忠祥每日一题 x 4</p>
<p> $\int x^narcsinxdx$ 之类的用换元 $x&#x3D;sint$ 做起来比分部积分更好算一点</p>
</li>
<li><p>整理典型题</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>每日一题<ul>
<li>后序遍历也叫做后根遍历、后续周游</li>
<li>网卡工作在<strong>物理层</strong>和<strong>数据链路层</strong>，数据链路层都是用各个网卡的MAC地址，同时网卡控制着主机对介质的访问，因此也工作在物理层</li>
<li>进程的组成成分中，<strong>共享程序段</strong>在进程运行中不可修改。</li>
</ul>
</li>
<li>数据结构二轮复习 <ul>
<li>听王道强化课数据结构应用题部分</li>
<li>整理数据结构大题应用题的相关知识点（未完待续）</li>
</ul>
</li>
<li>计组二轮复习<ul>
<li>1.2 计算机系统层次结构<ul>
<li>对某一功能，既可以用软件也可以用硬件实现，称为<strong>软硬件在逻辑上是等效的</strong></li>
<li>硬件基本组成：<strong>运算器</strong>（<strong>ALU</strong>、<strong>ACC</strong>、<strong>MQ</strong>、<strong>X</strong>、IX、BR）、<strong>存储器</strong>（<strong>MAR</strong>、<strong>MDR</strong>）、<strong>控制器</strong>（<strong>CU</strong>、<strong>IR</strong>、<strong>PC</strong>）、输入设备、输出设备</li>
<li><strong>MAR</strong> 用于寻址，位数与<strong>存储单元个数</strong>对应（<strong>与PC相等</strong>）；<strong>MDR</strong> 用于存储数据，位数与<strong>存储字长</strong>对应</li>
<li>区分 DBMS 和 DBS</li>
<li>从源程序到可执行文件：<strong>预处理阶段</strong>、<strong>编译阶段</strong>、<strong>汇编阶段</strong>、<strong>链接阶段</strong></li>
<li>计算机硬件能直接执行的语言：<strong>机器语言</strong>（only！）</li>
<li><strong>存取速度：寄存器 &gt; Cache &gt; 内存</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 300</p>
</li>
<li><p>2005真题 text2（错 1 个）</p>
</li>
</ol>
<h3 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660  46-61  不定积分计算出大问题，好多手法都忘了，而且计算也垮，导致做题效率很低<ul>
<li>常用的一些换元（看见复杂根号直接换  t，还有各种根号平方换三角函数 ）</li>
<li>注意！三角函数定积分的一些结论不定积分不能乱用！</li>
<li>分子分母次数相差较多的可以考虑上下同乘 x 的某一次方</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><p>采用哪种传输方式，由网络负责差错控制和流量控制，分组按顺序递交？			（虚电路分组交换）</p>
</li>
<li><p>操作系统两个最主要特性：并发性和共享性</p>
</li>
<li><p>周期挪用：是指利用 CPU 不访问存储器的周期来实现 DMA 操作，此时DMA可以使用总线而不用通知 CPU 也不会妨碍 CPU 工作。</p>
</li>
</ul>
</li>
<li><p>数据结构二轮复习</p>
<ul>
<li><p>8.5 归并排序和基数排序</p>
<ul>
<li>归并排序：时间复杂度 $O(nlog_2n)$ （最好最坏平均情况下都是） 空间复杂度 $O(n)$ <strong>稳定排序</strong></li>
<li>基数排序： 时间复杂度 $O(d(n+r))$  空间复杂度 $O(r)$  <strong>稳定排序</strong></li>
</ul>
</li>
<li><p>8.6 各种内部排序算法比较及应用</p>
  <img src="【考研】考研奋斗日程记录！/image-20210725000312710.png" alt="image-20210725000312710"  />

<p>  <strong>算法稳定性：插冒归基</strong></p>
</li>
<li><p>8.7 外部排序（掌握的并不好，赌他不是重点，没认真看，后面再抓）</p>
<ul>
<li>外部排序方法</li>
<li>多路平衡树与败者树</li>
<li>置换-选择排序</li>
<li>最佳归并树</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨背单词 x 300</p>
</li>
<li><p>2005年真题 text1 （错 1 个）</p>
</li>
</ol>
<h3 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h3><ul>
<li><p>数学</p>
<ol>
<li><p>660 28-45</p>
<p> 极值点是 x 的取值，不是一个点!</p>
</li>
<li><p>武忠祥每日一题</p>
<ul>
<li>注意 $1&#x2F;x$ 积分是 $ln(|x|)$ ！</li>
<li>微分中值证明题遇到两个不同的中值 η 和 ζ，需要两次拉格朗日或柯西证明。</li>
</ul>
</li>
</ol>
</li>
<li><p>408</p>
<ol>
<li><p>每日一题</p>
<ul>
<li>RIP 协议基于路由选择算法，OSPF 基于链路状态算法</li>
</ul>
</li>
<li><p>数据结构二轮复习</p>
<ul>
<li><p>8.3 交换排序：</p>
<p>  冒泡排序：空间复杂度 $O(1)$ ，时间复杂度 $O(n^2)$ ，每趟排序都会有一个元素被放在最终位置上 </p>
<p>  快速排序：平均栈深度 $O(log_2(n))$ ，时间复杂度 $O(nlog_2(n))$ ，每趟排序后将 <strong>pivot</strong> 元素放在最终位置上，要求能够手写代码	最坏情况是初始序列为顺序或逆序时，时间复杂度 $O(n^2)$ </p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> L[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = L[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L[high] &gt;= pivot) high--;</span><br><span class="line">       	L[low] = L[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L[low] &lt;= pivot) low++;</span><br><span class="line">        L[high] = L[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> L[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(L, low, high);</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="built_in">QuickSort</span>(L, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(L, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>英语</p>
<p>  背单词，久违的墨墨</p>
<p>  真题又偷懒没刷</p>
</li>
<li><p>科研训练</p>
<p>  转实操，准备啃代码</p>
</li>
</ul>
<h3 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h3><p>晚上出去玩了没总结。</p>
<h3 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h3><ul>
<li><p>数学</p>
<ul>
<li><p>二重积分课后习题大题剩余部分</p>
<ul>
<li>还是注意计算问题!</li>
<li>两个一重积分乘积的证明题，通常可以转换为二重积分的问题（把其中的一个积分中的 x 换成 y ）</li>
</ul>
</li>
<li><p>武忠祥每日一题</p>
<ul>
<li>界值定理：函数 <code>[a,b]</code>内连续，则一定存在一个 <code>c ∈ [a,b]</code>，使得 <code> m &lt; f(c) &lt; M</code></li>
<li>函数在一点 <code>a</code> 处的导数值大于0 $&#x3D;&gt;$ 左半领域小于 <code>f(a)</code>，右半领域大于 <code>f(a)</code></li>
</ul>
</li>
<li><p>660 1-9 (求极限手生了，泰勒、洛必达、等价无穷小、三步曲什么的)</p>
</li>
</ul>
<p>  整理错题重点题</p>
</li>
<li><p>408</p>
<ul>
<li><p>每日一题</p>
<ul>
<li><p>二叉树</p>
<p>  总结点数 n &#x3D; n0 + n1 + n2 &#x3D; 2n0 + n1 - 1</p>
</li>
<li><p>三次握手</p>
<p>  客户端 &#x3D;&#x3D;&#x3D;&gt; 服务端：SYN&#x3D;1，scq &#x3D; x											<strong>（我想说）</strong></p>
<p>  服务端 &#x3D;&#x3D;&#x3D;&gt; 客户端：SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ack&#x3D;x+1	 <strong>（好你说）</strong></p>
<p>  客户端 &#x3D;&#x3D;&#x3D;&gt; 服务端：ACK&#x3D;1，seq&#x3D;x + 1，ack&#x3D;y+1 			  <strong>（阿巴阿巴）</strong></p>
</li>
<li><p>内存划分的动态分区分配</p>
<p>  首次适应算法：空闲分区以地址递增次序链接。</p>
<p>  最佳适应算法：空闲分区按容量递增方式形成分区链。</p>
<p>  最坏适应算法：以容量递减次序链接。</p>
<p>  邻近适应算法：分配内存时从上次查找结束的位置开始继续查找。</p>
</li>
</ul>
</li>
<li><p>数据结构二轮</p>
<ul>
<li>7.2 顺序查找、折半查找和分块查找</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找</span></span><br><span class="line"><span class="comment">// 线性查找引入哨兵减少不必要的判断</span></span><br><span class="line">list[<span class="number">0</span>] = key; <span class="comment">//查找的关键字</span></span><br><span class="line"><span class="keyword">for</span>(i = len; list[i] != key; i--);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	ASL(succ) = (n + 1) / 2</span></span><br><span class="line"><span class="comment">	ASL(fail) = n + 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch</span><span class="params">(SeqList L, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, h = L.Length - <span class="number">1</span>, mid;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">		mid = (l + h) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (L.data[mid] = key) </span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(L.data[mid] &gt; k)</span><br><span class="line">			h = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	分块查找：</span></span><br><span class="line"><span class="comment">	分成 √n 块，块间和块内查找可以顺序也可以二分</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>7.3 B树和B+树</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* B树</span></span><br><span class="line"><span class="comment">	1.每个节点最多有 m 颗子树，m-1 个关键字</span></span><br><span class="line"><span class="comment">	2.若不只有根节点一个节点，则根节点至少有两颗子树</span></span><br><span class="line"><span class="comment">	3.除根节点外的非叶子节点至少有 向上取整 (m/2)  颗子树</span></span><br><span class="line"><span class="comment">	4.叶子节点出现在同一层且不带信息，可以看作是查找失败的节点</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	插入：超过 m - 1 个关键字就裂开，从 向上取整(m/2) 裂</span></span><br><span class="line"><span class="comment">	删除：看书</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* B+树</span></span><br><span class="line"><span class="comment">	大体同B树，但是记录全在叶子节点上，叶子节点用链表串联可以进行顺序查找，非叶子节点都起索引的	  作用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>英语</p>
<ul>
<li><p>单词新词全部背完，等剩下的一百多次复习完就转墨墨了，钱还是要花的</p>
</li>
<li><p>翻译真题：整体感觉难度不高，可以先放一放，先集中精力做做阅读这样子</p>
</li>
</ul>
</li>
<li><p>科研训练</p>
<p>  继续啃文献做笔记。图和各种深度学习技术相结合：AE、GCN、GAN…</p>
</li>
</ul>
<h3 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h3><ul>
<li><p>数学</p>
<p>  二重积分课后习题大题部分（运算还存在很大问题，很多题不是没思路是计算不对，要么丢了符号要么就是计算发放选择的不好）</p>
<p>  武忠祥每日一题（两道用单调性证明不等式的题目）</p>
</li>
<li><p>408</p>
<ul>
<li><p>王道每日一题</p>
<ul>
<li>执行IO指令、系统调用、修改页表的操作都需要切换到内核态进行，而对通用寄存器的清零，可以在用户态进行，也可以在内核态进行</li>
<li>计时器定时查询总线仲裁方式下，若每一次从头计数，则设备号小的优先级高，若每次计数从上一次计数的终点开始，则每个设备使用总线的机会均等</li>
</ul>
</li>
<li><p>数据结构二轮 6.4 图的应用剩下的知识点及课后习题</p>
<ul>
<li><p>最小生成树</p>
<p>  Prim算法：从初始节点开始每次找路径最短的（大致） $O(V^2)$</p>
<p>  Kruskal算法：从所有边里选最小的（大致）  $O(ElogE)$</p>
</li>
<li><p>最短路径</p>
<p>  最短路径一定是简单路径！</p>
<p>  Dijkstra算法：每次找到一个最短的（大致），不适用于负权值</p>
<p>  Floyd算法：方阵存储最短路径，可以求负权值的边，但是不能有带负权值的边组成的回路</p>
</li>
<li><p>有向无环图描述公共子式（乘法提公因子）</p>
</li>
<li><p>拓扑排序（AOV网）</p>
<p>  1.每个顶点只出现一次                         2.如果A在B前则不存在A-&gt;B的路径</p>
</li>
<li><p>关键路径（AOE网）</p>
<p>  影响工程进度的路径，增加或减少长度 <strong>可能</strong> 会决定总的花销（如果是多条关键路径则多条得一起变才行）</p>
<p>  ve、vl、e、l、l - e</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>英语</p>
<ul>
<li><p>单词 两三百</p>
</li>
<li><p>阅读 2004 Text4</p>
</li>
</ul>
</li>
<li><p>科研训练</p>
<p>  刚开始读文献然后被打断（ft）</p>
</li>
</ul>
<blockquote>
<p>由于课设、期末考试各种原因，搁置考研十天左右</p>
<p>放暑假回家，正式开始暑期学习</p>
<p>7.11 - 7.17 偷懒没记，总结一下 </p>
<ul>
<li><p>稳步推进高数，基本快结束了强化课的内容、讲义习题以及课后习题，同时更近武忠祥每日一题还有b站up主整理的一些秒杀技巧</p>
</li>
<li><p>专业课开始复习第二轮，还是从数据结构开始，速度比一轮快了很多，选择题准确率也比一轮高了不少，课后的大题的真题部分也开始做了（计划跟进王道暑假大题强化课）</p>
</li>
<li><p>单词也有认真背，英语真题也开始做了，由于每天留给英语时间不多，所以从2004年的真题开始每天只做一篇阅读理解及其精度</p>
</li>
<li><p>科研训练，换了下手方向，转向基于图的异常检测</p>
</li>
</ul>
<p>总体学习效率还是小低，会被很多东西分心，争取慢慢找回状态！</p>
<p>重视回顾！重视回顾！重视回顾！</p>
<p>​	<strong>楞冲！！！</strong></p>
</blockquote>
<h1 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h1><h3 id="6-28"><a href="#6-28" class="headerlink" title="6.28"></a>6.28</h3><ul>
<li><p>数学</p>
<ul>
<li>武忠祥十六讲  第五章第二节 偏导数与全微分的计算</li>
<li>每日一题</li>
</ul>
</li>
<li><p>408</p>
<p>  计网 复习思维导图 网络层</p>
<p>  数据结构 （二轮复习昨天开始）</p>
<ul>
<li>链表回顾 课后选择、真题大题</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 300</p>
</li>
</ul>
<h3 id="6-17-6-27"><a href="#6-17-6-27" class="headerlink" title="6.17 ~ 6.27"></a>6.17 ~ 6.27</h3><ul>
<li><p>数学</p>
<ul>
<li>武忠祥十五讲 </li>
<li>高数辅导讲义课后习题</li>
<li>武忠祥每日一题</li>
</ul>
</li>
<li><p>408</p>
<p>  计网</p>
<ul>
<li>第六章 网络层</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 40 ~ 60%</p>
</li>
</ul>
<h3 id="6-5-6-17"><a href="#6-5-6-17" class="headerlink" title="6.5 ~ 6.17"></a>6.5 ~ 6.17</h3><ul>
<li><p>数学</p>
<ul>
<li>武忠祥九讲 ~ 十四讲</li>
<li>高数辅导讲义课后题</li>
</ul>
</li>
<li><p>408</p>
<p>  计网</p>
<ul>
<li><p>第二章 物理层</p>
</li>
<li><p>第三章 数据链路层 🎈</p>
</li>
<li><p>第四层 网络层 🎈</p>
</li>
<li><p>第五章 传输层</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 0 ~ 40%</p>
</li>
</ul>
<h3 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h3><ul>
<li><p>数学</p>
<p>  武忠祥第九讲</p>
<ul>
<li>不等式证明：单调性、最值、L、泰勒、凹凸性</li>
<li>微分中值定理证明<ul>
<li>分析法</li>
<li>微分方程法</li>
<li>记住一个常用通用结论</li>
</ul>
</li>
</ul>
<p>  武忠祥每日一题 x 2</p>
</li>
<li><p>408</p>
<p>  计网 </p>
<p>  1.2 计算机网络体系结构与参考模型</p>
<ul>
<li>协议、接口、服务的区别与联系</li>
<li>OSI 参考模型（七层）</li>
<li>TCP&#x2F;IP 模型（四层）</li>
</ul>
<p>  2.1 通信基础单科书部分</p>
</li>
</ul>
<h3 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h3><ul>
<li><p>数学</p>
<p>  武忠祥第七讲 导数的应用</p>
<ul>
<li>微分中值定理（四个）</li>
<li>极值（一、二、<strong>三</strong>充分条件）</li>
<li>斜渐近线的特殊求法</li>
</ul>
<p>  武忠祥 每日一题 x 2</p>
</li>
<li><p>408</p>
<p>  计网 1.1 概述部分</p>
<p>  数据结构 LC每日一题</p>
</li>
<li><p>英语 </p>
<p>  单词 x 250</p>
</li>
</ul>
<h1 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h1><h3 id="5-28-6-2"><a href="#5-28-6-2" class="headerlink" title="5.28 - 6.2"></a>5.28 - 6.2</h3><p>复习专业课考试，抽空看高数</p>
<h3 id="5-27"><a href="#5-27" class="headerlink" title="5.27"></a>5.27</h3><ul>
<li><p>数学</p>
<p>  课后习题 x 30</p>
</li>
<li><p>408</p>
<p>  操作系统 回顾</p>
</li>
<li><p>英语</p>
<p>  单词 x 300</p>
</li>
</ul>
<h3 id="5-26"><a href="#5-26" class="headerlink" title="5.26"></a>5.26</h3><ul>
<li><p>数学</p>
<p>  回顾昨天的例题</p>
<p>  武忠祥第四讲 后半部分</p>
<ul>
<li>连续与间断</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 5.2 IO 核心子系统</p>
<ul>
<li><p>高速缓存与缓冲区</p>
<p>  （引入缓冲区的目的、缓冲区的分类、<strong>单缓冲区和双缓冲区的处理时间计算</strong>（重点））</p>
</li>
<li><p>设备分配数据结构</p>
<p>  （DCT、COCT、CHCT、SDT 之间的运作关系）</p>
</li>
<li><p><strong>SPOOLing 技术（掌握的还不是很好）</strong></p>
<p>  目的：缓解 CPU 和 IO 设备的速度差异</p>
<p>  必须要有多道程序技术支持</p>
<p>  组成：输入井和输出井（外存）、输入缓冲区和输出缓冲区（内存）、输入进程、输出进程</p>
<p>  通俗的讲就是，如果设备被占用，就把数据暂存一下，等设备空闲了就把数据输入到设备中</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 x 300</p>
</li>
</ul>
<h3 id="5-25"><a href="#5-25" class="headerlink" title="5.25"></a>5.25</h3><ul>
<li><p>数学</p>
<p>  武忠祥第四讲 前半部分</p>
<ul>
<li>确定极限中的参数</li>
<li>无穷小量比较（对阶比较好用）</li>
</ul>
<p>  每日一题 x 2</p>
<ul>
<li>1 - cosx的 a 次方 ~ a&#x2F;2 * x的平方</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 5.1 IO 管理概述</p>
<ul>
<li>IO 控制方式</li>
<li>IO 子系统层次结构</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 x 300</p>
</li>
<li><p>科研训练</p>
<p>  啃文献：<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/7022664">Efficient Anomaly Detection by Isolation Using Nearest Neighbour Ensemble | IEEE Conference Publication | IEEE Xplore</a></p>
</li>
</ul>
<h3 id="5-24"><a href="#5-24" class="headerlink" title="5.24"></a>5.24</h3><ul>
<li><p>数学</p>
<p>  武忠祥第四讲 （预习加正课）</p>
<ul>
<li>数列极限，用<strong>洛必达前先改成函数极限再求</strong></li>
<li><strong>n 项和数列极限</strong>：<br>  1. 夹逼定理   <strong>次量级</strong><br>   2. 定积分定义  <strong>同量级</strong></li>
<li>n 项连乘求极限</li>
<li><strong>根据递推关系求极限 （重难点，很有可能出今年最难的一道题）</strong></li>
</ul>
<p>  每日一题 x 2</p>
</li>
<li><p>408</p>
<p>  操作系统 4.3 磁盘组织与管理</p>
<ul>
<li>磁盘的结构</li>
<li>磁盘的一些时间参数计算（寻找时间、旋转延迟时间、传输时间）</li>
<li>磁盘调度算法<ul>
<li>先来先服务（FCFS）</li>
<li>最短寻找时间（SSTF）</li>
<li>扫描算法（SCAN）</li>
<li>循环扫描（C-SCAN）</li>
</ul>
</li>
<li>磁盘管理（磁盘初始化、引导块、坏块）</li>
</ul>
</li>
<li><p>英语</p>
<p>  墨墨单词 x 300</p>
</li>
</ul>
<h3 id="5-23"><a href="#5-23" class="headerlink" title="5.23"></a>5.23</h3><ul>
<li><p>数学</p>
<p>  武忠祥 第三讲回顾（例题）</p>
<p>  每日一题 x 2</p>
</li>
<li><p>408</p>
<p>  操作系统 文件系统实现 课后题、整理思维框图</p>
</li>
<li><p>英语</p>
<p>  单词单词</p>
</li>
</ul>
<h3 id="5-22"><a href="#5-22" class="headerlink" title="5.22"></a>5.22</h3><ul>
<li><p>数学</p>
<p>  武忠祥 强化班3 </p>
<p>  各种极限求法</p>
</li>
<li><p>408</p>
<p>  操作系统 4.2文件系统实现</p>
</li>
<li><p>英语</p>
<p>  单词</p>
</li>
</ul>
<h3 id="5-21"><a href="#5-21" class="headerlink" title="5.21"></a>5.21</h3><ul>
<li><p>数学</p>
<p>  武忠祥 强化班2</p>
</li>
<li><p>408</p>
<p>  操作系统 4.1 文件系统基础</p>
<ul>
<li><p>文件的打开与关闭</p>
</li>
<li><p>文件的逻辑结构</p>
<p>  流式文件</p>
<p>  记录式文件</p>
<ul>
<li>顺序文件</li>
<li>索引文件</li>
<li>索引顺序文件</li>
<li>直接文件或散列文件</li>
</ul>
</li>
<li><p>目录结构</p>
<ul>
<li>单极目录结构</li>
<li>两级目录结构</li>
<li>多级目录结构（树形目录结构）</li>
<li>无环图目录结构</li>
</ul>
</li>
<li><p>文件控制块</p>
</li>
<li><p>索引节点</p>
</li>
<li><p>文件共享</p>
</li>
<li><p>文件保护</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-20"><a href="#5-20" class="headerlink" title="5.20"></a>5.20</h3><ul>
<li><p>数学</p>
<p>  武忠祥 强化班1</p>
<ul>
<li>原函数奇（偶）函数 &#x3D;&#x3D;&gt; 导函数偶（奇）函数。<strong>反过来不一定对</strong>。</li>
<li>开区间有界 &#x3D;&#x3D;&gt; 两端点处极限存在</li>
<li>导函数开区间有界 &#x3D;&#x3D;&gt; 原函数开区间有界</li>
<li>极限保号性，区分 f(x) &gt; f(x0) 和 f(x) 在区间内单调递增</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 3.2 虚拟内存管理</p>
<ul>
<li>虚拟存储器大小由计算机地址结构决定</li>
<li>虚拟内存技术建立在非连续分配基础之上</li>
<li>FIFO 是唯一会导致 Belady 现象的页面置换算法</li>
<li>外存分为对换区和文件区</li>
<li>抖动</li>
<li>TODO 大题地址翻译 （P202）</li>
</ul>
<p>  LeetCode 每日一题</p>
</li>
<li><p>英语</p>
<p>  每日单词</p>
</li>
</ul>
<h3 id="5-13-5-19"><a href="#5-13-5-19" class="headerlink" title="5.13 - 5.19"></a>5.13 - 5.19</h3><p>复习测试技术，准备考试</p>
<p>武忠祥每日一题坚持在做</p>
<p>背单词</p>
<h3 id="5-12"><a href="#5-12" class="headerlink" title="5.12"></a>5.12</h3><ul>
<li><p>数学</p>
<p>  李林880 相似矩阵解答题（部分）</p>
<p>  武忠祥每日一题 x 2</p>
<ul>
<li>两道都是拉格朗日中值定理求极限</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 3.1 内存管理概念课后习题</p>
<ul>
<li>链接完成重定位，形成逻辑地址</li>
<li>动态重定位是在作业的执行过程中进行的</li>
<li>分页系统是给操作系统用的，对用户透明</li>
<li>重定位存储管理方式，整个系统设置一个重定位寄存器</li>
<li>程序如何分段是在用户编程时决定的</li>
<li>页式管理系统所划分的页面大小必须相同</li>
<li>逻辑地址按页分配，物理地址按块分配</li>
<li>区分页、页地址结构、页表项、段、段地址结构、段表项</li>
</ul>
</li>
<li><p>英语</p>
<p>单词单词！</p>
</li>
</ul>
<h3 id="5-11"><a href="#5-11" class="headerlink" title="5.11"></a>5.11</h3><ul>
<li><p>数学</p>
<p>  李林880 线性方程组解答题 相似矩阵选填</p>
<p>  两种含参方程求参数值：行列式、增广矩阵</p>
<p>  武忠祥每日一题 x 2</p>
<ul>
<li>常见极限 x - ln（x + 1）</li>
<li>拉格朗日中值定理求极限</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 3.1 内存管理概念</p>
<ul>
<li>程序执行过程（编译、链接、装入）</li>
<li>连续分配（单一连续分配、固定分区分配、动态分区分配）</li>
<li>非连续分配（页式存储管理、块式存储管理、块页式）</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
</li>
</ul>
<h3 id="5-10"><a href="#5-10" class="headerlink" title="5.10"></a>5.10</h3><ul>
<li><p>数学</p>
<p>  李林880 向量解答题 线性方程组选填</p>
<p>  武忠祥每日一题 x 2</p>
<ul>
<li>常见极限 x - sinx、tanx - x</li>
<li>极限等价代换的条件是 x 趋向于 0 而不能等于 0</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 3.1 内存管理概念（王道视频）</p>
</li>
<li><p>英语<br>  单词！</p>
</li>
</ul>
<h3 id="5-9"><a href="#5-9" class="headerlink" title="5.9"></a>5.9</h3><ul>
<li><p>数学</p>
<p>  李林880 矩阵解答题 向量填空题、选择题</p>
</li>
<li><p>408</p>
<p>  操作系统 2.4 死锁</p>
</li>
<li><p>英语</p>
<p>  不背单词 + 墨墨单词</p>
</li>
</ul>
<h3 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h3><ul>
<li><p>数学</p>
<p>  李林880 行列式 基础题 填空、解答</p>
<p>  武忠祥每日一题 x 2</p>
</li>
<li><p>408</p>
<p>  操作系统 2.3 进程同步</p>
<ul>
<li>临界资源</li>
<li>同步与互斥</li>
<li>信号量</li>
<li>生产者-消费者问题、读者-写者问题</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 不背复习 + 墨墨新学</p>
</li>
</ul>
<h3 id="5-6"><a href="#5-6" class="headerlink" title="5.6"></a>5.6</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 线性代数 二次型</p>
<ul>
<li>标准二次型和规范二次型</li>
<li>普通二次型到标准二次型的转换</li>
<li>惯性系数</li>
<li>矩阵的合同</li>
</ul>
<p>  武忠祥每日一题 x 2</p>
<p>  李林880 行列式 基础题 选择填空</p>
</li>
<li><p>408</p>
<p>  操作系统 2.2 处理机调度</p>
</li>
<li><p>英语</p>
<p>  复习不背单词 x 200</p>
<p>  新学墨墨单词 x 250</p>
</li>
</ul>
<h3 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 线性代数 特征值与特征向量</p>
<p>  武忠祥每日一题 x 2</p>
</li>
<li><p>408</p>
<p>  操作系统 2.1 进程管理</p>
<p>  数据结构 讲题顺带回顾了</p>
<ul>
<li>堆栈实现四则运算</li>
<li>二叉平衡树</li>
<li>散列表</li>
<li>克鲁斯卡尔和普利姆算法</li>
<li>迪杰斯特拉算法</li>
<li>快速排序</li>
</ul>
</li>
<li><p>英语</p>
<p>  复习不背单词</p>
<p>  新学墨墨单词</p>
</li>
</ul>
<h3 id="5-1-5-2-5-3-5-4"><a href="#5-1-5-2-5-3-5-4" class="headerlink" title="5.1 5.2 5.3 5.4"></a>5.1 5.2 5.3 5.4</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 线性代数 行列式、矩阵、向量、线性方程组</p>
</li>
<li><p>408</p>
<p>  操作系统 概述</p>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
</li>
</ul>
<blockquote>
<p>另外服务器到期，又花了不少的时间倒腾服务器的事情</p>
</blockquote>
<h1 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h1><h3 id="4-30"><a href="#4-30" class="headerlink" title="4.30"></a>4.30</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 二重积分</p>
<p>  武忠祥基础班 二重积分</p>
</li>
</ul>
<h3 id="4-29"><a href="#4-29" class="headerlink" title="4.29"></a>4.29</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 不定积分 + 定积分</p>
<p>  武忠祥基础班 不定积分 + 定积分</p>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li><p>回顾整理知识框架</p>
<p>  第四章 指令、第五章 CPU</p>
</li>
<li><p>数据结构</p>
<p>  LeetCode 每日一题</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  复习单词！</p>
</li>
</ul>
<h3 id="4-27"><a href="#4-27" class="headerlink" title="4.27"></a>4.27</h3><ul>
<li><p>数学</p>
<p>  武忠祥 多元函数微分学查漏补缺</p>
<ul>
<li>多元函数关系树形图</li>
<li>多元函数求导后求值，可以先带无关变量进去简化计算</li>
</ul>
<p>  李永乐全书 不定积分</p>
<p>  武忠祥 每日一题</p>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li><p>回顾整理知识框架</p>
<p>  第一章、第二章、第三章</p>
</li>
</ul>
<p>  数据结构</p>
<ul>
<li>LeetCode每日一题</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
<p>  不背单词 恋词5500 学完!（不知道复习要复习多久）</p>
</li>
</ul>
<h3 id="4-26"><a href="#4-26" class="headerlink" title="4.26"></a>4.26</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 多元函数微分学 + 不定积分</p>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li>7.4 I&#x2F;O方式 中断、DMA</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
</li>
</ul>
<h3 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 多元函数微分学例题</p>
</li>
<li><p>计组</p>
<ul>
<li>7.3 I&#x2F;O接口</li>
<li>7.4 I&#x2F;O方式 程序查询方式</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
</li>
</ul>
<h3 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h3><ul>
<li><p>数学</p>
<p>  李林880 第六章 微分方程 剩余填空及解答题</p>
<p>  李永乐全书 微分方程例题</p>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li><p>7.2 外部设备</p>
<ul>
<li>VRAM 容量及带宽</li>
<li>磁盘的传输速率及平均存取时间</li>
</ul>
</li>
<li><p>数据结构回顾 冒泡排序</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  复习单词 354个</p>
</li>
</ul>
<h3 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 微分方程例题</p>
<p>  李林880 第五章二重积分 解答题剩余部分 第六章 微分方程 选择题 部分填空题</p>
<p>  <strong>计算计算计算！</strong></p>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li>6.3 操作和定时</li>
<li>6.4 总线标准</li>
<li>7.1 I&#x2F;O 系统基本概念</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 547个</p>
</li>
</ul>
<h3 id="4-22"><a href="#4-22" class="headerlink" title="4.22"></a>4.22</h3><ul>
<li><p>数学</p>
<p>  李林880 第五章 二重积分 填空剩余部分、解答题（极坐标系的二重积分）</p>
</li>
<li><p>408</p>
<p>  计组 第六章 总线</p>
</li>
<li><p>英语</p>
<p>  单词 复习 + 新学200</p>
</li>
<li><p>科研训练</p>
<p>  FSBIF 整理</p>
</li>
</ul>
<h3 id="4-21"><a href="#4-21" class="headerlink" title="4.21"></a>4.21</h3><ul>
<li><p>数学</p>
<p>  李林880 第四章 多元函数微分学 基础题解答题部分</p>
<p>  ​					第五章 二重积分 选择填空部分 （<strong>变积分限</strong>）</p>
</li>
<li><p>408</p>
<p>  计组 5.5 指令流水线 </p>
<ul>
<li>数据相关、资源冲突、条件转移</li>
<li>吞吐率、加速比、效率</li>
<li>超标量流水线技术、超流水线技术</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 复习 + 新学200</p>
</li>
<li><p>科研训练</p>
<p>  Fuzzy Set-Based IF</p>
</li>
</ul>
<blockquote>
<p>重拾</p>
</blockquote>
<h3 id="4-20"><a href="#4-20" class="headerlink" title="4.20"></a>4.20</h3><ul>
<li><p>数学</p>
<p>  李林880 第四章 多元函数微分学 基础题</p>
</li>
<li><p>408</p>
<p>  计组  5.4 控制器的功能和原理</p>
<ul>
<li>控制器的结构和功能 CU、PC、IR</li>
<li>硬布线控制器、微程序控制器</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 复习 + 新学200</p>
</li>
</ul>
<h1 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h1><h3 id="3-18"><a href="#3-18" class="headerlink" title="3.18"></a>3.18</h3><ul>
<li><p>数学</p>
<p>  线性代数强化班第三次课</p>
<ul>
<li>矩阵运算</li>
<li>伴随矩阵</li>
<li>可逆矩阵</li>
<li>矩阵的 n 次方</li>
</ul>
</li>
<li><p>408</p>
<ul>
<li>散列表</li>
<li>插入排序</li>
</ul>
</li>
</ul>
<h3 id="3-17"><a href="#3-17" class="headerlink" title="3.17"></a>3.17</h3><ul>
<li><p>数学</p>
<p>  线性代数强化班第二次课</p>
</li>
<li><p>408</p>
<ul>
<li><p>查找概念</p>
</li>
<li><p>顺序查找</p>
</li>
<li><p>折半查找（二分查找）</p>
</li>
<li><p>分块查找</p>
</li>
<li><p>B树、B+树</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-16"><a href="#3-16" class="headerlink" title="3.16"></a>3.16</h3><ul>
<li><p>数学</p>
<p>  线性代数强化班第一次课</p>
</li>
<li><p>408</p>
<p>  6.4 图的应用</p>
<ul>
<li><p>最短路径：Floyd算法（动态规划）</p>
</li>
<li><p>拓扑排序</p>
</li>
<li><p>关键路径</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-15"><a href="#3-15" class="headerlink" title="3.15"></a>3.15</h3><ul>
<li><p>数学</p>
<p>  线代第一章：行列式</p>
</li>
<li><p>408</p>
<p>  6.3 图的遍历</p>
<ul>
<li>BFS</li>
<li>DFS</li>
</ul>
<p>  6.4 图的应用</p>
<ul>
<li>最小生成树：BFS、Prim 算法、Kruskal 算法</li>
<li>最短路径：Dijkstra 算法</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-14"><a href="#3-14" class="headerlink" title="3.14"></a>3.14</h3><ul>
<li><p>数学</p>
<p>  无</p>
</li>
<li><p>408</p>
<p>  6.1 图的基本概念</p>
<p>  6.2 图的存储操作</p>
<ul>
<li>邻接矩阵法</li>
<li>邻接表法</li>
<li>十字链表</li>
<li>邻接多重表</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-12"><a href="#3-12" class="headerlink" title="3.12"></a>3.12</h3><ul>
<li><p>数学</p>
<p>  回顾高数笔记</p>
</li>
<li><p>408</p>
<p>  5.5 树的应用</p>
<ul>
<li>二叉排序树</li>
<li>平衡二叉树</li>
<li>哈夫曼树和哈夫曼编码</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-11"><a href="#3-11" class="headerlink" title="3.11"></a>3.11</h3><ul>
<li><p>数学</p>
<p>  汤家凤基础班——第七章重积分</p>
</li>
<li><p>408</p>
<p>  5.4 树和森林</p>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-10"><a href="#3-10" class="headerlink" title="3.10"></a>3.10</h3><ul>
<li><p>数学</p>
<p>  接力题典1800——微分方程</p>
</li>
<li><p>408</p>
<p>  5.2 二叉树的性质</p>
<p>  5.3 二叉树的遍历(前序、中序、后序、层序)、线索化二叉树</p>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h3><ul>
<li><p>数学</p>
<p>  汤家凤基础班——第六章微分方程</p>
</li>
<li><p>408</p>
<p>  5.1 树的定义王道视频及对应习题</p>
</li>
<li><p>英语</p>
<p>  经济学人 1 篇</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h3><ul>
<li><p>数学</p>
<p>  接力题典1800 第六章入门部分</p>
</li>
<li><p>408</p>
<p>  串</p>
<ul>
<li>字符串</li>
<li><strong>字符串的匹配（暴力搜索和KMP）</strong></li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词：50个</p>
</li>
</ul>
<h3 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h3><ul>
<li><p>数学</p>
<p>  接力题典1800 第五章入门部分</p>
</li>
<li><p>408</p>
<p>  特殊矩阵</p>
<ul>
<li>对称矩阵</li>
<li>上（下）三角矩阵</li>
<li>三对角线矩阵</li>
<li>稀疏矩阵</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词：50个</p>
</li>
</ul>
<h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><ul>
<li><p>数学</p>
<p>  书到了！</p>
<p>  汤家凤基础班第六章所有视频</p>
</li>
<li><p>408</p>
<p>  无</p>
</li>
<li><p>英语</p>
<p>  不背单词：100个</p>
</li>
</ul>
<h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><ul>
<li><p>数学</p>
<p>  书还没有来，继续做前几章的习题</p>
</li>
<li><p>408</p>
<p>  浙大慕课二叉树的例题（求深度、求是否对称）</p>
<p>  BST</p>
</li>
<li><p>英语</p>
<p>  不背单词：160个</p>
</li>
</ul>
<h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>莫名其妙头疼睡了一天，可能是，学的太厉害了？</p>
<h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><p>返校归来打起精神继续开始！</p>
<ul>
<li>数学<ul>
<li>由于书还没有邮到，所有先停一停做做前几章笔记里的列题</li>
</ul>
</li>
<li>408<ul>
<li>树的建立、遍历，书还没有来~</li>
</ul>
</li>
<li>英语<ul>
<li>不背单词：5组</li>
</ul>
</li>
</ul>
<h1 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h1><h3 id="2-18"><a href="#2-18" class="headerlink" title="2.18"></a>2.18</h3><ul>
<li>数学<ul>
<li>接力题典1800 第五章 入门训练1-10</li>
</ul>
</li>
<li>墨墨单词：100个</li>
</ul>
<h3 id="2-17"><a href="#2-17" class="headerlink" title="2.17"></a>2.17</h3><ul>
<li>数学<ul>
<li>汤家凤高数基础班 29、30<ul>
<li>型三 定积分计算</li>
<li>型四 几何应用</li>
</ul>
</li>
</ul>
</li>
<li>看老师去了~</li>
</ul>
<h3 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h3><ul>
<li>数学（3h44min）<ul>
<li>汤家凤高数基础班  26、27、28<ul>
<li>奇（偶）函数、周期函数的定积分</li>
<li><strong>广义积分</strong>（反常积分）</li>
<li>几何应用：面积、体积</li>
<li>两种题型：概念与性质题、变积分限问题</li>
</ul>
</li>
</ul>
</li>
<li>408<ul>
<li>c++实现栈、顺序队列、链表队列</li>
<li>LeetCode每日一题</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
<li>刘晓燕</li>
</ul>
</li>
</ul>
<h3 id="2-15"><a href="#2-15" class="headerlink" title="2.15"></a>2.15</h3><ul>
<li>数学（4h55min）<ul>
<li>接力题典1800 第四章收尾</li>
<li>汤家凤高数基础班 23、24、25<ul>
<li>定积分的定义</li>
<li>定积分的一般性质</li>
<li>N-L 公式</li>
<li>定积分积分法</li>
</ul>
</li>
</ul>
</li>
<li>408<ul>
<li>数据结构王道单科书队列课后选择题</li>
</ul>
</li>
<li>英语：<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-14"><a href="#2-14" class="headerlink" title="2.14"></a>2.14</h3><ul>
<li>数学<ul>
<li>汤家凤基础班 21、22（不定积分剩下的部分）<ul>
<li>两种换元积分法（硬换、无理函数转有理函数）</li>
<li>平方和差还原（画三角形）</li>
<li>分部积分法的六种情形</li>
<li>有理函数的不定积分（真分式、假分式）</li>
</ul>
</li>
<li>接力题典1800 第四章入门部分（还留了些小尾巴）</li>
</ul>
</li>
<li>408<ul>
<li>数据结构王道单科书栈课后选择题</li>
<li>了解 C++ 基础语法</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-13"><a href="#2-13" class="headerlink" title="2.13"></a>2.13</h3><ul>
<li>数学<ul>
<li>汤家凤寒假专题三、四<ul>
<li>积分中值定理（开区间）</li>
<li>积分中值定理的推广（闭区间）</li>
</ul>
</li>
<li>汤家凤基础班 20 （不定积分第一小节）<ul>
<li>常用不定积分公式</li>
<li>还原法求不定积分</li>
</ul>
</li>
</ul>
</li>
<li>408<ul>
<li>LeetCode 每日一题</li>
<li>CASPP</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-12"><a href="#2-12" class="headerlink" title="2.12"></a>2.12</h3><ul>
<li>数学<ul>
<li>汤家凤基础班第三章剩下的题型</li>
<li>接力题典1800 第三章入门部分</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h3><ul>
<li>数学<ul>
<li>汤家凤基础班第二章题型</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><ul>
<li>数学<ul>
<li>汤家凤基础课18-19</li>
<li>接力题典1800  1-11题</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><ul>
<li>数学（5*45min）<ul>
<li>汤家凤基础课15-18</li>
</ul>
</li>
<li>408（3*45min）<ul>
<li>浙大MOOC 链表部分</li>
<li>王道第二章链表习题</li>
<li>手敲链表增删改查代码</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
<li>田静每日长难句</li>
</ul>
</li>
</ul>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><ul>
<li>数学（4*45min）<ul>
<li>汤家凤基础课13-14（讲义还没到，效率小低）</li>
</ul>
</li>
<li>408（3*45min）<ul>
<li>王道第二章线性表视频1-4</li>
<li>王道第二章线性表习题，线性表顺序表示部分的全部选择题</li>
<li>手敲顺序表增删改查代码，顺便把VSCode C语言环境配好</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
<li>田静每日长难句</li>
</ul>
</li>
</ul>
<h1 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h1><h3 id="1-30"><a href="#1-30" class="headerlink" title="1.30"></a>1.30</h3><ul>
<li>数学<ul>
<li>接力题典1800导数与微分入门练习：1-17</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="1-31"><a href="#1-31" class="headerlink" title="1.31"></a>1.31</h3><ul>
<li><p>数学（4*45min）</p>
<ul>
<li><p>汤家凤寒假专题（二）</p>
</li>
<li><p>汤家凤基础课 11-12</p>
</li>
</ul>
</li>
<li><p>408（2*45min）</p>
<ul>
<li>王道第一章概论全部视频</li>
<li>王道教材第一章习题全部选择题</li>
</ul>
</li>
<li><p>英语</p>
<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%80%83%E7%A0%94%E5%A5%8B%E6%96%97%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%81/" data-id="cleqef3we00ddogjoa75q41ns" data-title="【考研】考研冲冲冲！" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【数据结构与算法】LeetCode：每日一题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.285Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">【数据结构与算法】LeetCode：每日一题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h1><h2 id="3-连续数组🎈"><a href="#3-连续数组🎈" class="headerlink" title="3 连续数组🎈"></a>3 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contiguous-array/">连续数组</a>🎈</h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210603212532955.png" alt="image-20210603212532955" style="zoom:80%;" />

<h3 id="大佬思路"><a href="#大佬思路" class="headerlink" title="大佬思路"></a>大佬思路</h3><p>算法步骤：</p>
<p>创建一个哈希表，用 <code>key</code> 来储存 <code>cur</code> 值, <code>value</code> 来储存当前 <code>index</code>。</p>
<p>假设我们碰到 0 就将 <code>cur</code> 减一, 碰到 1 则 加一。<br>如果我们能在哈希表中找到当前的 <code>cur</code> 值, 则取出对应的 <code>pos</code>, 在看当前的 <code>index - pos</code> 是否比 <code>ans</code> 大, 取其中的最优解。</p>
<p><strong>核心：由于以上碰1加一，碰0减一的操作，当0与1数量一致时(连续数组), 其连续数组的和为零。因此我们知道数组前面的 <code>cur</code> 值是什么，在到达该连续数组尾部时就不会变。因此我们只需要检查哈希表中是否存在其相同的 <code>cur</code> 值即可！(多读几遍)</strong></p>
<blockquote>
<p>作者：Xiaohu9527<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contiguous-array/solution/dong-tu-yan-shi-qian-zhui-he-si-xiang-by-z2no/">https://leetcode-cn.com/problems/contiguous-array/solution/dong-tu-yan-shi-qian-zhui-he-si-xiang-by-z2no/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<img src="【数据结构与算法】LeetCode：每日一题/image-20210603214006741.png" alt="image-20210603214006741" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        map.put(counter, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(counter)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">prevIndex</span> <span class="operator">=</span> map.get(counter);</span><br><span class="line">                maxLength = Math.max(maxLength, i - prevIndex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(counter, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/contiguous-array/solution/lian-xu-shu-zu-by-leetcode-solution-mvnm/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h1 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h1><h2 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1. 无重复字符的最长子串"></a>1. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210504171538656.png" alt="image-20210504171538656" style="zoom:80%;" />

<h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>偷懒直接看了评论…</p>
<h3 id="大佬的思路"><a href="#大佬的思路" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p><strong>滑动窗口！！！</strong></p>
<p>滑动窗口具体内容就不多说了，直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 滑动窗口</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(r))) &#123;</span><br><span class="line">                l = Math.max(l, map.get(s.charAt(r)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(r), r);</span><br><span class="line">            max = Math.max(max, r - l + <span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-子数组异或查询"><a href="#2-子数组异或查询" class="headerlink" title="2. 子数组异或查询"></a>2. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">子数组异或查询</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210512172613337.png" alt="image-20210512172613337" style="zoom:80%;" />

<h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>直接两层循环搞定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] xorQueries(<span class="type">int</span>[] arr, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; queries.length; k++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queries[k][<span class="number">0</span>]; i &lt;= queries[k][<span class="number">1</span>]; i++) &#123;</span><br><span class="line">                tmp ^= arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res[k] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大佬的思路-1"><a href="#大佬的思路-1" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>题太简单，都差不多</p>
<h2 id="3-二叉树的堂兄弟节点"><a href="#3-二叉树的堂兄弟节点" class="headerlink" title="3. 二叉树的堂兄弟节点"></a>3. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">二叉树的堂兄弟节点</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210517213529650.png" alt="image-20210517213529650" style="zoom:80%;" />

<h3 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h3><p>层序遍历二叉树，如果某一层的节点满足条件且不是相同父节点，则输出 true</p>
<p>有想法但是没有实现</p>
<h3 id="大佬的思路-2"><a href="#大佬的思路-2" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/allenz-me/">FāKăL1</a></p>
<p>深度遍历，记录 x、y 两节点的深度与父节点，最后做判断即可</p>
<p>代码简单易懂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存 x、y 的深度与父节点</span></span><br><span class="line">    <span class="type">int</span> xpar, xdep, ypar, ydep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        dfs(root.left, <span class="number">1</span>, x, y, root.val);</span><br><span class="line">        dfs(root.right, <span class="number">1</span>, x, y, root.val);</span><br><span class="line">        <span class="keyword">return</span> (xpar != ypar) &amp;&amp; (xdep == ydep);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> dep, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> par)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.val == x) &#123;</span><br><span class="line">            xpar = par;</span><br><span class="line">            xdep = dep;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val == y) &#123;</span><br><span class="line">            ypar = par;</span><br><span class="line">            ydep = dep;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(node.left, dep+<span class="number">1</span>, x, y, node.val);</span><br><span class="line">            dfs(node.right, dep+<span class="number">1</span>, x, y, node.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-前K个高频单词"><a href="#4-前K个高频单词" class="headerlink" title="4. 前K个高频单词"></a>4. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-words/">前K个高频单词</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210520193745365.png" alt="image-20210520193745365" style="zoom:80%;" />

<h3 id="我的思路-3"><a href="#我的思路-3" class="headerlink" title="我的思路"></a>我的思路</h3><p>遍历 <code>words</code> 数组，将每个 <code>word</code> 及其出现的频率加入到一个 <code>map</code> 中，最后对 <code>map</code> 进行排序，输出前 <code>k</code> 个到 List 中进行返回。</p>
<p>思路没问题，但是在对 map 排序的时候出现了问题：需要同时对 <code>key</code> 和 <code>value</code> 进行排序</p>
<h3 id="大佬的思路-3"><a href="#大佬的思路-3" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><ul>
<li><code>map.entrySet</code> :</li>
</ul>
 <img src="【数据结构与算法】LeetCode：每日一题/image-20210520194554863.png" alt="image-20210520194554863" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            cnt.put(word, cnt.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; rec = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// Entry 可以建立起 key 与 value 一一对应的关系</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            rec.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(rec, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">                <span class="comment">// 两单词出现频率相同：按字母顺序排</span></span><br><span class="line">                <span class="comment">// 两单词出现频率不同：按单词频率排</span></span><br><span class="line">                <span class="keyword">return</span> cnt.get(word1) == cnt.get(word2) ? </span><br><span class="line">                    word1.compareTo(word2) : cnt.get(word2) - cnt.get(word1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rec.subList(<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-words/solution/qian-kge-gao-pin-dan-ci-by-leetcode-solu-3qk0/">https://leetcode-cn.com/problems/top-k-frequent-words/solution/qian-kge-gao-pin-dan-ci-by-leetcode-solu-3qk0/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h1 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h1><h2 id="1-递增顺序搜索树"><a href="#1-递增顺序搜索树" class="headerlink" title="1 递增顺序搜索树"></a>1 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-order-search-tree/">递增顺序搜索树</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210425210936999.png" alt="image-20210425210936999" style="zoom:80%;" />

<h3 id="我的思路-4"><a href="#我的思路-4" class="headerlink" title="我的思路"></a>我的思路</h3><p>先用一个数组保存树的中序序列，再通过中序序列根据题目要求构建新的树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">increasingBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inOrder(root, vals);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value: vals) &#123;</span><br><span class="line">            cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; vals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, vals);</span><br><span class="line">        vals.add(root.val);</span><br><span class="line">        inOrder(root.right, vals);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大佬的思路-4"><a href="#大佬的思路-4" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>在中序遍历的过程中，修改树的左右子节点，使左子树为空，右子树为中序中序遍历的下一个节点</p>
<img src="【数据结构与算法】LeetCode：每日一题/image-20210425211503346.png" alt="image-20210425211503346" style="zoom:80%;" />

<img src="【数据结构与算法】LeetCode：每日一题/image-20210425211522483.png" alt="image-20210425211522483" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode resNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">increasingBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>);</span><br><span class="line">        resNode = dummyNode;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> dummyNode.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历的过程中修改节点指向</span></span><br><span class="line">        resNode.right = node;</span><br><span class="line">        node.left = <span class="literal">null</span>;</span><br><span class="line">        resNode = node;</span><br><span class="line"></span><br><span class="line">        inorder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/increasing-order-search-tree/solution/di-zeng-shun-xu-cha-zhao-shu-by-leetcode-dfrr/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="2-在-D-天内送达包裹的能力"><a href="#2-在-D-天内送达包裹的能力" class="headerlink" title="2. 在 D 天内送达包裹的能力"></a>2. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210427200151926.png" alt="image-20210427200151926" style="zoom:80%;" />

<h3 id="我的思路-5"><a href="#我的思路-5" class="headerlink" title="我的思路"></a>我的思路</h3><p>没有一点点挣扎</p>
<h3 id="大佬的思路-5"><a href="#大佬的思路-5" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>采用二分查找</p>
<p>根据题意，结果一定落在 <code>[max(weights), sum(weights)]</code> 这个区间上</p>
<ul>
<li><p>左端点：船的运载能力不能小于单个包裹的重量</p>
</li>
<li><p>右端点：一艘船一次性直接把所有货物拉走</p>
</li>
</ul>
<p>在左右端点之间进行二分查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> D)</span> &#123;</span><br><span class="line">        <span class="comment">// 确定二分查找左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// need 为需要运送的天数</span></span><br><span class="line">            <span class="comment">// cur 为当前这一天已经运送的包裹重量之和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">need</span> <span class="operator">=</span> <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> weight : weights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur + weight &gt; mid) &#123;</span><br><span class="line">                    ++need;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weight;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need &lt;= D) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/solution/zai-d-tian-nei-song-da-bao-guo-de-neng-l-ntml/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="3-二叉搜索树的范围和"><a href="#3-二叉搜索树的范围和" class="headerlink" title="3. 二叉搜索树的范围和"></a>3. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-of-bst/">二叉搜索树的范围和</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210427191433608.png" alt="image-20210427191433608" style="zoom:80%;" />

<h3 id="我的思路-6"><a href="#我的思路-6" class="headerlink" title="我的思路"></a>我的思路</h3><p>困难题唯唯诺诺，简单题重拳出击</p>
<p>遍历二叉树，遍历过程中判断每个节点的值是否在 <code>low</code> 与 <code>high</code> 之间，满足条件就把 <code>sum</code> 加上该值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        inOrder(root, low, high);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, low, high);</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt;= low &amp;&amp; root.val &lt;= high) sum += root.val;</span><br><span class="line">        inOrder(root.right, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是考虑到题目中所给出的树是<strong>二叉搜索树</strong>，这一条件并没有被我用上，所以肯定可以通过这一条件对算法进行改进</p>
<h3 id="大佬的思路-6"><a href="#大佬的思路-6" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>直接进行递归，不借用辅助中序遍历的函数</p>
<p>有用到二叉搜索树的性质</p>
<p>效率更高且代码更加优雅</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt;= low &amp;&amp; root.val &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val + </span><br><span class="line">                   rangeSumBST(root.left, low, high) + </span><br><span class="line">                   rangeSumBST(root.right, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.right, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-两数相加"><a href="#4-两数相加" class="headerlink" title="4. 两数相加"></a>4. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210429203603745.png" alt="image-20210429203603745" style="zoom:80%;" />

<h3 id="我的思路-7"><a href="#我的思路-7" class="headerlink" title="我的思路"></a>我的思路</h3><ol>
<li><p>同时遍历两个链表，将对应位相加得 <code>val</code>，<code>val % 10</code> 存入新链表对应节点中，<code>val / 10</code> 作为进位与下一位相加</p>
<p> 思路没问题，但是最后的一位如果出现进位的的问题一直没能解决</p>
</li>
<li><p>先遍历链表得到两个整数，将两个整数相加后再转换为链表</p>
<p> 被测试用例教做人</p>
 <img src="【数据结构与算法】LeetCode：每日一题/image-20210429204608148.png" alt="image-20210429204608148" style="zoom:80%;" /></li>
</ol>
<h3 id="大佬的思路-7"><a href="#大佬的思路-7" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>思路大致与我的思路一相同，但是在循环条件中加了一条判断进位是否为0的条件，完美解决了我的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>; </span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2 + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">sumNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            cur.next = sumNode;</span><br><span class="line">            cur = sumNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h1><h2 id="1-公平的糖果棒交换"><a href="#1-公平的糖果棒交换" class="headerlink" title="1 公平的糖果棒交换"></a>1 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fair-candy-swap">公平的糖果棒交换</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210201222030150.png" alt="image-20210201222030150" style="zoom:80%;" />

<h3 id="自己家的解法"><a href="#自己家的解法" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><p>求出两个数组中个数的总和 <code>sum</code>，取其一半就是交换后<strong>各自数组</strong>中数的总和 <code>val</code></p>
<p>原数组中数的总和 <code>sumA</code>、<code>sumB</code>与 <code>val</code>只差就是需要交换的数量，分别找出每个数组中的这个差值的位置</p>
<p>接下来就遇到问题卡住辽</p>
<h3 id="别人家的解法"><a href="#别人家的解法" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><ul>
<li>哈希表</li>
</ul>
<img src="【数据结构与算法】LeetCode：每日一题/image-20210201224115760.png" alt="image-20210201224115760" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] fairCandySwap(<span class="type">int</span>[] A, <span class="type">int</span>[] B) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumA</span> <span class="operator">=</span> Arrays.stream(A).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumB</span> <span class="operator">=</span> Arrays.stream(B).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> (sumA - sumB) / <span class="number">2</span>;</span><br><span class="line">        Set&lt;Integer&gt; rec = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: A) &#123;</span><br><span class="line">            rec.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y: B) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> y + delta;</span><br><span class="line">            <span class="keyword">if</span>(rec.contains(x)) &#123;</span><br><span class="line">                ans[<span class="number">0</span>] = x;</span><br><span class="line">                ans[<span class="number">1</span>] = y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-替换后的最长重复字符"><a href="#2-替换后的最长重复字符" class="headerlink" title="2 替换后的最长重复字符"></a>2 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-repeating-character-replacement">替换后的最长重复字符</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210203191952563.png" alt="image-20210203191952563" style="zoom:80%;" />

<h3 id="自己家的解法-1"><a href="#自己家的解法-1" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><p>None</p>
<h3 id="别人家的解法-1"><a href="#别人家的解法-1" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><ul>
<li>本题是比较典型的滑动窗口问题</li>
<li>这类问题一般通过一个滑动窗口就能在 <em>O(N)</em> 的时间复杂度下求解</li>
</ul>
<p>本题可以先退化成考虑 <em>K&#x3D;0</em> 的情况，此时题目就变成了求解字符串中最长连续子串长度问题了。<br>  我们先可以通过这个特例先了解一下滑动窗口的求解过程</p>
<img src="【数据结构与算法】LeetCode：每日一题/578fc15b7b426eb61dcf1fd73bb87f1511d8733c474797dbb9188b706a219cc5.jpg" alt="滑动窗口求解最长连续子串长度" style="zoom:80%;" />

<p>上图的求解过程展示中，窗口从左至右不断扩张&#x2F;滑动，当窗口触达字符串末尾字符时，运算结束，窗口的宽度为最终结果。初始窗口的宽度为 1，我们不断的通过向当前窗口覆盖的子串后面追加一个字符看是否能满足我们的要求，如果满足窗口扩张，如果不满足，窗口向右滑动。</p>
<p>当 K&gt;0K&gt;0 时，子串的条件变成了允许我们变换子串中的 KK 个字符使其变成一个连续子串</p>
<p>那么这个题的关键点就是我们如何判断一个字符串改变 KK 个字符，能够变成一个连续串</p>
<p>如果当前字符串中的出现次数最多的字母个数 +K+K 大于串长度，那么这个串就是满足条件的</p>
<p>我们维护一个数组 int[26] 来存储当前窗口中各个字母的出现次数，leftleft 表示窗口的左边界，rightright 表示窗口右边界</p>
<p>窗口扩张：<code>left</code> 不变，<code>right++</code><br>窗口滑动：<code>left++</code>，<code>right++</code><br><code>historyCharMax</code> 保存滑动窗口内相同字母出现次数的 历史 最大值，通过判断窗口宽度                               <code>(right - left + 1)</code> 是否大于 <code>historyCharMax + k</code> 来决定窗口是否做滑动，否则窗口就扩张。</p>
<blockquote>
<p>作者：migoo<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/tong-guo-ci-ti-liao-jie-yi-xia-shi-yao-shi-hua-don/">https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/tong-guo-ci-ti-liao-jie-yi-xia-shi-yao-shi-hua-don/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characterReplacement</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 建立字符表，记录每个字符出现的次数</span></span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 记录字符串中出现次数最多的字母出现的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">historyCharMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 双指针，记录滑动窗口的左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 将新加入的字符加入字符表中</span></span><br><span class="line">            num[s.charAt(right) - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            <span class="comment">// 看新加入的字符是否会影响出现最多的字符</span></span><br><span class="line">            maxn = Math.max(maxn, num[s.charAt(right) - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">            <span class="comment">// 如果 滑动窗口宽度 大于 窗口内出现次数最多的字符与k之和，则窗口左边界移动</span></span><br><span class="line">            <span class="comment">// 既将其他字符中的k个字符全部进行替换以后窗口大小最长字串长度并不会增加</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; historyCharMax + k) &#123;</span><br><span class="line">                num[s.charAt(left) - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回滑动窗口的大小</span></span><br><span class="line">        <span class="keyword">return</span> right - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-滑动窗口中位数"><a href="#3-滑动窗口中位数" class="headerlink" title="3 滑动窗口中位数"></a>3 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-median/">滑动窗口中位数</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210203233343603.png" alt="image-20210203233343603" style="zoom:80%;" />

<h3 id="自己家的解法-2"><a href="#自己家的解法-2" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><p>最朴素的暴力求法，不出所料了的超时了…</p>
<h3 id="别人家的解法-2"><a href="#别人家的解法-2" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><p>直接挂链接吧：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/">https://leetcode-cn.com/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] medianSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">DualHeap</span> <span class="variable">dh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DualHeap</span>(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            dh.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span>[] ans = <span class="keyword">new</span> <span class="title class_">double</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = dh.getMedian();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            dh.insert(nums[i]);</span><br><span class="line">            dh.erase(nums[i - k]);</span><br><span class="line">            ans[i - k + <span class="number">1</span>] = dh.getMedian();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DualHeap</span> &#123;</span><br><span class="line">    <span class="comment">// 大根堆，维护较小的一半元素</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line">    <span class="comment">// 小根堆，维护较大的一半元素</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line">    <span class="comment">// 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; delayed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="comment">// small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> smallSize, largeSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DualHeap</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.small = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer num1, Integer num2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> num2.compareTo(num1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.large = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer num1, Integer num2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> num1.compareTo(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.delayed = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.smallSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.largeSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (k &amp; <span class="number">1</span>) == <span class="number">1</span> ? small.peek() : ((<span class="type">double</span>) small.peek() + large.peek()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (small.isEmpty() || num &lt;= small.peek()) &#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">            ++smallSize;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">            ++largeSize;</span><br><span class="line">        &#125;</span><br><span class="line">        makeBalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        delayed.put(num, delayed.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= small.peek()) &#123;</span><br><span class="line">            --smallSize;</span><br><span class="line">            <span class="keyword">if</span> (num == small.peek()) &#123;</span><br><span class="line">                prune(small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --largeSize;</span><br><span class="line">            <span class="keyword">if</span> (num == large.peek()) &#123;</span><br><span class="line">                prune(large);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        makeBalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断地弹出 heap 的堆顶元素，并且更新哈希表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prune</span><span class="params">(PriorityQueue&lt;Integer&gt; heap)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> heap.peek();</span><br><span class="line">            <span class="keyword">if</span> (delayed.containsKey(num)) &#123;</span><br><span class="line">                delayed.put(num, delayed.get(num) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (delayed.get(num) == <span class="number">0</span>) &#123;</span><br><span class="line">                    delayed.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (smallSize &gt; largeSize + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// small 比 large 元素多 2 个</span></span><br><span class="line">            large.offer(small.poll());</span><br><span class="line">            --smallSize;</span><br><span class="line">            ++largeSize;</span><br><span class="line">            <span class="comment">// small 堆顶元素被移除，需要进行 prune</span></span><br><span class="line">            prune(small);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (smallSize &lt; largeSize) &#123;</span><br><span class="line">            <span class="comment">// large 比 small 元素多 1 个</span></span><br><span class="line">            small.offer(large.poll());</span><br><span class="line">            ++smallSize;</span><br><span class="line">            --largeSize;</span><br><span class="line">            <span class="comment">// large 堆顶元素被移除，需要进行 prune</span></span><br><span class="line">            prune(large);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/">https://leetcode-cn.com/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="4-子数组最大平均数-I"><a href="#4-子数组最大平均数-I" class="headerlink" title="4 子数组最大平均数 I"></a>4 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">子数组最大平均数 I</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210204202536643.png" alt="image-20210204202536643" style="zoom:80%;" />

<h3 id="自己家解法"><a href="#自己家解法" class="headerlink" title="自己家解法"></a>自己家解法</h3><p>楞头暴力求也没多想…</p>
<h3 id="别人家解法"><a href="#别人家解法" class="headerlink" title="别人家解法"></a>别人家解法</h3><ul>
<li>先求出前 <code>k</code> 个数的和 <code>sum</code></li>
<li>接下来开始滑动窗口，每次滑动后 <code>sum</code> 的值变为 <code>sum</code> 加上新进入窗口的值，再减去从窗口中滑出的值</li>
<li>使用变量 <code>maxSum</code> 记录每次滑动后 <code>sum</code> 的最大值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum = sum + nums[i] - nums[i - k];</span><br><span class="line">            maxSum = Math.max(sum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * maxSum / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tips：</strong></p>
<ul>
<li><code>double</code> 类型的变量进行运算会较慢，所以可以先求 <code>int</code>类型的和，最后求平均时再转为 <code>double</code></li>
</ul>
<h2 id="13-找到所有数组中消失的数字"><a href="#13-找到所有数组中消失的数字" class="headerlink" title="13 找到所有数组中消失的数字"></a>13 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">找到所有数组中消失的数字</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210213213522841.png" alt="image-20210213213522841" style="zoom:80%;" />

<h3 id="自己家的解法-3"><a href="#自己家的解法-3" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><ul>
<li><p>一个思路</p>
<p>  既然要求没有出现的数字，那就把出现过的数字加入到一个 <code>Set</code> 中，从 1 到 n 开始遍历，不在 <code>Set</code> 中的数就是在数组中没有出现过的数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(i)) list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>另一个思路</p>
<p>  从1 - n求和得到 <code>sum1</code>，再将数组中的数求和得到 <code>sum2</code></p>
<p>   <code>sum1 - sum2</code> 就等于 <strong>没有出现的数减去重复出现的数</strong></p>
<p>  具体就不知道怎么实现了…</p>
</li>
</ul>
<h3 id="别人家的解法-3"><a href="#别人家的解法-3" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><ol>
<li>将数组元素对应为索引的位置 <strong>加n</strong> （<strong>置为负数</strong>）</li>
<li>遍历变化后得数组，若数组元素 小于n值（为负值），说明数组下标不存在，既为消失的数字</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            nums[(num - <span class="number">1</span>) % n] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= n) res.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-数组拆分-I"><a href="#16-数组拆分-I" class="headerlink" title="16 数组拆分 I"></a>16 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210216231135883.png" alt="image-20210216231135883" style="zoom:80%;" />

<h3 id="自己家的解法-4"><a href="#自己家的解法-4" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><p>将所给数组排序，<strong>奇数位置的数之和</strong>就是题目中要求的<strong>最大总和</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arrayPairSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="别人家的解法-4"><a href="#别人家的解法-4" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><p>跟我的想法差不多嘛</p>
 <img src="【数据结构与算法】LeetCode：每日一题/image-20210216231352461.png" alt="image-20210216231352461" style="zoom:67%;" />

<h2 id="19-最大连续1的个数-III"><a href="#19-最大连续1的个数-III" class="headerlink" title="19 最大连续1的个数 III"></a>19 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">最大连续1的个数 III</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210219230908647.png" alt="image-20210219230908647" style="zoom:80%;" />

<h3 id="别人家思路"><a href="#别人家思路" class="headerlink" title="别人家思路"></a>别人家思路</h3><p>问题可以转化为 <strong>找出一个最长字串，其中最多允许有 k 个 0</strong> </p>
<p>最大连续子区间问题，可以使用 <strong>滑动窗口</strong> 解决</p>
<ul>
<li><p>两个指针分别指向窗口的两端：<code>left</code>、<code>right</code></p>
</li>
<li><p><code>right</code> 主动右移，若窗口内 0 的个数大于 k，考虑左移 <code>left</code></p>
</li>
<li><p>一直左移 <code>left</code>，直到窗口内 0 的个数小于 k</p>
</li>
<li><p>统计每次移动后窗口的长度</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑到之后考研算法题大多需要用c或c++实现，故之后的代码都选择用c++实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, zeros = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; A.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[right] == <span class="number">0</span>) zeros++;</span><br><span class="line">            <span class="keyword">while</span> (zeros &gt; K) &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[left++] == <span class="number">0</span>) --zeros;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="20-比特位计数"><a href="#20-比特位计数" class="headerlink" title="20 比特位计数"></a>20 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210303212948035.png" alt="image-20210303212948035" style="zoom:80%;" />

<h3 id="自己家解法-1"><a href="#自己家解法-1" class="headerlink" title="自己家解法"></a>自己家解法</h3><p>没思路直接看了官方解</p>
<h3 id="别人家解法-1"><a href="#别人家解法-1" class="headerlink" title="别人家解法"></a>别人家解法</h3><blockquote>
<p>以下思路及代码均取自<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/">LeetCode官方解</a></p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/">https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<ul>
<li><p>暴力法</p>
<p>  从 0 到 num 计算每个数二进制的 【一比特数】</p>
<p>  对于任意整数 <code>x</code>，<code>x = x &amp; (x - 1)</code> 可以将二进制下 <code>x</code> 的<strong>最后一位 1 置为 0</strong>，重复操作，操作次数既为 x 的【一比特数】</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countOnes</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(num + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            bits[i] = <span class="built_in">countOnes</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>动态规划——最高有效位</p>
<p>   <img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20210303214100186.png" alt="image-20210303214100186"></p>
<p>  我们规定 2 的整数次方为<strong>最高有效位</strong>，最高有效位之间的数与上一最高有效位之间的数存在一定关系，具体看原回答</p>
<p>  其实就是偷懒</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] <span class="built_in">countBits</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="type">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态规划——最低有效位<ul>
<li>如果 <code>x</code> 是偶数， 那 <code>countBits(x) == countBits(x / 2)</code></li>
<li>如果 <code>x</code> 是奇数，那<code>countBits(x) == countBits(x - 1) + 1</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] <span class="built_in">countBits</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="type">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" data-id="cleqef3vf0072ogjogrs09rbv" data-title="【数据结构与算法】LeetCode：每日一题" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【机器学习】Python数据分析常用库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.571Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%BA%93/">【机器学习】Python数据分析常用库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>刚结束了4四天的死亡美赛，在建模过程和之前机器学习进行数据分析过程中用到了大量 Python 数据分析常用库</p>
<p>一次次在搜索引擎上查各个库的用法是真滴麻烦</p>
<p>本篇博客用以记录 Python 数据分析中常用库的常用用法，日常用到时查阅方便</p>
</blockquote>
<h1 id="1-Numpy"><a href="#1-Numpy" class="headerlink" title="1. Numpy"></a>1. Numpy</h1><ul>
<li><p>Python没有提供数组功能，Numpy可以提供数组支持以及相应的高效处理函数，是Python数据分析的基础，也是SciPy、Pandas等数据处理和科学计算库最基本的函数功能库，且其数据类型对Python数据分析十分有用。</p>
</li>
<li><p>Numpy提供了<strong>两种基本的对象</strong>：<strong>ndarray和ufunc</strong>。<strong>ndarray是存储单一数据类型的多维数组，而ufunc是能够对数组进行处理的函数</strong>。Numpy的功能：</p>
<ul>
<li>N维数组，一种快速、高效使用内存的多维数组，他提供矢量化数学运算。</li>
<li>可以不需要使用循环，就能对整个数组内的数据进行标准数学运算。</li>
<li>非常便于传送数据到用低级语言编写(C\C++)的外部库,也便于外部库以Numpy数组形式返回数据。</li>
</ul>
</li>
<li><p>Numpy不提供高级数据分析功能，但可以更加深刻的理解Numpy数组和面向数组的计算。</p>
</li>
<li><p>官方文档：<a target="_blank" rel="noopener" href="https://numpy.org/doc/stable/">https://numpy.org/doc/stable/</a>    （加载起来小慢）             </p>
<p>  中文文档：<a target="_blank" rel="noopener" href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>



<h3 id="1-1-创建-ndarray"><a href="#1-1-创建-ndarray" class="headerlink" title="1.1 创建 ndarray"></a>1.1 创建 ndarray</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">np.arange(n)</td>
<td align="center">类似range函数，放回ndarray类型，元素从0到n-1</td>
</tr>
<tr>
<td align="center">np.ones(shape)</td>
<td align="center">根据shape生成一个全1数组，shape是元组类型</td>
</tr>
<tr>
<td align="center">np.zeros(shape)</td>
<td align="center">根据shape生成一个全0数组</td>
</tr>
<tr>
<td align="center">np.full(shape,val)</td>
<td align="center">根据shape生成一个数组，每个元素值都为val</td>
</tr>
<tr>
<td align="center">np.eye(n)</td>
<td align="center">创建一个正方的n*n单位矩阵，对角线全为1其余为0</td>
</tr>
<tr>
<td align="center">np.linspace(b,e,n)</td>
<td align="center">根据起始值等间距的填充数据，形成数组</td>
</tr>
</tbody></table>
<h3 id="1-2-数组的变换"><a href="#1-2-数组的变换" class="headerlink" title="1.2 数组的变换"></a>1.2 数组的变换</h3><table>
<thead>
<tr>
<th>.reshape(shape)</th>
<th>不改变数组元素，返回一个shape形状的数组，但原数组不变</th>
</tr>
</thead>
<tbody><tr>
<td>.resize(shape)</td>
<td>与.reshape()功能一致，但修改原数组</td>
</tr>
<tr>
<td>.swapaxes(ax1,ax2)</td>
<td>将数组n个维度中两个进行交换</td>
</tr>
<tr>
<td>.flatten()</td>
<td>对数组进行降维,返回折叠后的一维数组，原数组不变</td>
</tr>
</tbody></table>
<h3 id="1-3-数组的运算"><a href="#1-3-数组的运算" class="headerlink" title="1.3  数组的运算"></a>1.3  数组的运算</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">np.abs(x) , np. fabs(x)</td>
<td align="center">计算数组各数的绝对值</td>
</tr>
<tr>
<td align="center">np.sqrt(x)</td>
<td align="center">计算数组各元素的平方</td>
</tr>
<tr>
<td align="center">np.square()</td>
<td align="center">计算数组各元素的平方</td>
</tr>
<tr>
<td align="center">np.log(x), np.log10(x), np.log2(x)</td>
<td align="center">计算各元素的自然对数，10底对数和2底对数</td>
</tr>
<tr>
<td align="center">np.ceil(x),np.floor(x)</td>
<td align="center">前者向上取整，后者向下取整</td>
</tr>
<tr>
<td align="center">np.rint(x)</td>
<td align="center">四舍五入</td>
</tr>
<tr>
<td align="center">np.modf(x)</td>
<td align="center">将各元素的小数和整数部分以两个独立的数组形式返回</td>
</tr>
<tr>
<td align="center">np.cos(x), np.cosh(x), np.sin(x), np.sinh(x), np.tan(x), np.tanh(x)</td>
<td align="center">计算各元素的普通型和双曲型三角函数</td>
</tr>
<tr>
<td align="center">np.exp(x)</td>
<td align="center">各元素指数值</td>
</tr>
<tr>
<td align="center">np.sign(x)</td>
<td align="center">计算各元素的符号值,1(+),0(0),-1(-)</td>
</tr>
</tbody></table>
<h3 id="1-4-统计函数"><a href="#1-4-统计函数" class="headerlink" title="1.4 统计函数"></a>1.4 统计函数</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sum(a,axis&#x3D;None)</td>
<td align="center">根据给定轴 axis 计算数组 a 相关元素之和，axis 为整数或元组</td>
</tr>
<tr>
<td align="center">mean(a,axis&#x3D;None)</td>
<td align="center">计算期望</td>
</tr>
<tr>
<td align="center">average(a,axis&#x3D;None,weights&#x3D;None)</td>
<td align="center">计算加权平均值</td>
</tr>
<tr>
<td align="center">std(a,axis&#x3D;None)</td>
<td align="center">计算标准差</td>
</tr>
<tr>
<td align="center">var(a,axis&#x3D;None</td>
<td align="center">计算方差</td>
</tr>
<tr>
<td align="center">min(a), max(a)</td>
<td align="center">计算a中的最小值，最大值</td>
</tr>
<tr>
<td align="center">ptp(a)</td>
<td align="center">计算最大值与最小值的差</td>
</tr>
<tr>
<td align="center">median(a)</td>
<td align="center">计算中位数</td>
</tr>
</tbody></table>
<h3 id="1-5-矩阵操作"><a href="#1-5-矩阵操作" class="headerlink" title="1.5 矩阵操作"></a>1.5 矩阵操作</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.T &#x2F; np.transpose()</td>
<td align="center">矩阵转置</td>
</tr>
<tr>
<td align="center">.dot(nd)</td>
<td align="center">矩阵点乘</td>
</tr>
<tr>
<td align="center">.trace()</td>
<td align="center">矩阵的迹（对角线之和）</td>
</tr>
<tr>
<td align="center">np.linalg.det(nd)</td>
<td align="center">矩阵行列式</td>
</tr>
</tbody></table>
<h1 id="2-Pandas"><a href="#2-Pandas" class="headerlink" title="2. Pandas"></a>2. Pandas</h1><ul>
<li><p>Pandas 是 Python 强大、灵活的数据分析和探索工具，包含 <strong>Series、DataFrame</strong> 等高级数据结构和工具，安装Pandas可使Python中处理数据非常快速和简单。</p>
</li>
<li><p>Pandas 是 Python 的一个数据分析包，Pandas最初被用作金融数据分析工具而开发出来，因此Pandas为<strong>时间序列分析</strong>提供了很好的支持。</p>
</li>
<li><p>Pandas 是为了解决数据分析任务而创建的，Pandas 纳入了大量的库和一些标准的数据模型，提供了高效的操作大型数据集所需要的工具。Pandas 提供了大量是我们快速便捷的处理数据的函数和方法。Pandas包含了高级数据结构，以及让数据分析变得快速、简单的工具。它建立在 Numpy 之上，使得 Numpy 应用变得简单。</p>
</li>
<li><p>带有坐标轴的数据结构，支持自动或明确的数据对齐。这能防止由于数据结构没有对齐，以及处理不同来源、采用不同索引的数据而产生的常见错误。</p>
</li>
<li><p>使用Pandas更容易处理丢失数据。</p>
</li>
<li><p>官方文档：<a target="_blank" rel="noopener" href="https://pandas.pydata.org/docs/">https://pandas.pydata.org/docs/</a></p>
<p>  中文文档：<a target="_blank" rel="noopener" href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>



<h3 id="2-1-导入数据"><a href="#2-1-导入数据" class="headerlink" title="2.1 导入数据"></a>2.1 导入数据</h3><p>导入数据后自动将数据转化为 <strong>DataFrame</strong> 结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pd.read_csv(file_name)					<span class="comment"># 从CSV文件中读取所有数据</span></span><br><span class="line">pd.read_table(file_name)				<span class="comment"># 从一个分隔的文本文件（如TSV）中读取所有数据</span></span><br><span class="line">pd.read_excel(file_name)				<span class="comment"># 从Excel表读取</span></span><br><span class="line">pd.read_sql(query, connectionObject)	<span class="comment"># 从SQL数据库中读取数据</span></span><br><span class="line">pd.read_json(jsonString)				<span class="comment"># 从JSON格式的字符串或URL中获取数据</span></span><br><span class="line">pd.read_clipboard()						<span class="comment"># 要获取剪贴板的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-导出文件"><a href="#2-2-导出文件" class="headerlink" title="2.2 导出文件"></a>2.2 导出文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(file_name)					<span class="comment"># 将DataFrame写入CSV文件</span></span><br><span class="line">df.to_excel(file_name)					<span class="comment"># 将DataFrame写入Excel文件</span></span><br><span class="line">df.to_sql(tableName, connectionObject)	<span class="comment"># 将一个DataFrame写入一个SQL表</span></span><br><span class="line">df.to_json(file_name)					<span class="comment"># 将DataFrame写入JSON格式的文件</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-查看-DataFrame-的相关信息"><a href="#2-3-查看-DataFrame-的相关信息" class="headerlink" title="2.3 查看 DataFrame 的相关信息"></a>2.3 查看 DataFrame 的相关信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.info()		<span class="comment"># 获取所有与索引、数据类型和内存相关的信息</span></span><br><span class="line">df.head(n)		<span class="comment"># 要提取DataFrame的起始n行</span></span><br><span class="line">df.tail(n)		<span class="comment"># 要提取DataFrame中最后n行</span></span><br><span class="line">df.shape		<span class="comment"># 要提取DataFrame中可用的行数和列数</span></span><br><span class="line">df.describe()	<span class="comment"># 总结数字列的统计</span></span><br><span class="line">df.mean()		<span class="comment"># 返回所有列的平均值</span></span><br><span class="line">df.count()		<span class="comment"># 返回非空值的数量</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-数据切片"><a href="#2-4-数据切片" class="headerlink" title="2.4 数据切片"></a>2.4 数据切片</h3><ul>
<li><p><code>loc</code>：可以按照数据的行名、列名进行索引，也可以用行号、列号进行索引</p>
<p>  <strong>但是不能索引不存在的行号（列好），比如- 1</strong></p>
</li>
<li><p><code>iloc</code>：只能根据行号、列号进行索引</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按行号和列号进行切片</span></span><br><span class="line">df.iloc[:, :]					<span class="comment"># 提取所有数据</span></span><br><span class="line">df.iloc[<span class="number">0</span>]						<span class="comment"># 取第一行的数据</span></span><br><span class="line">df.iloc[:, <span class="number">0</span>]					<span class="comment"># 取第一列的数据</span></span><br><span class="line">df.iloc[<span class="number">0</span>:<span class="number">5</span>, <span class="number">2</span>:-<span class="number">1</span>]				<span class="comment"># 取第一行到第五行，第二列到倒数第一列的数据（不包括倒数第一列）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行名和列名进行切片</span></span><br><span class="line">df[<span class="string">&#x27;A&#x27;</span>] / df.A					<span class="comment"># 提取列名为A的数据</span></span><br><span class="line">df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]]					<span class="comment"># 提取列名为A和B的数据</span></span><br><span class="line">df.loc[<span class="string">&#x27;a&#x27;</span>]						<span class="comment"># 提取行名为a的数据</span></span><br><span class="line">df.loc[:, <span class="string">&#x27;A&#x27;</span>]					<span class="comment"># 提取列名为A的数据</span></span><br><span class="line">df.loc[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]]	<span class="comment"># 提取行名为a和b，列名为A和B的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按条件进行切片，提取数据所在行</span></span><br><span class="line">df[df[<span class="string">&#x27;A&#x27;</span>] == <span class="number">0</span>] / df.loc[df[<span class="string">&#x27;A&#x27;</span>] == <span class="number">0</span>]							<span class="comment"># 提取A列中数据等于0的行</span></span><br><span class="line">df[(df.A == <span class="number">0</span>)&amp;(df.B == <span class="number">2</span>)] / df.loc[(df.A == <span class="number">0</span>)&amp;(df.B == <span class="number">2</span>)]	<span class="comment"># 多条件筛选</span></span><br><span class="line">data[data[<span class="string">&#x27;A&#x27;</span>].isin([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])]									<span class="comment"># 提取A列数据在[0,1,2]中的行</span></span><br><span class="line">df[~df[<span class="string">&#x27;A&#x27;</span>].isin(a)]											<span class="comment"># 按条件去除某一列</span></span><br><span class="line"></span><br><span class="line">df.query(expr)				<span class="comment"># 根据布尔值查找满足条件的行，expr是一个字符串形式的布尔表达式</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-数据操作"><a href="#2-5-数据操作" class="headerlink" title="2.5 数据操作"></a>2.5 数据操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df.rename(columns = <span class="keyword">lambda</span> x: x + <span class="string">&#x27;1&#x27;</span>)			<span class="comment"># 同时重命名所有列</span></span><br><span class="line">df.rename(columns = &#123;<span class="string">&#x27;oldName&#x27;</span>: <span class="string">&#x27;newName&#x27;</span>&#125;)		<span class="comment"># 选择性地重命名列</span></span><br><span class="line">df.rename(index = <span class="keyword">lambda</span> x: x + <span class="number">1</span>)				<span class="comment"># 重命名所有的索引</span></span><br><span class="line">df.columns = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]					<span class="comment"># 按顺序重命名列</span></span><br><span class="line">df.isnull()										<span class="comment"># 检查是否存在空值，相应地返回一个布尔型数组</span></span><br><span class="line">df.notnull()									<span class="comment"># 与上一条相反</span></span><br><span class="line">df.dropna()										<span class="comment"># 删除所有包含空的行</span></span><br><span class="line">df.dropna(axis=<span class="number">1</span>)								<span class="comment"># 删除所有包含空的列</span></span><br><span class="line">df.fillna(n)									<span class="comment"># 用n代替每个空值</span></span><br><span class="line">ser.astype(<span class="built_in">float</span>)								<span class="comment"># 将series的所有数据类型转换为浮点数</span></span><br><span class="line"></span><br><span class="line">df1.append(df2)									<span class="comment"># 将df2的行添加到df1的末尾</span></span><br><span class="line">pd.concat([df1,df2],axis=<span class="number">1</span>)						<span class="comment"># 将df2的列添加到df1的末尾</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-分组、排序"><a href="#2-6-分组、排序" class="headerlink" title="2.6 分组、排序"></a>2.6 分组、排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(colm)						<span class="comment"># 返回列值的groupby对象</span></span><br><span class="line">df.groupby([colm1, colm2])				<span class="comment"># 返回多列值的groupby对象</span></span><br><span class="line">df.sort_values(colm1)					<span class="comment"># 按升序排序（按列）</span></span><br><span class="line">df.sort_values(colm2, ascending=<span class="literal">False</span>)	<span class="comment"># 要按降序排序（按列）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-绘图"><a href="#2-7-绘图" class="headerlink" title="2.7 绘图"></a>2.7 绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line">display(df)</span><br><span class="line">df.plot(kind=<span class="string">&quot;line&quot;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="3-Matplotlib"><a href="#3-Matplotlib" class="headerlink" title="3. Matplotlib"></a>3. Matplotlib</h1><ul>
<li><p>Matplotlib是强大的数据可视化工具和作图库，是主要用于绘制数据图表的Python库，提供了绘制各类可视化图形的命令字库、简单的接口，可以方便用户轻松掌握图形的格式，绘制各类可视化图形。</p>
</li>
<li><p>Matplotlib是Python的一个可视化模块，他能方便的只做线条图、饼图、柱状图以及其他专业图形。<br>  使用Matplotlib，可以定制所做图表的任一方面。他支持所有操作系统下不同的GUI后端，并且可以将图形输出为常见的矢量图和图形测试，如PDF SVG JPG PNG BMP GIF.通过数据绘图，我们可以将枯燥的数字转化成人们容易接收的图表。</p>
</li>
<li><p>Matplotlib是基于Numpy的一套Python包，这个包提供了吩咐的数据绘图工具，主要用于绘制一些统计图形。<br>  Matplotlib有一套允许定制各种属性的默认设置，可以控制Matplotlib中的每一个默认属性：图像大小、每英寸点数、线宽、色彩和样式、子图、坐标轴、网个属性、文字和文字属性。</p>
</li>
<li><p>官方文档：<a target="_blank" rel="noopener" href="https://matplotlib.org/contents.html">https://matplotlib.org/contents.html</a></p>
<p>  中文文档：<a target="_blank" rel="noopener" href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<h3 id="3-1-设置中文字体"><a href="#3-1-设置中文字体" class="headerlink" title="3.1 设置中文字体"></a>3.1 设置中文字体</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="comment"># 设置图形中的字体为 黑体</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;SimHei&quot;</span></span><br><span class="line"><span class="comment"># 将 unicode 负号改为 ASCII 字符集的负号</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-常用局部设置"><a href="#3-2-常用局部设置" class="headerlink" title="3.2 常用局部设置"></a>3.2 常用局部设置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xticks / yticks 设置或获取坐标轴的数值刻度。(不传参数就是获取)</span></span><br><span class="line"><span class="comment"># 第一个参数，设置值，第二个参数可以不传，是标签，不传标签，就显示值</span></span><br><span class="line"><span class="comment"># rotation: 设置旋转度数</span></span><br><span class="line">plt.xticks([<span class="number">0</span>, <span class="number">60</span>, <span class="number">80</span>, <span class="number">100</span>], [<span class="string">&quot;开始&quot;</span>, <span class="string">&quot;及格&quot;</span>, <span class="string">&quot;良好&quot;</span>, <span class="string">&quot;卓越&quot;</span>], rotation = <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的标题,及标题位置</span></span><br><span class="line">plt.title(<span class="string">&quot;设置图形的标题&quot;</span>, y=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴与y轴显示的标签内容。</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;部门&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;销售量&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取绘图支持的所有样式。</span></span><br><span class="line">plt.style.available</span><br><span class="line"><span class="comment"># 设置绘图使用的样式。</span></span><br><span class="line">plt.style.use(<span class="string">&quot;ggplot&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图列</span></span><br><span class="line"><span class="comment"># loc: 指定图例显示的位置。默认为best。可以是int，string与元组类型。</span></span><br><span class="line"><span class="comment"># frameon: 指定图列是否有边框，默认为True</span></span><br><span class="line"><span class="comment"># ncol：设置图例列数</span></span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>, frameon=<span class="literal">False</span>, title=<span class="string">&quot;图例说明&quot;</span>, ncol=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的透明度</span></span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>], alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-设置绘图区域"><a href="#3-3-设置绘图区域" class="headerlink" title="3.3 设置绘图区域"></a>3.3 设置绘图区域</h3><p>隐式的创建了绘图区域：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.plot()</span><br><span class="line">plt.line()				<span class="comment"># 线型图</span></span><br><span class="line">plt.bar()				<span class="comment"># 柱状图</span></span><br><span class="line">plt.barh()				<span class="comment"># 条形图</span></span><br><span class="line">plt.hist()				<span class="comment"># 直方图</span></span><br><span class="line">plt.kde/density()		<span class="comment"># 核密度图</span></span><br><span class="line">plt.pie()				<span class="comment"># 饼图</span></span><br><span class="line">plt.box()				<span class="comment"># 箱线图</span></span><br><span class="line">plt.area()				<span class="comment"># 面积图</span></span><br></pre></td></tr></table></figure>

<p>显式的创建了绘图区域：</p>
<ul>
<li><p><code>add_subplot</code>：需要先创建画布对象，然后在画布对象上，创建绘图区域</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = plt.figure(figsize=(<span class="number">5</span>, <span class="number">5</span>))				<span class="comment"># 创建画布对象,可以通过参数设置画布大小（英寸）</span></span><br><span class="line"><span class="comment"># 也可以用 f.set_size_inches((7, 7)) 进行画布大小的设置</span></span><br><span class="line">ax = f.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>) 				<span class="comment"># 创建绘图区域 一行两列第一个</span></span><br><span class="line">ax.plot(x, y)								<span class="comment"># 绘图</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>subplot</code>：隐式创建画布对象，可以直接创建绘图区域</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(x, y)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>subplots </code>：可以同时创建多个子绘图区域 </p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该方法会返回一个元组，元组具有两个元素(figure, 所有的子绘图区域构成的整体【类型不定】)</span></span><br><span class="line"><span class="comment"># 参数 sharex/sharey，共享所有绘图区域的坐标轴，方便对比(默认是自己按照自己的扩展)</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)	<span class="comment"># 行、列、是否共享坐标轴</span></span><br><span class="line">ax[<span class="number">0</span>] = plot(x1, y1)</span><br><span class="line">ax[<span class="number">2</span>] = plot(x2, y2)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-4-开始绘图"><a href="#3-4-开始绘图" class="headerlink" title="3.4 开始绘图"></a>3.4 开始绘图</h3><ul>
<li><p>折线图 <code>plt.plot()</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 折线图，适合展现 数据的趋势和增加变化</span></span><br><span class="line"><span class="comment"># 可以传入 x 和 y 的数值，也可以只传入 y 的值，x 自动生成</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line"><span class="comment"># c：设置线的颜色</span></span><br><span class="line"><span class="comment"># ls：设置线的形状</span></span><br><span class="line"><span class="comment"># lw：线宽</span></span><br><span class="line"><span class="comment"># marker：点标记</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以一次性画多条线，分别指定颜色，标记与线条类型。</span></span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, -<span class="number">2</span>, <span class="number">4</span>], <span class="string">&quot;g*--&quot;</span>, [<span class="number">15</span>, <span class="number">17</span>], [-<span class="number">8</span>, <span class="number">6</span>], <span class="string">&quot;r&gt;-&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>柱状图、条形图 <code>plt.bar() / plt.barh()</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 柱形图，条形图，适合呈现数据的大小对比（传入标签值和每个标签值对应的数值）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> alpha---透明度，1代表不透明，0代表全透明。</span></span><br><span class="line"><span class="string"> width---柱子的宽度</span></span><br><span class="line"><span class="string"> color---柱状图填充的颜色，可采取的颜色同上</span></span><br><span class="line"><span class="string"> edgecolor---图形边缘的颜色，可采取的颜色同上</span></span><br><span class="line"><span class="string"> label---图像的标签</span></span><br><span class="line"><span class="string"> linewidth---边缘的宽度</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">plt.bar([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>], [<span class="number">50</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">20</span>])</span><br><span class="line"><span class="comment"># 条形图</span></span><br><span class="line">plt.barh([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>], [<span class="number">50</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">20</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>饼图 <code>plt.pie()</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适合呈现数据的大小对比</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> lablels---每一块的标签</span></span><br><span class="line"><span class="string"> explode---每一块离中心的距离</span></span><br><span class="line"><span class="string"> startangle---起始绘制角度,默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起</span></span><br><span class="line"><span class="string"> shadow---是否有阴影</span></span><br><span class="line"><span class="string"> labeldistance---label绘制位置,相对于半径的比例, 如&lt;1则绘制在饼图内侧</span></span><br><span class="line"><span class="string"> autopct---显示精度</span></span><br><span class="line"><span class="string"> pctdistance---类似于labeldistance,指定autopct的位置刻度</span></span><br><span class="line"><span class="string"> radius---控制饼图的半径</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">plt.pie([<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>], </span><br><span class="line">        labels=[<span class="string">&quot;A部门&quot;</span>, <span class="string">&quot;B部门&quot;</span>, <span class="string">&quot;C部门&quot;</span>, <span class="string">&quot;D部门&quot;</span>],</span><br><span class="line">        shadow=<span class="literal">True</span>,autopct=<span class="string">&quot;%.2f%%&quot;</span>, </span><br><span class="line">        explode=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>散点图 <code>plt.scatter()</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 散点图（气泡图）使用与显示数据的分布状态，可以用来比较（对比）数据维度之间的关系。</span></span><br><span class="line">plt.scatter(x, y, marker=<span class="string">&quot;o&quot;</span>, s=<span class="number">10</span>, color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点的颜色与大小可以统一设置，也可以分别设置每个点的大小与颜色。</span></span><br><span class="line">s = np.random.randint(<span class="number">10</span>, <span class="number">100</span>, size=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># colors = [&quot;r&quot;, &quot;g&quot;, &quot;b&quot;, &quot;y&quot;]</span></span><br><span class="line">colors = np.random.choice(colors, size=<span class="number">100</span>)</span><br><span class="line">plt.scatter(x, y, s=s, color=colors)</span><br></pre></td></tr></table></figure>
</li>
<li><p>直方图 <code>plt.hist()</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> range---默认None，选择直方图显示的范围</span></span><br><span class="line"><span class="string"> bins---指定我们显示的直方图的边界</span></span><br><span class="line"><span class="string"> alpha---透明度</span></span><br><span class="line"><span class="string"> facecolor---直方图颜色</span></span><br><span class="line"><span class="string"> histtype---直方图类型，可选‘bar’, ‘barstacked’, ‘step’, ‘stepfilled’</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 默认将区间等分为十份。</span></span><br><span class="line">plt.hist(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以自行指定桶的数量。</span></span><br><span class="line">plt.hist(x, bins=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要统计的区间是不等分的，可以给bins参数传递一个数组类型。</span></span><br><span class="line"><span class="comment"># 数组中的元素指定区间的界线。</span></span><br><span class="line">plt.hist(x, bins=[<span class="number">1</span>, <span class="number">60</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>箱线图 <code>plt.boxplot()</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">一般用于在数据清洗过程中，进行查找异常值的时候</span></span><br><span class="line"><span class="string">能够显示离群点，离群点可能是异常值，但是不一定是异常值</span></span><br><span class="line"><span class="string">传入一系列的值，可以显示 远远高于（低于）其他值的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">x 指定要绘制箱线图的数据；</span></span><br><span class="line"><span class="string">vert 是否需要将箱线图垂直摆放</span></span><br><span class="line"><span class="string">patch_artist 是否填充箱体的颜色；</span></span><br><span class="line"><span class="string">boxprops 设置箱体的属性，如边框色，填充色等；boxprops：color箱体边框色，facecolor箱体填充色；</span></span><br><span class="line"><span class="string">showmeans 是否显示均值</span></span><br><span class="line"><span class="string">meanline 是否用线的形式表示均值</span></span><br><span class="line"><span class="string">labels 为箱线图添加标签</span></span><br><span class="line"><span class="string">widths 指定箱线图的宽度</span></span><br><span class="line"><span class="string">positions 指定箱线图的位置</span></span><br><span class="line"><span class="string">flierprops 设置异常值的属性</span></span><br><span class="line"><span class="string">notch 是否是凹口的形式展现箱线图</span></span><br><span class="line"><span class="string">showcaps 是否显示箱线图顶端和末端的两条线</span></span><br><span class="line"><span class="string">showbox 是否显示箱线图的箱体</span></span><br><span class="line"><span class="string">sym 指定异常点的形状</span></span><br><span class="line"><span class="string">showfliers 是否显示异常值</span></span><br><span class="line"><span class="string">whis 指定上下须与上下四分位的距离</span></span><br><span class="line"><span class="string">medianprops 设置中位数的属性</span></span><br><span class="line"><span class="string">meanprops 设置均值的属性</span></span><br><span class="line"><span class="string">capprops 设置箱线图顶端和末端线条的属性</span></span><br><span class="line"><span class="string">whiskerprops 设置须的属性</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">plt.boxplot([<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">100</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>灰度图 <code>plt.imshow()</code></p>
   <img src="【机器学习】Python数据分析常用库/image-20210210214902804.png" alt="image-20210210214902804" style="zoom:80%;" />

  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)	<span class="comment"># 图像为灰色</span></span><br><span class="line">plt.colorbar()					<span class="comment"># 绘制颜色条</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-图的背景线"><a href="#3-5-图的背景线" class="headerlink" title="3.5 图的背景线"></a>3.5 图的背景线</h3><ul>
<li><code>plt.grid()</code> 设置横&#x2F;竖格线<ul>
<li><code>axis</code>选择方向 x, y, both 格线与刻度间隔设置相关</li>
<li><code>color</code> 同plot设置</li>
<li><code>linestyle</code> 同plot设置</li>
<li><code>linewidth</code>同plot设置</li>
</ul>
</li>
<li><code>plt.axhline()</code> <code>plt.axvline()</code> 在某个坐标轴位置绘制线条 或者<code>ax.axhline()</code><ul>
<li><code>y</code> 设置线的位置</li>
<li><code>xmin</code> 设置线的起始点 0-1 0是起点 ，1是终点</li>
<li><code>xmax</code> 设置线的终点 0-1</li>
<li><code>color</code> 颜色</li>
<li><code>alpha</code> 透明度</li>
<li><code>linewidth</code> 线的宽度</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/cccc-59-66">程序员阿狗</a>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/332900875#:~:text=%E8%BF%99%E7%AF%87pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%E5%B8%AE%E5%A4%A7%E5%AE%B6%E5%9B%9E%E9%A1%BE%E4%B8%8Bpandas%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%E6%88%91%E4%BB%AC%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E6%97%B6%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82.%20%E6%96%87%E6%9C%AB%E8%BF%98%E6%9C%89pandas%E7%9A%84cheat%20sheet%EF%BC%8C%E5%B8%AE%E5%8A%A9%E4%BD%A0%E8%AE%B0%E4%BD%8F%E5%B8%B8%E8%A7%81%E7%9A%84pandas%E6%93%8D%E4%BD%9C%E3%80%82.%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB%EF%BC%9A.%20%E4%BB%8E%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE.,%E4%BB%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AF%BC%E5%87%BADataFrames.%20%E6%9F%A5%E7%9C%8BDataFrame%E4%BF%A1%E6%81%AF.%20%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AD%90%E9%9B%86.%20%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E5%91%BD%E4%BB%A4.%20%E5%88%86%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE.">十分钟学习pandas！ pandas常用操作总结！</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24499745">勿语~</a>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24499745/article/details/88629687">matplotlib 常用操作（精简）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/StardustYu">Bai丁</a>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/StardustYu/article/details/104734294">AI小知识系列(四) Matplotlib常用操作</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%BA%93/" data-id="cleqef3vn0089ogjo7fcv8v52" data-title="【机器学习】Python数据分析常用库" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【考研】计算机组成原理知识点梳理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.766Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%80%83%E7%A0%94/">考研</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">【考研】计算机组成原理知识点梳理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本篇文章用于梳理 408 中最硬核的一门课——<strong>计算机组成原理</strong> 的知识点</p>
<p>便于之后与以后回顾</p>
<p>参考：王道单科书《计算机组成原理考研复习指导》未标明出处的图片等资源均取自书中</p>
<p>缺的内容会慢慢补上</p>
</blockquote>
<h1 id="总知识点框架"><a href="#总知识点框架" class="headerlink" title="总知识点框架"></a>总知识点框架</h1><img src="【考研】计算机组成原理知识点梳理/image-20210812170915865.png" alt="image-20210812170915865"  />

<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h3 id="考纲及章节框架"><a href="#考纲及章节框架" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210821164230591.png" alt="image-20210821164230591" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210821164813184.png" alt="image-20210821164813184" style="zoom:80%;" />

<h3 id="1-1-计算机系统层次结构"><a href="#1-1-计算机系统层次结构" class="headerlink" title="1.1 计算机系统层次结构"></a>1.1 计算机系统层次结构</h3><blockquote>
<h4 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h4></blockquote>
<p>硬件系统和软件系统共同构成了一个完整的计算机系统</p>
<ul>
<li>硬件是计算机系统中实际物理装置的总称</li>
<li>软件是指在硬件上运行的程序和相关数据及文档</li>
</ul>
<p>软件的效率表征计算机系统性能的好坏，而软件性能的发挥离不开硬件的支持</p>
<p><strong>软硬件在逻辑上等效：对某一功能既可以用软件实现又可以用硬件实现</strong></p>
<blockquote>
<h4 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h4></blockquote>
<p><strong>1. 冯·诺依曼机</strong></p>
<p>冯·诺依曼提出“存储程序”的思想，“<strong>存储程序</strong>”的思想奠定了现代计算机的基本结构</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210821165957258.png" alt="image-20210821165957258" style="zoom:80%;" />

<p>冯·诺依曼机的特点：</p>
<ol>
<li>计算机系统由 <strong>运算器、控制器、存储器、输入设备、输出设备</strong> 组成</li>
<li>指令和数据同等地位，并可以按地址寻访</li>
<li>指令数据均由<strong>二进制</strong>码组成</li>
<li>指令由 <strong>操做码和地址码</strong> 组成</li>
<li><strong>指令在存储器内顺序存放</strong></li>
<li><strong>早期</strong>冯·诺依曼机以 <strong>运算器</strong> 为中心（<strong>现代计算机已发展为以 存储器 为中心</strong>）</li>
</ol>
<p><strong>2. 计算机功能部件</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210821170025973.png" alt="image-20210821170025973" style="zoom:80%;" />

<ol>
<li><p>输入设备</p>
<p> 键盘、鼠标、扫描仪、摄像机……</p>
</li>
<li><p>输出设备</p>
<p> 显示器、打印机……</p>
</li>
<li><p>存储器</p>
<ul>
<li><p>主存（内存）：CPU 能够直接访问的存储器</p>
<p>  主存按存储单元的地址进行存取，这种存取方式称为 <strong>按地址存取方式</strong></p>
<ul>
<li><p><strong>MAR</strong>：用于寻址，<strong>其位数对应存储单元个数</strong></p>
</li>
<li><p><strong>MDR</strong>：用于要从存储器中读写的信息，<strong>其位数与存储字长相等</strong>，一般为字节的二次幂的整数倍</p>
</li>
</ul>
</li>
<li><p>辅存（外存）：必须将信息调入主存后才能被 CPU 访问</p>
</li>
</ul>
</li>
<li><p>运算器：计算机执行部件，用于进行逻辑和算术运算</p>
<ul>
<li>算术逻辑单元 ALU</li>
<li><strong>累加器 ACC</strong>、<strong>乘商寄存器 MQ</strong>、<strong>操作数寄存器 X</strong>、变址寄存器 IX、基址寄存器 BR</li>
<li>程序状态寄存器 PSW：存放 ALU 运算的标志和处理及的状态信息，如是否溢出、有无进位借位等</li>
</ul>
</li>
<li><p>控制器：CPU 的指挥中心</p>
<ul>
<li>程序计数器 PC：<strong>存放当前欲执行的指令地址</strong>，可以自动加一，与 MAR 之间有之间通路</li>
<li>指令寄存器 IR：存放当前指令，内容来自 MDR</li>
<li>控制单元 CU</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="计算机软件分类"><a href="#计算机软件分类" class="headerlink" title="计算机软件分类"></a>计算机软件分类</h4></blockquote>
<ul>
<li><p>系统软件</p>
<p>  <strong>操作系统 OS</strong>、<strong>数据库管理系统 DBMS</strong>、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序……</p>
</li>
<li><p>应用软件</p>
<p>  各种高级语言、数据处理程序……</p>
</li>
</ul>
<p>三个级别的语言：机器语言、汇编语言、高级语言</p>
<blockquote>
<h4 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h4></blockquote>
<p><strong>1. 工作过程</strong></p>
<ol>
<li>源程序和数据<strong>装入</strong>主存</li>
<li>源程序<strong>转换</strong>成 .exe</li>
<li>.exe 文件首地址开始逐条<strong>执行指令</strong></li>
</ol>
<p><strong>2. 从源程序到可执行文件</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210821172103005.png" alt="image-20210821172103005" style="zoom:80%;" />

<ol>
<li>预处理阶段：对字符 # 开头的命令进行处理</li>
<li>编译阶段：生成一个汇编语言源程序</li>
<li>汇编阶段：汇编器将汇编语言源程序翻译成机器语言</li>
<li>链接阶段：链接器将多个可重定位目标文件和标准库函数合并为一个 .exe 文件</li>
</ol>
<blockquote>
<h4 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h4></blockquote>
<img src="【考研】计算机组成原理知识点梳理/image-20210821172612547.png" alt="image-20210821172612547" style="zoom:80%;" />

<blockquote>
<p>Note：</p>
<ol>
<li><p><strong>相联存储器既可以按地址存取，也可以按内容存取</strong></p>
</li>
<li><p>冯·诺依曼机的基本工作方式：<strong>控制流驱动方式</strong></p>
</li>
<li><p>在现代计算机中，MAR、MDR、Cache 均是存在于 CPU 中的</p>
</li>
<li><p>运算器和控制器集成到同一个芯片上，称为 CPU</p>
<p> CPU 和主存共同构成主机</p>
</li>
<li><p>区分 DBMS 和 DBS</p>
<ul>
<li>DBMS：位于用户和操作系统之间的数据管理软件，是<strong>系统软件</strong></li>
<li>DBS：计算机系统引入数据库后的系统，是应用软件</li>
</ul>
</li>
<li><p><strong>CPU 存取速度比较：寄存器 &gt; Cache &gt; 内存</strong></p>
</li>
<li><p>编译程序和解释程序</p>
<ul>
<li>编译程序：先完整编译后再运行程序</li>
<li>一句一句翻译且边翻译边执行，速度慢于编译程序</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="1-2-计算机的性能指标"><a href="#1-2-计算机的性能指标" class="headerlink" title="1.2 计算机的性能指标"></a>1.2 计算机的性能指标</h3><blockquote>
<h4 id="计算机的主要性能指标"><a href="#计算机的主要性能指标" class="headerlink" title="计算机的主要性能指标"></a>计算机的主要性能指标</h4></blockquote>
<ol>
<li><p>机器字长：计算机进行一次整数运算所能处理的二进制数据的位数</p>
<p> <strong>一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高</strong></p>
</li>
<li><p>数据通路带宽：数据总线一次能并行传送数据的位数</p>
</li>
<li><p>主存容量：贮存所能存储的最大容量</p>
<p> 通常以字节来衡量，也可以用 <strong>字数 x 字长</strong>（512K x 16b）</p>
</li>
<li><p>运算速度</p>
<ul>
<li><p>吞吐量和响应时间</p>
<ul>
<li><p>吞吐量：单位时间内处理请求的数量</p>
<p>  <strong>系统的吞吐量主要取决于主存的存储周期</strong></p>
</li>
<li><p>响应时间：用户发出请求到系统做出响应获得结果所需时间</p>
<p>  通常包括：CPU 时间和 等待时间</p>
</li>
</ul>
</li>
<li><p>主频和 CPU 时钟周期</p>
<ul>
<li>CPU 时钟周期：<strong>CPU 中最小的时间单位</strong>，是主频的倒数</li>
<li>主频：对于同一型号的计算机，主频越高，完成指令的而一个执行步骤所用时间越短，指令执行速度越快</li>
</ul>
</li>
<li><p>CPI（Clock cycle Per Instruction）：执行一条指令所需要的时钟周期数（是一个平均值）</p>
</li>
<li><p>CPU 执行时间：<code>CPU 执行时间 = CPU 时钟周期数 / 主频 = (指令条数 x CPI) / 主频</code></p>
<p>  主要取决于：主频、CPI、指令条数，三者是相互制约的</p>
</li>
<li><p>MIPS（Million Instructions Per Second）</p>
</li>
<li><p>MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS：每秒执行 xxx 次浮点数运算</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h4></blockquote>
<ol>
<li>系列机：具有相同体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列</li>
<li>兼容：计算机软件或硬件的通用性</li>
<li>软件可移植性</li>
<li>固件：将程序固定在 ROM 中组成的部件，性能介于硬件和软件之间</li>
</ol>
<h1 id="第二章-数据表示与运算"><a href="#第二章-数据表示与运算" class="headerlink" title="第二章 数据表示与运算"></a>第二章 数据表示与运算</h1><h3 id="考纲及章节框架-1"><a href="#考纲及章节框架-1" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210824174123026.png" alt="image-20210824174123026" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210824173920136.png" alt="image-20210824173920136" style="zoom:80%;" />

<h3 id="2-1-数制与码制"><a href="#2-1-数制与码制" class="headerlink" title="2.1 数制与码制"></a>2.1 数制与码制</h3><blockquote>
<p>进位计数值</p>
</blockquote>
<p><strong>1. 计算机内部使用二进制编码的原因</strong></p>
<ul>
<li>二进制只有两种状态，易于用物理器件表示，制造成本低</li>
<li>二进制位 1 和 0 正好与逻辑值“真”和“假”对应</li>
<li>二进制的编码和运算都很简单，通过逻辑门电路能方便实现算术运算</li>
</ul>
<p><strong>2. 二进制与十进制的转换</strong></p>
<ul>
<li><p>十进制转二进制</p>
<ul>
<li><p>整数部分：除基取余法（取得余数为最高位）</p>
   <img src="【考研】计算机组成原理知识点梳理/image-20210824175151391.png" alt="image-20210824175151391" style="zoom:80%;" />
</li>
<li><p>小数部分：乘基取整法（取得余数为最低位）</p>
   <img src="【考研】计算机组成原理知识点梳理/image-20210824175210854.png" alt="image-20210824175210854" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>其他进制转化都比较简单，就不再赘述</p>
</li>
</ul>
<blockquote>
<p>真值机器数</p>
</blockquote>
<p>真值是日常生活中使用的数，是机器数所代表的实际值。</p>
<p>计算机中通过原码、补码等表示的数为机器数</p>
<blockquote>
<p>字符与字符串</p>
</blockquote>
<p><strong>1. ASCII 码</strong></p>
<p>ASCII码：国际上普遍采用的 <strong>7位二进制编码</strong>（每个字节的最高位保持为 0， 可用于传输时的奇偶校验），总共表示 <strong>128 个字符</strong></p>
<p><strong>2. 汉字的表示和编码</strong></p>
<p>1981 年实施的国家标准 GB2312-1980 中，每个编码用两个字节表示</p>
<p>2000 年公布的国家标准 GB 18030 中，编码标准采用 1B、2B、4B</p>
<p>汉字的编码包括：输入编码、汉字内码、汉字字形码</p>
<blockquote>
<p>Note：</p>
<ol>
<li>0<del>9 的 ASCII 码值位 48（011 0000）</del> 57（011 1001），去掉高三位正好是二进制形式的 0~9</li>
</ol>
</blockquote>
<h1 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h1><h3 id="考纲及章节框架-2"><a href="#考纲及章节框架-2" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210830172925330.png" alt="image-20210830172925330" style="zoom:80%;" />

<p><img src="/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/image-20210830173825963.png" alt="image-20210830173825963"></p>
<h3 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h3><blockquote>
<h4 id="3-1-1-存储器的分类"><a href="#3-1-1-存储器的分类" class="headerlink" title="3.1.1 存储器的分类"></a>3.1.1 存储器的分类</h4></blockquote>
<p><strong>1. 按作用层次分</strong></p>
<ul>
<li>主存储器<ul>
<li>CPU 可以随机进行访问</li>
<li>可以和 Cache 及辅存交换数据</li>
<li><strong>容量小、存取速度快、每位价格较高</strong></li>
</ul>
</li>
<li>辅助存储器<ul>
<li>存放暂时不用或需要永久保存的数据</li>
<li><strong>不能与 CPU 直接交换信息</strong></li>
<li><strong>容量极大、存取速度慢、单位成本低</strong></li>
</ul>
</li>
<li>高速缓冲存储器<ul>
<li>位于主存与 CPU 之间</li>
<li>存取速度与 CPU 相匹配，<strong>存储容量小、价格高</strong></li>
<li><strong>通常制作在 CPU 中</strong></li>
</ul>
</li>
</ul>
<p><strong>2. 按存储介质分</strong></p>
<ul>
<li>磁表面存储器（磁带、磁盘）</li>
<li>磁芯存储器半导体存储器（MOS 型存储器、双极存储器）</li>
<li>光存储器（光盘）</li>
</ul>
<p><strong>3. 按存取方式分</strong></p>
<ul>
<li>随机存储器（RAM）<ul>
<li>可随机存取</li>
<li>读写方便灵活</li>
<li>用作主存或高速缓存</li>
</ul>
</li>
<li>只读存储器（ROM）<ul>
<li>只能<strong>随机读入</strong>而不能写入</li>
<li>存放固定程序、常数等</li>
<li>与 RAM 共同作为主存的一部分，统一构成主存地址域</li>
</ul>
</li>
<li>串行访问存储器<ul>
<li>顺序存取存储器（如磁带，只能按某种顺序存取）</li>
<li>直接存取存储器（如磁盘、光盘，7.2节会详细讲到）</li>
</ul>
</li>
</ul>
<p><strong>4. 按信息可保存性分</strong></p>
<ul>
<li>易失性存储器（RAM）</li>
<li>非易失性存储器（ROM、磁表面存储器、光存储器）</li>
</ul>
<blockquote>
<h4 id="3-1-2-存储器性能指标"><a href="#3-1-2-存储器性能指标" class="headerlink" title="3.1.2 存储器性能指标"></a>3.1.2 存储器性能指标</h4></blockquote>
<p><strong>1. 存储容量</strong></p>
<p><code>存储容量 = 存储字数 x 存储字长（1M x 8bit）</code></p>
<p><strong>2. 单位成本</strong></p>
<p><strong>3. 存储速度</strong></p>
<p><code>数据传输率 = 数据宽度 / 存储周期</code></p>
<ul>
<li>存取时间</li>
<li>存取周期</li>
<li>主存带宽：每秒从主存进出信息的<strong>最大数量</strong>（B&#x2F;s、b&#x2F;s）</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>CD-ROM 是只读光盘，只能进行串行存取，不能随机存取</p>
</li>
<li><p><strong>存取时间与存取周期</strong></p>
<p> 存取周期大于存取时间，因为存储器在读写操作后需要一段恢复时间，存取周期 &#x3D; 存取时间 + 恢复时间</p>
</li>
</ol>
</blockquote>
<h3 id="3-2-存储器的层次结构"><a href="#3-2-存储器的层次结构" class="headerlink" title="3.2 存储器的层次结构"></a>3.2 存储器的层次结构</h3><blockquote>
<h4 id="3-2-1-多级存储系统"><a href="#3-2-1-多级存储系统" class="headerlink" title="3.2.1 多级存储系统"></a>3.2.1 多级存储系统</h4></blockquote>
<p>主要思想：上一层的存储器作为低一层存储器的高速缓存</p>
<ul>
<li>Cache—主存：解决 CPU 和主存速度不匹配的问题</li>
<li>主存—辅存：解决存储系统容量问题</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210904171805582.png" alt="image-20210904171805582" style="zoom:80%;" />

<blockquote>
<p>Note：</p>
<ol>
<li><strong>主存和 Cache</strong> 之间的数据调动由<strong>硬件</strong>完成，对<strong>所有程序员透明</strong></li>
<li><strong>主存与辅存</strong>之间的数据调动由<strong>硬件和 OS</strong> 共同完成，对<strong>应用程序员透明</strong></li>
</ol>
</blockquote>
<h3 id="3-3-半导体随机存储器（🚩）"><a href="#3-3-半导体随机存储器（🚩）" class="headerlink" title="3.3 半导体随机存储器（🚩）"></a>3.3 半导体随机存储器（🚩）</h3><blockquote>
<h4 id="3-3-1-SRAM-和-DRAM"><a href="#3-3-1-SRAM-和-DRAM" class="headerlink" title="3.3.1 SRAM 和 DRAM"></a>3.3.1 SRAM 和 DRAM</h4></blockquote>
<img src="【考研】计算机组成原理知识点梳理/image-20210904172436726.png" alt="image-20210904172436726" style="zoom:80%;" />

<blockquote>
<h4 id="3-3-2-只读存储器"><a href="#3-3-2-只读存储器" class="headerlink" title="3.3.2 只读存储器"></a>3.3.2 只读存储器</h4></blockquote>
<p><strong>1. ROM 特点</strong></p>
<ul>
<li>ROM 支持<strong>随机存取</strong></li>
<li>结构简单，位密度高</li>
<li>具有非易失性，可靠性高</li>
</ul>
<p><strong>2. ROM 类型</strong></p>
<ul>
<li>掩模式只读存储器（MROM）：可靠性高、集成度高、价格便宜；<strong>灵活性差</strong>（写入后内容无法改变）</li>
<li>一次可编程只读存储器（PROM）：<strong>允许</strong>用户利用专门设备<strong>写入程序</strong>，但<strong>只能写一次</strong></li>
<li>可擦除可编程只读存储器（EPROM）：可以进行<strong>编程</strong>也可以对内容进行<strong>擦除</strong>（电擦除和紫外擦除），但是<strong>编程次数有限</strong>，且写入时间过长，故不能替代 RAM</li>
<li>闪速存储器（FLash Memory）：即可在不加电的情况下长期保存，又能在线进行<strong>快速擦除与重写</strong>，擦除重写速度块；价格便宜、集成度高</li>
<li>固态硬盘（SSD）：由<strong>控制单元</strong>和<strong>存储单元</strong>组成，保留了闪存<strong>长期保存信息、擦除重写快</strong>的特性，读写速度快、功耗低，但是<strong>贵</strong></li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>DRAM 电荷只能维持 1~2ms，故需要不断刷新，将原来的内容重新<strong>读入</strong></p>
<ul>
<li>集中刷新：找一个大片时间进行刷新，刷新时候存储器停止工作，故存在 <strong>访存死区</strong></li>
<li>分散刷新：每行的刷新分散到各个工作周期中，不存在访存死区，但是效率低下</li>
<li>异步刷新：综合前两种方法，既可以<strong>缩短死时间</strong>，又可以充分利用最大刷新间隔的特点</li>
</ul>
</li>
<li><p>DRAM 刷新对 CPU 透明，不依赖于外部的访问</p>
</li>
<li><p><strong>DRAM 刷新单位是行</strong>，由芯片内部自行生成行地址</p>
</li>
<li><p>注意区分<strong>易失性存储器</strong>和<strong>刷新</strong>的区别</p>
</li>
<li><p><strong>RAM 引脚数：地址线个数 + 数据线个数 + 片选端 + RW 控制</strong></p>
<p> 容量为 1024 x 8bit 的SRAM，除电源和接地端外芯片引脚数最小为：10 + 8 + 1 + 1 &#x3D; 20</p>
</li>
</ol>
</blockquote>
<h3 id="3-4-主存储器与-CPU-的连接"><a href="#3-4-主存储器与-CPU-的连接" class="headerlink" title="3.4 主存储器与 CPU 的连接"></a>3.4 主存储器与 CPU 的连接</h3><blockquote>
<h4 id="3-4-1-连接原理"><a href="#3-4-1-连接原理" class="headerlink" title="3.4.1 连接原理"></a>3.4.1 连接原理</h4></blockquote>
<p>主存储器通过<strong>数据总线</strong>、<strong>地址总线</strong>、<strong>控制总线</strong>与 CPU 连接</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210905164141904.png" alt="image-20210905164141904" style="zoom:80%;" />

<blockquote>
<h4 id="3-4-2-主存容量的扩展"><a href="#3-4-2-主存容量的扩展" class="headerlink" title="3.4.2 主存容量的扩展"></a>3.4.2 主存容量的扩展</h4></blockquote>
<p><strong>1. 位扩展法</strong></p>
<p>8 个 <code>8K x 1bit</code> 的 RAM 芯片组成 <code>8K x 8bit</code> 的存储器：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210905164527963.png" alt="image-20210905164527963" style="zoom:80%;" />

<p><strong>2. 字扩展法</strong></p>
<p>4 片 <code>16K x 8bit</code> 的 RAM 芯片组成 <code>64K x 8bit</code>  的存储器：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210905164803945.png" alt="image-20210905164803945" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210905164845569.png" alt="image-20210905164845569" style="zoom:80%;" />

<p><strong>3. 字位同时扩展法</strong></p>
<p>8 片 <code>16K x 4bit</code> 的 RAM 芯片组成 <code>64K x 8bit</code> 的存储器</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210905165028231.png" alt="image-20210905165028231" style="zoom:80%;" />

<blockquote>
<h4 id="3-4-3-存储芯片的地址分配和片选"><a href="#3-4-3-存储芯片的地址分配和片选" class="headerlink" title="3.4.3 存储芯片的地址分配和片选"></a>3.4.3 存储芯片的地址分配和片选</h4></blockquote>
<ul>
<li>线选法</li>
<li>译码片选法</li>
</ul>
<h3 id="3-5-双端口-RAM-和多模块存储器"><a href="#3-5-双端口-RAM-和多模块存储器" class="headerlink" title="3.5 双端口 RAM 和多模块存储器"></a>3.5 双端口 RAM 和多模块存储器</h3><h3 id="3-6-高速缓存（Cache）"><a href="#3-6-高速缓存（Cache）" class="headerlink" title="3.6 高速缓存（Cache）"></a>3.6 高速缓存（Cache）</h3><h3 id="3-7-虚拟存储器"><a href="#3-7-虚拟存储器" class="headerlink" title="3.7 虚拟存储器"></a>3.7 虚拟存储器</h3><p>是对 OS 第三章 内存管理的简单描述，详细去看 OS</p>
<blockquote>
<h4 id="虚拟存储器基本概念"><a href="#虚拟存储器基本概念" class="headerlink" title="虚拟存储器基本概念"></a>虚拟存储器基本概念</h4></blockquote>
<ul>
<li><p>主机和联机工作的辅存共同构成了虚拟存储器</p>
<p>  <strong>虚拟存储器将主存和辅存的地址空间统一编址</strong>，形成一个庞大的地址空间，用户可以自由编程而不必在乎实际的主存容量和程序在主存中的实际存放位置。</p>
</li>
<li><p>对于<strong>应用程序员</strong>而言，<strong>虚拟存储器是透明的</strong></p>
</li>
<li><p>虚拟存储器具有<strong>主存的速度</strong>和<strong>辅存的容量</strong>，提高了存储系统性价比</p>
</li>
</ul>
<blockquote>
<h4 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h4></blockquote>
<ul>
<li>页式虚拟存储器：以页为基本单位的虚拟存储器</li>
<li>虚拟地址分为两段：<strong>虚页号</strong>、<strong>页内地址</strong></li>
<li><strong>虚拟地址到物理地址的转换由页表完成</strong></li>
<li>页表是一张存放<strong>虚页号</strong>和<strong>实页号</strong>的对照表，<strong>一般长久保存在内存中</strong></li>
</ul>
<p><strong>1.页表</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210830174922664.png" alt="image-20210830174922664" style="zoom:80%;" />

<p>几个特殊位：</p>
<ul>
<li>有效位（装入位）：表示对应页面是否在主存中</li>
<li>脏位（修改位）：表示页面是否被修改过</li>
<li>引用位（使用位）：配合页面替换算法使用</li>
</ul>
<p>虚拟地址到物理地址的地址变换过程：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210830175354607.png" alt="image-20210830175354607" style="zoom:80%;" />

<ol>
<li>根据虚拟页号找到对应的页表项</li>
<li>通过装入位判断是否被装入内存<ul>
<li><code>装入位 == 1</code>：拼接所查到的<strong>物理页号</strong>及虚拟地址的<strong>页内地址</strong>部分，形成物理地址</li>
<li><code>装入位 == 0</code>：产生缺页中断</li>
</ul>
</li>
</ol>
<p>优缺点：</p>
<ul>
<li>优点：页面长度固定，页表简单，调入方便</li>
<li>缺点：<ul>
<li>程序不会正好是页面的整数倍，最后一页的零头无法利用而造成浪费</li>
<li>页不是逻辑独立实体，处理、保护和共享不如段式存储器方便</li>
</ul>
</li>
</ul>
<p><strong>2. 快表（TLB）</strong></p>
<p>使用页表机制后每次获取数据都<strong>需要访问两次主存</strong>，效率大大降低，故考虑引入<strong>由高速缓冲器组成的快表</strong></p>
<p>快表通常采用全相联或组相联方式</p>
<p>TLB 标记的内容在<strong>全相联方式</strong>下就是该页表项对应的<strong>虚页号</strong>；<strong>组相联方式</strong>下对应虚页号的高位部分，而虚页号的低位部分用于选择 TLB组 的组索引</p>
<p><strong>3. 具有 TLB 和 Cache 的多级存储系统</strong></p>
<ul>
<li>TLB 和 Cache 访问过程如下图所示：</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210901154828530.png" alt="image-20210901154828530" style="zoom:80%;" />

<ul>
<li>访问过程框图：</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210901155032709.png" alt="image-20210901155032709" style="zoom:80%;" />

<blockquote>
<h4 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h4></blockquote>
<ul>
<li><p>段式虚拟存储器中的<strong>段是按程序的逻辑结构划分的</strong></p>
</li>
<li><p>虚拟地址分为：<strong>段号</strong>、<strong>段内地址</strong></p>
</li>
<li><p>段表每行记录包括：<strong>段号</strong>、<strong>装入位</strong>、<strong>段起点</strong>、<strong>段长</strong>等</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210901161128878.png" alt="image-20210901161128878" style="zoom:80%;" />
</li>
<li><p>优点</p>
<ul>
<li>段的分界与程序的自然分界对应，具有逻辑独立性</li>
<li>易于编译、管理、修改、保护</li>
<li>便于多道程序共享</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>段长可变，分配空间不便</li>
<li>容易在段内留下碎片，不好利用从而造成浪费</li>
</ul>
</li>
</ul>
<blockquote>
<p>段页式虚拟存储器</p>
</blockquote>
<ul>
<li><p>段页式虚拟存储器：先将程序按逻辑分段，再将各段划分为固定大小的页</p>
<p>  主存空间也划分为大小相等的页，程序对调以页为传送基本单位</p>
</li>
<li><p><strong>每个程序对应一个段表，每个段对应一个页表</strong></p>
</li>
<li><p>段长为页长整数倍，段的起点是某一页的起点</p>
</li>
<li><p>虚地址分为：<strong>段号</strong>、<strong>段内页号</strong>、<strong>页内地址</strong></p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210901161630658.png" alt="image-20210901161630658" style="zoom:80%;" />
</li>
<li><p>优点</p>
<ul>
<li>兼具页式和段式存储器的优点</li>
<li>可以按段实现共享和保护</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>地址变换过程中，需要两次查表，系统开销大</li>
</ul>
</li>
</ul>
<blockquote>
<p>虚拟存储器与 Cache 比较 </p>
</blockquote>
<ul>
<li><p>相同</p>
<ul>
<li>目标都是提高系统性能</li>
<li>都把数据划分为小数据块</li>
<li>都有<strong>地址映射</strong>、<strong>替换算法</strong>、<strong>更新策略</strong></li>
<li>都<strong>依据程序的局部性原理</strong>，应用快速缓存的思想</li>
</ul>
</li>
<li><p>不同</p>
<table>
<thead>
<tr>
<th align="center">Cache</th>
<th align="center">虚拟存储器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主要解决<strong>系统速度</strong></td>
<td align="center">主要解决主存容量</td>
</tr>
<tr>
<td align="center">全硬件实现，是硬件存储器<br />对程序员透明</td>
<td align="center">由 OS 和硬件共同实现，是逻辑上的存储器<br />对系统程序员不透明，对应用程序员透明</td>
</tr>
<tr>
<td align="center">不命中影响较小</td>
<td align="center">不命中影响较大（需要访问磁盘）</td>
</tr>
<tr>
<td align="center">不命中时主存与 CPU 可以直接通信</td>
<td align="center">不命中时，只能由硬盘调入主存，而不能直接和 CPU 通信</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li>Cache 和 虚拟存储器都是由 DRAM组成</li>
<li>CPU 访存的三种缺失：<ul>
<li>TLB 缺失</li>
<li>Cache 缺失</li>
<li>缺页</li>
</ul>
</li>
<li>页式存储器地址空间是一维的，而段式存储器地址空间是二维的</li>
</ol>
</blockquote>
<h1 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h1><h1 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h1><h3 id="考纲及章节框架-3"><a href="#考纲及章节框架-3" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210812173325315.png" alt="image-20210812173325315" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210812174119586.png" alt="image-20210812174119586" style="zoom:80%;" />

<h3 id="5-1-CPU的功能和基本结构"><a href="#5-1-CPU的功能和基本结构" class="headerlink" title="5.1 CPU的功能和基本结构"></a>5.1 CPU的功能和基本结构</h3><blockquote>
<h4 id="CPU-的功能"><a href="#CPU-的功能" class="headerlink" title="CPU 的功能"></a>CPU 的功能</h4></blockquote>
<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>时间控制</li>
<li>数据加工</li>
<li>中断处理</li>
</ul>
<blockquote>
<h4 id="CPU-的基本结构"><a href="#CPU-的基本结构" class="headerlink" title="CPU 的基本结构"></a>CPU 的基本结构</h4></blockquote>
<p>CPU 由<strong>运算器</strong>和<strong>控制器</strong>组成。</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210812180436053.png" alt="image-20210812180436053" style="zoom:80%;" />

<p>（图源自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chen1083376511/article/details/81941318">计算机组成原理（4）-中央处理器CPU_妖小谦-CSDN博客_cpu组成</a>）</p>
<ul>
<li>运算器：<strong>算术逻辑单元（ALU）</strong>、暂存寄存器、<strong>累加寄存器（ACC）</strong>、<strong>通用寄存器组</strong>、程序状态寄存器（PSW）、移位器、计数器（CT）<ul>
<li>暂存寄存器：<strong>对应用程序员透明</strong></li>
<li><strong>ACC</strong>：可以作为加法运算的一个输入端</li>
<li>通用寄存器组：AX、BX、CX、DX、<strong>SP（堆栈指针，用于指示栈顶地址）</strong></li>
<li><strong>PSW</strong>：溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）</li>
</ul>
</li>
<li>控制器：<strong>程序计数器（PC）</strong>、<strong>IR</strong>、指令译码器、<strong>存储器地址寄存器（MAR）</strong>、<strong>存储器数据寄存器（MDR）</strong>、时序系统、微操作信号发生器<ul>
<li>PC：用于指出<strong>下一条指令在主存中的地址</strong>，程序顺序执行故 <strong>PC 有自增功能</strong>。</li>
<li>IR：保存当前正在执行的指令</li>
<li>MAR：存放要访问的主存地址单元</li>
<li>MDR：存放向主存中存入或读出的数据</li>
<li>微操作信号发生器：根据 IR、PSW 及时序信号，产生控制整个计算机系统的控制信号</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>用户可见寄存器（不透明）：通用寄存器组、PSW</p>
<p> 用户不可见寄存器（透明）：MAR、MDR、IR、暂存寄存器</p>
</li>
<li><p><strong>PC 位数 &#x3D; MAR 位数</strong>，取决于存储容量</p>
<p> <strong>MDR 位数 &#x3D; 机器字长</strong></p>
<p> <strong>IR 位数取决于指令字长</strong></p>
</li>
<li><p>条件转移所依据的条件来自：PSW</p>
</li>
<li><p>n 位 CPU，n 指 <strong>数据总线位数</strong></p>
</li>
<li><p><strong>指令译码</strong>是对指令的<strong>操做码字段</strong>进行译码</p>
</li>
</ol>
</blockquote>
<h3 id="5-2-指令执行过程"><a href="#5-2-指令执行过程" class="headerlink" title="5.2 指令执行过程"></a>5.2 指令执行过程</h3><blockquote>
<h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4></blockquote>
<p>指令周期：从主存中取出并执行一条指令的时间称为指令周期</p>
<ul>
<li>若干个<strong>时钟周期</strong>构成一个<strong>机器周期（既为CPU 周期，一般等于存取周期）</strong></li>
<li>若干个<strong>机器周期</strong>构成一个<strong>指令周期</strong></li>
</ul>
<p>三者之间的关系如下图所示：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210813151204811.png" alt="image-20210813151204811" style="zoom:80%;" />

<p>整个指令周期包括：<strong>取指周期、间指周期、执行周期和中断周期</strong>四个机器周期。</p>
<p>四个工作周期都有 CPU 访存，只是访存目的不同。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">取指周期</th>
<th align="left">间指周期</th>
<th align="left">执行周期</th>
<th align="left">中断周期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">任务</td>
<td align="left">根据 PC 中的内容从主存中<strong>取出指令代码并放在 IR 中</strong></td>
<td align="left"><strong>取操作数的有效地址</strong></td>
<td align="left">不同指令执行周期任务不同</td>
<td align="left">处理中断请求</td>
</tr>
<tr>
<td align="center">访存目的</td>
<td align="left">取指令</td>
<td align="left">取有效地址</td>
<td align="left">取操作数</td>
<td align="left">保存程序断点</td>
</tr>
<tr>
<td align="center">数据流向</td>
<td align="left">1. PC–&gt;MAR–&gt;地址总线–&gt;主存<br />2. CU发出控制信号–&gt;控制总线–&gt;主存<br />3. 指令–&gt;数据总线–&gt;MDR–&gt;IR<br />4. CU发出命令–&gt;PC + 1</td>
<td align="left">1. Ad(IR)–&gt;MAR–&gt;地址总线–&gt;主存<br />2. CU发出读命令–&gt;控制总线–&gt;主存<br />3. 主存–&gt;数据总线–&gt;MDR</td>
<td align="left"></td>
<td align="left">1. CU控制SP-1–&gt;MAR–&gt;地址总线–&gt;主存<br />2. CU发出写命令–&gt;控制总线–&gt;主存<br />3. PC–&gt;MDR–&gt;数据总线–&gt;主存</td>
</tr>
<tr>
<td align="center">图示</td>
<td align="left"><img src="【考研】计算机组成原理知识点梳理/image-20210813152550821.png" alt="image-20210813152550821" style="zoom:80%;" /></td>
<td align="left"><img src="【考研】计算机组成原理知识点梳理/image-20210813152607016.png" alt="image-20210813152607016" style="zoom:80%;" /></td>
<td align="left"></td>
<td align="left"><img src="【考研】计算机组成原理知识点梳理/image-20210813152626969.png" alt="image-20210813152626969" style="zoom:80%;" /></td>
</tr>
</tbody></table>
<blockquote>
<h4 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h4></blockquote>
<ul>
<li>单指令周期</li>
<li>多指令周期</li>
<li>指令流水线</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>中断周期的进栈操作是 SP - 1，因为计算机中的堆栈都是向低地址增加的</p>
</li>
<li><p>进栈操作时先修改栈顶指针后存入数据</p>
</li>
<li><p>存取周期：连续执行两读&#x2F;写操作中间间隔的最小时间</p>
<p> 指令周期：主存中取出一条指令并执行所用的时间</p>
</li>
<li><p>取指周期是<strong>从主存中取出指令字</strong>，PC 会给出指令在主存中的位置</p>
</li>
<li><p>通常把通过一次总线事务访问一次主存或 IO 的时间定位机器周期</p>
</li>
<li><p><strong>指令字长等于存储字长的前提下，取指周期等于机器周期</strong>（一次就可以把整条指令取出）</p>
<p> 指令字长和机器字长没有任何关系</p>
</li>
</ol>
</blockquote>
<h3 id="5-3-数据通路的功能和基本结构（🚩）"><a href="#5-3-数据通路的功能和基本结构（🚩）" class="headerlink" title="5.3 数据通路的功能和基本结构（🚩）"></a>5.3 数据通路的功能和基本结构（🚩）</h3><blockquote>
<h4 id="概念及功能"><a href="#概念及功能" class="headerlink" title="概念及功能"></a>概念及功能</h4></blockquote>
<p>数据通路：数据在功能部件之间传送的道路</p>
<p>数据通路的功能：实现CPU内部的 <strong>运算器与寄存器</strong> 及 <strong>寄存器与寄存器</strong> 之间的数据交换</p>
<blockquote>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4></blockquote>
<ul>
<li><p>CPU 内部单总线方式</p>
<p>  结构简单，但是<strong>数据传输存在较多冲突，性能较低</strong></p>
</li>
<li><p>CPU 内部三总线方式</p>
<p>  同时在多个总线上传输不同数据，<strong>提高效率</strong></p>
</li>
<li><p>专用数据通路方式</p>
<p>  依据指令执行过程中的数据和地址的流动方向安排连接线路，避免共享总线，<strong>性能高，但是硬件量大</strong></p>
</li>
</ul>
<blockquote>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4></blockquote>
<ul>
<li><p>寄存器与寄存器之间：把 PC 内容送到 MAR</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PC--&gt;BUS</span><br><span class="line">BUS--&gt;MAR</span><br></pre></td></tr></table></figure>
</li>
<li><p>主存与 CPU 之间：CPU 从主存中读取指令</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PC--&gt;BUS--&gt;MAR</span><br><span class="line">1--&gt;R					// CU 发出读命令</span><br><span class="line">MEM(MAR)--&gt;MDR</span><br><span class="line">MDR--&gt;BUS--&gt;IR</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行算术或逻辑运算：取操作数和 ACC 中的内容相加</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ad(IR)--&gt;BUS--&gt;MAR</span><br><span class="line">1--&gt;R</span><br><span class="line">MEM--&gt;数据线--&gt;MDR</span><br><span class="line">MDR--&gt;BUS--&gt;Y			// 数据放入暂存寄存器中</span><br><span class="line">(ACC)+(Y)--&gt;Z</span><br><span class="line">Z--&gt;ACC</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>Note:</p>
<ol>
<li><p><strong>暂存寄存器 Y</strong>：执行算术逻辑操作时，由于 <strong>ALU 本身没有内部存储功能的组合电路</strong>，因此执行加法运算时，先将一个操作数放入暂存寄存器 Y 中保存，再将另一个数经总线直接送到 ALU 的另一端</p>
</li>
<li><p>内部总线：CPU 内部连接各寄存器及运算部件之间的总线（<strong>使用内部总线，实现简单，性能较低，冲突较多</strong>）</p>
<p> 系统总线：是指同一台计算机系统的各个部件间互相连接的总线</p>
</li>
<li><p><strong>单周期处理器不能使用单总线结构数据通路</strong>，因为单总线数据通路一个时钟周期只允许一次操作，无法完成指令的所有操作</p>
</li>
</ol>
</blockquote>
<h3 id="5-4-控制器的功能和工作原理"><a href="#5-4-控制器的功能和工作原理" class="headerlink" title="5.4 控制器的功能和工作原理"></a>5.4 控制器的功能和工作原理</h3><blockquote>
<h4 id="结构和功能"><a href="#结构和功能" class="headerlink" title="结构和功能"></a>结构和功能</h4></blockquote>
<p>计算机硬件系统和控制器部件的组成如下图所示</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210813161710249.png" alt="image-20210813161710249" style="zoom:80%;" />

<p>控制器的主要功能：</p>
<ul>
<li>从主存中<strong>取出一条指令</strong>，并<strong>指出下一条指令</strong>在主存中的位置</li>
<li>对指令进行译码和测试，<strong>产生相应的操作控制信号</strong>，以便启动规定动作</li>
<li>指挥并<strong>控制</strong> CPU、主存、IO 设备之间的<strong>数据流动方向</strong></li>
</ul>
<p>分类：</p>
<ul>
<li>硬布线控制器（不是重点不展开介绍了）</li>
<li>微程序控制器</li>
</ul>
<blockquote>
<h4 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h4></blockquote>
<p>微程序控制器<strong>采用存储逻辑实现</strong>，就是<strong>把微操作信号代码化</strong>，使每<strong>条机器指令转化成为一段微程序</strong>并<strong>存入一个专门的存储器中</strong>（控制存储器 CM）</p>
<p><strong>1. 一些概念：</strong></p>
<ul>
<li><p>微命令与微操作：微操作是计算机中最基本、不可再分解的操作。微命令是构成控制序列的最小单位。</p>
<p>  微操作与微命令是一一对应的。<strong>微命令是微操作的控制信号，微操作是微命令的执行过程</strong></p>
</li>
<li><p>微指令：若干微命令的集合，一条微指令通常包含<strong>微操作码字段（操作控制字段）</strong>和<strong>微地址码字段（顺序控制字段）</strong></p>
<ul>
<li>微操作码字段：产生某一步操作所需要的各种操作控制信号</li>
<li><strong>微地址码字段：控制产生下一条要执行的微指令地址字段</strong></li>
</ul>
</li>
<li><p>微周期：从控制存储器内读取一条微指令并执行相应微操作所需的时间</p>
</li>
<li><p>主存储器与控制存储器：</p>
<ul>
<li><strong>主存储器</strong>用于存放程序和数据，<strong>位于 CPU 外部，用 RAM 实现</strong></li>
<li><strong>控制存储器</strong>用于存放微程序，<strong>位于 CPU 内部，用 ROM 实现</strong></li>
</ul>
</li>
<li><p>程序与微程序：</p>
<ul>
<li>程序是指令的有序集合，用于完成特定功能</li>
<li>一条指令的功能是由一个微程序来实现的</li>
</ul>
</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210813171409025.png" alt="image-20210813171409025" style="zoom:80%;" />

<p><strong>2. 微程序控制器的基本组成：</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210813172047563.png" alt="image-20210813172047563" style="zoom:80%;" />

<ul>
<li>控制存储器（CM）：核心部件，用于存放指令对应的微程序</li>
<li>微指令寄存器（CMDR&#x2F;μIR）：存放从 CM 中取出的微指令</li>
<li>微地址形成部件</li>
<li>微地址寄存器（CMAR）</li>
</ul>
<p><strong>3. 微指令的编码方式</strong></p>
<ul>
<li><p>直接编码：微指令的微命令字段每位代表一个微命令</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210813173616533.png" alt="image-20210813173616533" style="zoom:80%;" />

<ul>
<li><p>优点：简单、直观，执行速度快，操作并行性好</p>
</li>
<li><p>缺点：微指令字长过长，造成 CM 容量极大</p>
</li>
</ul>
</li>
<li><p>字段直接编码方式：把微命令字段分成若干小段，把<strong>互斥性微命令组合放在同一字段中，把相容性微命令组合 放在不同字段中</strong>，每个字段独立编码</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210813173641726.png" alt="image-20210813173641726" style="zoom:80%;" />

<ul>
<li>优点：缩短指令字长</li>
<li>缺点：比直接编码方式慢</li>
<li>小段中的信息位不能太多，一般每个小段还留出一个状态表示本字段不发出任何微命令（如 000）</li>
</ul>
</li>
<li><p>字段间接编码：一个字段的微命令需要由另一个字段的某些微命令来解释（作为字段直接编码方式的辅助）</p>
</li>
</ul>
<p><strong>4. 微指令的地址形成方式</strong></p>
<ul>
<li>直接由微指令的下地址字段指出</li>
<li>根据机器指令操作码形成</li>
</ul>
<p><strong>5. 微指令的格式</strong></p>
<ul>
<li>水平型微指令：<strong>微程序短</strong>，执行速度快；<strong>微指令长</strong>，编写微程序较为麻烦</li>
<li>垂直型微指令：<strong>微指令短</strong>，便于编写微程序；<strong>微程序长</strong>，工作效率低</li>
<li>混合型微指令：在垂直型的基础上增加不复杂的并行操作</li>
</ul>
<blockquote>
<h4 id="硬布线控制器与微程序控制器对比"><a href="#硬布线控制器与微程序控制器对比" class="headerlink" title="硬布线控制器与微程序控制器对比"></a>硬布线控制器与微程序控制器对比</h4></blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">硬布线控制器</th>
<th align="center">微程序控制器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">工作原理</td>
<td align="center">微操作信号由组合逻辑电路根据当前指令码、状态和时序即时产生</td>
<td align="center">微操作信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td>
</tr>
<tr>
<td align="center">执行速度</td>
<td align="center">快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">规整性</td>
<td align="center">不规整</td>
<td align="center">规整</td>
</tr>
<tr>
<td align="center">应用场合</td>
<td align="center">RISC CPU</td>
<td align="center">CISC CPU</td>
</tr>
<tr>
<td align="center">易扩展性</td>
<td align="center">不易扩展</td>
<td align="center">易扩展</td>
</tr>
</tbody></table>
<blockquote>
<p>Note：</p>
<ol>
<li><p>在组合逻辑控制器（硬布线控制器）中也存在微命令与微操作的概念</p>
</li>
<li><p>对程序员来说，<strong>微程序的结构和功能都是透明的</strong></p>
</li>
<li><p>控制存储器中的微程序个数：机器指令数 + 对应取指、间指和中断周期等共用的微程序个数</p>
<p> 若指令系统中有 <strong>n 种机器指令</strong>，则 <strong>CM 中的微程序数至少是 n + 1</strong>（1 位公共取指微程序）</p>
</li>
<li><p>实现动态微程序设计可采用：可擦除可编程只读存储器（EPROM）</p>
</li>
<li><p>组合逻辑控制器种，微操作控制信号形成主要与 <strong>指令译码信号和时钟</strong> 有关</p>
</li>
<li><p>微程序的入口地址：机器指令的操做码字段</p>
</li>
<li><p>微指令结构设计所追求的目标：</p>
<ul>
<li>提高微程序的执行速度</li>
<li>提供程序设计的灵活性</li>
<li>缩短指令的长度</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="5-5-指令流水线（🚩）"><a href="#5-5-指令流水线（🚩）" class="headerlink" title="5.5 指令流水线（🚩）"></a>5.5 指令流水线（🚩）</h3><blockquote>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></blockquote>
<p>采用流水线技术<strong>只需要增加少量硬件</strong>就能把计算机的<strong>运算速度提升几倍</strong>，是计算机中普遍使用的一种<strong>并行处理技术</strong>。</p>
<p><strong>1. 指令执行阶段</strong></p>
<p>我们把一条指令的执行过程大致划分为三个阶段：<strong>取指、分析、执行</strong></p>
<ul>
<li>取指：根据 PC 内容访问主存取出指令送至 IR</li>
<li>分析：对指令操做码进行译码，按照给定的寻址方式和地址形成操作数的有效地址 EA，并根据 EA 取出操作数</li>
<li>执行：依据指令操做码完成指定功能，并将运算结果写入寄存器或主存中</li>
</ul>
<p><strong>2. 指令执行方式</strong></p>
<p>指令可采用两种方式执行：<strong>顺序执行、流水线执行</strong>（假设指令三个阶段花费时间相同，均为 t）</p>
<ul>
<li><p>顺序执行：就是按照指令顺序一条一条执行指令</p>
<p>  <strong>执行 n 条指令用时：$T&#x3D;3nt$​​</strong></p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210814152645275.png" alt="image-20210814152645275" style="zoom:80%;" />
</li>
<li><p>流水线执行：为了充分利用各功能部件，不让他们闲着摸🐟，在第一条指令执行完取指操作后就开始执行第二条指令的取指操作，后面指令依次这样进行</p>
<p>  <strong>执行 n 条指令用时：$T&#x3D;(3+n-1)t&#x3D;(n+2)t$​​</strong> （第一条指令运行结束后每经过 t 时间完成一条指令的运行）</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210814152701535.png" alt="image-20210814152701535" style="zoom:80%;" /></li>
</ul>
<p><strong>3. 流水线设计原则</strong></p>
<ul>
<li>指令流水段个数以最复杂指令所用的功能段个数为准</li>
<li>流水线的长度以最复杂的操作所花的时间为准</li>
</ul>
<p><strong>4. 指令集特征（为了实现流水线功能）</strong></p>
<ul>
<li>指令长度一致</li>
<li>指令格式规整，保证源寄存器位置相同</li>
<li>采用 <code>Load/Store</code> 指令访存</li>
<li>数据和指令对齐放置</li>
</ul>
<p><strong>5. 流水线的表示方法：时空图</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210814154021116.png" alt="image-20210814154021116" style="zoom:80%;" />

<blockquote>
<h4 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h4></blockquote>
<p><strong>流水线冲突（冒险）</strong>：指令流水线可能会因为一些情况而受到阻碍或停顿</p>
<ol>
<li><p><strong>资源冲突</strong>：多条指令同时征用同一硬件资源</p>
<p> 解决方法：1）后一条指令暂停一个时钟周期    2）数据与指令存储器分离</p>
</li>
<li><p><strong>数据冲突</strong>：下一条指令用到当前指令的计算结果</p>
<p> 分类：</p>
<ol>
<li>写后读相关（RAW）     </li>
<li>读后写相关（WAR）    </li>
<li>写后写相关（WAW）</li>
</ol>
<p> 解决方法：</p>
<ol>
<li>将后面指令暂停一到几个周期。（硬件阻塞&#x2F;软件插入“NOP”）</li>
<li>设置相关专用通路（数据旁路技术）</li>
<li>指令编译优化，调整指令执行顺序</li>
</ol>
</li>
<li><p><strong>控制冲突</strong>：执行转移、调用、返回等指令时修改 PC 的值造成断流</p>
<p> 解决办法：</p>
<ol>
<li>分支预测，尽早生成转移目标地址</li>
<li>预测转移成功和不成功两个控制流方向上的目标指令</li>
<li>加快和提前形成条件码</li>
<li>提高转移方向猜准率</li>
</ol>
</li>
</ol>
<blockquote>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4></blockquote>
<ol>
<li><p><strong>吞吐率</strong>：单位时间内流水线所完成的任务数量<br> $$<br> TP&#x3D;{n\over T_k} \\<br> TP&#x3D;{n \over (k+n-1)t}<br> $$<br> $n$​ 是任务数量，$T_k$​ 是处理完 $n$​ 个任务所用时间，$k$​​ 是流水线级数，$t$​​ 是一个流水线功能段处理时间</p>
</li>
<li><p><strong>加速比</strong>：不使用流水线与使用流水线所用时间之比<br> $$<br> S&#x3D;{T_0 \over T_k} \ \<br> S&#x3D;{kn \over k+n-1}<br> $$</p>
</li>
<li><p><strong>效率</strong>：设备利用率（时空图上，n 个任务有效面积与整个矩形面积之比）</p>
</li>
</ol>
<p><img src="/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/image-20210814161324557.png" alt="image-20210814161324557"></p>
<blockquote>
<h4 id="超标量流水线"><a href="#超标量流水线" class="headerlink" title="超标量流水线"></a>超标量流水线</h4></blockquote>
<ol>
<li><p>超标量流水线技术（<strong>空间换时间</strong>）</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210814161643985.png" alt="image-20210814161643985" style="zoom:80%;" />
</li>
<li><p>超流水线技术</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210814161656646.png" alt="image-20210814161656646" style="zoom:80%;" />
</li>
<li><p>超长指令字</p>
<p> 将多条能并行操作的指令组成一条具有多个操作码字段的超长指令字</p>
</li>
</ol>
<blockquote>
<p>Note：</p>
<ol>
<li><p>k 级流水线执行 n 条指令用时：$T &#x3D; (k+n-1)t$​</p>
</li>
<li><p>流水线并不能缩短一条指令的执行时间，但是整体而言，可以大大增加指令执行的吞吐率</p>
</li>
<li><p>Cache 缺失也会造成流水线阻塞</p>
</li>
<li><p>RISC、CISC 机器都有流水线 CPU</p>
</li>
<li><p>超标量流水线技术不能缩短流水线功能段的处理时间</p>
</li>
<li><p>指令流水线数据通路：</p>
<p> 不包含生成控制信号的控制部件</p>
<p> 包含 ALU、通用寄存器组</p>
<p> 由组合逻辑电路和时序逻辑电路组合而成</p>
</li>
<li><p>流水段越多，执行指令越快？</p>
<ul>
<li>流水段缓冲之间的额外开销增大</li>
<li>流水段间控制逻辑变多变复杂</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h1><h3 id="考纲及章节框架-4"><a href="#考纲及章节框架-4" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210816154332708.png" alt="image-20210816154332708" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210816155043489.png" alt="image-20210816155043489" style="zoom:80%;" />

<h3 id="6-1-总线概述"><a href="#6-1-总线概述" class="headerlink" title="6.1 总线概述"></a>6.1 总线概述</h3><blockquote>
<h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4></blockquote>
<p><strong>总线</strong>是一组能够为多个部件 <strong>分时共享</strong> 的公共信息传输线（更好的解决 IO 设备与主机之间连接的灵活性问题）</p>
<ul>
<li><p>分时：同一时刻只允许一个部件向总线发送信息</p>
</li>
<li><p>共享：总线上挂接多个部件，各部件之间可以通过总线分时共享信息</p>
<p>  🚩 某一时刻只允许<strong>一个部件</strong>向总线<strong>发送信息</strong>，但<strong>多个部件</strong>可以同时从总线上<strong>接受相同的信息</strong>！</p>
</li>
</ul>
<p>主设备与从设备：</p>
<ul>
<li>主设备：获得总线控制权的设备（只能有一个！）</li>
<li>从设备：被主设备访问，相应各种命令（可以有多个）</li>
</ul>
<p>总线特性：</p>
<ul>
<li><strong>机械特性</strong>：尺寸、形状</li>
<li><strong>电气特性</strong>：传输方向、有效电平范围</li>
<li><strong>功能特性</strong>：每根传输线的功能</li>
<li><strong>时间特性</strong>：信号和时序的关系</li>
</ul>
<p>引入总线系统的好处：</p>
<ul>
<li>简化系统结构</li>
<li>减少连线数目，便于布线，提高系统可靠性</li>
<li>便于接口设计</li>
<li>便于系统拓展，易于实现模块化</li>
<li>便于设备的软件设计</li>
<li>便于故障维修，降低成本</li>
</ul>
<p>🚩 <strong>总线的猝发传输方式</strong>：在<strong>一个总线周期</strong>内传输<strong>地址连续</strong>的<strong>多个数据字</strong>的总线传输方式（地址连续的数据只用传输第一个数据的地址）</p>
<blockquote>
<h4 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h4></blockquote>
<ol>
<li><p>片内总线</p>
</li>
<li><p>系统总线（本章主角）</p>
<ul>
<li>数据总线：🚩 <strong>双向传输总线，位数与机器字长、存储字长有关</strong></li>
<li>地址总线：🚩 <strong>单向传输总线，位数与主存地址空间大小有关</strong></li>
<li>控制总线</li>
</ul>
</li>
<li><p>通信总线</p>
<p> 计算机系统之间或计算机系统与其它系统之间传送信息的总线，也叫 外部总线</p>
</li>
</ol>
<blockquote>
<h4 id="系统总线的结构"><a href="#系统总线的结构" class="headerlink" title="系统总线的结构"></a>系统总线的结构</h4></blockquote>
<ol>
<li><p>单总线结构</p>
<p> CPU、主存、IO 设备都挂在一组总线上</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210816161653311.png" alt="image-20210816161653311" style="zoom:80%;" />

<ul>
<li>优点：结构简单、成本低、易于接入新设备</li>
<li>缺点：带宽低、负载重、多个部件只能争用一条总线、不支持并发传送</li>
</ul>
</li>
<li><p>双总线结构</p>
<p> 一条是 <strong>主存总线</strong>，另一条是 <strong>IO 总线</strong>（用于多个外部设备与<strong>通道</strong>之间的数据传输）</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210816162006058.png" alt="image-20210816162006058" style="zoom:80%;" />

<ul>
<li>优点：将低速 IO 设备从单总线上分离出来，实现了存储器总线和 IO 总线的分离</li>
<li>缺点：需要增加通道等硬件设备</li>
</ul>
</li>
<li><p>三总线结构</p>
<p> 用 主存总线、IO 总线、DMA 总线 这三条独立的总线来构成信息通道</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210816162226275.png" alt="image-20210816162226275" style="zoom:80%;" />

<ul>
<li>优点：提高 IO 设备性能，使响应更快速，提高系统吞吐量</li>
<li>缺点：系统工作效率低下</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4></blockquote>
<ol>
<li><p>总线传输周期：一次总线操作所用时间，通常由若干总线时钟周期组成，也叫 总线周期</p>
</li>
<li><p>总线时钟周期：机器的时钟周期</p>
</li>
<li><p>总线工作频率：总线周期的倒数</p>
</li>
<li><p>总线时钟频率：总线时钟周期的倒数</p>
</li>
<li><p>总线宽度：总线上能同时传输数据的位数</p>
</li>
<li><p>总线带宽：单位时间上总线可传输的位数。</p>
<p> 🚩 总线带宽 &#x3D; 总线工作频率 x (总线宽度 &#x2F; 8) B&#x2F;s</p>
</li>
<li><p>总线复用：一种信号线在不同的时间传输不同的信息，从而节省空间成本</p>
</li>
<li><p>信号线数：数据总线、地址总线、控制总线线数的总和</p>
</li>
</ol>
<blockquote>
<p>Note：</p>
<ol>
<li>单总线结构并不是指只有一根信号线</li>
<li>握手信号属于控制信号，不可能出现在数据线上，而指令、操作数、中断类型号等则有可能出现在数据线上</li>
<li>主存通过 <strong>总线的类型</strong> 来识别信息是地址还是数据</li>
</ol>
</blockquote>
<h3 id="6-2-总线操作和定时"><a href="#6-2-总线操作和定时" class="headerlink" title="6.2 总线操作和定时"></a>6.2 总线操作和定时</h3><blockquote>
<h4 id="总线传输阶段"><a href="#总线传输阶段" class="headerlink" title="总线传输阶段"></a>总线传输阶段</h4></blockquote>
<ol>
<li>申请分配阶段</li>
<li>寻址阶段</li>
<li>传输阶段</li>
<li>结束阶段</li>
</ol>
<blockquote>
<h4 id="🚩-同步定时方式"><a href="#🚩-同步定时方式" class="headerlink" title="🚩 同步定时方式"></a>🚩 同步定时方式</h4></blockquote>
<p>同步定时方式：采用一个统一的时钟信号来协调发送和接受双方的传送定时关系</p>
<p>优缺点：</p>
<ul>
<li>优点：传送速度快；具有较高的传输速率；总线控制逻辑简单</li>
<li>缺点：主从设备强制同步，不能及时进行数据通信的有效性检验，<strong>可靠性查</strong></li>
</ul>
<p>适用情况：</p>
<ul>
<li>总线长度较短</li>
<li>总线所连接各部件存取时间比较接近</li>
</ul>
<blockquote>
<h4 id="🚩-异步定时方式"><a href="#🚩-异步定时方式" class="headerlink" title="🚩 异步定时方式"></a>🚩 异步定时方式</h4></blockquote>
<p>异步定时方式：跟 TCP 建立连接有点类似，采用握手的方式来确定信息是否被成功接收</p>
<p>优缺点：</p>
<ul>
<li>优点：总线周期长度可变，能保证两个工作速度相差很大的设备之间进行可靠的信息交换</li>
<li>缺点：实现起来复杂，速度比同步方式慢</li>
</ul>
<p>分类：</p>
<ul>
<li>不互锁方式</li>
<li>半互锁方式</li>
<li>全互锁方式</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210816164508038.png" alt="image-20210816164508038" style="zoom:80%;" />

<h3 id="6-3-总线标准"><a href="#6-3-总线标准" class="headerlink" title="6.3 总线标准"></a>6.3 总线标准</h3><p>常见总线标准有：ISA、EISA、VESA、PCI、PCI-Express、AGP、RS-232C、USB</p>
<p>区分标准：总线宽度、带宽、时钟频率、寻址能力、是否支持猝发传送</p>
<table>
<thead>
<tr>
<th align="center">总线标准</th>
<th align="center">串行&#x2F;并行</th>
<th align="center">局部&#x2F;系统</th>
<th align="center">特性</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ISA</strong></td>
<td align="center">并行</td>
<td align="center">系统</td>
<td align="center"><strong>最早出现</strong>的微型计算机系统总线</td>
</tr>
<tr>
<td align="center"><strong>ISAE</strong></td>
<td align="center">并行</td>
<td align="center">系统</td>
<td align="center">ISA 的拓展，对 ISA兼容</td>
</tr>
<tr>
<td align="center">V(Video)ESA</td>
<td align="center">并行</td>
<td align="center">局部</td>
<td align="center">针对<strong>多媒体 PC</strong> 要求高速传送活动图像的大量数据</td>
</tr>
<tr>
<td align="center"><strong>PCI</strong></td>
<td align="center">并行</td>
<td align="center">局部</td>
<td align="center">专为高度集成的<strong>外围设备、扩充插板、处理器&#x2F;存储器</strong>系统设计<br />常用的PCI适配器：<strong>显卡、声卡、网卡</strong><br />PCI 总线支持<strong>即插即用</strong><br />PCI 总线可以<strong>通过桥连接</strong>，实现多层 PCI 总线<br />半同步总线</td>
</tr>
<tr>
<td align="center"><strong>PCI-Express</strong></td>
<td align="center">并行</td>
<td align="center">局部</td>
<td align="center"><strong>最新</strong>的总线接口标准，将最终<strong>统一</strong>总线标准</td>
</tr>
<tr>
<td align="center">AGP</td>
<td align="center"></td>
<td align="center">局部</td>
<td align="center">一种<strong>视频接口</strong>标准，用于连接主存和图形存储器<br />用于<strong>传输视频和三维图形数据</strong></td>
</tr>
<tr>
<td align="center">RS-232C</td>
<td align="center">串行</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>USB</strong></td>
<td align="center">串行</td>
<td align="center"></td>
<td align="center">连接外部设备的 IO 总线<br /><strong>即插即用、热插拔</strong><br />连接力强</td>
</tr>
<tr>
<td align="center">PCMCIA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">用于<strong>笔记本</strong>的接口标准，可以<strong>即插即用</strong></td>
</tr>
<tr>
<td align="center">IDE</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">更准确的称为 ATA，是 IDE接口磁盘驱动器接口<br /><strong>硬盘、光驱</strong>通过 IDE 接口与主板连接</td>
</tr>
<tr>
<td align="center">SCSI</td>
<td align="center"></td>
<td align="center">系统</td>
<td align="center">用于计算机和<strong>智能设备</strong>之间的独立处理器标准</td>
</tr>
<tr>
<td align="center">SATA</td>
<td align="center">串行</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>Note： </p>
<ol>
<li><p>局部总线不和系统共享统一时钟</p>
<p> 采用局部总线可以节省系统带宽</p>
</li>
</ol>
</blockquote>
<h1 id="第七章-输出输出系统"><a href="#第七章-输出输出系统" class="headerlink" title="第七章 输出输出系统"></a>第七章 输出输出系统</h1><h3 id="考纲及章节框架-5"><a href="#考纲及章节框架-5" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210819162539834.png" alt="image-20210819162539834" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210819163324437.png" alt="image-20210819163324437" style="zoom:80%;" />

<h3 id="7-1-IO-系统基本概念"><a href="#7-1-IO-系统基本概念" class="headerlink" title="7.1 IO 系统基本概念"></a>7.1 IO 系统基本概念</h3><blockquote>
<h4 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h4></blockquote>
<p>基本概念：</p>
<ul>
<li>外部设备</li>
<li>接口：外设与主机之间传输数据时进行协调工作的逻辑部件</li>
<li>输入设备</li>
<li>输出设备</li>
<li>外存设备：除内存及 CPU 缓存等外的存储器</li>
</ul>
<p>IO 系统：由 <strong>IO 硬件</strong>和 <strong>IO 软件</strong>组成</p>
<ul>
<li><p>IO 软件：包括驱动程序、用户程序、管理程序、升级补丁等</p>
<p>  通常采用 <strong>IO 指令</strong>和<strong>通道指令</strong>来实现 CPU 与 IO设备的数据交换</p>
</li>
<li><p>IO 硬件：包括外设、设备控制器、IO 总线等</p>
<p>  <strong>通过设备控制器来控制 IO 设备的具体动作；通过 IO 接口与主机相连</strong></p>
</li>
</ul>
<blockquote>
<h4 id="IO-控制方式"><a href="#IO-控制方式" class="headerlink" title="IO 控制方式"></a>IO 控制方式</h4></blockquote>
<ul>
<li>程序查询方式</li>
<li>程序中断方式</li>
<li>DMA 方式</li>
<li>通道方式</li>
</ul>
<p>别急，后面会进行详细介绍！</p>
<blockquote>
<p>Note：</p>
<ol>
<li>IO 设备通过 <strong>设备控制器</strong> 与主版的系统总线相<strong>连</strong></li>
<li><strong>通道程序存放在主存中！</strong></li>
</ol>
</blockquote>
<h3 id="7-2-外部设备"><a href="#7-2-外部设备" class="headerlink" title="7.2 外部设备"></a>7.2 外部设备</h3><blockquote>
<h4 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h4></blockquote>
<ol>
<li><p>键盘</p>
<p> 通常以矩阵形式排列按键，每个键相当于一个开关</p>
</li>
<li><p>鼠标</p>
<p> 常用的定位输入设备，鼠标在平面上移动时，底部传感器把运动的方向和距离检测出来</p>
</li>
</ol>
<blockquote>
<h4 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h4></blockquote>
<ol>
<li><p>显示器</p>
<p> <strong>参数：</strong></p>
<ul>
<li><p>屏幕大小：对角线的长度</p>
</li>
<li><p>分辨率：所能表示像素点的个数（1024 x 768）</p>
</li>
<li><p>灰度级：控制颜色或亮暗（8位、16位）</p>
</li>
<li><p>刷新频率：人在刷新频率大于 30Hz 时才不会感到闪烁，一般屏幕为 60-120Hz</p>
</li>
<li><p>显示存储器（VRAM）：为了不断提高刷新图像的信号，必须把一帧图像信息存储着 VRAM 中</p>
<p>  <strong>注意 VRAM 容量和 VRAM 带宽的计算！</strong></p>
</li>
</ul>
<p> <strong>分类：</strong></p>
<ul>
<li>阴极射线管显示器（CRT）</li>
<li>液晶显示器（LCD）：体积小、重量轻、省电、无辐射、绿色环保、画面柔和、不伤眼</li>
<li>发光二极管显示器（LED）：与 LCD 相比，在亮度、功耗、可视角度、刷新速率等方面更具优势</li>
</ul>
</li>
<li><p>打印机</p>
<p> 按工作原理分为：击打式和非击打式；按工作方式分为：点阵打印机、针式打印机、喷墨打印机、激光打印机等</p>
<ul>
<li>针式打印机：擅长<strong>多层复写打印</strong>，工作原理简单，造价低廉，耗材便宜，但是分辨率和速度不够高</li>
<li>喷墨打印机：噪声小，可实现高质量彩印，打印速度较快，但是防水性差</li>
<li>激光打印机：打印质量高、速度快、噪声小、处理能力强，但耗材多、价格贵、对纸张要求高</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="🚩-外存储器"><a href="#🚩-外存储器" class="headerlink" title="🚩 外存储器"></a>🚩 外存储器</h4></blockquote>
<p>计算机的外存主要使用<strong>磁表面存储器</strong>（磁盘、磁带、磁鼓）</p>
<p>磁表面存储器优点：</p>
<ol>
<li>容量大、价格低</li>
<li>记录介质可以重复使用</li>
<li>记录信息可长久保存（甚至能脱机存档）</li>
<li>非破坏性读出</li>
</ol>
<p>磁表面存储器缺点：存取速度慢，机械结构复杂，对工作环境要求高</p>
<p><strong>1. 磁盘存储器</strong></p>
<p>一块磁盘有若干个<strong>记录面</strong>，一个记录面有若干个<strong>磁道</strong>，一个磁道有若干个<strong>扇区</strong></p>
<p><strong>扇区也称块，是磁盘读写的最小单位，即磁盘按块存取</strong></p>
<p>其结构如下图所示</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210819170645048.png" alt="image-20210819170645048" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210819170630870.png" alt="image-20210819170630870" style="zoom:80%;" />

<p>磁盘的性能指标：</p>
<ul>
<li><p>磁盘的容量：有格式化与非格式化之分，格式化之后磁盘容量减小。</p>
</li>
<li><p>记录密度：通常以道密度、位密度、面密度（前两个的乘积）表示</p>
</li>
<li><p><strong>平均存取时间</strong>：由<strong>寻道时间</strong>、<strong>旋转延迟时间</strong>（旋转半周用时）、<strong>传输时间</strong>三部分构成</p>
</li>
<li><p>数据传输率：设磁盘转数 $r$ 转&#x2F;秒，每条磁道容量 $N$ 字节，则数据传输率：<br>  $$<br>  D_r&#x3D; rN<br>  $$</p>
</li>
</ul>
<p>磁盘地址：</p>
<table>
<thead>
<tr>
<th align="center">驱动器号</th>
<th align="center">柱面（磁道）号</th>
<th align="center">盘面号</th>
<th align="center">扇区号</th>
</tr>
</thead>
</table>
<p>磁盘工作过程：寻址、读盘、写盘（每个操作对应一个控制字）</p>
<p><strong>2. 磁盘阵列</strong></p>
<p>RAID（廉价冗余磁盘阵列）是指将多个独立的物理磁盘组成一个逻辑盘，<strong>数据在多个物理盘上分割交叉存储、并行访问</strong>，具有更好的存储性能、可靠性、安全性</p>
<p>RAID 通过<strong>同时使用多个磁盘</strong>提高了传输率；通过<strong>多个磁盘上并行存取</strong>来大幅提高存储系统的数据吞吐量；通过<strong>镜像功能</strong>提高了安全可靠性；通过<strong>数据校验</strong>提供了容错能力。</p>
<p><strong>3. 固态硬盘</strong></p>
<p>高性能 Flash Memory（贵）</p>
<blockquote>
<p>Note：</p>
<ol>
<li>硬盘属于机械式部件，其<strong>读写操作是串行的</strong></li>
<li>计算机中<strong>汉字内码</strong>在主存中占 <strong>2B</strong></li>
</ol>
</blockquote>
<h3 id="7-3-IO-接口"><a href="#7-3-IO-接口" class="headerlink" title="7.3 IO 接口"></a>7.3 IO 接口</h3><p>IO 接口（IO 控制器）是主机和外设之间的交界面，通过接口可以实现主机与外设之间的信息交换</p>
<blockquote>
<h4 id="IO-接口的功能"><a href="#IO-接口的功能" class="headerlink" title="IO 接口的功能"></a>IO 接口的功能</h4></blockquote>
<ol>
<li>实现主机和外设的通信联络控制：解决主机与外设时序配合问题</li>
<li>进行地址译码和设备选择</li>
<li><strong>实现数据缓冲</strong>：接口必须设置<strong>数据缓冲寄存器</strong>来暂存数据从而消除 CPU 与外设之间的速度差异</li>
<li>信号格式转换</li>
<li>传送控制命令和状态信息</li>
</ol>
<blockquote>
<h4 id="IO-接口基本结构"><a href="#IO-接口基本结构" class="headerlink" title="IO 接口基本结构"></a>IO 接口基本结构</h4></blockquote>
<img src="【考研】计算机组成原理知识点梳理/image-20210819172906637.png" alt="image-20210819172906637" style="zoom:80%;" />

<p><strong>数据线传送的信息：</strong></p>
<ul>
<li>数据缓冲寄存器与内存或 CPU 寄存器之间的<strong>数据</strong></li>
<li>接口和设备的<strong>状态信息</strong></li>
<li>CPU 对外设的<strong>控制命令</strong></li>
</ul>
<p><strong>地址线传送的信息：</strong></p>
<ul>
<li>要访问的 IO 接口中的<strong>寄存器的地址</strong></li>
</ul>
<p><strong>IO 指令：</strong></p>
<ul>
<li><strong>对数据缓冲寄存器、状态&#x2F;控制寄存器的访问操作</strong>是通过相应的 IO 指令来完成的。</li>
<li><strong>IO 指令只能在操作系统内核的底层 IO 软件中使用，是一种特权指令</strong></li>
</ul>
<blockquote>
<h4 id="IO-接口的类型"><a href="#IO-接口的类型" class="headerlink" title="IO 接口的类型"></a>IO 接口的类型</h4></blockquote>
<ol>
<li>并行接口、串行接口</li>
<li>程序查询接口、中断接口、DMA 接口</li>
<li>可编程接口、不可编程接口</li>
</ol>
<blockquote>
<h4 id="IO-端口及其编址"><a href="#IO-端口及其编址" class="headerlink" title="IO 端口及其编址"></a>IO 端口及其编址</h4></blockquote>
<p>IO 端口：接口电路中可以被 CPU 直接访问的寄存器，有：数据端口（读写）、状态端口（读）、控制端口（写）</p>
<p>对 IO 端口的编址分为 <strong>与存储器统一编址</strong> 和 <strong>独立编址</strong></p>
<ul>
<li>统一编址（存储器映射方式）：用统一的访存指令访问 IO 端口<ul>
<li>优点：操作灵活、方便，使端口有较大的编址空间</li>
<li>缺点：端口占用存储器地址，使内存容量变小，且执行速度慢</li>
</ul>
</li>
<li>独立编址（IO 映射方式）：设置专门的 IO 指令来访问 IO 端口<ul>
<li>优点：程序编制清晰、便于理解</li>
<li>缺点：指令少，一般只能对端口进行传送操作，增加了控制复杂性</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>端口：接口电路中可以进行读写的寄存器</p>
<p> 接口：若干端口加上相应的控制逻辑</p>
</li>
<li><p>IO 总线上的<strong>数据线</strong>传送的信号包括：</p>
<ul>
<li>IO 接口中的<strong>命令字</strong></li>
<li>IO 接口中的<strong>状态字</strong></li>
<li><strong>中断类型号</strong></li>
<li>数据缓冲寄存器与 内存&#x2F; CPU 交换的<strong>数据</strong></li>
</ul>
</li>
<li><p>统一编址的情况下，区分存储单元和 IO 设备靠 <strong>不同的地址码</strong></p>
</li>
</ol>
</blockquote>
<h3 id="7-4-IO-方式（🚩）"><a href="#7-4-IO-方式（🚩）" class="headerlink" title="7.4 IO 方式（🚩）"></a>7.4 IO 方式（🚩）</h3><p>常用的 IO 方式有：程序查询、程序中断、DMA、通道（前两种更依赖于 CPU 中程序指令的执行）</p>
<blockquote>
<h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4></blockquote>
<p><strong>1. 概念</strong></p>
<p>信息的交换完全由主机执行程序来实现，程序查询方式接口中设置一个<strong>数据缓冲寄存器（数据端口）</strong>和一个<strong>设备状态寄存器（状态端口）</strong></p>
<p>主机进行 IO 操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步是进行数据传送还是等待</p>
<p>具体流程如下图所示：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210820154756237.png" alt="image-20210820154756237" style="zoom:80%;" />

<p><strong>2. 特性</strong></p>
<ul>
<li><p>主要特点：是 <strong>CPU 有踏步等待的现象，CPU 与 IO 串行工作</strong></p>
</li>
<li><p>优点：接口设计简单，设备量小</p>
</li>
<li><p>缺点：CPU 要花费时间查询和等待，且在一段时间内只能和一台设备交换信息，效率巨低</p>
</li>
</ul>
<blockquote>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4></blockquote>
<p><strong>1. 异常</strong></p>
<p>异常是 <strong>CPU 内部异常</strong>引起的意外事件，分为<strong>硬故障中断</strong>和<strong>程序性异常</strong></p>
<ul>
<li><p>硬故障中断：电源掉电、存储线路出错……</p>
</li>
<li><p><strong>程序性异常</strong>（软中断）：除零异常、溢出、断点、单步跟踪、非法指令、栈溢出、地址越界、缺页、分时系统中的时间片中断、用户态到核心态的切换……</p>
</li>
</ul>
<p>根据报告方式和返回方式不同，内部异常可分为：<strong>故障（Fault）、自陷（Trap）、终止（Abort）</strong></p>
<ul>
<li><p><strong>故障</strong>：指令启动后、结束前被检测到的异常事件</p>
<p>  如：非法操做码、缺段&#x2F;缺页（解决故障后可以回到断点）、除数为零（必须终止进程的执行）……</p>
</li>
<li><p><strong>自馅</strong>：预先安排的一种异常</p>
<p>  如：80x86 中用于调试的断点、系统调用指令、条件自馅指令……</p>
</li>
<li><p><strong>终止</strong>：发生了计算机无法继续执行的硬件故障（不由特定指令产生，而是<strong>随机发生</strong>）</p>
<p>  如：电源掉电、线路故障……</p>
</li>
</ul>
<p><strong>2. 中断</strong>（外部）</p>
<p>外中断来自 CPU 外部，是与 CPU 执行指令无关的事件引起的中断</p>
<p>如：</p>
<ul>
<li>IO 设备发出的 IO 中断（键盘输入、打印机缺纸）</li>
<li>外部信号中断（用户按 Esc 键）</li>
<li>定时器引起的时钟中断</li>
</ul>
<p>中断与异常的区别：</p>
<ul>
<li><p>异常是由<strong>特定指令</strong>在执行过程中产生的；</p>
<p>  中断不和任何指令相关联，也不阻止任何指令的完成</p>
</li>
<li><p>异常的<strong>检测是由 CPU 完成</strong>的，不必通过某个外部信号通知 CPU；</p>
<p>  中断是 CPU 必须通过总线获取<strong>中断源的标识信息</strong>，才能获知那个设备发生了何种中断</p>
</li>
</ul>
<p>程序中断的作用：</p>
<ul>
<li><strong>实现 CPU 和 IO 设备并行工作</strong></li>
<li>处理硬件故障和软件错误</li>
<li>实现人机交互</li>
<li>实现多道程序、分时操作</li>
<li>实现应用程序和操作系统（管态程序）的切换</li>
<li>……</li>
</ul>
<p>程序中断方式示意图：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210820162159261.png" alt="image-20210820162159261" style="zoom:80%;" />

<p>🚩 程序中断方式工作流程：</p>
<ol>
<li><p>中断请求</p>
<ul>
<li>中断源：请求 CPU 终端的设备或事件，一台计算机允许有多个中断源</li>
<li>内中断皆为不可屏蔽中断</li>
<li>通过 INTR 信号线发出的外中断是可屏蔽中断，通过 NMI 信号发出的是不可屏蔽中断</li>
<li>不可屏蔽中断的处理优先级最高</li>
</ul>
</li>
<li><p>中断判优</p>
<ul>
<li>硬件故障中断 &gt; 软件中断</li>
<li>不可屏蔽中断 &gt; 可屏蔽中断</li>
<li><strong>DMA 请求 &gt; IO 设备传送的中断请求</strong></li>
<li><strong>高速设备 &gt; 低速设备</strong></li>
<li><strong>输入设备 &gt; 输出设备</strong></li>
<li>实时设备 &gt; 普通设备</li>
</ul>
</li>
<li><p>CPU 响应中断的条件</p>
<ul>
<li>中断源有中断请求</li>
<li>CPU 允许中断及开中断</li>
<li>一条指令执行完毕，没有更加紧迫的任务</li>
</ul>
</li>
<li><p>中断响应 🚩</p>
<ul>
<li><p>中断隐指令：CPU 响应中断后经过一些硬件直接实现的操作后才会转去执行终端服务子程序，这些操作称为中断隐指令</p>
<p>  中断隐指令<strong>不是真正的指令</strong>（没有指令码），是一种<strong>不能为用户使用</strong>的特殊指令，包括操作：</p>
<ul>
<li>关中断</li>
<li>保存断点</li>
<li>引出中断服务子程序</li>
</ul>
</li>
</ul>
</li>
<li><p>中断向量 🚩</p>
<ul>
<li>中断向量：中断服务子程序的入口地址</li>
<li>中断向量地址：中断服务子程序入口地址的地址</li>
</ul>
</li>
<li><p>中断处理过程 🚩</p>
<ol>
<li><p>关中断</p>
</li>
<li><p>保存断点</p>
</li>
<li><p>引出中断服务程序</p>
<p> 有两种方法寻址中断服务程序入口地址：硬件向量法、软件查询法</p>
<ul>
<li><p>硬件向量法：通过硬件产生中断向量地址，再由中断向量地址找到中断服务程序的入口地址</p>
<p>  （实际上产生的是中断类型号，而中断类信号指出中断向量存放的地址）</p>
</li>
<li><p>软件查询法：用软件编程的方法寻找入口地址</p>
</li>
</ul>
</li>
<li><p>保存现场和屏蔽字</p>
<ul>
<li><strong>现场是指用户可见的工作寄存器内容</strong></li>
<li><strong>现场和断点</strong><ul>
<li>现场信息因为用指令可以直接访问，所以通常在中断服务程序中通过指令把他们保存到栈中，<strong>由软件实现</strong></li>
<li>断点信息由 CPU 中断响应开始时自动保存到栈或专门寄存器中，<strong>由硬件实现</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>开中断</p>
<p> 实现中断嵌套</p>
</li>
<li><p>执行中断服务程序</p>
</li>
<li><p>关中断</p>
</li>
<li><p>恢复现场和屏蔽字</p>
</li>
<li><p>开中断、中断返回</p>
</li>
</ol>
 <img src="【考研】计算机组成原理知识点梳理/image-20210820165223815.png" alt="image-20210820165223815" style="zoom:80%;" />

<p> 多重中断和中断屏蔽技术</p>
<ul>
<li><p>中断屏蔽技术：主要用于多重中断</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210820170803256.png" alt="image-20210820170803256" style="zoom:80%;" />
</li>
<li><p>实现多重中断必须满足：</p>
<ul>
<li>在中断服务程序中提前设置开中断</li>
<li>优先级别高的中断源有权中断优先级别低的中断源</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h4></blockquote>
<p><strong>1. 概述</strong></p>
<p>采用 DMA 方式时，DMA 控制器获得总线的控制权后 DMA 控制器负责数据传输，而 CPU 可以干自己的事情去，<strong>是一种完全由硬件进行成组信息传送的控制方式，CPU 与外设并行工作</strong></p>
<p>由于数据不经过 CPU，也就<strong>不需要繁琐的保护、恢复现场等操作</strong>，适用于磁盘机、磁带机等高速设备大批量数据传送</p>
<p>在 DMA 方式中，<strong>中断的作用仅限于故障和正常传送结束时的处理</strong></p>
<p><strong>2. DMA 方式的特点</strong></p>
<ul>
<li><p><strong>IO 与主机并行工作，程序和传送并行工作</strong></p>
</li>
<li><p>主存既可以被 CPU 访问，也可以被外设访问</p>
</li>
<li><p>主存地址的确定、传送数据的计数等都是<strong>由硬件电路直接实现</strong></p>
</li>
<li><p>主存中要开辟专用的缓冲区</p>
</li>
<li><p>传送前要通过程序进行<strong>预处理</strong>，结束后要通过中断方式进行<strong>后处理</strong></p>
</li>
</ul>
<p><strong>3. DMA 控制器的组成</strong></p>
<p>DMA 方式中对数据传送进行控制的硬件称为 <strong>DMA控制器</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210820172357474.png" alt="image-20210820172357474" style="zoom:80%;" />

<p>在 DMA 传送过程中，DMA 控制器接管 CPU 的数据、地址、控制总线，CPU 的主存控制信号被禁用</p>
<p><strong>3. DMA 传送方式</strong></p>
<ol>
<li><p>停止 CPU 访存：使 CPU 脱离总线，停止访问主存</p>
</li>
<li><p>周期挪用（周期窃取）：CPU 暂时放弃总线占用权，让 IO 线访存，结束后再释放总线给 CPU</p>
<ul>
<li>IO 访存优先级高于 CPU 访存优先级，因为 IO 不立即访存可能就会丢失数据</li>
<li>IO 设备挪用 CPU 几个存取周期，传送玩一个数据后立即释放总线，是一种单字传送方式</li>
</ul>
</li>
<li><p>DMA 与 CPU 交替访存</p>
<p> 前半周期 DMA 访存，后半周 CPU 访存</p>
</li>
</ol>
<p><strong>4. DMA 传送过程</strong></p>
<ol>
<li><p>预处理</p>
<p> CPU 测试 IO 设备状态，设置一些 DMA 控制器有关寄存器的参数。IO 准备好后，<strong>IO 向 DMA 控制器发送 DMA 请求</strong>，由 <strong>DMA 控制器向 CPU 发送总线使用请求</strong></p>
</li>
<li><p>数据传送</p>
<p> 可以以<strong>字&#x2F;字节</strong>为基本单位，也可以以<strong>数据块</strong>为基本单位。数据传送阶段完全由 DMA 控制器控制</p>
</li>
<li><p>后处理</p>
<p> DMA 控制器向 CPU 发送中断请求，CPU 校验数据传送是否出错等</p>
</li>
</ol>
<blockquote>
<p>DMA 方式与中断方式区别</p>
</blockquote>
<ol>
<li><p>中断方式程序切换时需要<strong>保护和恢复现场</strong></p>
<p> DMA 方式除了预处理和后处理，其他时候不占用 CPU 任何资源</p>
</li>
<li><p>中断请求的响应只能发生在每条指令执行完毕时</p>
<p> <strong>DMA 请求的响应可以发生在每个机器周期（总线事务）结束时（取指、间指、执行周期之后都可）</strong></p>
</li>
<li><p><strong>DMA 请求优先级高于中断请求优先级</strong></p>
</li>
<li><p>中断方式可以处理异常事件</p>
<p> DMA 方式仅仅用来传送数据块</p>
</li>
<li><p>从数据传送来看，中断方式靠程序传送</p>
<p> DMA 方式靠硬件传送</p>
</li>
</ol>
<blockquote>
<p>Note：</p>
<ol>
<li><p>CPU 响应中断的时间是每条<strong>指令执行阶段的结束时刻</strong></p>
</li>
<li><p>DMA 请求：设备控制器发出</p>
<p> 总线使用请求：DMA控制器发出</p>
</li>
<li><p>只有具有 DMA 接口的设备才能产生 DMA 请求</p>
</li>
<li><p>中断响应优先级由高到低：访管 &gt; 程序性 &gt; 重新启动</p>
</li>
<li><p>**机器校验中断是主存故障引起的中断 **</p>
</li>
<li><p>中断屏蔽标志可以改变：多个中断服务程序执行完的持续</p>
</li>
<li><p>中断方式特点：CPU 与外设并行工作，传送与主程序串行工作</p>
<p> DMA 方式特点：CPU 与外设并行工作，传送与主程序并行工作</p>
</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/" data-id="cleqef3wf00dfogjo14pmcdt3" data-title="【考研】计算机组成原理知识点梳理" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【考研】数据结构知识点总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.722Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%80%83%E7%A0%94/">考研</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">【考研】数据结构知识点总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><ol>
<li><p><code>节点数 n = 所有节点度（degree） + 1</code></p>
</li>
<li><p>二叉树中：<code>n = n0 + n1 + n2</code></p>
</li>
<li><p><code>n2 = n0 + 1</code></p>
</li>
<li><p>树的路径长度：树根到每个节点的路径长度的总和</p>
</li>
<li><p>中序遍历 + 前序&#x2F;后序&#x2F;层序  ——》 构建一颗树</p>
</li>
<li><p>n 个节点二叉树的空指针域个数：<code>n + 1</code></p>
</li>
<li><p><strong>前序遍历</strong>结果与<strong>中序遍历</strong>结果<strong>相同</strong>：非叶子节点<strong>只有右子树</strong></p>
<p> <strong>前序遍历</strong>结果与<strong>后序遍历</strong>结果<strong>相反</strong>：高度等于节点数（所有节点度为 1）</p>
</li>
<li><p>树的<strong>先根遍历</strong>与二叉树（森林）的<strong>先序遍历</strong>结果相同</p>
<p> 树的<strong>后根遍历</strong>与二叉树（森林）的<strong>中序遍历</strong>结果相同</p>
</li>
<li><p>平衡二叉树调整不平衡</p>
<ul>
<li>LL：右旋</li>
<li>RR：左旋</li>
<li>LR：左旋、右旋</li>
<li>RL：右旋、左旋</li>
</ul>
</li>
<li><p>高为 h 的平衡二叉树最少有几个节点：<br>$$<br>h_n &#x3D; h_(n-1) + h_(n-2) + 1<br>$$</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" data-id="cleqef3vu008sogjo63tz46qr" data-title="【考研】数据结构知识点总结" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【机器学习飞速入门】" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.718Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/">【机器学习光速入门】</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在正式开始做 “异常新闻检测” 的科研训练之前，需要机器学习、深度学习有一定基础</p>
<p>为此，打算先做一个快速入门，在对所学知识有一定了解之后，再回头补一些基础的理论性较强的知识</p>
<p>该笔记作于 《2018年3天快速入门python机器学习【黑马程序员】》的观看学习过程中</p>
<h1 id="一、特征工程"><a href="#一、特征工程" class="headerlink" title="一、特征工程"></a>一、特征工程</h1><h3 id="0-梗概"><a href="#0-梗概" class="headerlink" title="0. 梗概"></a>0. 梗概</h3><img src="【机器学习飞速入门】/image-20200718165205103.png" alt="image-20200718165205103"  />

<img src="【机器学习飞速入门】/image-20200718165144638.png" alt="image-20200718165144638"  />



<h3 id="1-sklearn"><a href="#1-sklearn" class="headerlink" title="1. sklearn"></a>1. sklearn</h3><p>Scikit learn 也简称 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://scikit-learn.org/stable/">sklearn</a>, 是机器学习领域当中最知名的 python 模块之一。</p>
<ul>
<li>简单高效的数据挖掘和数据分析工具</li>
<li>可供大家在各种环境中重复使用</li>
<li>建立在 NumPy ，SciPy 和 matplotlib 上</li>
<li>开源，可商业使用 - BSD许可证</li>
</ul>
<blockquote>
<p><code>Scikit-learn</code> is an open source machine learning library that supports supervised and unsupervised learning. It also provides various tools for model fitting, data preprocessing, model selection and evaluation, and many other utilities.</p>
</blockquote>
<p>sklearn包含的内容：</p>
<ul>
<li><p>Classification 分类</p>
</li>
<li><p>Regression 回归</p>
</li>
<li><p>Clustering 非监督分类</p>
</li>
<li><p>Dimensionality reduction 数据降维</p>
</li>
<li><p>Model Selection 模型选择</p>
</li>
<li><p>Preprocessing 数据预处理</p>
</li>
</ul>
<img src="【机器学习飞速入门】/image-20200715172312712.png" alt="image-20200715172312712" style="zoom:67%;" />



<h3 id="2-数据集"><a href="#2-数据集" class="headerlink" title="2. 数据集"></a>2. 数据集</h3><p>sklearn 提供了用来学习的多种数据集：</p>
<ul>
<li>自带的小数据集（packaged dataset）：sklearn.datasets.load_<name></li>
<li>可在线下载的数据集（Downloaded Dataset）：sklearn.datasets.fetch_<name></li>
<li>计算机生成的数据集（Generated Dataset）：sklearn.datasets.make_<name></li>
<li>svmlight&#x2F;libsvm格式的数据集:sklearn.datasets.load_svmlight_file(…)</li>
<li>从买了data.org在线下载获取的数据集:sklearn.datasets.fetch_mldata(…)</li>
</ul>
<p>数据集返回结果：</p>
<img src="【机器学习飞速入门】/image-20200715173156243.png" alt="image-20200715173156243" style="zoom:67%;" />



<p>以自带的小数据集 <strong>鸢尾花数据集</strong> 为例演示数据集的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datasets_demo</span>():</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸢尾花数据集:\n&quot;</span>,iris)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看数据集描述:\n&quot;</span>,iris[<span class="string">&quot;DESCR&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值的名字:\n&quot;</span>,iris.feature_names)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值:\n&quot;</span>,iris.data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值形状:\n&quot;</span>,iris.data.shape)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    datasets_demo()</span><br></pre></td></tr></table></figure>

<p><strong>这里要注意不要把所有的数据集都拿来训练一个模型，还一个留一部分用来验证，于是有了数据集的划分</strong></p>
<p>数据集划分：</p>
<ul>
<li><p>机器学习一般的数据集会划分为两个部分：<strong>训练数据、测试数据</strong></p>
</li>
<li><p>划分比例：</p>
<ul>
<li>训练集：70%  80% 75%</li>
<li>测试集：30%  20% 30%</li>
</ul>
</li>
</ul>
<img src="【机器学习飞速入门】/image-20200715175248929.png" alt="image-20200715175248929" style="zoom:67%;" />



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets  <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datasets_demo</span>():</span><br><span class="line">    <span class="comment">#获取数据集</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸢尾花数据集:\n&quot;</span>,iris)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看数据集描述:\n&quot;</span>,iris[<span class="string">&quot;DESCR&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值的名字:\n&quot;</span>,iris.feature_names)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值:\n&quot;</span>,iris.data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值形状:\n&quot;</span>,iris.data.shape)</span><br><span class="line">    <span class="comment">#数据集的划分</span></span><br><span class="line">    x_train,x_test,y_train,y_test = train_test_split(iris.data,iris.target,test_size=<span class="number">0.2</span>,random_state=<span class="number">22</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练集的特征值:\n&quot;</span>,x_train,x_train.shape)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试集的特征值:\n&quot;</span>,x_test,x_test.shape)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    datasets_demo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-特征工程简介"><a href="#3-特征工程简介" class="headerlink" title="3. 特征工程简介"></a>3. 特征工程简介</h3><p>业界广泛流传：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</p>
<p>特征工程是使用<strong>专业背景知识和技巧处理数据</strong>，<strong>使得特征能在机器学习算法上发挥更好的作用的过程</strong>，<strong>会直接影响机器学习效果。</strong></p>
<p>特征工程内容：</p>
<ul>
<li>特征抽取</li>
<li>特征预处理</li>
<li>特征降维</li>
</ul>
<h3 id="4-特征抽取"><a href="#4-特征抽取" class="headerlink" title="4. 特征抽取"></a>4. 特征抽取</h3><p>特征抽取：将任意数据（文本或图像）转化为用于机器学习的数字特征</p>
<p>分类：</p>
<ul>
<li>字典特征抽取（特征离散化）</li>
<li>文本特征抽取</li>
<li>图像特征抽取（深度学习中使用）</li>
</ul>
<p>使用的 API ：<code>sklearn.feature_extraction</code></p>
<h4 id="1）字典特征提取"><a href="#1）字典特征提取" class="headerlink" title="1）字典特征提取"></a>1）字典特征提取</h4><p>简介：</p>
<img src="【机器学习飞速入门】/image-20200715180318408.png" alt="image-20200715180318408" style="zoom:67%;" />

<p>实例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dict_demo</span>():</span><br><span class="line">    data = [&#123;<span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;temperature&#x27;</span>:<span class="number">100</span>&#125;,&#123;<span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;temperature&#x27;</span>:<span class="number">60</span>&#125;,&#123;<span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;深圳&#x27;</span>,<span class="string">&#x27;temperature&#x27;</span>:<span class="number">30</span>&#125;]</span><br><span class="line">    <span class="comment">#实例一个转换器类</span></span><br><span class="line">    transfer = DictVectorizer(sparse=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment">#调用fit_transform（）</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new:\n&quot;</span>,data_new)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;特征名称:\n&quot;</span>,transfer.get_feature_names())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dict_demo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li><p><code>sparse = False</code>：</p>
  <img src="【机器学习飞速入门】/image-20200715180612908.png" alt="image-20200715180612908" style="zoom:67%;" />
</li>
<li><p><code>sparse = True</code>：</p>
  <img src="【机器学习飞速入门】/image-20200715180641344.png" alt="image-20200715180641344" style="zoom:67%;" /></li>
</ul>
<h4 id="2）文本特征提取"><a href="#2）文本特征提取" class="headerlink" title="2）文本特征提取"></a>2）文本特征提取</h4><p>简介：</p>
<img src="【机器学习飞速入门】/image-20200715180752889.png" alt="image-20200715180752889" style="zoom:67%;" />

<h5 id="英文文本分词："><a href="#英文文本分词：" class="headerlink" title="英文文本分词："></a>英文文本分词：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_demo</span>():</span><br><span class="line">    data = &#123;<span class="string">&quot;Life is short,i like like python&quot;</span>,<span class="string">&quot;Life is too long,i dislike python&quot;</span>&#125;</span><br><span class="line">    <span class="comment">#实例化一个转化器</span></span><br><span class="line">    transfer = CountVectorizer()</span><br><span class="line">    <span class="comment">#调用transform</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new:\n&quot;</span>,data_new.toarray())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    count_demo()</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200715180925250.png" alt="image-20200715180925250"></p>
<h5 id="中文文本分词："><a href="#中文文本分词：" class="headerlink" title="中文文本分词："></a>中文文本分词：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_word</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="built_in">list</span>(jieba.cut(text)))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_chinese_demo</span>():</span><br><span class="line">    data = [<span class="string">&quot;在北上广深，软考证书可以混个工作居住证，也是一项大的积分落户筹码。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;升职加薪必备，很多企业人力资源会以此作为审核晋升的条件。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;简历上浓彩重抹一笔，毕竟是国家人力部、工信部承认的IT高级人才。&quot;</span>]</span><br><span class="line">    data_new=[]</span><br><span class="line">    <span class="keyword">for</span> sent <span class="keyword">in</span> data:</span><br><span class="line">        data_new.append(cut_word(sent))</span><br><span class="line">    <span class="comment">#实例化一个转化器</span></span><br><span class="line">    transfer = CountVectorizer()</span><br><span class="line">    <span class="comment">#调用transform</span></span><br><span class="line">    data_final = transfer.fit_transform(data_new)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;转化后结果:\n&quot;</span>,data_final.toarray())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;特征名字:\n&quot;</span>,transfer.get_feature_names())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    count_chinese_demo()</span><br></pre></td></tr></table></figure>

<img src="【机器学习飞速入门】/image-20200715181700533.png" alt="image-20200715181700533" style="zoom:67%;" />



<p>上述方法会出现一些 “可以”、“很多” 等与主题无关紧要的特征，会印象我们对结果的判断，不够完善，此时我们引入 <strong>Tf-idf 文本特征提取</strong>方法 </p>
<h5 id="Tf-idf-文本特征提取："><a href="#Tf-idf-文本特征提取：" class="headerlink" title="Tf-idf 文本特征提取："></a>Tf-idf 文本特征提取：</h5><p>简介：</p>
<ul>
<li><p>TF-IDF的主要思想是:如果某个词或短语在一篇文章中出现的概率高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。</p>
</li>
<li><p>TF-IDF作用:用以评估-字词对于一个文件集或一个语料库中的其中一份文件的重要程度。</p>
</li>
</ul>
<img src="【机器学习飞速入门】/image-20200715182239136.png" alt="image-20200715182239136" style="zoom:67%;" />

<p>api：</p>
<img src="【机器学习飞速入门】/image-20200715182310569.png" alt="image-20200715182310569" style="zoom:67%;" />

<p>使用方法与上面提到的中文文本分词方法大体一致，只是将转换器换为：<code>TfidfVectorizer()</code></p>
<h3 id="5-特征预处理"><a href="#5-特征预处理" class="headerlink" title="5. 特征预处理"></a>5. 特征预处理</h3><img src="【机器学习飞速入门】/image-20200715182740495.png" alt="image-20200715182740495" style="zoom:67%;" />

<p><strong>特征预处理</strong>就是通过一些转化函数将特征数据转换成<strong>更加适合算法模型的特征数据过程</strong>（<strong>无量纲化</strong>处理）</p>
<p>特征的单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级，容易影响(支配)目标结果，使得一些算法无法学习到其它的特征</p>
<p>包括内容：归一化、标准化</p>
<p>使用的 api ：<code>sklearn.preprocessing</code></p>
<h4 id="1）归一化"><a href="#1）归一化" class="headerlink" title="1）归一化"></a>1）归一化</h4><p>通过对原始数据进行变换把数据映射到(默认为[0,1])之间</p>
<img src="【机器学习飞速入门】/image-20200715183155497.png" alt="image-20200715183155497" style="zoom:67%;" />

<p>api：</p>
<img src="【机器学习飞速入门】/image-20200715183210002.png" alt="image-20200715183210002" style="zoom:67%;" />

<p>实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minmax_demo</span>():</span><br><span class="line">    data = pd.read_csv(<span class="string">&quot;dating.txt&quot;</span>)</span><br><span class="line">    data = data.iloc[:,:<span class="number">3</span>]  <span class="comment">#只取数据前三列</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data=\n&quot;</span>,data)</span><br><span class="line">    transfer = MinMaxScaler() <span class="comment">#默认0-1</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new=\n&quot;</span>,data_new)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    minmax_demo()</span><br></pre></td></tr></table></figure>

<img src="【机器学习飞速入门】/image-20200715183245714.png" alt="image-20200715183245714" style="zoom:67%;" />

<p>归一化鲁棒性（最大值最小值容易受异常点影响）较差，<strong>只适合传统精确小数据场景</strong></p>
<h4 id="2）标准化"><a href="#2）标准化" class="headerlink" title="2）标准化"></a>2）标准化</h4><img src="【机器学习飞速入门】/image-20200715183530348.png" alt="image-20200715183530348" style="zoom:67%;" />

<p>api：</p>
<img src="【机器学习飞速入门】/image-20200715183605810.png" alt="image-20200715183605810" style="zoom:67%;" />

<p>使用方法与上面提到的<strong>归一化</strong>方法大体一致，只是将转换器换为：<code>StandardScaler()</code></p>
<h3 id="6-特征降维"><a href="#6-特征降维" class="headerlink" title="6. 特征降维"></a>6. 特征降维</h3><img src="【机器学习飞速入门】/image-20200715183831598.png" alt="image-20200715183831598" style="zoom:67%;" />

<p>降维两种方式：</p>
<ul>
<li>特征选择</li>
<li>主成分分析</li>
</ul>
<h4 id="1）特征选择"><a href="#1）特征选择" class="headerlink" title="1）特征选择"></a>1）特征选择</h4><p>数据中包含<strong>冗余或相关变量</strong>(或称特征、属性、指标等)，旨在从原有特征中找出<strong>主要特征</strong>。</p>
<p>方法：</p>
<img src="【机器学习飞速入门】/image-20200715184212364.png" alt="image-20200715184212364" style="zoom:67%;" />

<p>使用的模块： <code>sklearn-feature.selection</code></p>
<h5 id="低方差特征过滤"><a href="#低方差特征过滤" class="headerlink" title="低方差特征过滤"></a>低方差特征过滤</h5><p>删除低方差（衡量随机变量或一组数据时<strong>离散程度的度量</strong>，低方差说明数据相近）一些特征。</p>
<p>api：</p>
<img src="【机器学习飞速入门】/image-20200716162726579.png" alt="image-20200716162726579" style="zoom:67%;" />

<h5 id="高相关系数过滤"><a href="#高相关系数过滤" class="headerlink" title="高相关系数过滤"></a>高相关系数过滤</h5><p>相关关系是一种非确定性的关系，相关系数是研究变量之间<strong>线性相关</strong>程度的量。</p>
<img src="【机器学习飞速入门】/image-20200716163333534.png" alt="image-20200716163333534" style="zoom: 33%;" />

 <img src="【机器学习飞速入门】/image-20200716163349396.png" alt="image-20200716163349396" style="zoom:67%;" />

<p>api：</p>
<img src="【机器学习飞速入门】/image-20200716163534685.png" alt="image-20200716163534685" style="zoom:67%;" />



<img src="【机器学习飞速入门】/image-20200716163616901.png" alt="image-20200716163616901" style="zoom:67%;" />



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码总结</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">variance_demo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    过滤低方差特征</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1、获取数据</span></span><br><span class="line">    data = pd.read_csv(<span class="string">&quot;factor_returns.csv&quot;</span>)</span><br><span class="line">    data = data.iloc[:, <span class="number">1</span>:-<span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data:\n&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、实例化一个转换器类</span></span><br><span class="line">    transfer = VarianceThreshold(threshold=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3、调用fit_transform</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new:\n&quot;</span>, data_new, data_new.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算某两个变量之间的相关系数</span></span><br><span class="line">    r1 = pearsonr(data[<span class="string">&quot;pe_ratio&quot;</span>], data[<span class="string">&quot;pb_ratio&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;相关系数：\n&quot;</span>, r1)</span><br><span class="line">    r2 = pearsonr(data[<span class="string">&#x27;revenue&#x27;</span>], data[<span class="string">&#x27;total_expense&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;revenue与total_expense之间的相关性：\n&quot;</span>, r2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h4 id="2）-主成分分析（PCA）"><a href="#2）-主成分分析（PCA）" class="headerlink" title="2） 主成分分析（PCA）"></a>2） 主成分分析（PCA）</h4><ul>
<li><p>定义：<strong>高维数据转化为低维数据的过程</strong>，在此过程中可能会舍弃原有数据、创造新的变量。</p>
</li>
<li><p>作用：尽可能<strong>降低原数据的维数</strong>，同时尽量<strong>保证数据损失较少</strong>。</p>
</li>
<li><p>简单示例：</p>
<ol>
<li>三维物体的二维特征</li>
</ol>
<p>  <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200718164344152.png" alt="image-20200718164344152"></p>
<ol start="2">
<li><p>将给定一组坐标降维</p>
 <img src="【机器学习飞速入门】/image-20200718164455771.png" alt="image-20200718164455771" style="zoom:67%;" />

 <img src="【机器学习飞速入门】/image-20200718164514052.png" alt="image-20200718164514052" style="zoom:67%;" />

 <img src="【机器学习飞速入门】/image-20200718164540852.png" alt="image-20200718164540852" style="zoom:67%;" /></li>
</ol>
</li>
</ul>
<p>​															<img src="【机器学习飞速入门】/image-20200718164554187.png" alt="image-20200718164554187" style="zoom:67%;" /></p>
<ul>
<li><p>API</p>
  <img src="【机器学习飞速入门】/image-20200718164644648.png" alt="image-20200718164644648" style="zoom:67%;" />
</li>
<li><p>实例：</p>
  <img src="【机器学习飞速入门】/image-20200718164725784.png" alt="image-20200718164725784" style="zoom:67%;" />

  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition  <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pca_demo</span>():</span><br><span class="line">    data = [[<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">8</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>]]</span><br><span class="line">    transfer = PCA(n_components=<span class="number">2</span>) <span class="comment">#降维成两个特征</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new:\n&quot;</span>,data_new)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pca_demo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200718164750676.png" alt="image-20200718164750676"></p>
<p>  成功将四维坐标降为二维！</p>
</li>
</ul>
<h1 id="二、分类算法"><a href="#二、分类算法" class="headerlink" title="二、分类算法"></a>二、分类算法</h1><h3 id="0-梗概-1"><a href="#0-梗概-1" class="headerlink" title="0. 梗概"></a>0. 梗概</h3><p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721173457106.png" alt="image-20200721173457106"></p>
<h3 id="1-转换器和估计器"><a href="#1-转换器和估计器" class="headerlink" title="1. 转换器和估计器"></a>1. 转换器和估计器</h3><h4 id="1）转换器"><a href="#1）转换器" class="headerlink" title="1）转换器"></a>1）转换器</h4><p>​	我们把<strong>特征工程的接口</strong>称为转换器</p>
<p>转换器的调用方法：</p>
<ul>
<li><code>fit_transform</code>：<code>fit</code> 和 <code>transform</code> 的结合</li>
<li><code>fit</code>：计算每一列的平均值和标准差</li>
<li><code>transform</code>：<code>(x - mean) / std</code>（进行最终的计算）</li>
</ul>
<h4 id="2）估计器"><a href="#2）估计器" class="headerlink" title="2）估计器"></a>2）估计器</h4><p>估计器是一类<strong>实现了算法的 API</strong></p>
<ol>
<li><p>用于<strong>分类</strong>的估计器</p>
<ul>
<li>sklearn.neighbors    K-近邻算法</li>
<li>sklearn.naive_bayes    朴素贝叶斯  </li>
<li>sklearn.linear_model.LogisticRegression    逻辑回归</li>
<li>sklearn.tree    决策树和随机森林</li>
</ul>
</li>
<li><p>用于<strong>回归</strong>的估计器</p>
<ul>
<li><p>sklearn.linear_model.LinearRegression    线性回归</p>
</li>
<li><p>sklearn.linear_model.Ridge    岭回归</p>
</li>
</ul>
</li>
<li><p>用于<strong>无监督学习</strong>的估计器</p>
<ul>
<li>sklearn.cluster.KMeans    聚类</li>
</ul>
</li>
</ol>
<p>估计器工作流程：</p>
<img src="【机器学习飞速入门】/image-20200721164812435.png" alt="image-20200721164812435" style="zoom:67%;" />





<h3 id="2-K-近邻算法（KNN-算法）"><a href="#2-K-近邻算法（KNN-算法）" class="headerlink" title="2. K-近邻算法（KNN 算法）"></a>2. K-近邻算法（KNN 算法）</h3><p>核心思想：<strong>根据你的邻居来判断你的类别！</strong></p>
<p>给定一个训练集，对新输入的实例，在训练集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，我们就把该输入实例分为这个类。</p>
<img src="【机器学习飞速入门】/image-20200721165450099.png" alt="image-20200721165450099" style="zoom:67%;" />

<p>基本要素：</p>
<ul>
<li>距离度量方法<ul>
<li>欧氏距离	<img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721165649451.png" alt="image-20200721165649451"></li>
<li>曼哈顿距离    <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721165701626.png" alt="image-20200721165701626"></li>
<li>闵可夫斯基距离    <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721165755462.png" alt="image-20200721165755462"></li>
</ul>
</li>
<li>K值<ul>
<li>过小：容易受到异常数据的影响</li>
<li>过大：容易受到样本不均衡的影响</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span>  train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span>  StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">案例：使用 KNN 算法对鸢尾花集进行分类</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knn_iris</span>():</span><br><span class="line">    <span class="comment"># 1.获取数据</span></span><br><span class="line">    iris  = load_iris()</span><br><span class="line">    <span class="comment"># 2.划分数据集</span></span><br><span class="line">    x_train,x_test,y_train,y_test = train_test_split(iris.data,iris.target,random_state=<span class="number">22</span>)</span><br><span class="line">    <span class="comment"># 3.特征工程:标准化</span></span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.fit_transform(x_test)</span><br><span class="line">    <span class="comment"># 4.KNN算法预估器</span></span><br><span class="line">    estimator = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">    estimator.fit(x_train,y_train)</span><br><span class="line">    <span class="comment"># 5.模型评估</span></span><br><span class="line">    <span class="comment">#方法1：直接比对真实值和预测值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_predict:\n&quot;</span>,y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值:\n&quot;</span>,y_test == y_predict)</span><br><span class="line">    <span class="comment">#方法2:计算准确率</span></span><br><span class="line">    score = estimator.score(x_test,y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准确率为:\n&quot;</span>,score)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    knn_iris()</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721171101873.png" alt="image-20200721171101873"></p>
<h3 id="3-朴素贝叶斯算法"><a href="#3-朴素贝叶斯算法" class="headerlink" title="3. 朴素贝叶斯算法"></a>3. 朴素贝叶斯算法</h3><h4 id="1）贝叶斯公式"><a href="#1）贝叶斯公式" class="headerlink" title="1）贝叶斯公式"></a>1）贝叶斯公式</h4><p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721170331093.png" alt="image-20200721170331093"></p>
<ul>
<li>W：给定文档的特征值</li>
<li>C：文档类别</li>
</ul>
<h4 id="2）拉普拉斯平滑系数"><a href="#2）拉普拉斯平滑系数" class="headerlink" title="2）拉普拉斯平滑系数"></a>2）拉普拉斯平滑系数</h4><p>目的：防止计算出的分类概率为0</p>
<img src="【机器学习飞速入门】/image-20200721170612675.png" alt="image-20200721170612675" style="zoom:67%;" />

<h4 id="3）朴素贝叶斯"><a href="#3）朴素贝叶斯" class="headerlink" title="3）朴素贝叶斯"></a>3）朴素贝叶斯</h4><ul>
<li>朴素：假定各个事件相互独立</li>
<li>贝叶斯：贝叶斯公式</li>
</ul>
<p>API ：<code>sklearn.naive_bayes.MultinomialNB(alpha = 1.0)</code></p>
<ul>
<li>朴素贝叶斯分类</li>
<li>alpha：拉普拉斯平滑系数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_20newsgroups</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用朴素贝叶斯算法对新闻进行分类</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nb_news</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1）获取数据</span></span><br><span class="line">    news = fetch_20newsgroups(subset=<span class="string">&quot;all&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2）划分数据集</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(news.data, news.target)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3）特征工程：文本特征抽取-tfidf</span></span><br><span class="line">    transfer = TfidfVectorizer()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.transform(x_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4）朴素贝叶斯算法预估器流程</span></span><br><span class="line">    estimator = MultinomialNB()</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5）模型评估</span></span><br><span class="line">    <span class="comment"># 方法1：直接比对真实值和预测值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_predict:\n&quot;</span>, y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值:\n&quot;</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法2：计算准确率</span></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准确率为：\n&quot;</span>, score)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nb_news()</span><br></pre></td></tr></table></figure>

<img src="【机器学习飞速入门】/image-20200721172243905.png" alt="image-20200721172243905" style="zoom: 80%;" />



<h3 id="4-决策树"><a href="#4-决策树" class="headerlink" title="4. 决策树"></a>4. 决策树</h3><img src="【机器学习飞速入门】/image-20200721172449868.png" alt="image-20200721172449868" style="zoom:67%;" />

<p>上图是一棵结构简单的决策树，用于预测贷款用户是否具有偿还贷款的能力。贷款用户主要具备三个属性：是否拥有房产，是否结婚，平均月收入。每一个内部节点都表示一个属性条件判断，叶子节点表示贷款用户是否具有偿还能力。例如：用户甲没有房产，没有结婚，月收入 5K。通过决策树的根节点判断，用户甲符合右边分支 (拥有房产为”否”)；再判断是否结婚，用户甲符合左边分支 (是否结婚为否)；然后判断月收入是否大于 4k，用户甲符合左边分支 (月收入大于 4K)，该用户落在”可以偿还”的叶子节点上。所以预测用户甲具备偿还贷款能力。</p>
<p><strong>通过信息增益找到最⾼效的决策顺序。</strong></p>
<p>API：</p>
<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721172921450.png" alt="image-20200721172921450"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, export_graphviz</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用决策树对鸢尾花进行分类</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decision_iris</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1）获取数据集</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2）划分数据集</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3）决策树预估器</span></span><br><span class="line">    estimator = DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4）模型评估</span></span><br><span class="line">    <span class="comment"># 方法1：直接比对真实值和预测值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_predict:\n&quot;</span>, y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值:\n&quot;</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法2：计算准确率</span></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准确率为：\n&quot;</span>, score)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可视化决策树</span></span><br><span class="line">    export_graphviz(estimator, out_file=<span class="string">&quot;iris_tree.dot&quot;</span>, feature_names=iris.feature_names)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    decision_iris()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721173119603.png" alt="image-20200721173119603"></p>
<h3 id="5-随机森林"><a href="#5-随机森林" class="headerlink" title="5. 随机森林"></a>5. 随机森林</h3><img src="【机器学习飞速入门】/image-20200721173201773.png" alt="image-20200721173201773" style="zoom:67%;" />

<p>API：</p>
<img src="【机器学习飞速入门】/image-20200721173217939.png" alt="image-20200721173217939" style="zoom:67%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用随机森林实现泰坦尼克号实例</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randomForest_demo</span>():</span><br><span class="line">    <span class="comment"># 1、获取数据</span></span><br><span class="line">    path = <span class="string">&quot;http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic.txt&quot;</span></span><br><span class="line">    titanic = pd.read_csv(path)</span><br><span class="line">    <span class="comment"># 筛选特征值和目标值</span></span><br><span class="line">    x = titanic[[<span class="string">&quot;pclass&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>]]</span><br><span class="line">    y = titanic[<span class="string">&quot;survived&quot;</span>]</span><br><span class="line">    <span class="comment"># 2、数据处理</span></span><br><span class="line">    <span class="comment"># 1）缺失值处理</span></span><br><span class="line">    x[<span class="string">&quot;age&quot;</span>].fillna(x[<span class="string">&quot;age&quot;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 2) 转换成字典</span></span><br><span class="line">    x = x.to_dict(orient=<span class="string">&quot;records&quot;</span>)</span><br><span class="line">    <span class="comment"># 3、数据集划分</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">22</span>)</span><br><span class="line">    <span class="comment"># 4、字典特征抽取</span></span><br><span class="line">    transfer = DictVectorizer()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.transform(x_test)</span><br><span class="line">    <span class="comment">#随机森林预估器</span></span><br><span class="line">    estimator = RandomForestClassifier()</span><br><span class="line">    <span class="comment"># 加入网格搜索与交叉验证</span></span><br><span class="line">    <span class="comment"># 参数准备</span></span><br><span class="line">    param_dict = &#123;<span class="string">&quot;n_estimators&quot;</span>: [<span class="number">120</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">800</span>, <span class="number">1200</span>], <span class="string">&quot;max_depth&quot;</span>: [<span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">30</span>]&#125;</span><br><span class="line">    estimator = GridSearchCV(estimator, param_grid=param_dict, cv=<span class="number">3</span>)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5）模型评估</span></span><br><span class="line">    <span class="comment"># 方法1：直接比对真实值和预测值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_predict:\n&quot;</span>, y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值:\n&quot;</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法2：计算准确率</span></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准确率为：\n&quot;</span>, score)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最佳参数：best_params_</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最佳参数：\n&quot;</span>, estimator.best_params_)</span><br><span class="line">    <span class="comment"># 最佳结果：best_score_</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最佳结果：\n&quot;</span>, estimator.best_score_)</span><br><span class="line">    <span class="comment"># 最佳估计器：best_estimator_</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最佳估计器:\n&quot;</span>, estimator.best_estimator_)</span><br><span class="line">    <span class="comment"># 交叉验证结果：cv_results_</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;交叉验证结果:\n&quot;</span>, estimator.cv_results_)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    randomForest_demo()</span><br></pre></td></tr></table></figure>





<h1 id="三、回归与聚类算法"><a href="#三、回归与聚类算法" class="headerlink" title="三、回归与聚类算法"></a>三、回归与聚类算法</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>黑马程序员：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nt411r7tj?t=38&p=16">https://www.bilibili.com/video/BV1nt411r7tj?t=38&amp;p=16</a></li>
<li>sklearn 中文文档：<a target="_blank" rel="noopener" href="http://www.scikitlearn.com.cn/">http://www.scikitlearn.com.cn/</a></li>
<li>隔壁郑同学：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44517301/article/details/88405939">https://blog.csdn.net/weixin_44517301/article/details/88405939</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/" data-id="cleqef3we00dcogjoaexa5ola" data-title="【机器学习光速入门】" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【机器学习】异常检测：PyOD库中的算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%EF%BC%9APyOD%E5%BA%93%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.694Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%EF%BC%9APyOD%E5%BA%93%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/">【机器学习】异常检测：PyOD库中的算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一-PyOD概览"><a href="#一-PyOD概览" class="headerlink" title="一. PyOD概览"></a>一. PyOD概览</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>PyOD 是一个全面的、可扩展的 Python 工具包，用于检测多变量数据中的异常对象，是当下最流行的Python异常检测工具库。</p>
<p>这一检测过程通常被称为<strong>离群点检测或异常检测</strong>。</p>
<p>PyOD 库包含了超过 30 种异常检测算法，具体常用算法如下：</p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">缩写</th>
<th align="center">全称</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线性模式</td>
<td align="center">PCA</td>
<td align="center">Principal Component Analysis</td>
</tr>
<tr>
<td align="center">线性模型</td>
<td align="center">MCD</td>
<td align="center">Minimum Covariance Determinant</td>
</tr>
<tr>
<td align="center">线性模型</td>
<td align="center">OCSVM</td>
<td align="center">One-Class Support Vector Machines</td>
</tr>
<tr>
<td align="center">基于近邻</td>
<td align="center">LOF</td>
<td align="center">Local Outlier Factor</td>
</tr>
<tr>
<td align="center">基于近邻</td>
<td align="center">kNN</td>
<td align="center">k Nearest Neighbors</td>
</tr>
<tr>
<td align="center">基于近邻</td>
<td align="center">HBOS</td>
<td align="center">Histogram-based Outlier Score</td>
</tr>
<tr>
<td align="center">基于概率</td>
<td align="center">ABOD</td>
<td align="center">Angle-Based Outlier Detection</td>
</tr>
<tr>
<td align="center">异常集成</td>
<td align="center">IForest</td>
<td align="center">Isolation Forest</td>
</tr>
<tr>
<td align="center">异常集成</td>
<td align="center"></td>
<td align="center">Feature Bagging</td>
</tr>
</tbody></table>
<ul>
<li><strong>Github地址:</strong> <a href="https://link.zhihu.com/?target=https://github.com/yzhao062/pyod">pyod</a></li>
<li><strong>文档与API介绍（英文）</strong>: <a href="https://link.zhihu.com/?target=https://pyod.readthedocs.io/en/latest/">Welcome to PyOD documentation!</a></li>
<li><strong>Jupyter Notebook示例（notebooks文件夹）</strong>: <a href="https://link.zhihu.com/?target=https://mybinder.org/v2/gh/yzhao062/pyod/master">Binder (beta)</a></li>
</ul>
<h3 id="2-API与属性"><a href="#2-API与属性" class="headerlink" title="2. API与属性"></a>2. API与属性</h3><p>以下函数均属于包 <code>pyod.models.base.BaseDetector</code></p>
<ul>
<li><p><code>fit(X)</code>： 用数据 X 来“训练&#x2F;拟合”检测器 clf。（ 在非监督学习中，不需要 y 值）</p>
</li>
<li><p><code>decision_function(X)</code>：可以通过该函数来预测未知数据的异常程度，返回值为原始分数，分数越高，异常程度越高。</p>
</li>
<li><p><code>predict(X)</code>： 可以通过该函数来预测未知数据的异常标签，返X回值为二分类标签（0为正常点，1为异常点）</p>
</li>
<li><p><code>predict_proba()</code>：在检测器clf被fit后，预测未知数据的异常概率，返回该点是异常点概率</p>
</li>
<li><p><code>fit_predict(X)</code>： 训练模型并且预测一个特殊的样本是否是异常值</p>
</li>
<li><p><code>fit_predict_score()</code>：训练检测器，预测位置数据的异常标签，并且根据预定义的度量标准评估模型的分数</p>
</li>
<li><p><code>decision_scores_</code>：训练集的异常分数，分数越高表示异常程度越高. </p>
</li>
<li><p><code>labels_</code>：0 表示正常值，1 表示异常值</p>
</li>
</ul>
<h1 id="二、具体算法"><a href="#二、具体算法" class="headerlink" title="二、具体算法"></a>二、具体算法</h1><h3 id="1-PCA"><a href="#1-PCA" class="headerlink" title="1. PCA"></a>1. PCA</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200924092132102.png" alt="image-20200924092132102" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>PCA(Principal Component Analysis)，即<strong>主成分分析方法</strong>，是一种使用最广泛的<strong>数据降维算法</strong>。PCA 的主要思想是<strong>将 n 维特征映射到 k 维上</strong>，这 k 维是全新的正交特征也被称为主成分，是在原有 n 维特征的基础上重新构造出来的 k 维特征。PCA 的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。</p>
<p>其中，第一个新坐标轴选择是<strong>原始数据中方差最大</strong>的方向，第二个新坐标轴选取是<strong>与第一个坐标轴正交的平面中使得方差最大</strong>的，第三个轴是<strong>与第 1, 2 个轴正交的平面中方差最大</strong>的。依次类推，可以得到n个这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面 k 个坐标轴中，后面的坐标轴所含的方差几乎为 0。于是，我们可以忽略余下的坐标轴，只保留前面 k 个含有绝大部分方差的坐标轴。<strong>事实上，这相当于只保留包含绝大部分方差的维度特征，而忽略包含方差几乎为 0 的特征维度，实现对数据特征的降维处理。</strong></p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.pca <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span>  <span class="comment"># 异常值占比</span></span><br><span class="line">    n_train = <span class="number">200</span>  <span class="comment"># 训练集大小</span></span><br><span class="line">    n_test = <span class="number">100</span>  <span class="comment"># 测试集大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生产样本数据</span></span><br><span class="line">    X_train, X_test, y_train, y_test = \</span><br><span class="line">        generate_data(n_train=n_train,</span><br><span class="line">                      n_test=n_test,</span><br><span class="line">                      n_features=<span class="number">20</span>,</span><br><span class="line">                      contamination=contamination,</span><br><span class="line">                      random_state=<span class="number">42</span>,</span><br><span class="line">                      behaviour=<span class="string">&quot;new&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练 PCA 检测器</span></span><br><span class="line">    clf_name = <span class="string">&#x27;PCA&#x27;</span></span><br><span class="line">    clf = PCA(n_components=<span class="number">3</span>)</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得训练集的预测标签和异常分数</span></span><br><span class="line">    y_train_pred = clf.labels_  <span class="comment"># (0: 正常, 1: 异常)</span></span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得测试集的预测结果</span></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评估并且打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果可视化</span></span><br><span class="line">    <span class="comment"># 注意，为了实现可视化，原始维度必须是 2 维</span></span><br><span class="line">    <span class="comment"># visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span></span><br><span class="line">    <span class="comment">#           y_test_pred, show_figure=True, save_figure=False)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924100919300.png" alt="image-20200924100919300" style="zoom:80%;" />

<h3 id="2-MCD"><a href="#2-MCD" class="headerlink" title="2. MCD"></a>2. MCD</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200924101935248.png" alt="image-20200924101935248" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>一种鲁棒性很强的位置和分布估计算法，并且可以通过FAST-MCD方法高效计算。</p>
<p>具体原理可参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62146814">异常检测算法之-MCD（Minimum Covariance Determinant）</a></p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.mcd <span class="keyword">import</span> MCD</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span>  <span class="comment"># 异常值占比</span></span><br><span class="line">    n_train = <span class="number">200</span>  <span class="comment"># 训练集大小</span></span><br><span class="line">    n_test = <span class="number">100</span>  <span class="comment"># 测试集大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生产样本数据</span></span><br><span class="line">    X_train, X_test, y_train, y_test = \</span><br><span class="line">        generate_data(n_train=n_train,</span><br><span class="line">                      n_test=n_test,</span><br><span class="line">                      n_features=<span class="number">2</span>,	</span><br><span class="line">                      contamination=contamination,</span><br><span class="line">                      random_state=<span class="number">42</span>,</span><br><span class="line">                      behaviour=<span class="string">&quot;new&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练 MCD 检测器</span></span><br><span class="line">    clf_name = <span class="string">&#x27;MCD&#x27;</span></span><br><span class="line">    clf = MCD()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得训练集的预测标签和异常分数</span></span><br><span class="line">    y_train_pred = clf.labels_  <span class="comment"># (0: 正常, 1: 异常)</span></span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得测试集的预测结果</span></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评估并且打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果可视化</span></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">               y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924102617552.png" alt="image-20200924102617552" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924102750477.png" alt="image-20200924102750477" style="zoom: 50%;" />

<h3 id="3-OCSVM"><a href="#3-OCSVM" class="headerlink" title="3. OCSVM"></a>3. OCSVM</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200924102911438.png" alt="image-20200924102911438" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>是对 sk-learn 中 one-class SVM 类的封装</p>
<p>详情可参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wj-1314/p/10701708.html">Python机器学习笔记：One Class SVM</a></p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.ocsvm <span class="keyword">import</span> OCSVM</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span>  <span class="comment"># 异常值占比</span></span><br><span class="line">    n_train = <span class="number">200</span>  <span class="comment"># 训练集大小</span></span><br><span class="line">    n_test = <span class="number">100</span>  <span class="comment"># 测试集大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产样本数据</span></span><br><span class="line">X_train, X_test, y_train, y_test = \</span><br><span class="line">    generate_data(n_train=n_train,</span><br><span class="line">                  n_test=n_test,</span><br><span class="line">                  n_features=<span class="number">2</span>,	</span><br><span class="line">                  contamination=contamination,</span><br><span class="line">                  random_state=<span class="number">42</span>,</span><br><span class="line">                  behaviour=<span class="string">&quot;new&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练 OCSVM 检测器</span></span><br><span class="line">clf_name = <span class="string">&#x27;OCSVM&#x27;</span></span><br><span class="line">clf = OCSVM()</span><br><span class="line">clf.fit(X_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得训练集的预测标签和异常分数</span></span><br><span class="line">y_train_pred = clf.labels_  <span class="comment"># (0: 正常, 1: 异常)</span></span><br><span class="line">y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得测试集的预测结果</span></span><br><span class="line">y_test_pred = clf.predict(X_test)</span><br><span class="line">y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估并且打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果可视化</span></span><br><span class="line">visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">           y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924164659935.png" alt="image-20200924164659935" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924164726149.png" alt="image-20200924164726149" style="zoom: 50%;" />



<h3 id="4-LOF"><a href="#4-LOF" class="headerlink" title="4. LOF"></a>4. LOF</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200926113655703.png" alt="image-20200926113655703" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>LOF（Local Outlier Factor），即局部异常因子算法，同样是对 sk-learn 中 LOF 类的封装</p>
<p>LOF 通过计算一个数值 score 来反映一个样本的异常程度。这个数值的大致意思是：一个<strong>样本点周围的样本点</strong>所处位置的<strong>平均密度</strong>比上<strong>该样本点</strong>所在位置的<strong>密度</strong>。比值比 1 越大，则该点所在位置的密度比其周围样本所在位置的密度越小，这个点就越有可能是异常点。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.lof <span class="keyword">import</span> LOF</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span>  <span class="comment"># 异常值占比</span></span><br><span class="line">    n_train = <span class="number">200</span>  <span class="comment"># 训练集大小</span></span><br><span class="line">    n_test = <span class="number">100</span>  <span class="comment"># 测试集大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产样本数据</span></span><br><span class="line">X_train, X_test, y_train, y_test = \</span><br><span class="line">    generate_data(n_train=n_train,</span><br><span class="line">                  n_test=n_test,</span><br><span class="line">                  n_features=<span class="number">2</span>,	</span><br><span class="line">                  contamination=contamination,</span><br><span class="line">                  random_state=<span class="number">42</span>,</span><br><span class="line">                  behaviour=<span class="string">&quot;new&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练 LOF 检测器</span></span><br><span class="line">clf_name = <span class="string">&#x27;LOF&#x27;</span></span><br><span class="line">clf = LOF()</span><br><span class="line">clf.fit(X_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得训练集的预测标签和异常分数</span></span><br><span class="line">y_train_pred = clf.labels_  <span class="comment"># (0: 正常, 1: 异常)</span></span><br><span class="line">y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得测试集的预测结果</span></span><br><span class="line">y_test_pred = clf.predict(X_test)</span><br><span class="line">y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估并且打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果可视化</span></span><br><span class="line">visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">           y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200926115949002.png" alt="image-20200926115949002" style="zoom: 80%;" />



<img src="【机器学习】异常检测：PyOD库中的算法/image-20200926120007794.png" alt="image-20200926120007794" style="zoom:50%;" />



<h3 id="5-kNN"><a href="#5-kNN" class="headerlink" title="5. kNN"></a>5. kNN</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927081652658.png" alt="image-20200927081652658" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>kNN（K-NearestNeighbor），即 K 近邻算法，是一种基本的<strong>有监督式分类和回归算法</strong>。</p>
<p>K 近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例<strong>最邻近</strong>的K个实例，<strong>这K个实例的多数属于某个类</strong>，就把该输入实例分类到这个类中。</p>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927082708545.png" alt="image-20200927082708545" style="zoom:80%;" />

<p>如图，要将绿色原点归类：</p>
<ol>
<li>K &lt;&#x3D; 3 ：红色三角形</li>
<li>K &gt; 3：蓝色方块</li>
</ol>
<p>在实际使用中，K 值的选取既不能过大，也不能过小</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.knn <span class="keyword">import</span> KNN</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;KNN&#x27;</span></span><br><span class="line">    clf = KNN()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927083506477.png" alt="image-20200927083506477" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927083444614.png" alt="image-20200927083444614" style="zoom:50%;" />



<h3 id="6-HBOS"><a href="#6-HBOS" class="headerlink" title="6. HBOS"></a>6. HBOS</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927091752222.png" alt="image-20200927091752222" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>HBOS（Histogram-based outlier score），即基于直方图的异常检测算法。</p>
<p>它假设每个维度独立并在每个维度上划分 n 个区间，每个区间所对应的异常值取决于密度。密度越高，异常值越低，因此也可以看成是一种假设维度独立的密度检测。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.hbos <span class="keyword">import</span> HBOS</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;HBOS&#x27;</span></span><br><span class="line">    clf = HBOS()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927092426760.png" alt="image-20200927092426760" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927092459169.png" alt="image-20200927092459169" style="zoom: 50%;" />



<h3 id="7-ABOD"><a href="#7-ABOD" class="headerlink" title="7. ABOD"></a>7. ABOD</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927093058529.png" alt="image-20200927093058529" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>ABOD（Angle-base Outlier Detection），在该算法中，对于一个样本，它的加权余弦分数对所有邻居的方差可以作为离群分数。</p>
<p>在<strong>高维空间</strong>中，<strong>角度比距离更具有可参考性</strong>（维度灾难）：</p>
<ul>
<li>O 点为离群点，则其他点在 O 点的<strong>同一方向</strong>上</li>
<li>O 点不是离群点，则其他点在 O 点的<strong>各个方向</strong>上</li>
</ul>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927093752466.png" alt="image-20200927093752466" style="zoom:80%;" />

<p>给定一点 P，它与全体样本中的任意两点 x、y 所成角度的构成下图：</p>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927094853516.png" alt="image-20200927094853516" style="zoom:80%;" />

<p>可知<strong>所成角度的绝对值越小则该点越有可能为离群点</strong>，也就是说图像中红点数据代表离群点而蓝点数据代表正常点</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.abod <span class="keyword">import</span> ABOD</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;ABOD&#x27;</span></span><br><span class="line">    clf = ABOD()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927095418659.png" alt="image-20200927095418659" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927095516422.png" alt="image-20200927095516422" style="zoom:50%;" />



<h3 id="8-IForest"><a href="#8-IForest" class="headerlink" title="8. IForest"></a>8. IForest</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927095714193.png" alt="image-20200927095714193" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p><code>pyod.models.iforest.IForest</code> 是对 sk-learn 中 <code>Isolation Forest</code> 的封装。</p>
<p>类似于RandomForest，IsolationForest 通过<strong>随机选择一个特征</strong>，然后在所选特征的最大值和最小值之间<strong>随机选择一个分割值</strong>来隔离观察结果。</p>
<p>由于递归分区可以用树结构来表示，因此分离一个样本所需的分裂次数等于从根节点到终止节点的路径长度。这条路径的长度，在这些随机树的森林上的平均值，是一种正态性的度量，也是我们的决策函数。<strong>随机分区为异常的值生成明显更短的路径</strong>。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.iforest <span class="keyword">import</span> IForest</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;IForest&#x27;</span></span><br><span class="line">    clf = IForest()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927101132163.png" alt="image-20200927101132163" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927101156937.png" alt="image-20200927101156937" style="zoom: 50%;" />



<h3 id="9-feature-bagging"><a href="#9-feature-bagging" class="headerlink" title="9. feature_bagging"></a>9. feature_bagging</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927105513335.png" alt="image-20200927105513335" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>Feature bagging 检测器是一种 元估计器（meta estimator），它在数据集的各个子样本上匹配大量的基础检测器（base detectors），并使用<strong>平均或其他组合方法</strong>来提高预测精度和控制过拟合。子样本的大小始终与原始输入样本的大小相同，但特征是从一半的特征随机抽样到全部特征。<strong>默认情况下，LOF用作基础估计器。</strong>但是，任何估计器都可以用作基础估计器，如 kNN 和 ABOD。</p>
<p>Feature bagging 首先通过<strong>随机选择特征子集</strong>来构造 n 个子样本，这会引起基本估计量的多样性。 最后，通过平均&#x2F;取所有基本检测器的最大值来生成预测分数。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.feature_bagging <span class="keyword">import</span> FeatureBagging</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;FeatureBagging&#x27;</span></span><br><span class="line">    clf = FeatureBagging(check_estimator=<span class="literal">False</span>)</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927110718875.png" alt="image-20200927110718875" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927110700780.png" alt="image-20200927110700780" style="zoom:50%;" />





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p>PyOD 官方文档：<a target="_blank" rel="noopener" href="https://pyod.readthedocs.io/en/latest/index.html#">https://pyod.readthedocs.io/en/latest/index.html#</a></p>
</li>
<li><p>（知乎）微调：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58313521">https://zhuanlan.zhihu.com/p/58313521</a></p>
</li>
<li><p>（知乎）忆臻：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25994179">https://zhuanlan.zhihu.com/p/25994179</a></p>
</li>
<li><p>shaoyue1234：<a target="_blank" rel="noopener" href="https://blog.csdn.net/shaoyue1234/article/details/102537709">异常检测——ABOD（angle-based outlier detection）</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%EF%BC%9APyOD%E5%BA%93%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/" data-id="cleqef3vt008pogjo5ezse0wj" data-title="【机器学习】异常检测：PyOD库中的算法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/" rel="tag">异常检测</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【机器学习】异常检测顶会论文一览" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E9%A1%B6%E4%BC%9A%E8%AE%BA%E6%96%87%E4%B8%80%E8%A7%88/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.661Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E9%A1%B6%E4%BC%9A%E8%AE%BA%E6%96%87%E4%B8%80%E8%A7%88/">【机器学习】2021异常检测顶会论文一览</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文整理了 <strong>2021</strong> 年AAAI、ICML等顶会收录的异常检测领域的论文</p>
<p><a target="_blank" rel="noopener" href="https://www.paperdigest.org/">论文整合网站 paperdigest</a></p>
<p><a target="_blank" rel="noopener" href="https://aaai.org/Conferences/AAAI-21/wp-content/uploads/2020/12/AAAI-21_Accepted-Paper-List.Main_.Technical.Track_.pdf">AAAI 2021 Accepted-Paper-List</a></p>
<p><a target="_blank" rel="noopener" href="https://icml.cc/Conferences/2021/AcceptedPapersInitial">ICML 2021 Accepted-Paper-List</a></p>
<p><a target="_blank" rel="noopener" href="https://openreview.net/group?id=ICLR.cc/2021/Conference#oral-presentations">ICLR 2021 Accepted-Paper-List</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>paper</th>
<th>source</th>
<th>author</th>
</tr>
</thead>
<tbody><tr>
<td>LREN: Low-Rank Embedded Network for Sample-Free Hyperspectral Anomaly Detection</td>
<td>AAAI</td>
<td><em>Kai Jiang, Weiying Xie, Jie Lei, Tao Jiang, Yunsong Li</em></td>
</tr>
<tr>
<td>GAN Ensemble for Anomaly Detection</td>
<td>AAAI</td>
<td><em>Xiaohui Chen, Xu Han, Liping Liu</em></td>
</tr>
<tr>
<td>Anomaly Attribution with Likelihood Compensation</td>
<td>AAAI</td>
<td><em>Tsuyoshi Ide, Amit Dhurandhar, Jiri Navratil, Moninder Singh, Naoki Abe</em></td>
</tr>
<tr>
<td>Regularizing Attention Networks for Anomaly Detection in Visual Question Answering</td>
<td>AAAI</td>
<td><em>Regularizing Attention Networks for Anomaly Detection in Visual Question Answering</em></td>
</tr>
<tr>
<td>Appearance-Motion Memory Consistency Network for Video Anomaly Detection</td>
<td>AAAI</td>
<td><em>Ruichu Cai, Hao Zhang, Wen Liu, Shenghua Gao, Zhifeng Hao</em></td>
</tr>
<tr>
<td>Learning Semantic Context from Normal Samples for Unsupervised Anomaly Detection</td>
<td>AAAI</td>
<td><em>Xudong Yan, Huaidong Zhang, Xuemiao Xu, Xiaowei Hu, Pheng-Ann Heng</em></td>
</tr>
<tr>
<td>Graph Neural Network-Based Anomaly Detection in Multivariate Time Series</td>
<td>AAAI</td>
<td><em>Ailin Deng, Bryan Hooi</em></td>
</tr>
<tr>
<td>Time Series Anomaly Detection with Multiresolution Ensemble Decoding</td>
<td>AAAI</td>
<td><em>Lifeng Shen, Zhongzhong Yu, Qianli Ma, James Tin-Yau Kwok</em></td>
</tr>
<tr>
<td>Window Loss for Abnormal Finding Classification and Localization in X-Ray Image with Point-Base Annotat</td>
<td>AAAI</td>
<td><em>Xinyu Zhang, Yirui Wang, Chi Tung Cheng, Le Lu, Adam P Harrison, Jing Xiao, ChienHung Liao, Shun  Miao</em></td>
</tr>
<tr>
<td>Graph Neural Network to Dilute Outliers for Refactoring Monolith Application</td>
<td>AAAI</td>
<td><em>Utkarsh Desai, Sambaran Bandyopadhyay, Srikanth Tamilselvam</em></td>
</tr>
<tr>
<td>Accelerated Combinatorial Search for Outlier Detection with Provable Bound on Sub-Optimality</td>
<td>AAAI</td>
<td><em>Guihong Wan, Haim Schweitzer</em></td>
</tr>
<tr>
<td>Neighborhood Consensus Networks for Unsupervised Multi-View Outlier Detection</td>
<td>AAAI</td>
<td><em>Li Cheng, Yijie Wang, Xinwang Liu</em></td>
</tr>
<tr>
<td>Outlier Impact Characterization for Time Series Data</td>
<td>AAAI</td>
<td><em>Jianbo Li, Lecheng Zheng, Yada Zhu, Jingrui He</em></td>
</tr>
<tr>
<td>Near-Optimal Entrywise Anomaly Detection for Low-Rank Matrices with Sub-Exponential Noise</td>
<td>ICML</td>
<td><em>Vivek Farias (MIT) , Andrew Li (Carnegie Mellon University) ,Tianyi Peng (MIT)</em></td>
</tr>
<tr>
<td>Transfer-Based Semantic Anomaly Detection</td>
<td>ICML</td>
<td><em>Lucas Deecke (University of Edinburgh) , Lukas Ruff (Aignostics) , Robert Vandermeulen (TU Berlin) , Hakan Bilen (University of Edinburgh)</em></td>
</tr>
<tr>
<td>Neural Transformation Learning for Deep Anomaly Detection Beyond Images</td>
<td>ICML</td>
<td><em>Chen Qiu (TU Kaiserslautern&#x2F;Bosch Center for Artificial Intelligence) , Timo Pfrommer (Bosch Center for Artificial Intelligence) , Marius Kloft (TU Kaiserslautern) , Stephan Mandt (University of California, Irivine) , Maja Rudolph (BCAI)</em></td>
</tr>
<tr>
<td>Event Outlier Detection in Continuous Time</td>
<td>ICML</td>
<td><em>Siqi Liu (Borealis AI) , Milos Hauskrecht (University of Pittsburgh)</em></td>
</tr>
<tr>
<td>Outlier-Robust Optimal Transport</td>
<td>ICML</td>
<td><em>Debarghya Mukherjee (University of Michigan) , Aritra Guha (Duke University) , Justin Solomon (MIT) , Yuekai Sun (University of Michigan) , Mikhail Yurochkin (IBM Research AI)</em></td>
</tr>
<tr>
<td>DORO: Distributional and Outlier Robust Optimization</td>
<td>ICML</td>
<td><em>Runtian Zhai (Carnegie Mellon University) , Chen Dan (Carnegie Mellon University) , Zico Kolter (Carnegie Mellon University &#x2F; Bosch Center for AI) , Pradeep Ravikumar (Carnegie Mellon University)</em></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://openreview.net/forum?id=v5gjXpmR8J">SSD: A Unified Framework for Self-Supervised Outlier Detection</a></td>
<td>ICLR</td>
<td><em><a target="_blank" rel="noopener" href="https://openreview.net/profile?id=~Vikash_Sehwag1">Vikash Sehwag</a>, <a target="_blank" rel="noopener" href="https://openreview.net/profile?id=~Mung_Chiang2">Mung Chiang</a>, <a target="_blank" rel="noopener" href="https://openreview.net/profile?id=~Prateek_Mittal1">Prateek Mittal</a></em></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aclweb.org/anthology/2021.naacl-main.25">DATE: Detecting Anomalies in Text Via Self-Supervision of Transformers</a></td>
<td>NAACL</td>
<td><em><a target="_blank" rel="noopener" href="https://www.paperdigest.org/expert/?name=andrei_manolache">Andrei Manolache</a>, <a target="_blank" rel="noopener" href="https://www.paperdigest.org/expert/?name=florin_brad">Florin Brad</a>, <a target="_blank" rel="noopener" href="https://www.paperdigest.org/expert/?name=elena_burceanu">Elena Burceanu</a></em></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E9%A1%B6%E4%BC%9A%E8%AE%BA%E6%96%87%E4%B8%80%E8%A7%88/" data-id="cleqef3vr008kogjo2tsle11k" data-title="【机器学习】2021异常检测顶会论文一览" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NLP/" rel="tag">NLP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/" rel="tag">异常检测</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【机器学习】异常检测文献阅读：基于K-Means的IForest" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8EK-Means%E7%9A%84IForest/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.639Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8EK-Means%E7%9A%84IForest/">【机器学习】异常检测文献阅读：基于K-Means的IForest</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文梳理论文 《K-Means-based isolation forest》</p>
<p>希望通过梳理这篇论文理清思路，以便获得启发</p>
<p>论文地址：<a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0950705120301064#tbl1">https://www.sciencedirect.com/science/article/pii/S0950705120301064#tbl1</a></p>
</blockquote>
<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h1><p>异常处理是数据科学领域中的重要问题，然而现有的异常检测模型还都有待提高：</p>
<ul>
<li>不够高效</li>
<li>只能应用于单一领域</li>
<li>以非直觉（nonintuitive）的方式运行</li>
</ul>
<p>在这篇论文中，我们对经典的 <strong>Isolation Forest</strong> 进行了分析，并且在它的基础上提出了<strong>基于 K-Means 的 IFoest</strong></p>
<p>该方法的优点：</p>
<ul>
<li>高效检测各种类型的异常值</li>
<li>使用户<strong>直观</strong>确定所分析数据集中<strong>单个样本的异常分数</strong></li>
<li>能够在决策树构件的步骤中拟合数据</li>
</ul>
<h1 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2 预备知识"></a>2 预备知识</h1><h2 id="2-1-K-Means"><a href="#2-1-K-Means" class="headerlink" title="2.1 K-Means"></a>2.1 K-Means</h2><h3 id="2-1-1-算法描述："><a href="#2-1-1-算法描述：" class="headerlink" title="2.1.1 算法描述："></a>2.1.1 算法描述：</h3><p>k-means 算法是无监督学习领域最为经典的算法之一。</p>
<p>在数据中<strong>选取多个点作为初始化的样本中心</strong>，所有样本<strong>选择距离自己最近的样本中心</strong>进行聚类，并在新生成的类中依据类中样本间的距离<strong>重新选择</strong>样本的样本中心，选择好新的样本中心后再根据所有样本到新样本中心的距离<strong>生成新的类</strong>，依此循环往复，直到达到某一限定条件（迭代次数、最小误差变化等）。</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/v2-371e88c867d1015d65cbab831a7542c5_b.webp" alt="img" style="zoom: 50%;" />

<p> K-means 算法步骤为：</p>
<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8EK-Means%E7%9A%84IForest/image-20210409145534589.png" alt="image-20210409145534589"></p>
<h3 id="2-1-2-算法优化"><a href="#2-1-2-算法优化" class="headerlink" title="2.1.2 算法优化"></a>2.1.2 算法优化</h3><p>由于生成类的数量 k 需要我们自己选定，所以需要一些选定 k 值的方法（手肘法、Gap statistic 方法）</p>
<p>本论文中使用<strong>手肘法</strong>选择 k 值：</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409150602616.png" alt="image-20210409150602616" style="zoom:80%;" />

<p>本图中 Y 轴是样本距离之和，X 轴是 k 值，可以看出 k &#x3D; 3 是拐点，故选择 3 作为 k 值</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78798251">https://zhuanlan.zhihu.com/p/78798251</a></p>
</blockquote>
<h2 id="2-2-Isolation-Forest"><a href="#2-2-Isolation-Forest" class="headerlink" title="2.2 Isolation Forest"></a>2.2 Isolation Forest</h2><p>专家门在数据挖掘时通常会列出一些在<strong>异常检测领域比较高效的算法</strong>，<strong>Isolation Forest</strong> 几乎每次都会位列其中。</p>
<p>隔离森林通过<strong>随机选取属性与属性对应的值</strong>对所有数据进行切分，切分后得到两部分数据分别放入左右子树中，对左右子树继续进行上述操作，直到数据不能再分或树高达到上限高度，一棵 <strong>Isolation Tree</strong> 就构建成功了。</p>
<p>直观上，正常点通过多次切分也还是在同一层中，而异常点在切分的过程中更易被切分出去，所以异常点所在树的深度并不深，以此就能分离出异常点来。</p>
<p>我们可以<strong>依据某个点所在树的深度</strong>计算其异常分数值，树越浅，异常分数越高。</p>
<p>通过<strong>随机采样</strong>选取多组数据构建多棵 ITree，就能构建出一个完整的 <strong>Isolation Forest</strong>。</p>
<p>对某个点在各个树中的异常分数求平均，就能得到该点总的异常分数。</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409152651542.png" alt="image-20210409152651542" style="zoom:80%;" />

<h1 id="3-基于-K-Means-的-Isolation-Forest"><a href="#3-基于-K-Means-的-Isolation-Forest" class="headerlink" title="3 基于 K-Means 的 Isolation Forest"></a>3 基于 K-Means 的 Isolation Forest</h1><h2 id="3-1-思想"><a href="#3-1-思想" class="headerlink" title="3.1 思想"></a>3.1 思想</h2><p>根据 IForest 中给出的图示我们可以看出，在对平面中的 x、y 交替划分了 10 次之后，我们分离出了红点。</p>
<p>可以注意到，无论这个点在是否接近分割区域的边界，最终的分割次数始终为 10（10 这个值最后被我们传入异常分数计算公式来计算异常分数）。这个方法是严格二分的，与分割点有关，因此异常分数与分割次数严管相关。</p>
<p>另外也可以注意到，该方法对直观上观察到的簇（clusters）不敏感。</p>
<p>因此我们可以对方法进行改进：<strong>对每次取得的属性对应的值进行 K-Means 聚类</strong>，得到的多个簇作为子节点重复之前的操作。</p>
<p>一棵树的叶子节点数取决于训练阶段数据集子分区中存在的最佳聚类数（也就是上文中通过手肘法决定的 k 值）。</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409160335732.png" alt="image-20210409160335732" style="zoom:80%;" />

<h2 id="3-2-具体算法"><a href="#3-2-具体算法" class="headerlink" title="3.2 具体算法"></a>3.2 具体算法</h2><ol>
<li>训练的初始阶段与经典的 IForest 相似，随机选取一个属性 <code>q</code>；</li>
<li>使用 K-means 将属性 <code>q</code> 中所有值划分为 k 个簇（k 值由手肘法选定）；</li>
<li>划分得到的 k 个簇作为根节点的叶子节点</li>
<li>对于每一个叶子节点，可以重复上述操作</li>
</ol>
<h2 id="3-3-异常分数的计算"><a href="#3-3-异常分数的计算" class="headerlink" title="3.3 异常分数的计算"></a>3.3 异常分数的计算</h2><p><strong>每次分割后得到的异常分数：</strong></p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409160426672.png" alt="image-20210409160426672" style="zoom:80%;" />

<ul>
<li>c_q：簇的中心点</li>
<li>c_l ：簇的边界</li>
<li>x    ：需要计算异常分数的点</li>
<li>d(x, y)：x 到 y 的距离</li>
</ul>
<p><strong>最终得分是每个数据在每次分割后得异常分数之和：</strong></p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409161001668.png" alt="image-20210409161001668" style="zoom:80%;" />

<h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h1><p>选用 NYC taxi trip data 数据集进行测试</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409164837084.png" alt="image-20210409164837084" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409164903853.png" alt="image-20210409164903853" style="zoom:80%;" />

<p>各数据集中 IForest 与 K-Means-based IF 执行时间效率对比：</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409165015495.png" alt="image-20210409165015495" style="zoom:80%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8EK-Means%E7%9A%84IForest/" data-id="cleqef3vq008hogjog1ls9ozc" data-title="【机器学习】异常检测文献阅读：基于K-Means的IForest" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OD/" rel="tag">OD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" rel="tag">文献阅读</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【机器学习】异常检测文献阅读：IsolationForest拓展" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AIsolationForest%E6%8B%93%E5%B1%95/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:23.616Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AIsolationForest%E6%8B%93%E5%B1%95/">【机器学习】异常检测文献阅读：IsolationForest拓展</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文梳理基于 Isolation Forest（IF）的若干拓展算法</p>
<p>关于 IF 的相关知识我在之前的文章<a target="_blank" rel="noopener" href="http://www.wxshhh.com/2021/01/20/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91NLP%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95%E7%AF%87/">【机器学习】异常检测文献阅读：关键算法篇 </a>中进行了梳理</p>
<ul>
<li><p>Extended Isolation Forest</p>
<p>  论文地址：<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/8888179">https://ieeexplore.ieee.org/document/8888179</a></p>
<p>  GitHub：<a target="_blank" rel="noopener" href="https://github.com/sahandha/eif">https://github.com/sahandha/eif</a></p>
</li>
<li><p>Rotated Isolation Forest</p>
<p>  论文地址：<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9177718">https://ieeexplore.ieee.org/document/9177718</a></p>
</li>
<li><p>Fuzzy Set-Based Isolation Forest</p>
<p>  论文地址：<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9177718">https://ieeexplore.ieee.org/document/9177718</a></p>
</li>
<li><p>Efficient Anomaly Detection by Isolation Using Nearest Neighbour Ensemble</p>
<p>  论文地址：<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/7022664">https://ieeexplore.ieee.org/document/7022664</a></p>
</li>
</ul>
</blockquote>
<h1 id="1-Extended-Isolation-Forest（EIF）"><a href="#1-Extended-Isolation-Forest（EIF）" class="headerlink" title="1 Extended Isolation Forest（EIF）"></a>1 Extended Isolation Forest（EIF）</h1><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>原有的算法 IF 利用了异常数据总是<strong>少而与众不同的特点</strong>，通过一次次的<strong>随机分割数据</strong>建立隔离森林来分离出异常值，足够<strong>直观</strong>且<strong>高效</strong>。</p>
<p>然而分割数据的方式是每次分割是个数据的某一单一维度上进行的，所以每次运行的结果总会出现一定的偏差。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210248189.png" alt="image-20210419210248189" style="zoom:80%;" />

<p>通过 <strong>正态数据分布的异常分数图</strong> 可以看出，异常分数总是随着到某一数据中心的距离的增加而增加，IF单纯的从某一维度对数据切割，总会存在偏差。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210219580.png" alt="image-20210419210219580" style="zoom:80%;" />

<p>同样对于两簇正态分布的数据，使用 IF 不断选取单一维度进行切割，不难发现在数据右上角与左下角也会产生异常分数较低的簇（gohst clusters）（实际上这些位置的点应该为异常点）。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210425081.png" alt="image-20210419210425081" style="zoom:80%;" />

<p>对于正弦波形也是同理。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210159784.png" alt="image-20210419210159784" style="zoom:80%;" />

<p>试想我们如果可以<strong>斜着切割数据</strong>，那么就可以有效弥补这一不足。</p>
<p>在 EIF 中，对 IF 中的数据分割方式进行了改进，来弥补原有算法的缺陷。</p>
<p>改进的方法中，EIF 使用了一个拥有随机斜度（slopes）的超平面来对数据进行切割，该超平面不与坐标轴平行。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210548911.png" alt="image-20210419210548911" style="zoom:80%;" />

<h3 id="1-2-算法描述"><a href="#1-2-算法描述" class="headerlink" title="1.2 算法描述"></a>1.2 算法描述</h3><p>Isolation Forest 分支切口（branchs cuts）的信息：</p>
<ol>
<li>一个随机选取的特征或坐标</li>
<li>一个来自于该特征的随机值</li>
</ol>
<p>Extended Isolation Forest 分支切口信息：</p>
<ol>
<li>一个分支切口的随机斜度（slope）</li>
<li>一个在数据集可用值范围内随机选择的截距（intercept）</li>
</ol>
<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AIsolationForest%E6%8B%93%E5%B1%95/image-20210429204912315.png" alt="image-20210429204912315"></p>
<blockquote>
<p>二维空间如此，高维空间（N 维）也是同理，只不过分支切口变味了一个 N -1 维的超平面</p>
<p>这些超平面同样被一个随机正交向量和一个随机截距点所确定，如二维情况类似</p>
</blockquote>
<h3 id="1-3-算法实现"><a href="#1-3-算法实现" class="headerlink" title="1.3 算法实现"></a>1.3 算法实现</h3><img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205349794.png" alt="image-20210420205349794" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205412696.png" alt="image-20210420205412696" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205437388.png" alt="image-20210420205437388" style="zoom:80%;" />

<h3 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h3><img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419214517225.png" alt="image-20210419214517225" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419214532878.png" alt="image-20210419214532878" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205557800.png" alt="image-20210420205557800" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205633002.png" alt="image-20210420205633002" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205650795.png" alt="image-20210420205650795" style="zoom:80%;" />



<h1 id="2-Fuzzy-Set-Based-Isolation-Forest（FSBIS）"><a href="#2-Fuzzy-Set-Based-Isolation-Forest（FSBIS）" class="headerlink" title="2 Fuzzy Set-Based Isolation Forest（FSBIS）"></a>2 Fuzzy Set-Based Isolation Forest（FSBIS）</h1><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9177718">文章</a>在原有算法 IF 的基础上，提出通过对记录的属性的隶属度（membership）进行划分从而构建森林。</p>
<p>其中，隶属度是根据到样本中心（middle of the cluster）的距离（也就是属性的平均值）来确定的。</p>
<p>优点：</p>
<ul>
<li>直观</li>
<li>返回异常值的隶属度几乎为零</li>
<li>以返回异常程度的方式构造的函数不需要使用复杂的标准化公式</li>
<li>运行时间并不比经典 IF 多，在某些情况下甚至短于经典 IF</li>
</ul>
<h3 id="2-2-算法描述"><a href="#2-2-算法描述" class="headerlink" title="2.2 算法描述"></a>2.2 算法描述</h3><p>对于经典 IF 相对复杂的建树过程，FSBIS 提出了如下改进</p>
<ol>
<li><p>在经典 IF 的第一阶段中，我们会从过滤后的簇（cluster）中所选择的属性的所有值中确定<strong>平均值</strong> <strong>m</strong>，这个值会被存在相应的节点上</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO 平均值m的具体确定方法？</span><br></pre></td></tr></table></figure>

<p> we always determine the average value of <em>m</em> from all the values of the chosen attribute located in the filtered cluster.</p>
</li>
<li><p>通过公式计算出已经构建好的簇的隶属度</p>
<p> <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AIsolationForest%E6%8B%93%E5%B1%95/image-20210429204937140.png" alt="image-20210429204937140"></p>
</li>
<li><p>最终，异常分数是每个节点所有隶属度之和</p>
</li>
</ol>
<h3 id="2-3-算法实例"><a href="#2-3-算法实例" class="headerlink" title="2.3 算法实例"></a>2.3 算法实例</h3><img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422202750238.png" alt="image-20210422202750238" style="zoom:80%;" /> 

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">如上图所示，我们要计算异常分数的点是 （x， y） = （<span class="number">0.7</span>， <span class="number">0.6</span>）</span><br><span class="line"></span><br><span class="line">第一次划分：x = <span class="number">0.5</span>，过滤后得到黄色区域</span><br><span class="line"></span><br><span class="line">黄色区域中心点 center <span class="comment">#1 在 x = 0.8 处</span></span><br><span class="line"></span><br><span class="line">故隶属度：p1 = <span class="number">1</span> - (<span class="number">0.8</span> - <span class="number">0.7</span>) / (<span class="number">0.8</span> - <span class="number">0.5</span>) = <span class="number">2</span>/<span class="number">3</span></span><br><span class="line"></span><br><span class="line">第二次划分：y = <span class="number">0.7</span>，过滤后得到红色区域</span><br><span class="line"></span><br><span class="line">红色区域中心点 center <span class="comment">#2 在 y = 0.3处</span></span><br><span class="line"></span><br><span class="line">故隶属度：p2 = <span class="number">1</span> - (<span class="number">0.6</span> - <span class="number">0.3</span>) / (<span class="number">0.7</span> - <span class="number">0.3</span>) = <span class="number">1</span>/<span class="number">4</span></span><br><span class="line"></span><br><span class="line">第三次划分：x = <span class="number">0.75</span>，过滤后得到绿色区域</span><br><span class="line"></span><br><span class="line">划分至绿色区域后，只剩下目标点，其隶属度不需要计算，因为明显是 <span class="number">1</span></span><br><span class="line"></span><br><span class="line">最后该点的异常分数 <span class="number">2</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">4</span> = <span class="number">11</span>/<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>构建的二叉树如下所示：</p>
<p>​                                                   <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422204718182.png" alt="image-20210422204718182" style="zoom: 50%;" /> </p>
<h3 id="2-4-算法实现"><a href="#2-4-算法实现" class="headerlink" title="2.4 算法实现"></a>2.4 算法实现</h3><img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422205159551.png" alt="image-20210422205159551" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422205241318.png" alt="image-20210422205241318" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422205159551.png" alt="image-20210422205159551" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422205241318.png" alt="image-20210422205241318" style="zoom:80%;" />



<h1 id="3-Efficient-Anomaly-Detection-by-Isolation-Using-Nearest-Neighbour-Ensemble"><a href="#3-Efficient-Anomaly-Detection-by-Isolation-Using-Nearest-Neighbour-Ensemble" class="headerlink" title="3 Efficient Anomaly Detection by Isolation Using Nearest Neighbour Ensemble"></a>3 Efficient Anomaly Detection by Isolation Using Nearest Neighbour Ensemble</h1><p>Advantage:</p>
<ul>
<li>Compared with some nearest neighbour-based method, the proposed method has <strong>linear time complexity</strong> and <strong>constant space complexity</strong>.</li>
<li>Compared with tree-based isolation method iForest, the proposed isolation method overcomes three weaknesses of iForest<ul>
<li>Its inability to <strong>detect local anomalies</strong></li>
<li>anomalies with <strong>a low number of relevant</strong> attributes</li>
<li>anomalies that are surrounded by normal instances</li>
</ul>
</li>
</ul>
<p>Two important challenging:</p>
<ul>
<li>the requirement of low computational cost</li>
<li>the susceptibility to issues in high-dimensional datasets</li>
</ul>
<p>How to operate:</p>
<ul>
<li>it partitions the data space into regions using a subsample and determines an isolation score for each region</li>
<li>each region is defined with a centre represented by an instance from the subsample; and its boundary is defined by the distance to the nearest neighbour of the instance at the centre.</li>
</ul>
<p>The intuition behind iNNE:</p>
<ul>
<li>an anomaly can be expected to be far from its nearest neighbour</li>
</ul>
<p>Some definations:</p>
<ul>
<li><p>Definition 1</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525210727558.png" alt="image-20210525210727558" style="zoom:80%;" />
</li>
<li><p>Definition 2</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525210817030.png" alt="image-20210525210817030" style="zoom:80%;" />
</li>
<li><p>Definition 3</p>
</li>
</ul>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525211202981.png" alt="image-20210525211202981" style="zoom:80%;" />



<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525211517695.png" alt="image-20210525211517695" style="zoom:80%;" />

<ul>
<li><p>Defination 4</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525211555777.png" alt="image-20210525211555777" style="zoom:80%;" />

<p>  Where <em>β</em> is a user defined threshold.</p>
</li>
<li><p>Defination 5</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525211913605.png" alt="image-20210525211913605" style="zoom:80%;" />
</li>
<li><p>Defination 6</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525212137950.png" alt="image-20210525212137950" style="zoom:80%;" />
</li>
<li><p>Defination 7</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525212209132.png" alt="image-20210525212209132" style="zoom:80%;" />
</li>
<li><p>Defination 8</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525212230930.png" alt="image-20210525212230930" style="zoom:80%;" /></li>
</ul>
<p>$$\begin{pmatrix} 1&#x2F;\sqrt{2} &amp; 1&#x2F;\sqrt{2} \ -1&#x2F;\sqrt{2} &amp; 1&#x2F;\sqrt{2} \end{pmatrix} \begin{pmatrix} 1 &amp; 2 &amp; 3 \ 1 &amp; 2 &amp; 3 \end{pmatrix} &#x3D; \begin{pmatrix} 2&#x2F;\sqrt{2} &amp; 4&#x2F;\sqrt{2} &amp; 6&#x2F;\sqrt{2} \ 0 &amp; 0 &amp; 0 \end{pmatrix}$$</p>
<p>$$\begin{pmatrix} 1&#x2F;\sqrt{2} &amp; 1&#x2F;\sqrt{2} \ -1&#x2F;\sqrt{2} &amp; 1&#x2F;\sqrt{2} \end{pmatrix} \begin{pmatrix} 3 \ 2 \end{pmatrix} &#x3D; \begin{pmatrix} 5&#x2F;\sqrt{2} \ -1&#x2F;\sqrt{2} \end{pmatrix}$$</p>
<p>$$\begin{pmatrix} p_1 \ p_2 \ \vdots \ p_R \end{pmatrix} \begin{pmatrix} a_1 &amp; a_2 &amp; \cdots &amp; a_M \end{pmatrix} &#x3D; \begin{pmatrix} p_1a_1 &amp; p_1a_2 &amp; \cdots &amp; p_1a_M \ p_2a_1 &amp; p_2a_2 &amp; \cdots &amp; p_2a_M \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ p_Ra_1 &amp; p_Ra_2 &amp; \cdots &amp; p_Ra_M \end{pmatrix}$$</p>
<p>$$\begin{pmatrix} 1 &amp; 1 &amp; 2 &amp; 4 &amp; 2 \ 1 &amp; 3 &amp; 3 &amp; 4 &amp; 4 \end{pmatrix}$$</p>
<p>$$\begin{pmatrix} -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \ -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \end{pmatrix}$$</p>
<p>$$Var(a)&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^m{(a_i-\mu)^2}$$</p>
<p>$$Cov(a,b)&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^m{a_ib_i}$$</p>
<p>$$X&#x3D;\begin{pmatrix} a_1 &amp; a_2 &amp; \cdots &amp; a_m \ b_1 &amp; b_2 &amp; \cdots &amp; b_m \end{pmatrix}$$</p>
<p>$$\frac{1}{m}XX^\mathsf{T}&#x3D;\begin{pmatrix} \frac{1}{m}\sum_{i&#x3D;1}^m{a_i^2} &amp; \frac{1}{m}\sum_{i&#x3D;1}^m{a_ib_i} \ \frac{1}{m}\sum_{i&#x3D;1}^m{a_ib_i} &amp; \frac{1}{m}\sum_{i&#x3D;1}^m{b_i^2} \end{pmatrix}$$</p>
<p>$$\begin{array}{l l l} D &amp; &#x3D; &amp; \frac{1}{m}YY^\mathsf{T} \ &amp; &#x3D; &amp; \frac{1}{m}(PX)(PX)^\mathsf{T} \ &amp; &#x3D; &amp; \frac{1}{m}PXX^\mathsf{T}P^\mathsf{T} \ &amp; &#x3D; &amp; P(\frac{1}{m}XX^\mathsf{T})P^\mathsf{T} \ &amp; &#x3D; &amp; PCP^\mathsf{T} \end{array}$$</p>
<p>$$E&#x3D;\begin{pmatrix} e_1 &amp; e_2 &amp; \cdots &amp; e_n \end{pmatrix}$$</p>
<p>$$E^\mathsf{T}CE&#x3D;\Lambda&#x3D;\begin{pmatrix} \lambda_1 &amp; &amp; &amp; \ &amp; \lambda_2 &amp; &amp; \ &amp; &amp; \ddots &amp; \ &amp; &amp; &amp; \lambda_n \end{pmatrix}$$</p>
<p>$$P&#x3D;E^\mathsf{T}$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AIsolationForest%E6%8B%93%E5%B1%95/" data-id="cleqef3vp008cogjo4lwpfe9e" data-title="【机器学习】异常检测文献阅读：IsolationForest拓展" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OD/" rel="tag">OD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" rel="tag">文献阅读</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%80%83%E7%A0%94/">考研</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatisPlus/" rel="tag">MyBatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLP/" rel="tag">NLP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OD/" rel="tag">OD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Project/" rel="tag">Project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringSecurity/" rel="tag">SpringSecurity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shiro/" rel="tag">shiro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" rel="tag">尚硅谷</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/" rel="tag">异常检测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" rel="tag">文献阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag">源码阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/" rel="tag">狂神说Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%BF%E9%87%8C%E4%BA%91/" rel="tag">阿里云</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 18.33px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/LeetCode/" style="font-size: 19.17px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 17.5px;">Linux</a> <a href="/tags/MyBatisPlus/" style="font-size: 10px;">MyBatisPlus</a> <a href="/tags/MySQL/" style="font-size: 11.67px;">MySQL</a> <a href="/tags/NLP/" style="font-size: 12.5px;">NLP</a> <a href="/tags/OD/" style="font-size: 13.33px;">OD</a> <a href="/tags/Project/" style="font-size: 11.67px;">Project</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Spring/" style="font-size: 11.67px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/SpringSecurity/" style="font-size: 10px;">SpringSecurity</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/shiro/" style="font-size: 10px;">shiro</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 11.67px;">前端</a> <a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" style="font-size: 17.5px;">尚硅谷</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">并发编程</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/" style="font-size: 10.83px;">异常检测</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15.83px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 11.67px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" style="font-size: 12.5px;">文献阅读</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 16.67px;">机器学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 14.17px;">源码阅读</a> <a href="/tags/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/" style="font-size: 15px;">狂神说Java</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E8%80%83%E7%A0%94/" style="font-size: 18.33px;">考研</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机组成原理</a> <a href="/tags/%E9%98%BF%E9%87%8C%E4%BA%91/" style="font-size: 10px;">阿里云</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">【考研】计算机组成原理知识点梳理</a>
          </li>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%80%83%E7%A0%94%E5%A5%8B%E6%96%97%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%81/">【考研】考研冲冲冲！</a>
          </li>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">【考研】数据结构知识点总结</a>
          </li>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/">【机器学习光速入门】</a>
          </li>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%EF%BC%9APyOD%E5%BA%93%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/">【机器学习】异常检测：PyOD库中的算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 wxshhh<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>