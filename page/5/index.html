<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>从入门到入土</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="中国科学技术大学软件工程在读">
<meta property="og:type" content="website">
<meta property="og:title" content="从入门到入土">
<meta property="og:url" content="http://wxshhh.github.io/page/5/index.html">
<meta property="og:site_name" content="从入门到入土">
<meta property="og:description" content="中国科学技术大学软件工程在读">
<meta property="og:locale">
<meta property="article:author" content="wxshhh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="从入门到入土" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">从入门到入土</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wxshhh.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-【数据结构与算法】LeetCode：day11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday11/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.827Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday11/">【数据结构与算法】LeetCode：day11</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-相交链表"><a href="#1-相交链表" class="headerlink" title="1. 相交链表"></a>1. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">相交链表</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200720175326197.png" alt="image-20200720175326197" style="zoom:67%;" />

<h5 id="思路一：暴力求解"><a href="#思路一：暴力求解" class="headerlink" title="思路一：暴力求解"></a>思路一：暴力求解</h5><p>对 <code>headA</code> 中的每一个节点，遍历 <code>headB</code> 中的每一个节点判断是否与其相等。</p>
<ul>
<li><p>时间复杂度：<code>O (mn)</code></p>
</li>
<li><p>空间复杂度：<code>O (1)</code></p>
</li>
</ul>
<h5 id="思路二：借助哈希表"><a href="#思路二：借助哈希表" class="headerlink" title="思路二：借助哈希表"></a>思路二：借助哈希表</h5><p>将 <code>headA</code> 中的节点存入一个 <code>HashSet</code> 中，如果 <code>headB</code> 中有节点在 <code>HashSet</code> 中，则说明该节点为交叉点</p>
<ul>
<li><p>时间复杂度：<code>O (m + n)</code></p>
</li>
<li><p>空间复杂度：<code>O (m) </code></p>
</li>
</ul>
<h5 id="思路三：浪漫双指针法"><a href="#思路三：浪漫双指针法" class="headerlink" title="思路三：浪漫双指针法"></a>思路三：浪漫双指针法</h5><p>创建两个指针分别指向 <code>headA</code> 、 <code>headB</code>，两个指针分别向前走，若相同则返回当前节点，若为空则指向另一条链表的头</p>
<blockquote>
<p>初看很难理解，但是细想就会发现很简单很巧妙 A和B两个链表长度可能不同，但是 A+B 和 B+A 的长度是相同的，所以遍历 A+B 和遍历 B+A 一定是同时结束。 如果A, B相交的话A和B有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点 如果A,B不相交的话两个指针就会同时到达 A+B（B+A）的尾节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)</span></span><br><span class="line"><span class="comment">        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="comment">// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头</span></span><br><span class="line">     	<span class="comment">// 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null</span></span><br><span class="line">        <span class="keyword">while</span>(pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：<code>O (m + n)</code></p>
</li>
<li><p>空间复杂度：<code>O (1) </code></p>
</li>
</ul>
<p>至于，为什么说他浪漫……</p>
<img src="【数据结构与算法】LeetCodee：day11/image-20200720180421830.png" alt="image-20200720180421830" style="zoom:67%;" />

<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCodee%EF%BC%9Aday11/image-20200720180447776.png" alt="image-20200720180447776"></p>
<h3 id="2-Excel表列名称"><a href="#2-Excel表列名称" class="headerlink" title="2.  Excel表列名称"></a>2. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-title"> Excel表列名称</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200720182149737.png" alt="image-20200720182149737" style="zoom:67%;" />

<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>Excel 表中相对应列的名称遵循 <strong>逢26进一</strong>  的原则，所以这题本质上考的是进制的转化！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            sb.append((<span class="type">char</span>)(n % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-Excel表列序号"><a href="#3-Excel表列序号" class="headerlink" title="3.  Excel表列序号"></a>3. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-number"> Excel表列序号</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200723170226918.png" alt="image-20200723170226918" style="zoom:67%;" />

<h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><p>与上题一致，主要考察进制的转化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sum = sum * <span class="number">26</span> + (<span class="type">int</span>)(s.charAt(i) - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-多数元素"><a href="#4-多数元素" class="headerlink" title="4.  多数元素"></a>4. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/"> 多数元素</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200723160835580.png" alt="image-20200723160835580" style="zoom:67%;" />

<h5 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h5><p>使用 <code>HashMap</code> 存储每个数字出现的次数，当某个数字出现的次数大于 <code>n/2</code> 时，返回该数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(num) &gt; len / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCodee：day11/image-20200723161041959.png" alt="image-20200723161041959" style="zoom:67%;" />



<h5 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h5><p>对数组进行排序，排序后的数组的第 <code>n/2</code> 个元素一定是众数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>算法题应该考验<strong>算法设计能力</strong>，而不是调用现成 api 的能力，故这种方法<strong>不推荐使用</strong>！</p>
<h5 id="最优的思路：Boyer-Moore-投票算法"><a href="#最优的思路：Boyer-Moore-投票算法" class="headerlink" title="最优的思路：Boyer-Moore 投票算法"></a>最优的思路：Boyer-Moore 投票算法</h5><p>如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 <code>0</code>，从结果本身我们可以看出众数比其他数多。</p>
<p>从第一个数开始count&#x3D;1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maj</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == maj) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    maj = nums[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCodee：day11/image-20200723163229747.png" alt="image-20200723163229747" style="zoom:67%;" />



<h3 id="5-阶乘后的零"><a href="#5-阶乘后的零" class="headerlink" title="5. 阶乘后的零"></a>5. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factorial-trailing-zeroes">阶乘后的零</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200723170428188.png" alt="image-20200723170428188" style="zoom:67%;" />

<h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><p>按一般思路：先求出 n 的阶乘，如何再计算阶乘结果中末尾 0 的个数。然而这样做不能满足时间复杂度的要求</p>
<blockquote>
<p>不可能去直接计算阶乘的结果看看有多少个0.</p>
<p>可以直接发现，尾数要为0，看看阶承中的数有多少个相乘后可以为10.</p>
<p>比如 5！：可以2*5.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10！：可以2*5，1*10，其中10又可以拆分为2*5.</span><br></pre></td></tr></table></figure>

<p>说4*5也可以，不过我们要的是最小的因数.</p>
<p>那么就转为寻找一个阶乘有多少个2和多少个5</p>
<p>拿20！来分析：[1<em>10, 2</em>5, 4<em>15, 5</em>6] 即：[1<em>2</em>5, 2<em>5, 2</em>2<em>5</em>3, 5<em>2</em>3]</p>
<p>再来个30！：[1<em>10, 2</em>5, 4<em>15, 5</em>6, 随便一个数<em>20, 25</em>8, 30<em>随便一个数]，即：[1</em>2<em>5, 2</em>5, 2<em>2</em>5<em>3, <em>2</em>2</em>5, 5<em>5</em>2<em>2</em>2, 2<em>5</em>3]</p>
<p>可以看出2总是比5多，那看看多少个5是不是就是多少个0</p>
<p>20!的结果为2432902008176640000，有4个0刚好跟有4个5相同</p>
<p>30！265252859812191058636308480000000有7个0,刚好也有7个5，所以可以证明</p>
<p>只需要看给定的数中有多少个5或者5的倍数就行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n / <span class="number">5</span> + trailingZeroes(n / <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday11/" data-id="cleqef3uw0054ogjoa3h0b0q6" data-title="【数据结构与算法】LeetCode：day11" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【数据结构与算法】LeetCode：day10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday10/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.804Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday10/">【数据结构与算法】LeetCode：day10</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-两个数组的交集-II"><a href="#1-两个数组的交集-II" class="headerlink" title="1. 两个数组的交集 II"></a>1. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">两个数组的交集 II</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200713200853665.png" alt="image-20200713200853665" style="zoom:67%;" />

<h5 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h5><ol>
<li>使用 <code>HashMap</code> 将 <code>nums1</code> 中的元素加入到 map 中并统计所有数字出现的次数</li>
<li>遍历 <code>nums2</code>，若 <code>nums2</code> 中的元素在 map 中有，则将该元素加入到结果集中并且将 map 中该元素出现的次数减一</li>
<li>返回结果集</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 提高效率，遍历较小的数组，将其元素加入到 map 中</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2,nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums1) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums2) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[index++] = num;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(num, count);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h5><blockquote>
<p>如果两个数组是有序的，则可以便捷地计算两个数组的交集。</p>
<p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</p>
<p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span>[] intersection = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(length1, length2)];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intersection[index] = nums1[index1];</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="2-二叉树的最小深度"><a href="#2-二叉树的最小深度" class="headerlink" title="2. 二叉树的最小深度"></a>2. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">二叉树的最小深度</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200713203100463.png" alt="image-20200713203100463" style="zoom: 67%;" />

<h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>使用递归，思路与求二叉树最大深度相似。</p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-杨辉三角"><a href="#3-杨辉三角" class="headerlink" title="3.  杨辉三角"></a>3. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle"> 杨辉三角</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200713205033766.png" alt="image-20200713205033766" style="zoom:67%;" />

<h5 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h5><p>每一行都基于前一行构造，顺的写即可</p>
<h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First base case; if user requests zero rows, they get zero rows.</span></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> triangle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Second base case; first row is always [1].</span></span><br><span class="line">        triangle.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        triangle.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rowNum</span> <span class="operator">=</span> <span class="number">1</span>; rowNum &lt; numRows; rowNum++) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; prevRow = triangle.get(rowNum-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The first row element is always 1.</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Each triangle element (other than the first and last of each row)</span></span><br><span class="line">            <span class="comment">// is equal to the sum of the elements above-and-to-the-left and</span></span><br><span class="line">            <span class="comment">// above-and-to-the-right.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; rowNum; j++) &#123;</span><br><span class="line">                row.add(prevRow.get(j-<span class="number">1</span>) + prevRow.get(j));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The last row element is always 1.</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            triangle.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> triangle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/pascals-triangle/solution/yang-hui-san-jiao-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h3 id="4-买卖股票的最佳时机"><a href="#4-买卖股票的最佳时机" class="headerlink" title="4.  买卖股票的最佳时机"></a>4. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock"> 买卖股票的最佳时机</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200718150149049.png" alt="image-20200718150149049" style="zoom:67%;" />

<h5 id="解题方法一：暴力枚举法"><a href="#解题方法一：暴力枚举法" class="headerlink" title="解题方法一：暴力枚举法"></a>解题方法一：暴力枚举法</h5><p>使用 嵌套循环遍历数组，列出所有可能的收益，从中找到最大的作为结果返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有可能不做交易，因此结果的初始值设置为 0 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                res = Math.max(res, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：liweiwei1419</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="解题方法二：暴力算法的优化"><a href="#解题方法二：暴力算法的优化" class="headerlink" title="解题方法二：暴力算法的优化"></a>解题方法二：暴力算法的优化</h5><p>只需要关心之前看到的最低价格，用一个变量记录下之前的最低价格，这样可以省去内层循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示在当前位置之前的最小值，假设修正法（打擂台法）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 注意：这里从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res = Math.max(res, prices[i] - minVal);</span><br><span class="line">            minVal = Math.min(minVal, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：liweiwei1419</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="5-环形链表"><a href="#5-环形链表" class="headerlink" title="5.  环形链表"></a>5. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle"> 环形链表</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200718152847322.png" alt="image-20200718152847322" style="zoom:67%;" />

<h5 id="解体方法一：哈希表"><a href="#解体方法一：哈希表" class="headerlink" title="解体方法一：哈希表"></a>解体方法一：哈希表</h5><p>我们使用 <code>HashSet</code> 来存储每个访问过的节点的引用，如果该节点出现在 <code>HashSet</code> 中，则说明链表为环形链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="解题方法二：快慢指针"><a href="#解题方法二：快慢指针" class="headerlink" title="解题方法二：快慢指针"></a>解题方法二：快慢指针</h5><p>想象两个人跑圈子，如果一个人较快一个人较慢，则这两个人迟早会相遇</p>
<p>我们用快慢指针来代表这两个人，快指针每次后移两步，慢指针每次后移一步，如果两个指针相遇，则说明链表为环形链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="6-最小栈"><a href="#6-最小栈" class="headerlink" title="6.  最小栈"></a>6. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack"> 最小栈</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200718162438484.png" alt="image-20200718162438484" style="zoom:67%;" />

<h5 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h5><p>更改底层数据结构，设计一个 <strong>MinStackNode</strong> 类，类中每个节点用来存放值和当前栈中的最小值。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    LinkedList&lt;MinStackNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * initialize your data structure here.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">preMin</span> <span class="operator">=</span> stack.getLast().min;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(x, preMin);</span><br><span class="line">            stack.add(<span class="keyword">new</span> <span class="title class_">MinStackNode</span>(x, min));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.add(<span class="keyword">new</span> <span class="title class_">MinStackNode</span>(x, x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.getLast().value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.getLast().min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStackNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStackNode</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> min)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.min = min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h5><p>设计一个辅助栈，用来保存最小值，如果 <code>pop()</code> 的值刚好是最小值，那么同时将辅助栈的栈顶也 <code>pop()</code> 了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 先将 x 压入数据栈</span></span><br><span class="line">        dataStack.push(x);</span><br><span class="line">        <span class="comment">// 如果 x 是当前的最小值，则也需要将 x 压入辅助栈</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || x &lt;= minStack.peek()) &#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先删除数据栈的栈顶元素 x</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dataStack.pop();</span><br><span class="line">        <span class="comment">// 若 x 是当前的最小值，则也需要删除辅助栈的栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (x == minStack.peek()) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：sweetiee</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/min-stack/solution/3-chong-fang-fa-shi-xian-bi-xu-miao-dong-by-sweeti/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday10/" data-id="cleqef3uv0051ogjo6sqi4jbd" data-title="【数据结构与算法】LeetCode：day10" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【数据结构与算法】LeetCode：day1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday1/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.776Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday1/">【数据结构与算法】LeetCode：day1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>寒假刚刚过去，暑假正式开始！</p>
<p>开始刷 LeetCode 的第一天，计划每天两小时，从简单题开始，到刷完为止（刷不完就一直刷~~~）</p>
<h3 id="1-一维数组的动态和"><a href="#1-一维数组的动态和" class="headerlink" title="1. 一维数组的动态和"></a>1. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/running-sum-of-1d-array">一维数组的动态和</a></h3><h3 id="2-拥有最多糖果的孩子"><a href="#2-拥有最多糖果的孩子" class="headerlink" title="2. 拥有最多糖果的孩子"></a>2. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies">拥有最多糖果的孩子</a></h3><h3 id="3-重新排列数组"><a href="#3-重新排列数组" class="headerlink" title="3. 重新排列数组"></a>3. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-the-array">重新排列数组</a></h3><img src="【数据结构与算法】LeetCode：day1/image-20200621151446703.png" alt="image-20200621151446703" style="zoom:67%;" />

<h5 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h5><ol>
<li>引入一个<strong>空数组</strong>用于存放结果，使用<strong>两个指针</strong>分别指向原数组和新数组</li>
<li>指向原数组的指针每次加2，指向新数组的指针每次加1</li>
</ol>
<h5 id="我的代码："><a href="#我的代码：" class="headerlink" title="我的代码："></a>我的代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shuffle(<span class="type">int</span>[] nums, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n; i = i + <span class="number">2</span>, j++)&#123;</span><br><span class="line">            res[i] = nums[j];</span><br><span class="line">            res[i + <span class="number">1</span>] = nums[j + n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day1/image-20200621151957545.png" alt="image-20200621151957545" style="zoom:67%;" />

<p>时间复杂度为 O(n) ，然而只击败26%，有改进空间！</p>
<h5 id="更好的方法："><a href="#更好的方法：" class="headerlink" title="更好的方法："></a>更好的方法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shuffle(<span class="type">int</span>[] nums, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            res[i * <span class="number">2</span>] = nums[i];</span><br><span class="line">            res[i * <span class="number">2</span> + <span class="number">1</span>] = nums[i+n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个指针是二倍的关系</strong>，完全可以用一个指针代替两个指针！</p>
<h3 id="4-1比特与2比特字符"><a href="#4-1比特与2比特字符" class="headerlink" title="4. 1比特与2比特字符"></a>4. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters">1比特与2比特字符</a></h3><img src="【数据结构与算法】LeetCode：day1/image-20200621162935088.png" alt="image-20200621162935088" style="zoom:67%;" />

<h5 id="我的思路：-1"><a href="#我的思路：-1" class="headerlink" title="我的思路："></a>我的思路：</h5><ol>
<li><p>设置布尔型变量 flag 来标记最后一个字符是否为一个比特，动态的进行判断</p>
</li>
<li><p>若字符数组长度为 1 则直接返回 true</p>
</li>
<li><p>否则进行判断：</p>
<ul>
<li>若上一次判断的结果是 false （两比特） ，则当前字符必定为一比特</li>
<li>若上一次判断结果为true （一比特）：<ul>
<li>若上一个字符为 0 ，则当前字符必定为一比特</li>
<li>若上一个字符为 1 ，则当前字符必定为两比特</li>
</ul>
</li>
</ul>
</li>
<li><p>返回 flag</p>
</li>
</ol>
<h5 id="我的代码：-1"><a href="#我的代码：-1" class="headerlink" title="我的代码："></a>我的代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOneBitCharacter</span><span class="params">(<span class="type">int</span>[] bits)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (bits.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; bits.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bits[i-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果：-1"><a href="#执行结果：-1" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day1/image-20200621163608741.png" alt="image-20200621163608741" style="zoom:67%;" />

<p>显然，在运行时间和内存消耗上都仍有较大改进空间！</p>
<p>康康大佬们是怎么做的</p>
<h5 id="更好的方法：-1"><a href="#更好的方法：-1" class="headerlink" title="更好的方法："></a>更好的方法：</h5><blockquote>
<p>我们可以对  <code>bits</code> 数组从左到右扫描来判断最后一位是否为一比特字符。当扫描到第 i 位时，如果 <code>bits[i] = 1</code>，那么说明这是一个两比特字符，将 i 的值增加 2。如果 <code>bits[i] = 0</code>，那么说明这是一个一比特字符，将 i 的值增加 1。</p>
<p>如果 i 最终落在了 <code>bits.length − 1</code> 的位置，那么说明最后一位一定是一比特字符。</p>
<p>作者：LeetCode<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/solution/1bi-te-yu-2bi-te-zi-fu-by-leetcode/">https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/solution/1bi-te-yu-2bi-te-zi-fu-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOneBitCharacter</span><span class="params">(<span class="type">int</span>[] bits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bits.length - <span class="number">1</span>) &#123;</span><br><span class="line">            i += bits[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == bits.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>妙啊！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday1/" data-id="cleqef3uu004xogjoaffkf4td" data-title="【数据结构与算法】LeetCode：day1" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【操作系统】第四章：非连续式内存分布" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.751Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/">【操作系统】第四章：非连续式内存分布</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> <strong>非连续内存分配优点</strong></p>
<ul>
<li>一个程序的物理地址是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码与数据</li>
<li>支持动态加载和动态链接</li>
</ul>
<p><strong>潜在问题</strong></p>
<ul>
<li>如何建立虚拟地址与物理地址之间的转换<ul>
<li>软件方案</li>
<li>硬件方案<ul>
<li>分段</li>
<li>分页</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><h3 id="程序的分段地址空间"><a href="#程序的分段地址空间" class="headerlink" title="程序的分段地址空间"></a>程序的分段地址空间</h3><ul>
<li>将逻辑地址空间分成各个块</li>
</ul>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418141948265.png" alt="image-20200418141948265" style="zoom:50%;" />

<ul>
<li>如下图，需要一种运行机制，来使<strong>逻辑地址空间</strong>与<strong>物理地址空间</strong>之间有对应的<strong>关联</strong></li>
</ul>
<p><img src="【操作系统】第四章：非连续式内存分布/image-20200418142034374.png" alt="image-20200418142034374" style="zoom:50%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200418142254435.png" alt="image-20200418142254435"></p>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418142312648.png" alt="image-20200418142312648" style="zoom:50%;" />



<h3 id="分段寻址方案"><a href="#分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h3><ul>
<li><p>两种实现方案：</p>
<ul>
<li><p>段寄存器 + 地址寄存器：将段号和段内偏移分开放置</p>
</li>
<li><p>单地址实现方案：将段号和段内偏移放在一起</p>
</li>
</ul>
</li>
</ul>
<p><img src="【操作系统】第四章：非连续式内存分布/image-20200418142553901.png" alt="image-20200418142553901" style="zoom:50%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200418143008669.png" alt="image-20200418143008669"></p>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418143028307.png" alt="image-20200418143028307" style="zoom:50%;" />



<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><ul>
<li>现在CPU主要使用分页方式</li>
</ul>
<h3 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h3><ul>
<li><p>与分段方式相似，同样拥有页号和偏移</p>
</li>
<li><p>不同之处在于分段中<strong>段的大小可变</strong>，而分页中<strong>页的大小固定的</strong></p>
</li>
<li><p>帧（frame）和页（page）：</p>
<ul>
<li><p>划分<strong>物理内存</strong>至固定大小的<strong>帧</strong>：大小是2的幂次方</p>
  <img src="【操作系统】第四章：非连续式内存分布/image-20200418144103065.png" alt="image-20200418144103065" style="zoom:50%;" />

  <img src="【操作系统】第四章：非连续式内存分布/image-20200418144606645.png" alt="image-20200418144606645" style="zoom:50%;" />
</li>
<li><p>划分<strong>逻辑地址空间</strong>至相同大小的<strong>页</strong>：大小也是2的幂次方</p>
  <img src="【操作系统】第四章：非连续式内存分布/image-20200418145629651.png" alt="image-20200418145629651" style="zoom:50%;" />

  <img src="【操作系统】第四章：非连续式内存分布/image-20200418145930471.png" alt="image-20200418145930471" style="zoom:50%;" />

  

<p>  依据逻辑地址的页号到页表中查询出物理地址的帧号</p>
</li>
</ul>
</li>
<li><p>建立方案转化逻辑地址为物理地址（pages to frames）</p>
</li>
</ul>
<h3 id="页的寻址方案"><a href="#页的寻址方案" class="headerlink" title="页的寻址方案"></a>页的寻址方案</h3><img src="【操作系统】第四章：非连续式内存分布/image-20200418150212728.png" alt="image-20200418150212728" style="zoom:50%;" />

<h1 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>页表其实就是一个<strong>大数组</strong>，索引代表的是 page_number，索引对应的值存的是 frame_number</p>
  <img src="【操作系统】第四章：非连续式内存分布/image-20200418150738864.png" alt="image-20200418150738864" style="zoom:50%;" /></li>
</ul>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418151533051.png" alt="image-20200418151533051" style="zoom: 80%;" />

<ul>
<li>存在问题：访问一个内存单元需要两次访问内存，存在性能问题<ul>
<li>一次获取页表项</li>
<li>一次用于访问数据</li>
</ul>
</li>
</ul>
<h3 id="TLB（Translation-Look-aside-Buffer）"><a href="#TLB（Translation-Look-aside-Buffer）" class="headerlink" title="TLB（Translation Look-aside Buffer）"></a>TLB（Translation Look-aside Buffer）</h3><ul>
<li>缓存近期访问的页帧转换表项<ul>
<li>TLB使用关联内存（速度快容量小）实现，具备快速访问性能</li>
<li>如果查到，则物理帧号可以被快速获取</li>
<li>如果查不到，就在页表中进行查找然后将内容更新到TLB</li>
</ul>
</li>
</ul>
<h3 id="二级、多级页表（时间换空间）"><a href="#二级、多级页表（时间换空间）" class="headerlink" title="二级、多级页表（时间换空间）"></a>二级、多级页表（时间换空间）</h3><ul>
<li>会增加时间开销</li>
<li>省下空间（一级页表中的保留位为0，二级页表就不需要留位置了）</li>
</ul>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418153639436.png" alt="image-20200418153639436" style="zoom: 67%;" />

<img src="【操作系统】第四章：非连续式内存分布/image-20200418153843016.png" alt="image-20200418153843016" style="zoom:67%;" />

<h3 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h3><ul>
<li>大地址空间问题：<ul>
<li>有大地址空间，向前映射页表变得繁琐（5级页表）</li>
<li>不是让页表与逻辑地址空间的大小相对应，而是让页表与物理地址空间的大小相对于（虚拟地址空间增长速度快于物理地址空间）</li>
</ul>
</li>
</ul>
<p><img src="【操作系统】第四章：非连续式内存分布/image-20200418155010474.png" alt="image-20200418155010474" style="zoom: 67%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200418155148496.png" alt="image-20200418155148496"></p>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418155557962.png" alt="image-20200418155557962" style="zoom:67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/" data-id="cleqef3ut004uogjo6fhfejz7" data-title="【操作系统】第四章：非连续式内存分布" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【操作系统】第六章：页面置换算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.723Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/">【操作系统】第六章：页面置换算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>功能目标</strong></p>
<ul>
<li><p>功能：当缺页中断发生，需要调入新的页面而内存已满时，选择当中哪个物理页面被置换。</p>
</li>
<li><p>目标：<strong>尽可能减少页面的换进换出次数。</strong></p>
</li>
<li><p>页面锁定：将相关的页（必须常驻操作系统的关键部分）放在内存里面，确保操作系统随时能够正常工作</p>
</li>
</ul>
<h1 id="6-1-最优页面置换算法"><a href="#6-1-最优页面置换算法" class="headerlink" title="6.1 最优页面置换算法"></a>6.1 最优页面置换算法</h1><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>（如果能预知将来）根据将来什么时候访问，将<strong>距离再次使用间隔时间最长的页</strong>作为被置换的页面（不太实际，无法预知未来）</p>
<p>可用作其他算法的性能评价依据。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><img src="【操作系统】第六章：页面置换算法/image-20200421160738838.png" alt="image-20200421160738838" style="zoom:80%;" />

<h1 id="6-2-先进先出算法（FIFO）"><a href="#6-2-先进先出算法（FIFO）" class="headerlink" title="6.2 先进先出算法（FIFO）"></a>6.2 先进先出算法（FIFO）</h1><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>选择在内存中驻留时间最长的页面并淘汰之。</p>
<p>系统维护着一个<strong>链表</strong>，记录了所有位于内存中的逻辑页面，链表首页驻留时间最长，尾部最短，发生缺页中断时，链表首页先淘汰，在链表尾部加入新的页面。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>性能较差</strong>，调出的页面有可能是经常要访问的页面，并且有可能出现 <strong>Belady现象</strong>（后面讲），<strong>很少单独使用</strong>。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><img src="【操作系统】第六章：页面置换算法/image-20200421161641490.png" alt="image-20200421161641490" style="zoom:80%;" />

<h1 id="6-3-最近最久未使用（LRU）"><a href="#6-3-最近最久未使用（LRU）" class="headerlink" title="6.3 最近最久未使用（LRU）"></a>6.3 最近最久未使用（LRU）</h1><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><p>当一个缺页中断发生时，<strong>选择最久未使用</strong>的那个页面并淘汰之。</p>
<p><strong>根据过去推测将来。</strong>（过去使用的较少，推测将来使用的也会很少）</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p><strong>LRU算法需要记录各个页面使用的先后顺序，开销比较大</strong></p>
<p>两种可能的实现方式：</p>
<ol>
<li><p><strong>链表</strong></p>
<p> 系统维护一个页面链表，<strong>最近刚刚使用的页面作为首节点，最久未使用的页面作为尾节点</strong></p>
</li>
<li><p><strong>堆栈</strong></p>
<p> 设置一个活动页面栈，当访问某页时，将此页号压入栈顶，然后考察站内是否有与此页面相同的页号，有则抽出。需要淘汰一个页面时，总是选择栈底的页面。</p>
</li>
</ol>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/image-20200421162315694.png" alt="image-20200421162315694"></p>
<h1 id="6-4-时钟页面置换算法"><a href="#6-4-时钟页面置换算法" class="headerlink" title="6.4 时钟页面置换算法"></a>6.4 时钟页面置换算法</h1><p>Clock 页面置换算法，LRU 近似，对 FIFO 的一种改进</p>
<h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li><p>需用用到页表中的<strong>访问位</strong>，页面被装入内存时，访问位初始化为0，页面被读写，访问位被置为1</p>
</li>
<li><p>将页面制成<strong>环形链表</strong>，指针指向最先进来的页</p>
</li>
<li><p>发生缺页中断时，指针开始移动</p>
<p>  ​		若所指页面访问位为0，立即被淘汰</p>
<p>  ​		若所指页面访问位为1，把该位置为0，指针继续移动</p>
</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>访问位只占一个字节，只有两种可能，结果不是很准确！</p>
<p>准确率跟 LRU 差不多</p>
<img src="【操作系统】第六章：页面置换算法/image-20200421164403875.png" alt="image-20200421164403875" style="zoom:80%;" />



<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/image-20200421165406064.png" alt="image-20200421165406064"></p>
<h1 id="6-5-二次机会法"><a href="#6-5-二次机会法" class="headerlink" title="6.5 二次机会法"></a>6.5 二次机会法</h1><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>同时使用 <strong>脏位（dirty bit）和访问位（used bit）</strong> 来指导位置交换。</p>
<p>脏位：用来标识是否进行过<strong>写操作</strong></p>
<p>​			如果执行过写操作，则脏位置为1，淘汰该页时需要将其写入物理硬盘以更新信息</p>
<p>​			如果没有执行过写操作，则脏位置为0，淘汰该页时直接将其释放即可，不需要再写入硬盘</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><img src="【操作系统】第六章：页面置换算法/image-20200421170625437.png" alt="image-20200421170625437" style="zoom:80%;" />

<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><img src="【操作系统】第六章：页面置换算法/image-20200421171058688.png" alt="image-20200421171058688" style="zoom:80%;" />



<h1 id="6-6-最不常用法"><a href="#6-6-最不常用法" class="headerlink" title="6.6 最不常用法"></a>6.6 最不常用法</h1><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h3><p>当一个缺页中断发生时，选择访问次数最少的那个页面，淘汰之</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>对每个页面设置一个计数器，页面被访问时计数器加一。发生缺页中断时，选择计数器最小的淘汰。</p>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>引入计数器占用物理内存，开销较大。</p>
<p>检索计数器觉得淘汰谁时同样存在开销。</p>
<h1 id="6-7-Belady现象、LRU、FIFO、Clock"><a href="#6-7-Belady现象、LRU、FIFO、Clock" class="headerlink" title="6.7 Belady现象、LRU、FIFO、Clock"></a>6.7 Belady现象、LRU、FIFO、Clock</h1><p>Belady现象：在采用FIFO算法时，有时候会出现分配的<strong>物理页面数增加</strong>，<strong>缺页率反而提高</strong>的异常现象</p>
<p>产生原因：FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的，因此，被它置换出去的页面并不一定是进程不会访问的。</p>
<h3 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h3><ul>
<li>三个物理页帧：</li>
</ul>
<p><img src="【操作系统】第六章：页面置换算法/image-20200423180050021.png" alt="image-20200423180050021" style="zoom:67%;" />- </p>
<ul>
<li>四个物理页帧：</li>
</ul>
<img src="【操作系统】第六章：页面置换算法/image-20200423180202056.png" style="zoom:67%;" />

<h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><img src="【操作系统】第六章：页面置换算法/image-20200423180342776.png" alt="image-20200423180342776" style="zoom:67%;" />



<h1 id="6-8-局部页面替换算法的问题、工作集模型"><a href="#6-8-局部页面替换算法的问题、工作集模型" class="headerlink" title="6.8 局部页面替换算法的问题、工作集模型"></a>6.8 局部页面替换算法的问题、工作集模型</h1><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><img src="【操作系统】第六章：页面置换算法/image-20200423182114630.png" alt="image-20200423182114630" style="zoom:67%;" />



<img src="【操作系统】第六章：页面置换算法/image-20200423190957657.png" alt="image-20200423190957657" style="zoom:67%;" />

<img src="【操作系统】第六章：页面置换算法/image-20200423191500252.png" alt="image-20200423191500252" style="zoom:67%;" />

<img src="【操作系统】第六章：页面置换算法/image-20200423191724551.png" alt="image-20200423191724551" style="zoom:67%;" />

<h1 id="6-9-两个全局置换算法"><a href="#6-9-两个全局置换算法" class="headerlink" title="6.9 两个全局置换算法"></a>6.9 两个全局置换算法</h1><h3 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h3><ul>
<li><p>基本思想：</p>
<p>  需要替换页面时，替换那些不在工作集窗口内的页</p>
<p>  工作集会随程序执行挪动，如果某个页不在工作集窗口之内，它会被丢掉</p>
</li>
</ul>
<img src="【操作系统】第六章：页面置换算法/image-20200423192758848.png" alt="image-20200423192758848" style="zoom:67%;" />

<ul>
<li>在整个系统层面，会确保整个系统的缺页次数较低</li>
</ul>
<h3 id="缺页率页面置换算法"><a href="#缺页率页面置换算法" class="headerlink" title="缺页率页面置换算法"></a>缺页率页面置换算法</h3><img src="【操作系统】第六章：页面置换算法/image-20200423193027256.png" alt="image-20200423193027256" style="zoom:67%;" />

<ul>
<li><p>缺页率：</p>
<p>  缺页次数 &#x2F; 内存访问次数</p>
<ul>
<li>影响因素：<ul>
<li>页面置换算法</li>
<li>分配给进程的物理页大小</li>
<li>页面本身大小</li>
<li>程序的编写</li>
</ul>
</li>
<li>方法：<ul>
<li>缺页率高——–增加工作集</li>
<li>缺页率低——–减少工作集</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="【操作系统】第六章：页面置换算法/image-20200423193934644.png" alt="image-20200423193934644" style="zoom:67%;" />

<p><strong>总结：</strong>对操作系统而言，如果要<strong>应对多个正在运行的程序</strong>，采取<strong>全局页替换算法</strong>效果要好于局部页替换算法</p>
<h1 id="6-10-抖动问题"><a href="#6-10-抖动问题" class="headerlink" title="6.10 抖动问题"></a>6.10 抖动问题</h1><img src="【操作系统】第六章：页面置换算法/image-20200423194424780.png" alt="image-20200423194424780" style="zoom:67%;" />

<img src="【操作系统】第六章：页面置换算法/image-20200423194520833.png" alt="image-20200423194520833" style="zoom:67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" data-id="cleqef3us004qogjob74x4jpd" data-title="【操作系统】第六章：页面置换算法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【操作系统】第八章：CPU调度" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.690Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/">【操作系统】第八章：CPU调度</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li><p>在进程&#x2F;线程的生命周期中什么时候进行调度？</p>
<p>  在一个状态向另一个状态转换的时候会触发一次调度。</p>
</li>
<li><p>内核运行调度程序的条件</p>
<ul>
<li>一个进程从运行状态切换到等待状态</li>
<li>一个进程被终结了</li>
</ul>
</li>
<li><p>不可抢占</p>
<p>  调度程序必须等待事件结束</p>
<p>  （效率并不是很高）</p>
</li>
<li><p>可以抢占</p>
<p>  调度程序在中断被响应后执行</p>
<p>  当前程序从运行切换到就绪，或者一个进程从等待切换到就绪</p>
<p>  当前运行的进程可以被换出</p>
<p>  （现代操作系统常用的策略，效率较高）</p>
</li>
</ul>
<h1 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h1><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429090909424.png" alt="image-20200429090909424"></p>
<h3 id="程序执行模型"><a href="#程序执行模型" class="headerlink" title="程序执行模型"></a>程序执行模型</h3><ul>
<li><strong>CPU利用率</strong>：CPU处于忙状态所占时间的百分比</li>
<li><strong>吞吐量</strong>：在单位时间内完成的进程数量</li>
<li><strong>周转时间</strong>：一个进程从初始化到结束，包括所有<strong>等待时间</strong>所花的时间</li>
<li><strong>等待时间</strong>：进程在<strong>就绪队列</strong>中的总时间</li>
<li><strong>响应时间</strong>：从一个请求被提交到产生第一次响应所花费的时间</li>
</ul>
<h3 id="比较调度算法的准则"><a href="#比较调度算法的准则" class="headerlink" title="比较调度算法的准则"></a>比较调度算法的准则</h3><ul>
<li>更快的服务<ul>
<li>低延迟：喝水的时候想要打开水龙头就有水</li>
<li>高带宽：给游泳池冲水时希望从水龙头里<strong>同时</strong>流出<strong>大量</strong>的水，并且不介意是否存在延迟</li>
</ul>
</li>
<li>减少响应时间</li>
<li>减少平均响应时间的波动</li>
<li>增加吞吐量<ul>
<li>减少开销（操作系统开销，上下文切换）</li>
<li>系统资源高效利用（CPU、I&#x2F;O设备）</li>
</ul>
</li>
<li>减少等待时间</li>
</ul>
<h3 id="吞吐量-vs-延迟"><a href="#吞吐量-vs-延迟" class="headerlink" title="吞吐量 vs 延迟"></a>吞吐量 vs 延迟</h3><ul>
<li><p>吞吐量时操作系统的计算带宽</p>
</li>
<li><p>响应时间是是操作系统的计算延迟</p>
</li>
</ul>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h3 id="FCFS（先来先服务）"><a href="#FCFS（先来先服务）" class="headerlink" title="FCFS（先来先服务）"></a>FCFS（先来先服务）</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429093124676.png" alt="image-20200429093124676"></p>
<img src="【操作系统】第八章：CPU调度/image-20200429093307340.png" alt="image-20200429093307340" style="zoom:67%;" />

<h3 id="SPN-x2F-SJF-SRT（短进程优先）"><a href="#SPN-x2F-SJF-SRT（短进程优先）" class="headerlink" title="SPN&#x2F;SJF SRT（短进程优先）"></a>SPN&#x2F;SJF SRT（短进程优先）</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429093757961.png" alt="image-20200429093757961"></p>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429094338916.png" alt="image-20200429094338916"></p>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429094355350.png" alt="image-20200429094355350"></p>
<h3 id="HRRN（最高响应比优先）"><a href="#HRRN（最高响应比优先）" class="headerlink" title="HRRN（最高响应比优先）"></a>HRRN（最高响应比优先）</h3><img src="【操作系统】第八章：CPU调度/image-20200429094916767.png" alt="image-20200429094916767" style="zoom:67%;" />

<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429095315462.png" alt="image-20200429095315462">缓解了<strong>长程序</strong>可能产生的<strong>饥饿状态</strong></p>
<h3 id="Round-Robin（轮询）"><a href="#Round-Robin（轮询）" class="headerlink" title="Round Robin（轮询）"></a>Round Robin（轮询）</h3><img src="【操作系统】第八章：CPU调度/image-20200429095325005.png" alt="image-20200429095325005" style="zoom:67%;" />

<img src="【操作系统】第八章：CPU调度/image-20200429095342702.png" alt="image-20200429095342702" style="zoom:67%;" />

<img src="【操作系统】第八章：CPU调度/image-20200429100235462.png" alt="image-20200429100235462" style="zoom:67%;" />

<h3 id="Multilevel-Feedback-Queue（多级反馈队列）"><a href="#Multilevel-Feedback-Queue（多级反馈队列）" class="headerlink" title="Multilevel Feedback Queue（多级反馈队列）"></a>Multilevel Feedback Queue（多级反馈队列）</h3><img src="【操作系统】第八章：CPU调度/image-20200429100455259.png" alt="image-20200429100455259" style="zoom:67%;" />

<img src="【操作系统】第八章：CPU调度/image-20200429100552763.png" alt="image-20200429100552763" style="zoom:67%;" />

<h3 id="Fair-Share-Scheduling（公平共享调度）"><a href="#Fair-Share-Scheduling（公平共享调度）" class="headerlink" title="Fair Share Scheduling（公平共享调度）"></a>Fair Share Scheduling（公平共享调度）</h3><h1 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h1><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><ul>
<li>定义：正确性依赖于其时间和功能两方面的一种操作系统</li>
<li>性能指标：<ul>
<li>时间约束的及时性（deadline）</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>主要特性：时间约束的可预测性</li>
<li>分类：<ul>
<li>强实时系统：规定时间内必须完成</li>
<li>若实时系统：尽量完成</li>
</ul>
</li>
<li><img src="【操作系统】第八章：CPU调度/image-20200429101316653.png" alt="image-20200429101316653" style="zoom:67%;" /></li>
</ul>
<h3 id="可调度性"><a href="#可调度性" class="headerlink" title="可调度性"></a>可调度性</h3><h3 id="单调速率（RM）"><a href="#单调速率（RM）" class="headerlink" title="单调速率（RM）"></a>单调速率（RM）</h3><ul>
<li>最佳静态优先级调度</li>
<li>通过周期安排优先级</li>
<li>周期越短优先级越高</li>
<li>执行周期最短的任务</li>
</ul>
<h3 id="截止日期最早优先（EDF）"><a href="#截止日期最早优先（EDF）" class="headerlink" title="截止日期最早优先（EDF）"></a>截止日期最早优先（EDF）</h3><ul>
<li>最佳的动态优先级调度</li>
<li>Deadline越早优先级越高</li>
<li>执行Deadline最早的任务</li>
</ul>
<h1 id="多处理器调度与优先级反转"><a href="#多处理器调度与优先级反转" class="headerlink" title="多处理器调度与优先级反转"></a>多处理器调度与优先级反转</h1><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><img src="【操作系统】第八章：CPU调度/image-20200429101851018.png" alt="image-20200429101851018" style="zoom:67%;" />

<h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3><ul>
<li>优先级翻转是当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。</li>
</ul>
<img src="【操作系统】第八章：CPU调度/image-20200429102551017.png" alt="image-20200429102551017" style="zoom: 67%;" />

<img src="【操作系统】第八章：CPU调度/image-20200429102551017.png" alt="image-20200429102551017" style="zoom:67%;" />

<ul>
<li><p>解决方法：优先级继承、优先级天花板</p>
<ul>
<li><p>优先级继承：</p>
<p>  优先级继承是当任务A 申请共享资源S 时， 如果S正在被任务C 使用，通过比较任务C 与自身的优先级，如发现任务C 的优先级小于自身的优先级， 则将任务C的优先级提升到自身的优先级， 任务C 释放资源S 后，再恢复任务C 的原优先级。这种方法只在占有资源的低优先级任务阻塞了高优先级任务时才动态的改变任务的优先级，如果过程较复杂， 则需要进行判断。</p>
</li>
<li><p>优先级天花板：</p>
<p>  优先级天花板是当任务<strong>申请某资源</strong>时， 把<strong>该任务的优先级提升到可访问这个资源的所有任务中的最高优先级</strong>， 这个优先级称为该资源的优先级天花板。这种方法简单易行， 不必进行复杂的判断， 不管任务是否阻塞了高优先级任务的运行， 只要任务访问共享资源都会提升任务的优先级。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/" data-id="cleqef3ur004nogjof9z48uug" data-title="【操作系统】第八章：CPU调度" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【操作系统】第五章：虚拟内存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.675Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">【操作系统】第五章：虚拟内存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h1><p>随着技术发展，程序对内存的需求越来越大</p>
<p>我们需要更大的内存更强的机器才能让软件跑起来</p>
<p><strong>程序规模的增长远大于存储器容量的增长速度</strong></p>
<p>需要让更多的程序跑在有限的内存里</p>
<p>理想中的存储器：</p>
<ul>
<li>更大</li>
<li>更快</li>
<li>更便宜</li>
<li>非易失性存储器</li>
</ul>
<img src="【操作系统】第五章：虚拟内存/image-20200419172905391.png" alt="image-20200419172905391" style="zoom: 80%;" />



<h1 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h1><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>在较小可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>把程序按照其自身逻辑结构，划分为若干功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行<ul>
<li>必要部分的代码和数据<strong>常驻内存</strong></li>
<li>可选部分在其他程序模块中实现，平时放在外存，<strong>需要时装入内存</strong></li>
<li>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖，<strong>即他们可以公用一个分区</strong></li>
</ul>
</li>
<li>例子：</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200419174839065.png" alt="image-20200419174839065"></p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>coder 把一个大程序分为若干小功能模块并确定覆盖关系，费时费力，增加编程复杂度</li>
<li>覆盖模块实际上是<strong>时间换空间</strong></li>
</ul>
<h1 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h1><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>将暂时不能运行的程序送到外存</li>
<li>OS 将一个进程的地址空间保存到外存（<strong>换出</strong>），再将外存中某个进程的地址空间读入到内存（<strong>换入</strong>）。（换入换出大小是整个程序的地址空间）</li>
</ul>
<h3 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h3><ul>
<li><p>何时交换？</p>
<p>  内存不够或有不够的危险时</p>
</li>
<li><p>交换区的大小？</p>
<p>  必须足够大来存放所有用户进程的所有内存映像拷贝</p>
</li>
<li><p>换出再换入后地址需要一样嘛？</p>
<p>  最好采用动态地址映射的方法（建立页表）</p>
</li>
</ul>
<h3 id="交换与覆盖区别"><a href="#交换与覆盖区别" class="headerlink" title="交换与覆盖区别"></a>交换与覆盖区别</h3><p>交换发生在<strong>程序之间</strong>，不需要程序员操作</p>
<p>覆盖发生在<strong>程序之内</strong>，需要程序员！</p>
<h1 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h1><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><ul>
<li>覆盖技术：程序员负担大</li>
<li>交换技术：处理器开销大</li>
<li>充分解决覆盖技术与交换技术存在的问题</li>
</ul>
<h3 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h3><ul>
<li><p>程序的局部性原理：程序在执行过程中的一个较短时期，所执行的指令地址和指令操作数地址分别局限于一定区域</p>
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul>
  <img src="【操作系统】第五章：虚拟内存/image-20200419183544017.png" alt="image-20200419183544017" style="zoom:80%;" />

  <img src="【操作系统】第五章：虚拟内存/image-20200419183746684.png" alt="image-20200419183746684" style="zoom:80%;" /></li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200419184200800.png" alt="image-20200419184200800"></p>
<h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200419184449532.png" alt="image-20200419184449532"></p>
<h3 id="虚拟页式内存管理"><a href="#虚拟页式内存管理" class="headerlink" title="虚拟页式内存管理"></a>虚拟页式内存管理</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200419184621909.png" alt="image-20200419184621909"></p>
<p>hhh，偷懒直接截屏了~~~</p>
<ul>
<li>需要用到的功能：<ul>
<li>请求调页</li>
<li>页面置换</li>
</ul>
</li>
</ul>
<img src="【操作系统】第五章：虚拟内存/image-20200419185124939.png" alt="image-20200419185124939" style="zoom:80%;" />

<img src="【操作系统】第五章：虚拟内存/image-20200419185256585.png" alt="image-20200419185256585" style="zoom:80%;" />

<p><img src="【操作系统】第五章：虚拟内存/image-20200419185600279.png" alt="image-20200419185600279" style="zoom:80%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200420122547152.png" alt="image-20200420122547152"></p>
<img src="【操作系统】第五章：虚拟内存/image-20200420122547152.png" alt="image-20200420122547152" style="zoom:80%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" data-id="cleqef3uq004jogjo3lokbau7" data-title="【操作系统】第五章：虚拟内存" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【操作系统】第三章：连续式内存分布" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.634Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/">【操作系统】第三章：连续内存分布</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="3-1-计算机体系结构及内存分层体系"><a href="#3-1-计算机体系结构及内存分层体系" class="headerlink" title="3.1 计算机体系结构及内存分层体系"></a>3.1 计算机体系结构及内存分层体系</h1><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417165432213.png" alt="image-20200417165432213"></p>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><ul>
<li><p>CPU：完成基本的对程序或软件的控制</p>
</li>
<li><p>内存：放置程序代码和他处理的数据</p>
<p>  <img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417170005686.png" alt="image-20200417170005686"></p>
</li>
<li><p>外设</p>
</li>
</ul>
<h3 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417170232005.png" alt="image-20200417170232005"></p>
<h3 id="操作系统管理内存的方法"><a href="#操作系统管理内存的方法" class="headerlink" title="操作系统管理内存的方法"></a>操作系统管理内存的方法</h3><ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存</li>
</ul>
<h1 id="3-2-地址空间和地址生成"><a href="#3-2-地址空间和地址生成" class="headerlink" title="3.2 地址空间和地址生成"></a>3.2 地址空间和地址生成</h1><h3 id="地址空间定义"><a href="#地址空间定义" class="headerlink" title="地址空间定义"></a>地址空间定义</h3><ul>
<li>物理地址空间 — 硬件支持的地址空间（<strong>主存和磁盘</strong>）</li>
<li>逻辑地址空间— 一个运行程序所拥有的内存范围（一维的线性空间）</li>
</ul>
<h3 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h3><ul>
<li>逻辑地址的生成</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417171957066.png" alt="image-20200417171957066"></p>
<ul>
<li><p>物理地址的生成</p>
<p>  <strong>CPU方面</strong></p>
<ol>
<li>计算器<strong>需要</strong>在逻辑地址的<strong>内存内容</strong></li>
<li>内存管理单元<strong>寻找</strong>在逻辑地址和物理地址之间的<strong>映射</strong></li>
<li>控制器从总线<strong>发送</strong>在物理地址的内存内容的<strong>请求</strong></li>
</ol>
<p>  <strong>内存方面</strong></p>
<ol start="4">
<li>内存<strong>发送</strong>物理地址内存的<strong>内容</strong>给CPU</li>
</ol>
<p>  <strong>操作系统方面</strong></p>
<ol start="5">
<li><strong>建立</strong>逻辑地址和物理地址之间的<strong>映射</strong></li>
</ol>
</li>
</ul>
<h3 id="地址安全检查"><a href="#地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查</h3><h1 id="3-3-连续内存分配"><a href="#3-3-连续内存分配" class="headerlink" title="3.3 连续内存分配"></a>3.3 连续内存分配</h1><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p>当我们给正在运行的程序分配空间之后，会出现一些空闲的空间（碎片）不能被利用</p>
<ul>
<li><p>外部碎片</p>
<p>  在分配单元<strong>间</strong>未使用的内存（程序空间之间的碎片）</p>
</li>
<li><p>内部碎片</p>
<p>  在分配单元<strong>中</strong>的未使用内存（在分配给程序的空间内部出现的碎片）</p>
</li>
</ul>
<h3 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h3><ul>
<li>简单的内存管理方法：<ul>
<li>当一个程序准许运行在内存中时，分配一个连续的区间</li>
<li>分配一个连续的内存区间给运行的程序以访问数据</li>
</ul>
</li>
</ul>
<h5 id="第一适配"><a href="#第一适配" class="headerlink" title="第一适配"></a>第一适配</h5><ul>
<li>找到第一个满足需求的空闲块立马返回</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417183628752.png" alt="image-20200417183628752"></p>
<ul>
<li>优点：<ul>
<li>简单</li>
<li>易于产生更大的空闲块，向着地址空间的结尾</li>
</ul>
</li>
<li>缺点<ul>
<li>容易产生外部碎片</li>
<li>不确定性</li>
</ul>
</li>
</ul>
<h5 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h5><ul>
<li>寻找空间中最满足需求的空闲块</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417183554657.png" alt="image-20200417183554657"></p>
<ul>
<li>优点：<ul>
<li>大部分分配是小尺寸时非常有效</li>
<li>比较简单</li>
</ul>
</li>
<li>缺点：<ul>
<li>分配时需要先将空闲块按大小排序进行查找，降低效率</li>
<li>易产生很多没怎么用的微小碎片</li>
</ul>
</li>
</ul>
<h5 id="最差适配"><a href="#最差适配" class="headerlink" title="最差适配"></a>最差适配</h5><ul>
<li>寻找空间中大小最不匹配的空闲块</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417183701187.png" alt="image-20200417183701187"></p>
<ul>
<li>优点：<ul>
<li>分配是中等尺寸时效果最好</li>
</ul>
</li>
<li>缺点：<ul>
<li>效率降低</li>
<li>容易破碎大的空闲块导致大分区无法被分配</li>
</ul>
</li>
</ul>
<h3 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h3><ul>
<li>重置程序以合并孔洞，要求所有程序是 <strong>动态可重置的</strong></li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417184612553.png" alt="image-20200417184612553"></p>
<ul>
<li>何时重置？</li>
<li>开销如何？</li>
</ul>
<h3 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h3><ul>
<li>运行程序需要更多的内存，抢占等待的程序并回收他们的内存</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417184629751.png" alt="image-20200417184629751"></p>
<ul>
<li>选择哪些程序进行交换？</li>
<li>何时进行？</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/" data-id="cleqef3uo004bogjo0u2uc2ml" data-title="【操作系统】第三章：连续内存分布" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【操作系统】第七章：进程和线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.619Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">【操作系统】第七章：进程和线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="7-1-进程的定义"><a href="#7-1-进程的定义" class="headerlink" title="7.1 进程的定义"></a>7.1 进程的定义</h1><img src="【操作系统】第七章：进程和线程/image-20200424205148926.png" alt="image-20200424205148926" style="zoom:67%;" />

<ul>
<li><p><strong>定义：</strong>一个具有一定独立功能的<strong>程序</strong>在一个数据集合上一次<strong>动态的执行过程</strong>。</p>
<p>  进程代表运行的程序的执行过程，需要消耗各种计算机的资源</p>
<p>  通过进程可以更好的表示程序的执行过程</p>
<p>  <strong>进程是程序动态执行的过程</strong></p>
</li>
</ul>
<h1 id="7-2-进程的组成"><a href="#7-2-进程的组成" class="headerlink" title="7.2 进程的组成"></a>7.2 进程的组成</h1><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><ul>
<li><strong>程序的代码</strong></li>
<li><strong>程序处理的数据</strong></li>
<li>程序计数器中的值，指示下一条将运行的指令</li>
<li>一组通用的寄存器的当前值，堆、栈</li>
<li>一组系统资源（如打开的程序）</li>
</ul>
<h3 id="进程与程序的联系（多对多）"><a href="#进程与程序的联系（多对多）" class="headerlink" title="进程与程序的联系（多对多）"></a>进程与程序的联系（多对多）</h3><ul>
<li>程序是产生进程的基础</li>
<li>程序的每次运行构成不同的进程</li>
<li>进程是程序功能的</li>
<li>通过多次执行，<strong>一个程序可对应多个进程</strong>；通过调用关系，<strong>一个进程可以包含多个程序</strong>。</li>
</ul>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><table>
<thead>
<tr>
<th align="center">进程</th>
<th align="center">程序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">动态的</td>
<td align="center">静态的</td>
</tr>
<tr>
<td align="center">暂时的</td>
<td align="center">永久的</td>
</tr>
<tr>
<td align="center">进程组成包含程序、数据、进程控制块</td>
<td align="center">……</td>
</tr>
</tbody></table>
<h1 id="7-3-进程的特点"><a href="#7-3-进程的特点" class="headerlink" title="7.3 进程的特点"></a>7.3 进程的特点</h1><ul>
<li>动态性：可动态的创建、结束进程</li>
<li>并发性：进程可以被独立调度并占用处理及运行</li>
<li>独立性：不同进程的工作不相互影响</li>
<li>制约性：因访问共享数据&#x2F;资源或进程间同步而产生制约</li>
</ul>
<p>&#x3D;&#x3D;程序 &#x3D; 算法 + 数据结构&#x3D;&#x3D;</p>
<p>描述进程的数据结构：<strong>进程控制块（Process Control Block，PCB）</strong></p>
<p>操作系统为每个进程维护了一个PCB，用来保存与该进程有关的各种信息状态</p>
<h1 id="7-4-进程的控制结构"><a href="#7-4-进程的控制结构" class="headerlink" title="7.4 进程的控制结构"></a>7.4 进程的控制结构</h1><p>进程控制块：操作系统管理控制进程运行所用的信息集合</p>
<p>操作系统用PCB来描述进程的基本情况以及运行变化的过程，<strong>PCB是进程存在的唯一标志</strong></p>
<p>进程控制块的使用：</p>
<ul>
<li>进程的创建：生成PCB</li>
<li>进程的终止：回收PCB</li>
<li>进程的组织管理</li>
</ul>
<p>PCB含有下列三大类信息：</p>
<ol>
<li><p>进程标识信息（pid）</p>
</li>
<li><p>处理机状态信息保存区（状态信息）</p>
<ul>
<li>用户可见寄存器、用户程序可以使用的数据、地址等寄存器</li>
<li>控制和状态控制器，如程序计数器（PC）、程序状态字（PSW）</li>
<li>栈指针，过程调用&#x2F;系统调用&#x2F;中断处理和返回时用到</li>
</ul>
</li>
<li><p>进程控制信息（控制信息）</p>
 <img src="【操作系统】第七章：进程和线程/image-20200424212652589.png" alt="image-20200424212652589" style="zoom:67%;" /></li>
</ol>
<img src="【操作系统】第七章：进程和线程/image-20200424213026940.png" alt="image-20200424213026940" style="zoom:67%;" />

<h1 id="7-5-进程的生命周期原理"><a href="#7-5-进程的生命周期原理" class="headerlink" title="7.5 进程的生命周期原理"></a>7.5 进程的生命周期原理</h1><p>进程的生命周期管理：</p>
<ul>
<li>进程创建</li>
<li>进程运行</li>
<li>进程等待</li>
<li>进程唤醒</li>
<li>进程结束</li>
</ul>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><img src="【操作系统】第七章：进程和线程/image-20200424213324923.png" alt="image-20200424213324923" style="zoom:67%;" />

<h3 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h3><img src="【操作系统】第七章：进程和线程/image-20200424213348158.png" alt="image-20200424213348158" style="zoom: 67%;" />

<h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><img src="【操作系统】第七章：进程和线程/image-20200424213450286.png" alt="image-20200424213450286" style="zoom:67%;" />

<h3 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h3><img src="【操作系统】第七章：进程和线程/image-20200424213605087.png" alt="image-20200424213605087" style="zoom:67%;" />

<h3 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h3><img src="【操作系统】第七章：进程和线程/image-20200424213718947.png" alt="image-20200424213718947" style="zoom:67%;" />

<h1 id="7-6-进程状态变化模型"><a href="#7-6-进程状态变化模型" class="headerlink" title="7.6 进程状态变化模型"></a>7.6 进程状态变化模型</h1><img src="【操作系统】第七章：进程和线程/image-20200424213908227.png" alt="image-20200424213908227" style="zoom:67%;" />

<img src="【操作系统】第七章：进程和线程/image-20200424213934958.png" alt="image-20200424213934958" style="zoom:67%;" />

<img src="【操作系统】第七章：进程和线程/image-20200424214214017.png" alt="image-20200424214214017" style="zoom:67%;" />

<h1 id="7-7-进程挂起"><a href="#7-7-进程挂起" class="headerlink" title="7.7 进程挂起"></a>7.7 进程挂起</h1><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20200424214727314.png" alt="image-20200424214727314"></p>
<h1 id="7-8-为什么使用线程"><a href="#7-8-为什么使用线程" class="headerlink" title="7.8 为什么使用线程"></a>7.8 为什么使用线程</h1><p>80年代中期，人们提出了比进程更小的<strong>能独立运行的基本单位</strong>——线程。</p>
<p>为什么要使用线程？</p>
<ul>
<li><p>案例：编写一个MP3播放软件</p>
<p>  核心模块功能：</p>
<ul>
<li>从MP3音频文件当中读取数据</li>
<li>对数据进行解压</li>
<li>把解压后的音频数据播放出来</li>
</ul>
  <img src="【操作系统】第七章：进程和线程/image-20200426101500455.png" alt="image-20200426101500455" style="zoom:67%;" />

  <img src="【操作系统】第七章：进程和线程/image-20200426101537425.png" alt="image-20200426101537425" style="zoom:67%;" />

<p>  如何来解决上述问题呢？</p>
<p>  我们需要一个新的实体来满足以下特性：</p>
<ul>
<li>实体之间可以<strong>并发的执行</strong></li>
<li>实体之间<strong>共享相同的地址</strong></li>
</ul>
<p>  这种实体就是，<strong>线程（Thread）</strong></p>
</li>
</ul>
<h1 id="7-9-什么是线程"><a href="#7-9-什么是线程" class="headerlink" title="7.9 什么是线程"></a>7.9 什么是线程</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>线程是进程当中的一条执行流程。</strong></p>
<p>进程的主要功能是管理资源，线程用来管理进程的执行资源。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p><strong>线程 &#x3D; 进程 - 共享资源</strong></p>
</li>
<li><p>线程的优点：</p>
<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各线程之间可以并发地执行</li>
<li>线程之间可以共享地址空间和文件等资源</li>
</ul>
</li>
<li><p>线程的缺点：</p>
<ul>
<li>安全可靠性没有保障，一个线程崩溃，会导致其所属的进程的所有线程崩溃</li>
</ul>
</li>
</ul>
<h3 id="线程与进程比较"><a href="#线程与进程比较" class="headerlink" title="线程与进程比较"></a>线程与进程比较</h3><table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>资源分配单位</td>
<td>CPU调度单位</td>
</tr>
<tr>
<td>拥有完整的资源平台</td>
<td>独享必不可少的资源，如寄存器、栈</td>
</tr>
<tr>
<td>具有<strong>就绪、阻塞、执行</strong>三种基本状态</td>
<td>具有<strong>就绪、阻塞、执行</strong>三种基本状态</td>
</tr>
</tbody></table>
<p>线程能减少并发执行的时间和空间开销：</p>
<ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同一进程内的线程切换时间比进程短</li>
<li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li>
</ul>
<h1 id="7-10-线程的实现"><a href="#7-10-线程的实现" class="headerlink" title="7.10 线程的实现"></a>7.10 线程的实现</h1><h3 id="用户线程：在用户空间实现"><a href="#用户线程：在用户空间实现" class="headerlink" title="用户线程：在用户空间实现"></a>用户线程：在用户空间实现</h3><p>操作系统看不到的线程</p>
<p>由专门的用户线程库来进行管理，包括线程的创建、终止、同步、调度等。</p>
<img src="【操作系统】第七章：进程和线程/image-20200426103953516.png" alt="image-20200426103953516" style="zoom:67%;" />

<ul>
<li>用户线程缺点：<ul>
<li>阻塞性的系统调用（读文件，可能发生阻塞），如果一个线程发起系统调用而阻塞，则整个进程在等待；</li>
<li>当一个线程开始运行后，除非他主动交出CPU的使用权，否则他所在的线程当中的其他线程将无法运行；</li>
<li>由于时间片分配给进程，故与其他进程相比，在多线程执行时，每个线程得到的时间片较少，执行较慢。</li>
</ul>
</li>
</ul>
<h3 id="内核线程：在内核中实现"><a href="#内核线程：在内核中实现" class="headerlink" title="内核线程：在内核中实现"></a>内核线程：在内核中实现</h3><p>操作系统能够看到并进行管理的线程</p>
<p>由操作系统本身进行管理</p>
<img src="【操作系统】第七章：进程和线程/image-20200426104620533.png" alt="image-20200426104620533" style="zoom:67%;" />

<h3 id="轻量级进程：在内核中实现，支持用户线程"><a href="#轻量级进程：在内核中实现，支持用户线程" class="headerlink" title="轻量级进程：在内核中实现，支持用户线程"></a>轻量级进程：在内核中实现，支持用户线程</h3><p>内核支持用户线程。一个进程可有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。</p>
<img src="【操作系统】第七章：进程和线程/image-20200426104921999.png" alt="image-20200426104921999" style="zoom:67%;" />

<h1 id="7-11-上下文切换"><a href="#7-11-上下文切换" class="headerlink" title="7.11 上下文切换"></a>7.11 上下文切换</h1><img src="【操作系统】第七章：进程和线程/image-20200426105252010.png" alt="image-20200426105252010" style="zoom:67%;" />

<p><img src="【操作系统】第七章：进程和线程/image-20200426105318686.png" alt="image-20200426105318686" style="zoom:67%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20200426105516465.png" alt="image-20200426105516465"></p>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20200426105516465.png" alt="image-20200426105516465"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" data-id="cleqef3un0048ogjoherg3oqv" data-title="【操作系统】第七章：进程和线程" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【探秘JVM】" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/01/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/" class="article-date">
  <time class="dt-published" datetime="2023-03-01T12:16:22.507Z" itemprop="datePublished">2023-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/01/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/">【初探JVM】</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>JVM是现在面试中的常客，多是些概念性的东西需要把它记住，这个时候可不能拉跨！</p>
<p>先来几道题练练手，心里有个数</p>
<ul>
<li>请你谈谈你对JVM的理解？</li>
<li><strong>Java8</strong>虚拟机和之前的<strong>变化</strong>更新？</li>
<li>什么是<strong>OOM</strong>？什么是栈溢出（<strong>StackOverFlowError</strong>）？怎么分析？</li>
<li>JVM常用的<strong>调优参数</strong>有哪些?</li>
<li>内存<strong>快照</strong>如何抓取、怎么分析<strong>Dump文件</strong>?</li>
<li>谈谈JVM中，<strong>类加载器</strong>的认识？</li>
<li>……</li>
</ul>
<p>懵逼了吧，那就来系统学习一波！</p>
<p>在学习的过程中会遇到很多抽象的概念，需要我们结合图式梳理分析，参考下面的网站：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.processon.com/view/5c749debe4b0f9fba6921d15">https://www.processon.com/view/5c749debe4b0f9fba6921d15</a></li>
<li><a target="_blank" rel="noopener" href="https://www.processon.com/view/5a7bff4be4b024b99bf5d30f">https://www.processon.com/view/5a7bff4be4b024b99bf5d30f</a></li>
<li><a target="_blank" rel="noopener" href="https://www.processon.com/view/5bc708cde4b08faf8c808c91#map">https://www.processon.com/view/5bc708cde4b08faf8c808c91#map</a></li>
</ul>
</blockquote>
<h1 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h1><h1 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h1><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502100551288.png" alt="image-20200502100551288"></p>
<p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502102116094.png" alt="image-20200502102116094"></p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​	加载Class文件</p>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502104222975.png" alt="image-20200502104222975"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>虚拟机自带的加载器</p>
</li>
<li><p>启动（根）加载器（BootStrap）</p>
<p>  它<strong>不是Java类</strong>，因此它不需要被别人加载，它嵌套在Java虚拟机内核里面，也就是JVM启动的时候Bootstrap就已经启动，它<strong>是用C++写的二进制代码</strong>（不是字节码），它<strong>可以去加载别的类</strong>。</p>
</li>
<li><p>扩展类加载器（Extension）</p>
</li>
<li><p>应用程序（系统）加载器（System）</p>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; aClass = person.getClass();</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line">        System.out.println(aClass.getClassLoader());	<span class="comment">//AppClassLoader</span></span><br><span class="line">        System.out.println(aClass.getClassLoader().getParent());	<span class="comment">//ExtClassLoader</span></span><br><span class="line">        System.out.println(aClass.getClassLoader().getParent().getParent());	</span><br><span class="line">        <span class="comment">//根加载器，java程序获取不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502105839415.png" alt="image-20200502105839415"></p>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，<strong>依次递归</strong>，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p>AppClassLoader——&gt;ExtClassLoader——&gt;Bootstrap（最终执行）</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>保证安全性</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果程序会报错：在类 <code>java.lang.String</code> 中找不到 <code>main</code> 方法</p>
<p>分析：程序不会先执行在自己创建的类中的方法，而是<strong>先委托给其父类加载器</strong>，最后在 jdk 自带的 <code>java.lang</code> 中<strong>找到要完成的类加载任务</strong>，会选择该类执行而不是自己创建的类，进而由于找不到 <code>main</code> 方法而报错。</p>
<ul>
<li>类加载器收到类加载请求</li>
<li>将这个请求向上委托给父类加载器完成，一直向上委托直到根类加载器</li>
<li>启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前的类加载器，否则就抛出异常，通知子加载器进行加载</li>
<li>重复上一步</li>
</ul>
<blockquote>
<p>能不能自己写个类叫<code>java.lang.System</code>？</p>
<p><strong>答案：</strong>通常不可以，但可以采取另类方法达到这个需求。<br><strong>解释：</strong>为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，<strong>自己写的System类根本没有机会得到加载。</strong></p>
<p>但是，我们可以<strong>自己定义一个类加载器来达到这个目的</strong>，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。</p>
</blockquote>
<h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h1><blockquote>
<p> 	Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p> 	所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html">https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html</a></p>
<h1 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简化版</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//在调用该方法后线程启动成功</span></span><br><span class="line">    start0();</span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。</p>
<p>JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。</p>
</blockquote>
<ul>
<li><p>JNI作用：扩展Java的使用，融合不同的编程语言为Java所用</p>
</li>
<li><p>在最终执行的时候，通过 JNI 加载本地方法库中的方法</p>
</li>
</ul>
<h1 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h1><blockquote>
<p>程序计数器是一个记录着当前线程所执行的字节码的行号指示器。</p>
<p>JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程</p>
</blockquote>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区是被所有线程所共享的，所有字段、方法字节码、特殊方法（构造函数、接口代码）等在此定义，<strong>属于共享空间</strong>。</p>
<ul>
<li>静态变量：<code>static</code></li>
<li>常量：<code>final</code></li>
<li>类信息：<code>Class</code></li>
<li>常量池</li>
</ul>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><blockquote>
<p>程序员学习思想：</p>
<p>​	程序 &#x3D; 数据结构 + 算法 √ （持续学习）</p>
<p>​	程序 &#x3D; 框架 + 业务逻辑 ×（很容易被淘汰，吃饭用的）</p>
</blockquote>
<h3 id="一个小问题：为什么-main-方法先执行，最后结束？"><a href="#一个小问题：为什么-main-方法先执行，最后结束？" class="headerlink" title="一个小问题：为什么 main 方法先执行，最后结束？"></a>一个小问题：为什么 <code>main</code> 方法先执行，最后结束？</h3><p>一个图解释清楚：<img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502115532577.png" alt="image-20200502115532577"></p>
<h3 id="再想想递归调用出现栈溢出是怎么肥四？"><a href="#再想想递归调用出现栈溢出是怎么肥四？" class="headerlink" title="再想想递归调用出现栈溢出是怎么肥四？"></a>再想想递归调用出现栈溢出是怎么肥四？</h3><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502115354355.png" alt="image-20200502115354355"></p>
<h3 id="对于栈来说，不存在垃圾回收问题"><a href="#对于栈来说，不存在垃圾回收问题" class="headerlink" title="对于栈来说，不存在垃圾回收问题"></a>对于栈来说，不存在垃圾回收问题</h3><h3 id="栈存放的内容"><a href="#栈存放的内容" class="headerlink" title="栈存放的内容"></a>栈存放的内容</h3><ul>
<li>8大基本类型</li>
<li>对象引用</li>
<li>实例的方法</li>
</ul>
<p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502120644868.png" alt="image-20200502120644868"></p>
<h3 id="类实例化的过程"><a href="#类实例化的过程" class="headerlink" title="类实例化的过程"></a>类实例化的过程</h3><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502122508381.png" alt="image-20200502122508381"></p>
<h1 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h1><p>了解即可</p>
<ul>
<li>Sun公司 - HotSpot</li>
<li>BEA - JRockit</li>
<li>IBM - J9VM</li>
</ul>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><strong>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</strong></p>
<p>类加载器读取了类文件后，一般会把什么东西放在堆中？</p>
<ul>
<li>类</li>
<li>方法</li>
<li>常量</li>
<li>变量</li>
</ul>
<p>保存引用类型的真实对象</p>
<p>堆内存中还要细分为三个区域：</p>
<ul>
<li>新生区（伊甸园区）</li>
<li>养老区</li>
<li>永久区</li>
</ul>
<img src="【探秘JVM】/image-20200502143710520.png" alt="image-20200502143710520" style="zoom:67%;" />

<p><strong>GC垃圾回收主要是在伊甸园区和养老区！</strong></p>
<p>堆内存满了会爆出 OutOfMemoryError：Java heap space</p>
<p>JDK8以后，永久区——&gt;元空间</p>
<h1 id="新生区、老年区"><a href="#新生区、老年区" class="headerlink" title="新生区、老年区"></a>新生区、老年区</h1><h3 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h3><p>对象诞生、成长甚至死亡的地方</p>
<ul>
<li><p>伊甸园区</p>
<p>  所有对象都是在伊甸园区 <code>new</code> 出来的</p>
</li>
<li><p>幸存区</p>
<ul>
<li>0区</li>
<li>1区</li>
</ul>
</li>
</ul>
<p><strong>经过研究，99%的对象都是临时对象！</strong></p>
<h1 id="永生区（元空间）"><a href="#永生区（元空间）" class="headerlink" title="永生区（元空间）"></a>永生区（元空间）</h1><p>这个区域是常驻的，用来存放 JDK 自身携带的 Class 对象。Interface 元空间，存储的是Java运行时的一些环境或类信息，这个区域不存在 GC。关闭 JVM 时这个区域的内存被释放。</p>
<ul>
<li>JDK1.6 之前：永久带，常量池在方法区中</li>
<li>JDK1.7        ：永久带，但是慢慢退化了（去永久带），常量池在堆中</li>
<li>JDK1.8之后：无永久带，常量池在元空间</li>
</ul>
<h1 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h1><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200503161549133.png" alt="image-20200503161549133"></p>
<p>Dump文件：</p>
<p>使用命令 <code>-XX:HeapDumpOnxxxError</code>、<code>-XX:HeapDumpOnxxxException</code></p>
<p>可以生成关于异常的文件，使用插件 Jprofilter 可以对其进行分析</p>
<p>排除OOM错误故障的方法：</p>
<ul>
<li>能够看到代码第几行出错：内存快照分析工具，MAT（Eclipse）、Jprofiler（IDEA）</li>
<li>Debug</li>
</ul>
<p><strong>MAT、Jprofiler作用</strong></p>
<ul>
<li>分析Dump内存文件，快速定位内存泄露</li>
<li>获得堆中的数据</li>
<li>获得大的对象</li>
<li>……</li>
</ul>
<h1 id="GC：垃圾回收"><a href="#GC：垃圾回收" class="headerlink" title="GC：垃圾回收"></a>GC：垃圾回收</h1><h3 id="一些GC的问题"><a href="#一些GC的问题" class="headerlink" title="一些GC的问题"></a>一些GC的问题</h3><ul>
<li>JVM的内存模型和分区（详细到每个区放什么）</li>
<li>堆里面的分区有哪些？Eden、from、to、老年区，说说他们的特点</li>
<li>GC算法有哪些？怎么用？</li>
<li>轻GC 和 重GC 分别在什么时候发生</li>
</ul>
<h3 id="GC的作用区域"><a href="#GC的作用区域" class="headerlink" title="GC的作用区域"></a>GC的作用区域</h3><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200503194655724.png" alt="image-20200503194655724"></p>
<p>JVM在进行GC时，并不是对新生代、幸存区（from、to）、老年去进行统一回收，<strong>大部分回收的都是新生代</strong>。</p>
<h3 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h3><ul>
<li>轻GC（普通GC）</li>
<li>重GC（全局GC）</li>
</ul>
<h3 id="GC的算法"><a href="#GC的算法" class="headerlink" title="GC的算法"></a>GC的算法</h3><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h4><p>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，<strong>无法解决对象相互循环引用</strong>的问题。</p>
<h4 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h4><img src="【探秘JVM】/image-20200503200832689.png" alt="image-20200503200832689" style="zoom:150%;" />

<p>当一个对象经历了 <strong>15次</strong> GC还没有被清除，就会进入老年代。</p>
<p>（可以使用参数 <code>-XX:MaxTenuringThreshold=?</code>来进行调节）</p>
<ul>
<li>好处：没有内存碎片</li>
<li>坏处：浪费了空间</li>
<li>使用场景：对象存活度较低的区域—新生区。</li>
</ul>
<h4 id="3-标记清除算法"><a href="#3-标记清除算法" class="headerlink" title="3.标记清除算法"></a>3.标记清除算法</h4><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200503203352254.png" alt="image-20200503203352254"></p>
<ul>
<li>优点：不需要浪费额外的空间</li>
<li>缺点：两次扫描，严重浪费时间，会产生内存碎片</li>
</ul>
<h4 id="4-标记压缩算法"><a href="#4-标记压缩算法" class="headerlink" title="4.标记压缩算法"></a>4.标记压缩算法</h4><p>对标记清除算法的优化</p>
<p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200503203646419.png" alt="image-20200503203646419"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="内存效率"><a href="#内存效率" class="headerlink" title="内存效率"></a>内存效率</h4><p><code>复制算法 &gt; 标记清除算法 &gt;  标记压缩算法</code> </p>
<h4 id="内存整齐度"><a href="#内存整齐度" class="headerlink" title="内存整齐度"></a>内存整齐度</h4><p><code>复制算法 = 标记压缩算法 &gt; 标记清除算法</code></p>
<h4 id="内存利用率"><a href="#内存利用率" class="headerlink" title="内存利用率"></a>内存利用率</h4><p><code>标记压缩算法 = 标记清除算法 &gt; 复制算法</code></p>
<blockquote>
<ul>
<li>思考：难道没有最优的算法嘛？</li>
<li>答案：莫得，只有最合适的</li>
<li>GC：分代收集算法</li>
</ul>
</blockquote>
<p>完结撒花~~~~~~~~~</p>
<p><strong>狂神，永远滴神！！！</strong></p>
<p>完了之后抽空深入了解JVM，看<strong>《深入理解JVM原理》</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iJ411d7jS">https://www.bilibili.com/video/BV1iJ411d7jS</a></p>
<p>程序媛想事儿：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanxuezaipiao/p/4138511.html">https://www.cnblogs.com/lanxuezaipiao/p/4138511.html</a></p>
<p>不止吧：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/b3051/p/7484501.html">https://www.cnblogs.com/b3051/p/7484501.html</a></p>
<p>re-phoenix：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/manayi/p/9290490.html">https://www.cnblogs.com/manayi/p/9290490.html</a></p>
<p>春_：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43736084/article/details/103937547">https://blog.csdn.net/weixin_43736084/article/details/103937547</a></p>
<p>纯洁的微笑：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ityouknow/p/5614961.html">https://www.cnblogs.com/ityouknow/p/5614961.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wxshhh.github.io/2023/03/01/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/" data-id="cleqef3ul0043ogjo4ex515hy" data-title="【初探JVM】" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/" rel="tag">狂神说Java</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%80%83%E7%A0%94/">考研</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatisPlus/" rel="tag">MyBatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLP/" rel="tag">NLP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OD/" rel="tag">OD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Project/" rel="tag">Project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringSecurity/" rel="tag">SpringSecurity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shiro/" rel="tag">shiro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" rel="tag">尚硅谷</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/" rel="tag">异常检测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" rel="tag">文献阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag">源码阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/" rel="tag">狂神说Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%BF%E9%87%8C%E4%BA%91/" rel="tag">阿里云</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 18.33px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/LeetCode/" style="font-size: 19.17px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 17.5px;">Linux</a> <a href="/tags/MyBatisPlus/" style="font-size: 10px;">MyBatisPlus</a> <a href="/tags/MySQL/" style="font-size: 11.67px;">MySQL</a> <a href="/tags/NLP/" style="font-size: 12.5px;">NLP</a> <a href="/tags/OD/" style="font-size: 13.33px;">OD</a> <a href="/tags/Project/" style="font-size: 11.67px;">Project</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Spring/" style="font-size: 11.67px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/SpringSecurity/" style="font-size: 10px;">SpringSecurity</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/shiro/" style="font-size: 10px;">shiro</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 11.67px;">前端</a> <a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" style="font-size: 17.5px;">尚硅谷</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">并发编程</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/" style="font-size: 10.83px;">异常检测</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15.83px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 11.67px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" style="font-size: 12.5px;">文献阅读</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 16.67px;">机器学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 14.17px;">源码阅读</a> <a href="/tags/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/" style="font-size: 15px;">狂神说Java</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E8%80%83%E7%A0%94/" style="font-size: 18.33px;">考研</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机组成原理</a> <a href="/tags/%E9%98%BF%E9%87%8C%E4%BA%91/" style="font-size: 10px;">阿里云</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">【考研】计算机组成原理知识点梳理</a>
          </li>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%80%83%E7%A0%94%E5%A5%8B%E6%96%97%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%81/">【考研】考研冲冲冲！</a>
          </li>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">【考研】数据结构知识点总结</a>
          </li>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/">【机器学习光速入门】</a>
          </li>
        
          <li>
            <a href="/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%EF%BC%9APyOD%E5%BA%93%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/">【机器学习】异常检测：PyOD库中的算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 wxshhh<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>