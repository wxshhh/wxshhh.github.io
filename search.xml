<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>【Ajax和Json】</title>
    <url>/2023/03/01/%E3%80%90Ajax%E5%92%8CJson%E3%80%91/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img src="/%E3%80%90Ajax%E5%92%8CJson%E3%80%91/image-20200516180438430.png" alt="image-20200516180438430"></p>
<h3 id="Web1-0时代"><a href="#Web1-0时代" class="headerlink" title="Web1.0时代"></a>Web1.0时代</h3><blockquote>
<p>web1.0时代是一个群雄并起，逐鹿网络的时代，虽然各个网站采用的手段和方法不同，但第一代<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186">互联网</a>有诸多共同的特征，表现在技术创新主导模式、基于点击流量的盈利共通点、门户合流、明晰的主营兼营产业结构、动态网站。在WEB1.0上做出巨大贡献的公司有<a href="https://baike.baidu.com/item/Netscape">Netscape</a>，<a href="https://baike.baidu.com/item/Yahoo">Yahoo</a>和<a href="https://baike.baidu.com/item/Google">Google</a>。 Netscape研发出第一个大规模商用的浏览器，Yahoo的<a href="https://baike.baidu.com/item/%E6%9D%A8%E8%87%B4%E8%BF%9C/709484">杨致远</a>提出了互联网黄页， 而Google后来居上，推出了大受欢迎的搜索服务。</p>
</blockquote>
<p>早期网站进行登陆操作，如果登陆失败，必须要<strong>刷新整个页面</strong>才能重新登陆，不点击提交按钮就不知道自己的密码输错了。</p>
<h3 id="Web2-0时代"><a href="#Web2-0时代" class="headerlink" title="Web2.0时代"></a>Web2.0时代</h3><blockquote>
<p>Web2.0是相对于<a href="https://baike.baidu.com/item/Web1.0">Web1.0</a>的新的时代。指的是一个利用Web的平台，由用户主导而生成的内容互联网产品模式，为了区别传统由网站雇员主导生成的内容而定义为第二代<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186">互联网</a>，web2.0是一个新的时代。 [1] 抛开纷繁芜杂的Web 2.0现象，进而将其放到科技发展与社会变革的大视野下来看，Web 2.0可以说是信息技术发展引发网络革命所带来的面向未来、以人为本的<a href="https://baike.baidu.com/item/%E5%88%9B%E6%96%B02.0">创新2.0</a>模式在互联网领域的典型体现，是由专业人员织网到所有用户参与织网的创新民主化进程的生动注释。</p>
</blockquote>
<p>Web2.0，最重要的一个因素就是 <strong>Ajax</strong>，通过 Ajax，网站可以<strong>实现局部刷新</strong>。</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote>
<p><a href="https://baike.baidu.com/item/JSON">JSON</a>(<a href="https://baike.baidu.com/item/JavaScript">JavaScript</a> Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 <a href="https://baike.baidu.com/item/ECMAScript">ECMAScript</a> (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>
</blockquote>
<p><strong>在 JS 语言中，一切皆对象</strong></p>
<h3 id="要求和语法格式"><a href="#要求和语法格式" class="headerlink" title="要求和语法格式"></a>要求和语法格式</h3><ul>
<li>对象表示为键值对</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<h3 id="JSON-和-JS对象"><a href="#JSON-和-JS对象" class="headerlink" title="JSON 和 JS对象"></a>JSON 和 JS对象</h3><ul>
<li>实例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个JS对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;world&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//这是一个Json字符串，本质是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;hello&quot;, &quot;b&quot;: &quot;world&quot;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>相互转化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用JSON.parse()将JSON字符串转化为JS对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;a&quot;: &quot;hello&quot;, &quot;b&quot;: &quot;world&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">//使用JSON.stringify()将JS对象转化为JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">a</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;world&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>在 <strong>SpringMVC</strong> 的使用中，我们经常会用到注解 <strong>@ResponseBody</strong> </p>
<p><strong>@ResponseBody</strong> 注解的作用是 将 controller 的方法返回的对象通过适当的转换器转化为指定的格式之后，写入到 response 对象的 body 区，通常用来返回 <strong>JSON数据</strong> 或者是 XML，在使用此注解之后不会再走视图处理器。</p>
<p>简单来说，**@ResponseBody** 注解就是将后台的对象转换成 JSON字符串，返回到页面</p>
<ul>
<li><p>实例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(User user)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  前台收到的数据:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;&quot;userName&quot;:&quot;xxx&quot;,&quot;pwd&quot;:&quot;xxx&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Ajax（Asynchronous JavaScript and XML，<strong>异步的 JavaScript 和 XML</strong>）</p>
<p><strong>Ajax 是在无需重新加载整个网页的情况下，能够更新部分网页的技术。</strong></p>
<ul>
<li><p>实例：</p>
<p>  <img src="/%E3%80%90Ajax%E5%92%8CJson%E3%80%91/image-20200517092228344.png" alt="image-20200517092228344"></p>
<p>  在搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器返回一个搜索建议的列表</p>
</li>
<li><p>传统的网页，想要更新内容或者提交表单，都需要重新加载整个页面。</p>
</li>
<li><p>使用 Ajax 技术的网页，通过与后台服务器进行少量数据交互，就可以实现异步局部更新</p>
</li>
</ul>
<p>使用 Ajax ，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的 Web 用户界面。</p>
<h3 id="伪造Ajax"><a href="#伪造Ajax" class="headerlink" title="伪造Ajax"></a>伪造Ajax</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> myDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;currentTime&#x27;</span>).<span class="property">innerText</span> = myDate.<span class="title function_">getTime</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">loadPage</span> () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> targetURL = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;url&#x27;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myFrame&#x27;</span>).<span class="property">src</span> = targetURL;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入想要加载的地址：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;currentTime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;loadPage()&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;myFrame&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%;height: 500px&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/%E3%80%90Ajax%E5%92%8CJson%E3%80%91/image-20200517094747102.png" alt="image-20200517094747102"></p>
<h3 id="jQuery-中的-Ajax"><a href="#jQuery-中的-Ajax" class="headerlink" title="jQuery 中的 Ajax"></a>jQuery 中的 Ajax</h3><blockquote>
<p>jQuery 提供多个与 AJAX 有关的方法。</p>
<p>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中。</p>
<p><strong>提示：</strong>如果没有 jQuery，AJAX 编程还是有些难度的。</p>
<p>编写常规的 AJAX 代码并不容易，因为不同的浏览器对 AJAX 的实现并不相同。这意味着您必须编写额外的代码对浏览器进行测试。不过，jQuery 团队为我们解决了这个难题，我们只需要一行简单的代码，就可以实现 AJAX 功能。</p>
</blockquote>
<h5 id="jQuery-get-方法"><a href="#jQuery-get-方法" class="headerlink" title="jQuery $.get() 方法"></a>jQuery $.get() 方法</h5><p>$.get() 方法通过 HTTP GET 请求从服务器上请求数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URL：Controller请求（待载入页面的url）</span></span><br><span class="line"><span class="comment">//callback：回调函数</span></span><br><span class="line">$.<span class="title function_">get</span>(<span class="variable constant_">URL</span>,callback);</span><br></pre></td></tr></table></figure>

<h5 id="jQuery-post-方法"><a href="#jQuery-post-方法" class="headerlink" title="jQuery $.post() 方法"></a>jQuery $.post() 方法</h5><p>$.post() 方法通过 HTTP POST 请求从服务器上请求数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URL：Controller请求（待载入页面的url）</span></span><br><span class="line"><span class="comment">//data：发送的数据，供后端接收</span></span><br><span class="line"><span class="comment">//callback：回调函数</span></span><br><span class="line">$.<span class="title function_">post</span>(<span class="variable constant_">URL</span>,data,callback);</span><br></pre></td></tr></table></figure>

<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>实时监测用户名输入有误（不用点击提交）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ajax&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">ajax</span><span class="params">(String name, String pwd)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name)) &#123;</span><br><span class="line">            msg = <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg = <span class="string">&quot;用户名有误&quot;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">f</span> () &#123;</span></span><br><span class="line"><span class="language-javascript">      $.<span class="title function_">post</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: <span class="string">&#x27;localhost:8080/ajax&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;<span class="string">&#x27;name&#x27;</span>: $(<span class="string">&#x27;#name&#x27;</span>).<span class="title function_">val</span>()&#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (data.<span class="title function_">toString</span>() == <span class="string">&#x27;ok&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&#x27;#userInfo&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&#x27;#userInfo&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">          $(<span class="string">&#x27;#userInfo&#x27;</span>).<span class="property">innerHTML</span> = data</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  用户名：</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">onblur</span>=<span class="string">&quot;f()&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;userInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  密码：</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV1Pt411u7R3?t=34">https://www.bilibili.com/video/BV1Pt411u7R3?t=34</a></p>
<p>百度百科：<a href="https://baike.baidu.com/item/web1.0">https://baike.baidu.com/item/web1.0</a></p>
<p>百度百科：<a href="https://baike.baidu.com/item/web2.0">https://baike.baidu.com/item/web2.0</a></p>
<p>百度百科：<a href="https://baike.baidu.com/item/JSON/2462549">https://baike.baidu.com/item/JSON/2462549</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>【Docker】</title>
    <url>/2023/03/01/%E3%80%90Docker%E3%80%91/</url>
    <content><![CDATA[<h1 id="Dock概述"><a href="#Dock概述" class="headerlink" title="Dock概述"></a>Dock概述</h1><h3 id="常用地址"><a href="#常用地址" class="headerlink" title="常用地址"></a>常用地址</h3><ul>
<li><p>官网地址：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
</li>
<li><p>文档地址：<a href="https://docs.docker.com/">https://docs.docker.com/</a>       炒鸡详细！！</p>
</li>
<li><p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a>        类似于Github</p>
</li>
</ul>
<h3 id="为什么会出现Docker"><a href="#为什么会出现Docker" class="headerlink" title="为什么会出现Docker"></a>为什么会出现Docker</h3><p>一款产品要经过<strong>开发、测试、上线</strong>等过程，在不同的阶段可能会使用不同的环境、不同的应用配置。</p>
<p>故经常会有人发出这样的疑问：<strong>我这电脑上运行都整挺好的，怎么到你这就拉跨了呢？！</strong></p>
<p>这就关系到<strong>环境配置</strong>问题了，环境配置十分麻烦，得一个机器一个机器配置、部署，费时费力。</p>
<p>一般一个项目成型后要打成一个 jar包 ，环境得自己配，这时候docker就出现了</p>
<p>docker 把 [ jar包、Redis、Mysql、jdk、ES、……] <strong>（项目 + 环境）打包在一起</strong>，就可以解决这样的问题了。</p>
<p><strong>docker核心思想：隔离！</strong></p>
<p>docker通过隔离机制，可以将服务器利用到极致！</p>
<p><img src="/%E3%80%90Docker%E3%80%91/image-20200517172233728.png" alt="image-20200517172233728"></p>
<h3 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h3><ul>
<li><p>传统的虚拟机技术</p>
<p>  <img src="/%E3%80%90Docker%E3%80%91/image-20200517181221006.png" alt="image-20200517181221006"></p>
<p>  传统虚拟机，<strong>虚拟出一条硬件</strong>，<strong>运行一个完整的操作系统</strong>，然后在这个系统上安装和运行软件</p>
<p>  缺点：</p>
<ol>
<li>资源占用十分多</li>
<li>冗余步骤多</li>
<li>启动慢</li>
</ol>
</li>
<li><p>容器化技术</p>
<p>  <strong>容器化技术不是模拟的一个完整的操作系统</strong></p>
<p>  <img src="/%E3%80%90Docker%E3%80%91/image-20200517181501805.png" alt="image-20200517181501805"></p>
<p>  容器内的应用直接运行在宿主机的内容，<strong>容器是没有自己的内核的</strong>，<strong>也没有虚拟我们的硬件</strong>，所以就轻便了</p>
<p>  容器间相互隔离，每个容器内有自己的文件系统，互不影响！</p>
</li>
<li><p>DevOps（开发、运维）</p>
<ul>
<li><p><strong>应用更快的交付和部署</strong></p>
<p>  传统：开发写好一堆帮助文档交给运维，运维根据帮助文档安装程序测试运行</p>
<p>  Docker：打包镜像发布测试，一键运行</p>
</li>
<li><p><strong>更便捷的升级和扩缩容</strong></p>
</li>
<li><p><strong>更简单的系统运维</strong></p>
<p>  在容器化后，开发、测试环境都是高度一致的</p>
</li>
<li><p><strong>更高效的计算机资源利用</strong></p>
<p>  Docker 是<strong>内核级别的虚拟化</strong>，可以在一个物理机上运行很多容器实例！服务器性能可以压缩至极致。</p>
</li>
</ul>
</li>
</ul>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h3 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h3><img src="【Docker】/image-20200518175427253.png" alt="image-20200518175427253" style="zoom:80%;" />



<ul>
<li><p><strong>镜像（image）</strong></p>
<p>  Docker 镜像就好比是一个模板，可以通过这个模板创建容器服务</p>
</li>
<li><p><strong>容器（container）</strong></p>
<p>  Docker 利用容器技术，独立运行一个或一组应用，通过镜像来创建</p>
<p>  基本命令：启动、停止、删除……</p>
<p>  可以简单理解为一个简易的 Linux 系统</p>
</li>
<li><p><strong>仓库（repository）</strong></p>
<p>  存放镜像的地方</p>
<p>  分为公有仓库和私有仓库</p>
</li>
</ul>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><ol>
<li><p>环境准备</p>
<p> Docker需要搭建到 Linux 系统上</p>
<p> 我们这里用自己购买的阿里云服务器上的 CentOS 7 系统，使用Xshell进行远程连接</p>
<p> 没有的也可以用 Vmware 代替~</p>
</li>
<li><p>环境查看</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Welcome to Alibaba Cloud Elastic Compute Service !</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">系统内核是 3.10 以上的</span></span><br><span class="line">[admin@iZuf6iwj4bpbjtsf1yoaqlZ ~]$ uname -r</span><br><span class="line">3.10.0-514.26.2.el7.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">系统版本</span></span><br><span class="line">[admin@iZuf6iwj4bpbjtsf1yoaqlZ ~]$ cat /etc/os-release</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>正式安装</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.卸载旧版本</span></span><br><span class="line">yum remove docker \</span><br><span class="line">           docker-client \</span><br><span class="line">           docker-client-latest \</span><br><span class="line">           docker-common \</span><br><span class="line">           docker-latest \</span><br><span class="line">           docker-latest-logrotate \</span><br><span class="line">           docker-logrotate \</span><br><span class="line">           docker-engine</span><br><span class="line">                  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.设置镜像仓库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">国外的仓库，下载缓慢，不推荐</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo  </span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">阿里云的仓库，推荐！</span> </span><br><span class="line">yum-config-manager \</span><br><span class="line">	--add-repo \</span><br><span class="line">	http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.5.更新yum软件包索引</span>  </span><br><span class="line">yum makecache fast</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.安装 docker 相关的内容  docker-ce：社区版   docker-ee：企业版</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.查看docker是否安装成功</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p> <img src="/%E3%80%90Docker%E3%80%91/image-20200521171850570.png" alt="image-20200521171850570"></p>
</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li><p>运行hello-world</p>
<p> <code>docker run hello-world</code></p>
<p> <img src="/%E3%80%90Docker%E3%80%91/image-20200521172144938.png" alt="image-20200521172144938"></p>
</li>
<li><p>查看下载的镜像</p>
<p> <code>docker images</code></p>
<p> <img src="/%E3%80%90Docker%E3%80%91/image-20200521172345307.png" alt="image-20200521172345307"></p>
</li>
<li><p>梳理流程</p>
<p> <img src="/%E3%80%90Docker%E3%80%91/image-20200521174420079.png" alt="image-20200521174420079"></p>
</li>
</ol>
<h3 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.卸载依赖</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.删除资源</span></span><br><span class="line">re -rf /var/lib/docker	#docker的默认工作路径</span><br></pre></td></tr></table></figure>



<h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><ol>
<li><p>登录阿里云，找到容器镜像服务</p>
<p> <img src="/%E3%80%90Docker%E3%80%91/image-20200521173233168.png" alt="image-20200521173233168"></p>
</li>
<li><p>找到镜像加速地址</p>
<p> <img src="/%E3%80%90Docker%E3%80%91/image-20200521173534263.png" alt="image-20200521173534263"></p>
</li>
<li><p>配置使用</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://ljk3xy6r.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>1. Docker时怎么工作的？</strong></p>
<p>Docker 是一个 Client-Server 结构的系统，Docker 的守护进程运行在主机上，通过 Socket 从客户端访问</p>
<p>Docker-Server 收到 Docker-Client 的指令，就会执行这个命令！</p>
<p><img src="/%E3%80%90Docker%E3%80%91/image-20200522114439607.png" alt="image-20200522114439607"></p>
<p><strong>2. Docker 为什么比 VM 快？</strong></p>
<ol>
<li><p>Docker 有比虚拟机更少的抽象层</p>
</li>
<li><p>Docker 利用的是宿主机的内核，VM 需要的是Guest OS</p>
 <img src="【Docker】/image-20200522114647782.png" alt="image-20200522114647782" style="zoom:67%;" /></li>
</ol>
<p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载 Guest OS，<strong>分钟级别</strong>的，而daocker 利用宿主机的操作系统，省略了这个复杂的过程，是<strong>秒级别</strong>的！</p>
<p><img src="/%E3%80%90Docker%E3%80%91/image-20200522115133985.png" alt="image-20200522115133985"></p>
<h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version		# 显示docker的版本信息</span><br><span class="line">docker info			# 显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help   # 帮助命令</span><br></pre></td></tr></table></figure>

<p>帮助文档的地址：<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h5 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列举镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY	镜像的仓库源</span><br><span class="line">TAG			镜像的标签(版本)</span><br><span class="line">IMAGE ID	镜像的id</span><br><span class="line">CREATED		镜像的创建时间</span><br><span class="line">SIZE		镜像的大小</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用可选项</span></span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">  -q, --quiet           Only show numeric IDs</span><br></pre></td></tr></table></figure>

<h5 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搜索镜像</span></span><br><span class="line">docker search 镜像名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">NAME                              </span><br><span class="line">DESCRIPTION 	                                    </span><br><span class="line">STARS           收藏数    </span><br><span class="line">OFFICIAL        是否来自官方    </span><br><span class="line">AUTOMATED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用可选项</span></span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don&#x27;t truncate output</span><br><span class="line">      </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实例</span></span><br><span class="line">docker search mysql --filter=starts=3000  	# 收藏数不小3000的</span><br></pre></td></tr></table></figure>

<h5 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像</span></span><br><span class="line">docker pull 镜像名 [:tag]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">[root@wxshhh ~]# docker pull mysql</span><br><span class="line">Using default tag: latest				# 不设置tag，默认下载最新版</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">afb6ec6fdc1c: Pull complete 			# 分层下载，docker image的核心</span><br><span class="line">0bdc5971ba40: Pull complete </span><br><span class="line">97ae94a2c729: Pull complete </span><br><span class="line">f777521d340e: Pull complete </span><br><span class="line">1393ff7fc871: Pull complete </span><br><span class="line">a499b89994d9: Pull complete </span><br><span class="line">7ebe8eefbafe: Pull complete </span><br><span class="line">597069368ef1: Pull complete </span><br><span class="line">ce39a5501878: Pull complete </span><br><span class="line">7d545bca14bf: Pull complete </span><br><span class="line">211e5bb2ae7b: Pull complete </span><br><span class="line">5914e537c077: Pull complete </span><br><span class="line">Digest: sha256:a31a277d8d39450220c722c1302a345c84206e7fd4cdb619e7face046e89031d # 签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest			# 真实地址</span><br><span class="line"></span><br><span class="line">docker pull mysql 等价于 docker pull docker.io/library/mysql:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本下载</span></span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<h5 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi -f 镜像id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除多个镜像</span></span><br><span class="line">docker rmi -f 镜像id 镜像id 镜像id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除全部镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)</span><br></pre></td></tr></table></figure>



<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>说明：我们有了镜像才可以创建容器，先要下载一个 CentOS 镜像来学习</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>

<h5 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">	-- name=&quot;Name&quot;		# 容器名字，用来区分容器</span><br><span class="line">	-d 					# 后台方式运行</span><br><span class="line">	-it					# 使用交互方式运行，进入容器查看内容</span><br><span class="line">	-p(小写)			   # 指定容器端口 -p 8080:8080</span><br><span class="line">		-p ip:主机端口:容器端口</span><br><span class="line">		-p 主机端口:容器端口(常用)</span><br><span class="line">		-p 容器端口</span><br><span class="line">		容器端口</span><br><span class="line">	-P(大写)			   # 随机指定端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试，启动并进入容器</span></span><br><span class="line">[root@iZuf6iwj4bpbjtsf1yoaqlZ ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@7a98c694480d /]# </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器内的centos，基础版本很多命令是不完善的</span></span><br><span class="line">[root@7a98c694480d /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出容器到主机</span></span><br><span class="line">[root@7a98c694480d /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@iZuf6iwj4bpbjtsf1yoaqlZ ~]# </span><br><span class="line">[root@iZuf6iwj4bpbjtsf1yoaqlZ /]# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<h5 id="列出正在运行的容器"><a href="#列出正在运行的容器" class="headerlink" title="列出正在运行的容器"></a>列出正在运行的容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用参数</span></span><br><span class="line">	-a 				# 列出当前正在运行的容器和历史运行过的容器</span><br><span class="line">	-n=?			# 显示最近创建的容器</span><br><span class="line">	-q				# 只显示容器的编号</span><br><span class="line"></span><br><span class="line">[root@iZuf6iwj4bpbjtsf1yoaqlZ /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@iZuf6iwj4bpbjtsf1yoaqlZ /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">7a98c694480d        centos              &quot;/bin/bash&quot;         4 minutes ago       Exited (0) 2 minutes ago                       dazzling_matsumoto</span><br><span class="line">8bdd901e69de        hello-world         &quot;/hello&quot;            20 hours ago        Exited (0) 20 hours ago                        funny_leavitt</span><br></pre></td></tr></table></figure>

<h5 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器之间停止并退出</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器不停止，退出</span></span><br><span class="line">Ctrl + P + Q </span><br></pre></td></tr></table></figure>

<h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定<span class="built_in">id</span>删除容器,不能删除正在运行的容器，如果要强制删除，用 -f 参数</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有容器</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure>

<h5 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动容器</span></span><br><span class="line">docker start 容器id</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器id</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止当前正在运行的容器</span></span><br><span class="line">docker stop 容器id</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">强制停止容器</span></span><br><span class="line">docker kill 容器id</span><br></pre></td></tr></table></figure>



<h3 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h3><h5 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d 镜像名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常见的坑</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 ps 查看，发现centos停止了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx，容器启动后，发现自己没有提供服务，就会立刻停止</span></span><br></pre></td></tr></table></figure>

<h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -tf --tail 行数 容器id</span><br></pre></td></tr></table></figure>

<h5 id="查看容器中的进程信息"><a href="#查看容器中的进程信息" class="headerlink" title="查看容器中的进程信息"></a>查看容器中的进程信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure>

<h5 id="查看镜像元数据"><a href="#查看镜像元数据" class="headerlink" title="查看镜像元数据"></a>查看镜像元数据</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<h5 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们通常容器都是后台方式运行的，有时需要进入容器修改一些配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">区别</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span>		进入容器后开启一个新的终端，可以在里面操作</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker attach		进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure>

<h5 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 目的的主机路径</span><br></pre></td></tr></table></figure>







<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV1og4y1q7M4">https://www.bilibili.com/video/BV1og4y1q7M4</a>?</p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>狂神说Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go面试常备】</title>
    <url>/2023/03/12/%E3%80%90Go%E9%9D%A2%E8%AF%95%E5%B8%B8%E5%A4%87%E3%80%91/</url>
    <content><![CDATA[<h2 id="Go语言基础"><a href="#Go语言基础" class="headerlink" title="Go语言基础"></a>Go语言基础</h2><h5 id="1-什么是协程"><a href="#1-什么是协程" class="headerlink" title="1. 什么是协程"></a>1. 什么是协程</h5><ul>
<li>携程是一种<strong>用户态轻量级线程</strong>，是<strong>线程调度的基本单位</strong></li>
<li>通常在函数前加关键字 <code>go</code> 就可以实现</li>
<li>一个Goroutine会以一个<strong>很小的栈启动</strong>（2KB或4KB），当遇到栈空间不足时，栈会<strong>自动伸缩</strong>， 因此可以轻易实现成千上万个goroutine同时启动</li>
</ul>
<h5 id="2-高效拼接字符串-💖"><a href="#2-高效拼接字符串-💖" class="headerlink" title="2. 高效拼接字符串 💖"></a>2. 高效拼接字符串 💖</h5><p>拼接字符串的方式有：<code>+</code>、<code>fmt.Sprintf</code>、<code>strings.Builder</code>、<code>bytes.Buffer</code>、<code>strings.Join</code></p>
<ol>
<li><code>+</code><br> 使用 <code>+</code> 对字符串进行拼接时，需要对字符串进行<strong>遍历</strong>，计算并<strong>开辟一个新的空间</strong>来存储新的字符串</li>
<li><code>fmt.Sprintf</code><br> 采用了<strong>接口参数</strong>，必须要用<strong>反射</strong>获取值，有一定的性能损耗</li>
<li><code>strings.Builder</code><br> 使用 <code>WriteString</code> 进行拼接，内部实现是：<strong>指针+切片</strong>，同时使用 <code>String()</code> 返回拼接后的字符串。它是直接把 <code>[]byte</code> 转化成 <code>string</code>，从而避免了变量拷贝</li>
<li><code>bytes.Buffer</code><br> <code>bytes.Buffer</code> 是一个缓冲 <code>byte</code> 的缓冲器。<code>bytes.Buffer</code> 的底层也是一个 <strong><code>[]byte</code></strong></li>
<li><code>strings.Join</code><br> <code>strings.Join</code> 也是基于 <strong><code>strings.builder</code></strong> 来实现的，并且可以自定义分隔符，在 join 方法内调用了 <strong>b.Grow(n)</strong> 方法，这个是进行初步的容量分配，而前面计算的n的长度就是我们要拼接的slice的长度，因为我们传入切片长度固定，所以提前进行容量分配可以减少内存分配，很高效。</li>
</ol>
<p>性能比较：<code>strings.Join</code> ≈ <code>strings.Builder</code> &gt; <code>bytes.Buffer</code> &gt; <code>+</code> &gt; <code>fmt.Sprintf</code></p>
<p>五种拼接方式代码实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//方式1：+</span></span><br><span class="line">	ret := a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//方式2：fmt.Sprintf</span></span><br><span class="line">	ret := fmt.Sprintf(<span class="string">&quot;%s%s%s&quot;</span>, a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//方式3：strings.Builder</span></span><br><span class="line">	<span class="keyword">var</span> sb strings.Builder</span><br><span class="line">	sb.WriteString(a[<span class="number">0</span>])</span><br><span class="line">	sb.WriteString(a[<span class="number">1</span>])</span><br><span class="line">	sb.WriteString(a[<span class="number">2</span>])</span><br><span class="line">	ret := sb.String()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//方式4：bytes.Buffer</span></span><br><span class="line">	buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	buf.Write(a[<span class="number">0</span>])</span><br><span class="line">	buf.Write(a[<span class="number">1</span>])</span><br><span class="line">	buf.Write(a[<span class="number">2</span>])</span><br><span class="line">	ret := buf.String()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//方式5：strings.Join</span></span><br><span class="line">	ret := strings.Join(a,<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-Go-是否支持默认参数-x2F-可选参数？"><a href="#3-Go-是否支持默认参数-x2F-可选参数？" class="headerlink" title="3. Go 是否支持默认参数&#x2F;可选参数？"></a>3. Go 是否支持默认参数&#x2F;可选参数？</h5><p>Go 语言不支持默认参数&#x2F;可选参数，但是可以通过结构体参数，或者传入参数切片数组来实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 可以传入任意数量的整型参数，会被当作一个整型切片处理</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        total += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**结构体参数是值传递**，如果需要修改结构体参数中的值，则应该传入结构体指针！</span><br></pre></td></tr></table></figure>

<h5 id="4-defer-执行顺序"><a href="#4-defer-执行顺序" class="headerlink" title="4. defer 执行顺序"></a>4. defer 执行顺序</h5><p><code>defer</code> 执行顺序与调用顺序相反，类似于栈的<strong>先入后出（FILO）</strong><br><code>defer</code> 会在 <code>return</code> 语句后执行，但是在函数退出之前，<code>defer</code> 可以修改返回值</p>
<p>在<strong>无名返回</strong>中，go 会创建临时变量保存返回值，在所有 <code>defer</code> 执行完毕后将临时变量保存的返回值返回<br>在有名返回中，执行 <code>return</code> 语句时，并不会再创建临时变量保存，因此，defer 语句修改了 i，即对返回值产生了影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无名返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;return&quot;</span>, test())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defer2</span></span><br><span class="line"><span class="comment">// defer1</span></span><br><span class="line"><span class="comment">// return 0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有名返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;return&quot;</span>, test())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defer2</span></span><br><span class="line"><span class="comment">// return 1</span></span><br></pre></td></tr></table></figure>

<h5 id="5-Go-语言中的-tag"><a href="#5-Go-语言中的-tag" class="headerlink" title="5. Go 语言中的 tag"></a>5. Go 语言中的 tag</h5><p>tag 用处：<br>tag 可以为结构体成员提供属性。常见的：</p>
<ol>
<li>json：序列化或反序列化时字段的名称</li>
<li>db：sqlx模块中对应的数据库字段名</li>
<li>form：gin框架中对应的前端的数据字段名</li>
<li>binding：搭配 form 使用，默认如果没查找到结构体中的某个字段则不报错值为空，binding 为 required 代表如果没找到则返回错误给前端</li>
</ol>
<p>如何获取一个结构体中的 tag：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用反射机制</span></span><br><span class="line"><span class="keyword">import</span> reflect </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Author <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name         <span class="type">int</span>      <span class="string">`json:Name`</span></span><br><span class="line">	Publications []<span class="type">string</span> <span class="string">`json:Publication,omitempty`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(Author&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		<span class="comment">// 获取属性</span></span><br><span class="line">		<span class="comment">// 调用 t.Filed(i) 返回一个 reflect.StructField 类型</span></span><br><span class="line">		attr := t.Field(i)</span><br><span class="line">		fmt.Println(attr.Name, attr.Tag)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Name json:Name</span></span><br><span class="line"><span class="comment">// Publications json:Publication,omitempty</span></span><br></pre></td></tr></table></figure>
<p>reflect.StructField：<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230312151856.png"></p>
<h5 id="6-如何判断两个字符串切片是否相等"><a href="#6-如何判断两个字符串切片是否相等" class="headerlink" title="6. 如何判断两个字符串切片是否相等"></a>6. 如何判断两个字符串切片是否相等</h5><p>可以使用 <code>reflect.DeepEqual(x, y any)</code> 来判断两个字符串数组(<code>[]string</code>) 是否相等<br>但是由于使用了反射，效率会很底</p>
<h5 id="7-格式化输出结构体"><a href="#7-格式化输出结构体" class="headerlink" title="7. 格式化输出结构体"></a>7. 格式化输出结构体</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">au := Author&#123;  </span><br><span class="line">   Name: <span class="string">&quot;jack&quot;</span>,  </span><br><span class="line">   Age:  <span class="number">20</span>,  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, au)  </span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, au)  </span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, au)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>%v</code>：输出结构体各成员的值<br><code>&#123;jack 20&#125;</code></li>
<li><code>%+v</code>：输出结构体各成员的<strong>名称</strong>和<strong>值</strong><br><code>&#123;Name:jack Age:20&#125;</code></li>
<li><code>%#v</code>：输出结构体全称和结构体各成员的名称和值<br><code>test.Author&#123;Name:&quot;jack&quot;, Age:20&#125;</code></li>
</ul>
<h5 id="8-空结构体的作用"><a href="#8-空结构体的作用" class="headerlink" title="8. 空结构体的作用"></a>8. 空结构体的作用</h5><p>在 Go 中，我们可以使用 <code>unsafe.Sizeof</code> 计算出一个数据类型实例需要占用的字节数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>我们不难发现<strong>一个空结构体实例不占用内存空间</strong><br>因为空结构体不占据内存空间，因此被广泛作为各种场景下的<strong>占位符</strong>使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符。</p>
<ol>
<li>&#x3D;&#x3D;实现 Set&#x3D;&#x3D;<br> Go 语言中本身没有 Set，一般来说我们可以使用 <code>map[string]bool</code> 来实现一个 Set，但是事实上我们只需要集合的键而不需要集合的值，即使是将值设置为 bool 类型，也会多占据 1 个字节的空间，假设 map 中有一百万条数据，就会浪费 1MB 的空间。<br> 因此呢，将 map 作为集合(Set)使用时，<strong>可以将值类型定义为空结构体</strong>，仅作为占位符使用即可。<br> <code>type Set map[string]struct&#123;&#125;</code></li>
<li>&#x3D;&#x3D;不发送数据的通道&#x3D;&#x3D;<br> 有时候使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine) 执行任务，或只用来控制协程并发度。这种情况下，使用空结构体作为占位符就非常合适了。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125;()</span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>&#x3D;&#x3D;仅有方法的结构体&#x3D;&#x3D;<br> 在部分场景下，结构体只包含方法，不包含任何的字段。例如上面例子中的 <code>Door</code>，在这种情况下，<code>Door</code> 事实上可以用任何的数据结构替代。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Door <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Door)</span></span> Open() &#123;  </span><br><span class="line">	fmt.Println(<span class="string">&quot;Open the door&quot;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Door)</span></span> Close() &#123;  </span><br><span class="line">	fmt.Println(<span class="string">&quot;Close the door&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="9-go里面的int和int32是同一个概念吗？"><a href="#9-go里面的int和int32是同一个概念吗？" class="headerlink" title="9. go里面的int和int32是同一个概念吗？"></a>9. go里面的int和int32是同一个概念吗？</h5><p>go 语言中的 int 不能和 int32 混为一谈，int32 的大小固定为 4 字节，而 <strong>int 的大小与操作系统位数有关</strong>，如果是 32 位操作系统则 int 占 4 字节，如果是64 位操作系统则 int 占 8 字节</p>
<table>
<thead>
<tr>
<th>类型</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td>int8</td>
<td align="center">1 字节</td>
</tr>
<tr>
<td>int16</td>
<td align="center">2 字节</td>
</tr>
<tr>
<td>int32</td>
<td align="center">4 字节</td>
</tr>
<tr>
<td>int64</td>
<td align="center">8 字节</td>
</tr>
<tr>
<td>int</td>
<td align="center">取决于操作系统位数</td>
</tr>
</tbody></table>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h5 id="1-init-是什么时候执行的？"><a href="#1-init-是什么时候执行的？" class="headerlink" title="1. init() 是什么时候执行的？"></a>1. init() 是什么时候执行的？</h5><p>结论：<strong>在 <code>mian()</code> 函数执行之前执行</strong></p>
<p><code>init()</code> 函数是 go 初始化的一部分，由 runtime 初始化每个导入的包，初始化的顺序不是从上到下的， 而是按照解析的依赖关系，没有依赖的包最先初始化。</p>
<p>每个包首先初始化包作用域的变量和常量（常量优先于变量），然后执行包的 <code>init()</code> 函数。<strong>同一个包、同一个源文件都可以有多个 <code>init()</code> 函数。</strong><code>init()</code> 函数没有参数和返回值，同一个包内多个 <code>init()</code> 函数的执行顺序没有保证。</p>
<p>执行顺序：**<code>import</code> –&gt; <code>const</code> –&gt; <code>var</code> –&gt;<code>init()</code>–&gt;<code>main()</code>**</p>
<h5 id="2-如何知道一个对象是分配在堆上还是在栈上的？💖"><a href="#2-如何知道一个对象是分配在堆上还是在栈上的？💖" class="headerlink" title="2. 如何知道一个对象是分配在堆上还是在栈上的？💖"></a>2. 如何知道一个对象是分配在堆上还是在栈上的？💖</h5><p>Go 和 C++ 不同，Go 的局部变量会进行<a href="https://geektutu.com/post/hpg-escape-analysis.html">逃逸分析</a>。如果变量离开作用域后没有被引用，则优先分配到栈上，否则分配到堆上。</p>
<p>如何判断是否发生了逃逸？</p>
<p><code>go build -gcflags=m xxx.go</code></p>
<p>关于逃逸的可能情况：变量大小不确定，变量类型不确定，变量分配的内存超过用户栈最大值，暴露给了外部指针。<br><img src="/../attachment/Pasted%20image%2020230123172527.png"></p>
<h5 id="3-两个-interface-可以进行比较吗"><a href="#3-两个-interface-可以进行比较吗" class="headerlink" title="3. 两个 interface 可以进行比较吗"></a>3. 两个 interface 可以进行比较吗</h5><p>在 Go 中，interface 内部实现包含了两个字段：类型 T 和值 V，interface 可以使用 <code>==</code> 和 <code>!=</code> 进行比较，满足以下情况时两个 interface 相等：</p>
<ol>
<li>两个 interface 均为 nil 时（T、V 此时均处于 unset 状态）</li>
<li>两个 interface T、V 均相同时</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">     Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StuInt <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> stu1, stu2 StuInt = &amp;Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;, &amp;Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">     <span class="keyword">var</span> stu3, stu4 StuInt = Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;, Stu&#123;<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">     fmt.Println(stu1 == stu2) <span class="comment">// false，stu1与stu2值是结构体的地址</span></span><br><span class="line">     fmt.Println(stu3 == stu4) <span class="comment">// true，stu3与stu4值是结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-两个-nil-可能不相等吗"><a href="#4-两个-nil-可能不相等吗" class="headerlink" title="4. 两个 nil 可能不相等吗"></a>4. 两个 nil 可能不相等吗</h5><p>有可能，interface 在运行时绑定值，只有值为 nil 的接口才是 nil，但此时与指针的 nil 不相等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">fmt.Println(p == i) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>总结：<strong>两个 nil 只有在类型相同时才相等</strong>。</p>
<h5 id="5-Go-垃圾回收💖"><a href="#5-Go-垃圾回收💖" class="headerlink" title="5. Go 垃圾回收💖"></a>5. Go 垃圾回收💖</h5><p>摘自：<br><a href="https://zhuanlan.zhihu.com/p/471490292">Go常见面试题【由浅入深】2022版</a><br>参考：<br><a href="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/">Golang垃圾回收(GC)介绍 | Random walk to my blog</a><br><a href="https://learnku.com/articles/59021">图解Golang垃圾回收机制！ | Go 技术论坛 - LearnKu</a></p>
<p>垃圾回收机制是Go一大特(nan)色(dian)。Go1.3采用<strong>标记清除法</strong>， Go1.5采用<strong>三色标记法</strong>，Go1.8采用<strong>三色标记法+混合写屏障</strong>。</p>
<ul>
<li><p><strong>标记清除法</strong><br>  分为两个阶段：标记和清除</p>
<p>  标记阶段：从根对象出发寻找并标记所有存活的对象。</p>
<p>  清除阶段：遍历堆中的对象，回收未标记的对象，并加入空闲链表。</p>
<p>  缺点是需要暂停程序STW。</p>
</li>
<li><p><strong>三色标记法</strong><br>  将对象标记为白色，灰色或黑色。</p>
<p>  白色：不确定对象（默认色）；黑色：存活对象。灰色：存活对象，子对象待处理。</p>
<p>  标记开始时，先将所有对象加入白色集合（需要STW）。首先将根对象标记为灰色，然后将一个对象从灰色集合取出，遍历其子对象，放入灰色集合。同时将取出的对象放入黑色集合，直到灰色集合为空。最后的白色集合对象就是需要清理的对象。</p>
<p>  这种方法有一个缺陷，如果对象的引用被用户修改了，那么之前的标记就无效了。因此Go采用了<strong>写屏障技术</strong>，当对象新增或者更新会将其着色为灰色。</p>
<p>  一次完整的GC分为四个阶段：</p>
<ol>
<li>准备标记（需要STW），开启写屏障。</li>
<li>开始标记</li>
<li>标记结束（STW），关闭写屏障</li>
<li>清理（并发）</li>
</ol>
</li>
<li><p><strong>三色标记法+混合写屏障</strong><br>  基于插入写屏障和删除写屏障在结束时需要STW来重新扫描栈，带来性能瓶颈。<strong>混合写屏障</strong>分为以下四步：</p>
<ol>
<li>GC开始时，将栈上的全部对象标记为黑色（不需要二次扫描，无需STW）；</li>
<li>GC期间，任何栈上创建的新对象均为黑色</li>
<li>被删除引用的对象标记为灰色</li>
<li>被添加引用的对象标记为灰色<br>  总而言之就是确保黑色对象不能引用白色对象，这个改进直接使得GC时间从 2s降低到2us。</li>
</ol>
</li>
</ul>
<h5 id="6-函数返回局部变量的指针是否安全？"><a href="#6-函数返回局部变量的指针是否安全？" class="headerlink" title="6. 函数返回局部变量的指针是否安全？"></a>6. 函数返回局部变量的指针是否安全？</h5><p>和C++不同，在Go里面返回局部变量的指针是安全的。因为Go会进行<strong>逃逸分析</strong>，如果发现局部变量的作用域超过该函数则会<strong>把指针分配到堆区</strong>，避免内存泄漏。</p>
<h5 id="7-非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？"><a href="#7-非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？" class="headerlink" title="7. 非接口的任意类型 T 都能够调用 *T 的方法吗？反过来呢？"></a>7. 非接口的任意类型 T 都能够调用 <code>*T</code> 的方法吗？反过来呢？</h5><p>一个 T 类型的值可以调用 <code>*T</code> 类型声明的方法，当且仅当 T 是可寻址的<br>反之，<code>*T</code> 可以调用 T 的方法，因为指针可以解引用</p>
<h5 id="8-Go-slice扩容💖"><a href="#8-Go-slice扩容💖" class="headerlink" title="8. Go slice扩容💖"></a>8. Go slice扩容💖</h5><ul>
<li>Go &lt;&#x3D; 1.17：<br>  如果当前容量小于 1024，则判断所需容量是否大于原来容量的两倍，如果大于，则当前容量加上所需容量，如果小于，则当前容量乘二</li>
<li>Go &gt;&#x3D; 1.18:<br>  引入了新的扩容规则：<a href="https://link.zhihu.com/?target=https://www.lookcos.cn/archives/1204.html">浅谈 Go 1.18.1的切片扩容机制</a><br>  <img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230312151815.png"><br>  对于容量小的切片，按照 2 倍的速率扩容<br>  对于容量大的切片，按照 1.25 倍的速率扩容<br>  公式为以上两个原则提供了平滑的过度！</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>【JDK1.8源码】AbstractList、ArrayList、LinkedList</title>
    <url>/2020/04/11/%E3%80%90JDK1-8%E3%80%91AbstractList%E3%80%81ArrayList%E3%80%81LinkedList/</url>
    <content><![CDATA[<h2 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h2><h4 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 继承自父类AbstractCollection&lt;E&gt;</span></span><br><span class="line"><span class="comment">        两个抽象方法，子类必须实现</span></span><br><span class="line"><span class="comment">        public abstract Iterator&lt;E&gt; iterator();</span></span><br><span class="line"><span class="comment">        public abstract int size();</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 实现了List&lt;E&gt;接口</span></span><br><span class="line"><span class="comment">    public interface List&lt;E&gt; extends Collection&lt;E&gt;</span></span><br><span class="line"><span class="comment">        int size();</span></span><br><span class="line"><span class="comment">        boolean isEmpty();</span></span><br><span class="line"><span class="comment">        boolean contains(Object o);</span></span><br><span class="line"><span class="comment">        Object[] toArray();</span></span><br><span class="line"><span class="comment">        void add(int index, E element);</span></span><br><span class="line"><span class="comment">        E remove(int index);</span></span><br><span class="line"><span class="comment">        int indexOf(Object o);</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; </span><br></pre></td></tr></table></figure>

<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractCollection</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>提供了抽象方法 <code>abstract public E get(int index);</code> <strong>子类必须实现</strong></li>
<li>默认不支持的 <code>add()</code>, <code>set()</code>,<code>remove()</code>,子类要想实现元素的修改必须<strong>重写这些方法</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();&#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();&#125;</span><br></pre></td></tr></table></figure></li>
<li>全部&#x2F;局部删除<br><code>public void clear() &#123;removeRange(0, size());&#125;</code><br><code>protected void removeRange(int fromIndex, int toIndex)</code></li>
</ul>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">extends</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomAccessSubList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">SubList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span></span><br></pre></td></tr></table></figure>


<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h4 id="类的关系图"><a href="#类的关系图" class="headerlink" title="类的关系图"></a>类的关系图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    List&lt;E&gt;接口：提供了一些基本的增、删、改、查方法</span></span><br><span class="line"><span class="comment">    RandomAccess接口：说明改方法支持随机访问，get、set等方法时间复杂度为 O(1)</span></span><br><span class="line"><span class="comment">    Serializable接口：可序列化接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>&#x3D;&#x3D;底层是一个Object数组&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量为0的空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//容量为默认容量的空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">//所含元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<h4 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h4><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>修剪容量<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//结构性修改数组的次数加一</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>扩容<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//新的容量是旧容量的1.5倍</span></span><br><span class="line">    <span class="comment">//向右位移运算，提升处理速度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//仍要小于最少需要的容量，则 新容量=最少需要的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判断是否包含元素o  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若不包含该元素，indexOf会返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;<span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h4 id="类关系图-1"><a href="#类关系图-1" class="headerlink" title="类关系图"></a>类关系图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<h4 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h4><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul>
<li>连接的相关方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将元素e连接到链表头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;    <span class="comment">//设置变量存储原来的链表头</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f); <span class="comment">//根据元素e新建节点</span></span><br><span class="line">    first = newNode;    <span class="comment">//将新建的节点设为链表的头</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)  <span class="comment">//如果原来的链表头是空的，则将新的节点也设成链表的尾部</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//否则，连接旧头和新头</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素e连接到链表尾，与linkFirst同理</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将节点e连接到某个非空节点前</span></span><br><span class="line"><span class="comment">  思路：设置新的节点存储目标节点的前一个节点，然后将目标节点的前一个节点的next指向元素e的节点，</span></span><br><span class="line"><span class="comment">        succ.prev = newNode</span></span><br><span class="line"><span class="comment">        如果目标节点的前一个节点为空，则将头节点设置为 e节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于删除第一个节点</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="literal">null</span>;</span><br><span class="line">    f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于删除最后一个节点</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="literal">null</span>;</span><br><span class="line">    l.prev = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除不为空的节点x</span></span><br><span class="line"><span class="comment">//前面的值指向后面的值，后面的值指向前面的值</span></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【JDK1.8源码】AbstractStringBuilder、StringBuffer、StringBuilder</title>
    <url>/2020/04/11/%E3%80%90JDK1-8%E3%80%91AbstractStringBuilder%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
    <content><![CDATA[<h2 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*抽象类</span></span><br><span class="line"><span class="comment">  实现两个接口：Appendable和CharSequence</span></span><br><span class="line"><span class="comment">  Appendable：表明类中序列是可拓展的</span></span><br><span class="line"><span class="comment">  CharSequence：只读的字符序列接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Appendable</span> &#123;</span><br><span class="line">    Appendable <span class="title function_">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    Appendable <span class="title function_">append</span><span class="params">(CharSequence csq, <span class="type">int</span> start, <span class="type">int</span> end)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    Appendable <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] value;   <span class="comment">//底层是一个可变的字符数组</span></span><br><span class="line"><span class="type">int</span> count;      <span class="comment">//字符数组中含有的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//无参构造器</span></span><br><span class="line">AbstractStringBuilder() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//给定容量的构造器</span></span><br><span class="line">AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保数组的大小够用，不够用就调用方法进行拓展</span></span><br><span class="line"><span class="comment"> * 调用方法 newCapacity来确定扩容后数组的大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minimumCapacity 添加元素后字符数组所需要的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &gt; <span class="number">0</span>)</span><br><span class="line">        ensureCapacityInternal(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="comment">//如果 新容量（原来容量*2+2） 还是小于所需要的容量，直接将 新容量=所需要的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当新容量过大时，调用hugeCapacity方法，否则直接返回新容量</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//过大直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比数组最大容量大则返回本身，否则返回数组的最大容量</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? minCapacity : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul>
<li><code>trimToSize()</code>:如果value数组的容量有多余的，那么就把多余的全部都释放掉</li>
<li><code>append()</code> <code>delete()</code> <code>insert()</code> <code>relpace()</code>方法都是调用 <code>System.arrayCopy()</code>或者<code>Arrays.copyOf()</code>方法</li>
<li><code>reverse</code>方法是设置两个指针分别指向中间元素和中间边上的元素，交换后向两侧移动，直至整个数组颠倒完成</li>
</ul>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ul>
<li>线程安全的可变字符序列</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承自AbstractStringBuilder，实现了Serializable、CharSequence两个接口</span></span><br><span class="line"><span class="comment">//CharSequence：可序列化接口，是一个空接口，只是一个可序列化的标志</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuffer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence</span><br></pre></td></tr></table></figure>
<h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//？？？</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">char</span>[] toStringCache;</span><br><span class="line"><span class="comment">//序列化id</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3388685877147921107L</span>;</span><br></pre></td></tr></table></figure>

<h4 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h4><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用synchronized关键字修饰，确保线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(...)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">delete</span><span class="params">(...)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">replace</span><span class="params">(...)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">delete</span><span class="params">(...)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对数组进行修改的方法中会先将数组toStringCache置空<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><ul>
<li>非线程安全、可变的字符序列</li>
<li>运行速度快，一般情况（单线程）推荐使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence</span><br></pre></td></tr></table></figure>
<h4 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h4>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【JDK1.8源码】AbstractMap、HashMap</title>
    <url>/2020/04/11/%E3%80%90JDK1-8%E3%80%91AbstractMap%E3%80%81HashMap/</url>
    <content><![CDATA[<h2 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h2><h4 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现了Map接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Map接口</li>
</ul>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>判断是否包含键或值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用迭代器判断是否含有值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getValue()==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器判断是否含有键</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增删改查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由键获取值</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不支持添加元素，会抛出异常，想要增加元素需要子类重写该方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据所给键删除元素</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    Entry&lt;K,V&gt; correctEntry = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (correctEntry==<span class="literal">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="literal">null</span>)</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (correctEntry==<span class="literal">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (correctEntry !=<span class="literal">null</span>) &#123;</span><br><span class="line">        oldValue = correctEntry.getValue();</span><br><span class="line">        i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回键或值的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//临时变量</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;        keySet;     <span class="comment">//将Map中的键放在Set中</span></span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;     <span class="comment">//将Map中的值放在Collection中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到键的集合</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> <span class="title class_">AbstractSet</span>&lt;K&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;K&gt;() &#123;</span><br><span class="line">                    <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> K <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> i.next().getKey();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">                        i.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">                AbstractMap.<span class="built_in">this</span>.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.containsKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到值的集合</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">    Collection&lt;V&gt; vals = values;</span><br><span class="line">    <span class="keyword">if</span> (vals == <span class="literal">null</span>) &#123;</span><br><span class="line">        vals = <span class="keyword">new</span> <span class="title class_">AbstractCollection</span>&lt;V&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Iterator&lt;V&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> V <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> i.next().getValue();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">                        i.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">                AbstractMap.<span class="built_in">this</span>.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="built_in">this</span>.containsValue(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        values = vals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重写equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">    <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h4 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h4><h4 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h4><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap的默认初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap的最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//aka 2**30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子，代表了table的填充度有多少，默认是0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将链表转化为红黑树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//将红黑树转化为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的最小容量？</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层是Node数组加链表或红黑树</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构性修改HashMap的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容阈值，大于该值且位置不为空，则进行resize()。</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//内部类构造方法</span></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>哈希算法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算键的插入位置 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>扩容<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过位运算返回大于cap且与cap最近的2的整数倍</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【JDK1.8源码】JDK源码阅读目录</title>
    <url>/2020/04/11/%E3%80%90JDK1.8%E3%80%91JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>数字表示优先级，1为最高</p>
</blockquote>
<h2 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h2><pre><code>1) Object 1
2) String 1
3) AbstractStringBuilder 1 
4) StringBuffer 1 
5) StringBuilder 1 
6) Boolean 2
7) Byte 2
8) Double 2
9) Float 2
10) Integer 2
11) Long 2
12) Short 2
13) Thread 2
14) ThreadLocal 2
15) Enum 3
16) Throwable 3
17) Error 3
18) Exception 3
19) Class 4
20) ClassLoader 4
21) Compiler 4
22) System 4
23) Package 4
24) Void 4
</code></pre>
<h2 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h2><pre><code>1) AbstractList 1 
2) AbstractMap 1
3) AbstractSet 1
4) ArrayList 1 
5) LinkedList 1 
6) HashMap 1
7) Hashtable 1
8) HashSet 1
9) LinkedHashMap 1
10) LinkedHashSet 1
11) TreeMap 1
12) TreeSet 1
13) Vector 2
14) Queue 2
15) Stack 2
16) SortedMap 2
17) SortedSet 2
18) Collections 3
19) Arrays 3
20) Comparator 3
21) Iterator 3
22) Base64 4
23) Date 4
24) EventListener 4
25) Random 4
26) SubList 4
27) Timer 4
28) UUID 4
29) WeakHashMap 4
</code></pre>
<h2 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h2><pre><code>1) ConcurrentHashMap 1
2) Executor 2
3) AbstractExecutorService 2
4) ExecutorService 2
5) ThreadPoolExecutor 2
6) BlockingQueue 2
7) AbstractQueuedSynchronizer 2
8) CountDownLatch 2
9) FutureTask 2
10) Semaphore 2
11) CyclicBarrier 2
13) CopyOnWriteArrayList 3
14) SynchronousQueue 3
15) BlockingDeque 3
16) Callable 4
</code></pre>
<h2 id="java-util-concurrent-atomic"><a href="#java-util-concurrent-atomic" class="headerlink" title="java.util.concurrent.atomic"></a>java.util.concurrent.atomic</h2><pre><code>1) AtomicBoolean 2
2) AtomicInteger 2
3) AtomicLong 2
4) AtomicReference 3
</code></pre>
<h2 id="java-lang-reflect"><a href="#java-lang-reflect" class="headerlink" title="java.lang.reflect"></a>java.lang.reflect</h2><pre><code>1) Field 2
2) Method 2
</code></pre>
<h2 id="java-lang-annotation"><a href="#java-lang-annotation" class="headerlink" title="java.lang.annotation"></a>java.lang.annotation</h2><pre><code>1) Annotation 3
2) Target 3
3) Inherited 3
4) Retention 3
5) Documented 4
6) ElementType 4
7) Native 4
8) Repeatable 4
</code></pre>
<h2 id="java-util-concurrent-locks"><a href="#java-util-concurrent-locks" class="headerlink" title="java.util.concurrent.locks"></a>java.util.concurrent.locks</h2><pre><code>1) Lock 2
2) Condition 2
3) ReentrantLock 2
4) ReentrantReadWriteLock 2
</code></pre>
<h2 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h2><pre><code>1) File 3
2) InputStream   3
3) OutputStream  3
4) Reader  4
5) Writer  4
</code></pre>
<h2 id="java-nio"><a href="#java-nio" class="headerlink" title="java.nio"></a>java.nio</h2><pre><code>1) Buffer 3
2) ByteBuffer 4
3) CharBuffer 4
4) DoubleBuffer 4
5) FloatBuffer 4
6) IntBuffer 4
7) LongBuffer 4
8) ShortBuffer 4
</code></pre>
<h2 id="java-sql"><a href="#java-sql" class="headerlink" title="java.sql"></a>java.sql</h2><pre><code>1) Connection 3
2) Driver 3
3) DriverManager 3
4) JDBCType 3
5) ResultSet 4
6) Statement 4
</code></pre>
<h2 id="java-net"><a href="#java-net" class="headerlink" title="java.net"></a>java.net</h2><pre><code>1) Socket 3
2) ServerSocket 3
3) URI 4
4) URL 4
5) URLEncoder 4
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【JDK1.8源码】Object、String</title>
    <url>/2020/04/11/%E3%80%90JDK1.8%E3%80%91Object%E3%80%81String/</url>
    <content><![CDATA[<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul>
<li>object 作为超类，是一切类的父类</li>
</ul>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">// o1 == o2</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用来另存一个当前存在的对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//让当前线程失去操作权限，进入等待序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//随机通知一个持有对象的锁的线程获取操作权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//垃圾回收时调用</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    CharSequence是一个只读的字符序列接口，包括：</span></span><br><span class="line"><span class="comment">       int length();</span></span><br><span class="line"><span class="comment">        char charAt(int index);</span></span><br><span class="line"><span class="comment">        CharSequence subSequence(int start, int end);</span></span><br><span class="line"><span class="comment">        public String toString();</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    StringBuffer和StringBuilder也实现了这个接口</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>String<strong>不是</strong>java的基本类型</p>
</li>
<li><p>String是const，不能改变：<br><code>private final char value[];</code></p>
</li>
</ul>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(StringBuffer buffer)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(StringBuilder builder)</span></span><br><span class="line"><span class="comment">//不常用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">int</span>[] codePoints, <span class="type">int</span> offset, <span class="type">int</span> count)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> ascii[], <span class="type">int</span> hibyte, <span class="type">int</span> offset, <span class="type">int</span> count)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> ascii[], <span class="type">int</span> hibyte)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[], <span class="type">int</span> offset, <span class="type">int</span> length, String charsetName)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[], String charsetName)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[], Charset charset)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[], <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[])</span></span><br><span class="line">String(<span class="type">char</span>[] value, <span class="type">boolean</span> share)</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  与StringBuffer, StringBuilder作比较时使用</span></span><br><span class="line"><span class="comment">  传入参数是一个CharSequence，StringBuffer, StringBuilder均实现了CharSequence接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contentEquals</span><span class="params">(CharSequence cs)</span> &#123;</span><br><span class="line">    <span class="comment">// Argument is a StringBuffer, StringBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> AbstractStringBuilder) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> StringBuffer) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(cs) &#123;</span><br><span class="line">               <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a String</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a generic CharSequence</span></span><br><span class="line">    <span class="type">char</span> v1[] = value;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> v1.length;</span><br><span class="line">    <span class="keyword">if</span> (n != cs.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != cs.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span>  <span class="comment">//将str拼接到字符串后</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【JUC并发编程】</title>
    <url>/2023/03/01/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/</url>
    <content><![CDATA[<h1 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h1><p><strong>线程</strong>是 Java 中浓墨重彩的一笔。</p>
<p>JUC 就是 <strong>java.util .concurrent</strong> 工具包的简称。这是一个<strong>处理线程</strong>的工具包，JDK 1.5开始出现的。</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200504091645858.png" alt="image-20200504091645858"></p>
<p>这里列举两个之前学习 Java基础 用到过的两个接口：</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200504091815405.png" alt="image-20200504091815405"></p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200504091917934.png" alt="image-20200504091917934"></p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><ul>
<li>进程：一个程序的一次动态执行过程，<code>.exe</code></li>
<li>线程：进程可细分的最小单位，一个进程往往可以包含多个线程</li>
</ul>
<blockquote>
<p>Java 默认有几个线程？</p>
<p>​	2 个 ！</p>
<ul>
<li><p>main线程</p>
</li>
<li><p>GC线程</p>
</li>
</ul>
<p>对于Java有哪几种开启线程的方式？</p>
<ul>
<li>Thread</li>
<li>Runnable</li>
<li>Callable</li>
</ul>
<p>Java真的可以开启线程嘛？</p>
<p>​	并不行，需要使用 <code>public native void start0()</code> 方法来调用本地方法使用其他语言开启线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li><p>并发：多个线程操作同一个资源（<strong>交替执行</strong>）</p>
<p>  本质：充分利用 CPU 的资源</p>
</li>
<li><p>并行：多个线程 <strong>同时</strong> 操作一个资源（<strong>同时执行</strong>）</p>
<p>  查看 CPU 核心数（CPU核心数代表最多可以并行操作多少线程）</p>
</li>
</ul>
<img src="【JUC并发编程】一/image-20200504094108209.png" alt="image-20200504094108209" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//获取cpu核心数</span></span><br><span class="line">    <span class="comment">//cpu密集型、io密集型</span></span><br><span class="line">    System.out.println(Runtime.getRuntime().availableProcessors());		<span class="comment">//12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程有几个状态？</p>
<p>​	六个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,			<span class="comment">//新生</span></span><br><span class="line">    RUNNABLE,		<span class="comment">//运行</span></span><br><span class="line">    BLOCKED,		<span class="comment">//阻塞</span></span><br><span class="line">    WAITING,		<span class="comment">//等待，死死的等</span></span><br><span class="line">    TIMED_WAITING,	<span class="comment">//超时等待</span></span><br><span class="line">    TERMINATED;		<span class="comment">//终止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Wait 和 Sleep 的区别：</p>
<table>
<thead>
<tr>
<th align="center">wait</th>
<th align="center">sleep</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Object</td>
<td align="center">Thread</td>
</tr>
<tr>
<td align="center">会释放锁</td>
<td align="center">不会释放（睡着了都怎么释放）</td>
</tr>
<tr>
<td align="center">必须在同步代码块中使用</td>
<td align="center">可以在任何地方睡</td>
</tr>
<tr>
<td align="center">不需要捕获异常</td>
<td align="center">必须捕获异常</td>
</tr>
</tbody></table>
</blockquote>
<h1 id="Lock锁（重点）"><a href="#Lock锁（重点）" class="headerlink" title="Lock锁（重点）"></a>Lock锁（重点）</h1><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Runnable @FunctionalInterface 函数式接口，jdk1.8之后可以使用 lambda 表达式</span></span><br><span class="line">        <span class="comment">// ()-&gt;&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程A</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">		<span class="comment">//线程B</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> * OOP思想</span></span><br><span class="line"><span class="comment"> * 只写属性、方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了&quot;</span> + (number--) + <span class="string">&quot;张票，剩余：&quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入 <code>synchronized</code> 关键字之前：</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200504102033618.png" alt="image-20200504102033618"></p>
<p>加入 <code>synchronized</code> 关键字之后：</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200504102234831.png" alt="image-20200504102234831"></p>
<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><ul>
<li><p>使用方法</p>
<p>  <img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200504102537490.png" alt="image-20200504102537490"></p>
</li>
<li><p>实现类</p>
</li>
</ul>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200504102513162.png" alt="image-20200504102513162"></p>
<ul>
<li><p>公平锁和非公平锁</p>
<ul>
<li>公平锁：十分公平，可以先来后到</li>
<li><strong>非公平锁：十分不公平，可以插队（默认）</strong></li>
</ul>
</li>
<li><p>实例</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了&quot;</span> + (number--) + <span class="string">&quot;张票，剩余：&quot;</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行结果与使用<code>synchronized</code> 一致</p>
</li>
<li><p><strong>synchronized</strong> 和 <strong>Lock锁</strong> 的区别</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">synchronized</th>
<th align="left">Lock</th>
</tr>
</thead>
<tbody><tr>
<td align="left">是一个内置的关键字</td>
<td align="left">是一个Java类</td>
</tr>
<tr>
<td align="left">无法判断锁的状态</td>
<td align="left">可以判断是否获取到了锁</td>
</tr>
<tr>
<td align="left">会自动释放锁</td>
<td align="left">必需要手动释放（不释放会出现<strong>死锁</strong>）</td>
</tr>
<tr>
<td align="left">Thread1(获得锁、阻塞)、Thread2(等待，傻傻的等)</td>
<td align="left">不一定会等下去</td>
</tr>
<tr>
<td align="left">可重入锁、不可中断的、非公平的</td>
<td align="left">可重入锁、可以中断的、非公平的（可以设置）</td>
</tr>
<tr>
<td align="left">适合锁少量的同步代码</td>
<td align="left">适合锁大量的同步代码</td>
</tr>
</tbody></table>
<blockquote>
<p>锁是什么？如何判断锁的是谁？</p>
<p>​	<strong>普通方法上锁，锁住的是调用方法的对象实例</strong></p>
<p>​	<strong>静态方法上锁，锁住的是整个类</strong></p>
</blockquote>
<h1 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h1><p>问题描述：</p>
<blockquote>
<p>本质是线程之间的通信问题</p>
<p>两个线程交替执行，A、B 同时操作同一个变量</p>
<p>A：num + 1</p>
<p>B：num - 1</p>
<p>要保证 num  在 0、1 之间交替</p>
<p><strong>大有门道</strong>！</p>
</blockquote>
<h3 id="Synchronized版"><a href="#Synchronized版" class="headerlink" title="Synchronized版"></a>Synchronized版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是一个资源类</span></span><br><span class="line"><span class="comment"> * 只提供要操作的属性和方法,具有较低耦合性</span></span><br><span class="line"><span class="comment"> * 六字口诀：等待、业务、通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//线程数大于二时，用 if 会出大问题</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，+1 完毕</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//线程数大于二时，用 if 会出大问题</span></span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，-1 完毕</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505090908390.png" alt="image-20200505090908390"></p>
<blockquote>
<p>问题：</p>
<p>如果存在 A、B、C、D 四个线程，线程还是安全的嘛</p>
<p>答：不安全，存在虚假唤醒问题</p>
<p>解决方法： if —&gt;  while</p>
<p>​					用 if 判断时，当被其他线程唤醒就会直接接着执行后面的指令</p>
<p>​					用while判断时，当被其他线程唤醒后还会再次进行判断</p>
</blockquote>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505091658081.png" alt="image-20200505091658081"></p>
<h3 id="JUC版"><a href="#JUC版" class="headerlink" title="JUC版"></a>JUC版</h3><p>只是对 synchronized版本 的覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是一个资源类</span></span><br><span class="line"><span class="comment"> * 只提供要操作的属性和方法,具有较低耦合性</span></span><br><span class="line"><span class="comment"> * 六子口诀：等待、业务、通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            <span class="comment">//通知其他线程，+1 完毕</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            <span class="comment">//通知其他线程，+1 完毕</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JUC进阶版"><a href="#JUC进阶版" class="headerlink" title="JUC进阶版"></a>JUC进阶版</h3><p>改进：&#x3D;&#x3D;Condition：精准的通知和唤醒线程&#x3D;&#x3D;</p>
<p>​			A - B - C 顺序调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span> ).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span> ).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span> ).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;AAAAAA&quot;</span>);</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;BBBBBB&quot;</span>);</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;CCCCCC&quot;</span>);</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合类不安全"><a href="#集合类不安全" class="headerlink" title="集合类不安全"></a>集合类不安全</h1><blockquote>
<p>普通集合类在单线程下安全的不得了，多线程就8行了。</p>
</blockquote>
<h3 id="List不安全"><a href="#List不安全" class="headerlink" title="List不安全"></a>List不安全</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在线程安全问题，爆出错误：<code>java.util.ConcurrentModificationException</code> 并发修改异常</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505114208518.png" alt="image-20200505114208518"></p>
<p>解决方法：</p>
<ol>
<li><p><code>List&lt;Object&gt; list = new Vector&lt;&gt;()</code></p>
</li>
<li><p>&#96;&#96;List<Object> list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;())&#96; </p>
<p> <img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505113916028.png" alt="image-20200505113916028"></p>
</li>
<li><p><code>List&lt;Object&gt; list = CopyOnWriteArrayList&lt;&gt;()</code></p>
</li>
</ol>
<blockquote>
<p>CopyOnWrite（COW），写入时复制，计算机程序设计领域的一种优化策略</p>
</blockquote>
<h3 id="Set不安全"><a href="#Set不安全" class="headerlink" title="Set不安全"></a>Set不安全</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            System.out.println(set);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505115426546.png" alt="image-20200505115426546"></p>
<p>依然存在安全问题！</p>
<p>解决方法：</p>
<ol>
<li><code>Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</code></li>
<li><code>Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</code></li>
</ol>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505115640044.png" alt="image-20200505115640044"></p>
<p>HashSet底层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//就是一个HashMap！</span></span><br><span class="line"><span class="comment">//使用HashMap的key来存放数据（key是不能重复的）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不变的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map不安全"><a href="#Map不安全" class="headerlink" title="Map不安全"></a>Map不安全</h3><p>先简单回顾一下HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子，减少哈希碰撞</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表转化成红黑树的门槛</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//一般不这样用</span></span><br><span class="line">    <span class="comment">//默认等价于： new HashMap&lt;&gt;(16.0.75);</span></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505152249722.png" alt="image-20200505152249722"></p>
<p>解决方法：</p>
<ol>
<li><code>Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</code></li>
<li><code>Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</code></li>
</ol>
<p>&#x3D;&#x3D;抽空看研究ConcurrentHashMap源码&#x3D;&#x3D;</p>
<h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505153025107.png" alt="image-20200505153025107"></p>
<h3 id="Runnable与Callable比较"><a href="#Runnable与Callable比较" class="headerlink" title="Runnable与Callable比较"></a>Runnable与Callable比较</h3><table>
<thead>
<tr>
<th>Runnable</th>
<th>Callable</th>
</tr>
</thead>
<tbody><tr>
<td>没有返回值</td>
<td>可以有返回值</td>
</tr>
<tr>
<td>不能抛出异常</td>
<td>可以抛出异常</td>
</tr>
<tr>
<td><code>run()</code></td>
<td><code>call()</code></td>
</tr>
</tbody></table>
<h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><ul>
<li><p>传统方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用 Callable接口</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"><span class="comment">//        new Thread(new Runnable()).start();</span></span><br><span class="line">        <span class="comment">//new Thread(new FutureTask&lt;&gt;()).start();</span></span><br><span class="line">        <span class="comment">//new Thread(new FutureTask&lt;&gt;( Callable )).start();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(thread);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;B&quot;</span>).start();	<span class="comment">//启动两个线程，call()执行了一次（缓存）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//get方法可能会产生阻塞！把他放在最后一行或者使用异步通信来处理</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call 成功被调用&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1024&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="常用辅助类-必会"><a href="#常用辅助类-必会" class="headerlink" title="常用辅助类(必会)"></a>常用辅助类(必会)</h1><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote>
<ul>
<li>java.util.concurrent</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">java.lang.Object</a></li>
<li>java.util.concurrent.CountDownLatch</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatch</span> <span class="keyword">extends</span> <span class="title class_">Object</span></span><br></pre></td></tr></table></figure>

<p>A synchronization aid that <strong>allows one or more threads to wait until a set of operations being performed in other threads completes.</strong></p>
<p>A <code>CountDownLatch</code> is initialized with <strong>a given <em>count</em>.</strong> The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html#await--"><code>await</code></a> methods block until the current count reaches zero due to invocations of the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html#countDown--"><code>countDown()</code></a> method, after which all waiting threads are released and any subsequent invocations of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html#await--"><code>await</code></a> return immediately. This is a one-shot phenomenon – the count cannot be reset. If you need a version that resets the count, consider using a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html"><code>CyclicBarrier</code></a>.</p>
<p>A <code>CountDownLatch</code> is a versatile synchronization tool and can be used for a number of purposes. A <code>CountDownLatch</code> initialized with a count of one serves as a simple on&#x2F;off latch, or gate: all threads invoking <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html#await--"><code>await</code></a> wait at the gate until it is opened by a thread invoking <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html#countDown--"><code>countDown()</code></a>. A <code>CountDownLatch</code> initialized to <em>N</em> can be used to make one thread wait until <em>N</em> threads have completed some action, or some action has been completed N times.</p>
</blockquote>
<ul>
<li>不等计数器归零：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//总数是6</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;out&quot;</span>);</span><br><span class="line">            countDownLatch.countDown(); <span class="comment">//数量 -1</span></span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//countDownLatch.await();             //等待计数器归零，然后再向下执行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505161657950.png" alt="image-20200505161657950"></p>
<ul>
<li><p>等待计数器归零</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//总数是6</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;out&quot;</span>);</span><br><span class="line">            countDownLatch.countDown(); <span class="comment">//数量 -1</span></span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    countDownLatch.await();             <span class="comment">//等待计数器归零，然后再向下执行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200505161819615.png" alt="image-20200505161819615"></p>
<ul>
<li><p>用法</p>
<p>  <code>countDownLatch.countDown();</code></p>
<p>  <code>countDownLatch.await();</code></p>
<p>  每次有线程调用 <code>countDownLatch.countDown()</code>，计数器数量 -1 ，计数器变为 0 ，<code>countDownLatch.await()</code>就会被唤醒，继续执行下面的操作。</p>
</li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote>
<ul>
<li><p>java.util.concurrent</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">java.lang.Object</a></p>
</li>
<li><p>java.util.concurrent.CyclicBarrier</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrier</span> <span class="keyword">extends</span> <span class="title class_">Object</span></span><br></pre></td></tr></table></figure>

<p>A synchronization aid that <strong>allows a set of threads to all wait for each other to reach a common barrier point</strong>. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called <em>cyclic</em> because it can be re-used after the waiting threads are released.</p>
<p>A <code>CyclicBarrier</code> supports an optional <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html"><code>Runnable</code></a> command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released. This <em>barrier action</em> is useful for updating shared-state before any of the parties continue.</p>
</blockquote>
<p>可以简单理解为 <strong>加法计数器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集齐七颗龙珠召唤神龙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;召唤神龙成功！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;收集了&quot;</span>+temp+<span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote>
<ul>
<li>java.util.concurrent</li>
</ul>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">java.lang.Object</a></p>
<ul>
<li><p>java.util.concurrent.Semaphore</p>
</li>
<li><p>All Implemented Interfaces:<a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html">Serializable</a></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br></pre></td></tr></table></figure>

<p>  A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html#acquire--"><code>acquire()</code></a> blocks if necessary until a permit is available, and then takes it. Each <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html#release--"><code>release()</code></a> adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the <code>Semaphore</code> just keeps a count of the number available and acts accordingly.</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程数量：停车位</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//acquire()</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;抢到车位！&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);      <span class="comment">//停两秒钟</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开车位！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//release()</span></span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用法</p>
<p>  <code>semaphore.acquire()</code>：获得，假设如果已经满了，等待，等待被释放为止！</p>
<p>  <code>semaphore.release()</code>：释放，会将当前的信号量释放 +1，然后唤醒等待的线程</p>
</li>
<li><p>作用</p>
<p>  多个资源互斥的使用！并发限流，控制最大的线程数！</p>
</li>
</ul>
<h1 id="ReadWriteLock（读写锁）"><a href="#ReadWriteLock（读写锁）" class="headerlink" title="ReadWriteLock（读写锁）"></a>ReadWriteLock（读写锁）</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>java.util.concurrent.locks</p>
<ul>
<li>All Known Implementing Classes:</li>
</ul>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html">ReentrantReadWriteLock</a></p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span></span><br></pre></td></tr></table></figure>

<p>A <code>ReadWriteLock</code> maintains <strong>a pair of associated <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html"><code>locks</code></a></strong>, one for read-only operations and one for writing. The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html#readLock--"><code>read lock</code></a> may <strong>be held simultaneously by multiple reader threads</strong>, so long as there are no writers. The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html#writeLock--"><code>write lock</code></a> is <strong>exclusive</strong>.</p>
<p>读操作可以被多线程执行，写只能被一个线程去写</p>
<p>独占锁（写锁）：一次只能被一个线程占有</p>
<p>共享锁（读锁）：多个线程可以同时占有</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li><p>不加锁</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//write</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.put(String.valueOf(temp), UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.get(String.valueOf(temp));</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存，写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,Object value)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入！&quot;</span> + key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入完毕!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取，读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取！&quot;</span> + key);</span><br><span class="line">        map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出结果</p>
<p>  ​	写入操作时存在插队现象</p>
<p>  <img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200506093655430.png" alt="image-20200506093655430"></p>
</li>
<li><p>加锁</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCacheWithLock</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCacheWithLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//write</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.put(String.valueOf(temp), UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.get(String.valueOf(temp));</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCacheWithLock</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//读写锁，更加细粒度的控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存，写，只希望同时只有一个线程在写入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key,Object value)</span> &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入！&quot;</span> + key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入完毕!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取，读，希望所有人可以读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取！&quot;</span> + key);</span><br><span class="line">            map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取完毕！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  结果：</p>
<p>  <img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200506094037329.png" alt="image-20200506094037329"></p>
</li>
</ul>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200506094836508.png" alt="image-20200506094836508"></p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200506101956987.png" alt="image-20200506101956987"></p>
<p><strong>不是新的东西</strong>！</p>
<ul>
<li>多线程并发处理</li>
<li>线程池</li>
</ul>
<h3 id="四组API"><a href="#四组API" class="headerlink" title="四组API"></a>四组API</h3><table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值，不抛异常</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add()</td>
<td>offer() —&gt; false</td>
<td>put()</td>
<td>offer(e,timeout,TimeUnit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll() —&gt; null</td>
<td>take()</td>
<td>poll(e,timeout,TimeUnit)</td>
</tr>
<tr>
<td>查看队列首部</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p><code>SynchronousQueue</code>，和其他 <code>BlockingQueue</code> 不同，必须将 <code>put()</code> 的元素先 <code>take()</code> 出来，才能 <code>put()</code> 下一个元素！</p>
<h1 id="线程池（重点）"><a href="#线程池（重点）" class="headerlink" title="线程池（重点）"></a>线程池（重点）</h1><h3 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h3><p>程序运行的本质：占用系统资源！</p>
<p>我们需要引入池化技术来优化资源的使用</p>
<p>池化技术：事先准备好一些资源，有人要用，就过来拿，用完之后还回来！</p>
<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ol>
<li>降低资源的消耗</li>
<li>提高响应速度</li>
<li>方便管理</li>
</ol>
<p><strong>总结：线程复用、可以控制最大并发数、管理线程</strong></p>
<h3 id="线程池核心"><a href="#线程池核心" class="headerlink" title="线程池核心"></a>线程池核心</h3><blockquote>
<p>三大方法、七大参数、四种拒绝策略</p>
</blockquote>
<h5 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h5><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200507094427242.png" alt="image-20200507094427242"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//单个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//        创建一个固定大小的线程池</span></span><br><span class="line"><span class="comment">//        Executors.newFixedThreadPool(5);</span></span><br><span class="line"><span class="comment">//        //可伸缩的</span></span><br><span class="line"><span class="comment">//        Executors.newCachedThreadPool();</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//程序结束前需要关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h5><p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,			//核心线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,		//最大核心线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,		//超时没人调用就会被释放</span></span><br><span class="line"><span class="params">                          TimeUnit unit,			//超时单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,	//阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,			//创建线程的</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler//拒绝策略)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h5><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200507101002241.png" alt="image-20200507101002241"></p>
<h3 id="手动创建线程池"><a href="#手动创建线程池" class="headerlink" title="手动创建线程池"></a>手动创建线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">*                               int maximumPoolSize,</span></span><br><span class="line"><span class="comment">*                               long keepAliveTime,</span></span><br><span class="line"><span class="comment">*                               TimeUnit unit,</span></span><br><span class="line"><span class="comment">*                               BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">*                               ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">*                               RejectedExecutionHandler handler)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());  <span class="comment">//银行满了还有人进来，不处理这个人的，抛出异常</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//程序结束前需要关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最大线程（maximumPoolSize）该如何定义？（调优）</p>
<ol>
<li><p>CPU密集型</p>
<p> 12核 —&gt; 12条线程</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取CPU的核心数</span></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());	<span class="comment">//12</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>IO密集型</p>
<p> 判断程序中十分耗 IO 的线程数 x，设置最大线程数 &gt; x</p>
</li>
</ol>
</blockquote>
<h1 id="函数式接口（必须掌握）"><a href="#函数式接口（必须掌握）" class="headerlink" title="函数式接口（必须掌握）"></a>函数式接口（必须掌握）</h1><blockquote>
<p>Java程序员需要掌握的旧技术：泛型、枚举、反射</p>
<p>Java程序员需要掌握的新技术：lambda表达式、链式编程、函数式接口、Stream流式计算</p>
</blockquote>
<p>函数式接口：只有一个方法的接口</p>
<p>​						简化编程模型，在新版本的框架底层被大量使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四大原生的函数式接口：</p>
<ul>
<li><code>Consumer</code></li>
<li><code>Function</code></li>
<li><code>Predicate</code></li>
<li><code>Supplier</code></li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200507110148623.png" alt="image-20200507110148623"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 函数式接口，有一个输入参数，有一个输出</span></span><br><span class="line"><span class="comment"> * 只要是 函数式接口，就可以用 lambda表达式简化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//工具类，输出输入的值</span></span><br><span class="line"><span class="comment">//        Function&lt;String, String&gt; function = new Function&lt;String, String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String apply(String s) &#123;</span></span><br><span class="line"><span class="comment">//                return s;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Function&lt;String,String&gt; function = (str) -&gt; &#123; <span class="keyword">return</span> str; &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;123&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="断定型接口"><a href="#断定型接口" class="headerlink" title="断定型接口"></a>断定型接口</h3><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200507112345415.png" alt="image-20200507112345415"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Predicate 断定型接口，有一个输入参数，返回值只能是布尔值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//判断字符串是否为空</span></span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public boolean test(String str) &#123;</span></span><br><span class="line"><span class="comment">//                return str.isEmpty();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = (str) -&gt; &#123; <span class="keyword">return</span> str.isEmpty();&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费型接口"><a href="#消费型接口" class="headerlink" title="消费型接口"></a>消费型接口</h3><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200507112539535.png" alt="image-20200507112539535"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consumer 消费性接口，只有输入，没有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String str) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(str);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = (str) -&gt; &#123; System.out.println(str); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="供给型接口"><a href="#供给型接口" class="headerlink" title="供给型接口"></a>供给型接口</h3><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200507112937140.png" alt="image-20200507112937140"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Supplier 供给型接口：没有参数，有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        Supplier supplier = new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">//                return 1024;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        </span><br><span class="line">        Supplier&lt;Integer&gt; supplier = ()-&gt;&#123; <span class="keyword">return</span> <span class="number">1024</span>;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><p>大数据 ： 存储 + 计算</p>
<p>​	存储：集合、MySQL</p>
<p>​	计算：交给流来操作！</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200507113911453.png" alt="image-20200507113911453"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  题目要求：一分钟内完成此题，只能用一行代码实现</span></span><br><span class="line"><span class="comment"> *  现在有五个用户，筛选：</span></span><br><span class="line"><span class="comment"> *  1.ID 必须是偶数</span></span><br><span class="line"><span class="comment"> *  2.年龄必须大于23岁</span></span><br><span class="line"><span class="comment"> *  3.用户名转为大写字母</span></span><br><span class="line"><span class="comment"> *  4.用户名字母倒着排序</span></span><br><span class="line"><span class="comment"> *  5.只输出一个用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">5</span>, <span class="string">&quot;e&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        <span class="comment">//集合就是存储</span></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算交给Stream</span></span><br><span class="line">        <span class="comment">//lambda表达式、链式编程、函数式接口、Stream流式计算</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getId()%<span class="number">2</span> == <span class="number">0</span>;&#125;)</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">                .map(u-&gt;&#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted((uu1,uu2)-&gt;&#123;<span class="keyword">return</span> uu2.compareTo(uu1);&#125;)</span><br><span class="line">                .limit(<span class="number">1</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h1><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>ForkJoin（分支合并）出现在 JDK 1.7，可以并行执行任务，提高效率。</p>
<p>在大数据量的情况下使用！</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200508092713288.png" alt="image-20200508092713288"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>工作窃取</strong>：</p>
<p>​	多个线程执行任务时，提前执行完任务的线程可以将没执行完任务的现场的任务拿过来执行，提高效率<strong>（维护了一个双端队列）</strong></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200508100716554.png" alt="image-20200508100716554"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *  ForkJoin</span></span><br><span class="line"><span class="comment"> *      1.ForkJoinPool</span></span><br><span class="line"><span class="comment"> *      2.forkJoinPool.execute(ForkJoinTask forkJoinTask)</span></span><br><span class="line"><span class="comment"> *      3.计算类继承ForkJoinTask</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">thershold</span> <span class="operator">=</span> <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; thershold) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(start, middle);</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//拆分</span></span><br><span class="line">            task1.fork();</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="comment">//合并并返回</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求和计算任务</span></span><br><span class="line"><span class="comment"> * 程序员的369等</span></span><br><span class="line"><span class="comment"> *  3：头铁直接求和</span></span><br><span class="line"><span class="comment"> *  6：ForkJoin</span></span><br><span class="line"><span class="comment"> *  9：Stream并行流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1L</span>; i &lt;= <span class="number">10_000_1000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;3：&quot;</span>+<span class="string">&quot;sum = &quot;</span>+ sum +<span class="string">&quot; time= &quot;</span>+ (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ForkJoin</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">ForkJoinDemo</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">10_000_1000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> submit.get();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;6：&quot;</span>+<span class="string">&quot;sum = &quot;</span>+ sum +<span class="string">&quot; time= &quot;</span>+ (end - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Stream并行流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_000_1000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;9：&quot;</span>+<span class="string">&quot;sum = &quot;</span>+ sum +<span class="string">&quot; time= &quot;</span>+ (end - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200508103137218.png" alt="image-20200508103137218"></p>
<h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><p>……</p>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><h3 id="Volatile的理解"><a href="#Volatile的理解" class="headerlink" title="Volatile的理解"></a>Volatile的理解</h3><p>Volatile 是 Java 虚拟机提供轻量级的同步机制</p>
<ol>
<li>保证可见性</li>
<li><strong>不保证原子性</strong></li>
<li>禁止指令重排</li>
</ol>
<h3 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h3><p>JMM(Java Memory Model,Java内存模型)，不像JVM，JMM是不存在的东西，是一种概念、约定。</p>
<p>关于JMM的一些同步约定：</p>
<ol>
<li>线程<strong>解锁前</strong>，必须把共享变量<strong>立刻</strong>刷回主存</li>
<li>线程<strong>加锁前</strong>，必须读取主存中的最新值到工作内存中</li>
<li>加锁和解锁是<strong>同一把锁</strong></li>
</ol>
<p>8种操作：</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200509092515374.png" alt="image-20200509092515374"></p>
<blockquote>
<ul>
<li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
</blockquote>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200509094216939.png" alt="image-20200509094216939"></p>
<p>线程A 在执行时 线程B 修改了变量值并且存到了主存中,但是 线程A 却不知道主存中的值发生了变化,仍在使用原来旧的值。</p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><h3 id="1-保证可见性"><a href="#1-保证可见性" class="headerlink" title="1.保证可见性"></a>1.保证可见性</h3><p>上面问题的解决方法：</p>
<p><code>private volatile static int num = 0;</code></p>
<h3 id="2-不保证原子性"><a href="#2-不保证原子性" class="headerlink" title="2.不保证原子性"></a>2.不保证原子性</h3><p>原子性：不可分割</p>
<p>线程A 在执行任务的时候，不能被打扰，也不能被分割，要么同时成功，要么同时失败</p>
<blockquote>
<p>如果不加 lock 和 synchronized ，怎么保证原子性？</p>
<p>使用原子类（底层用的是CAS）来解决原子性问题！</p>
</blockquote>
<img src="【JUC并发编程】一/image-20200509095742877.png" alt="image-20200509095742877" style="zoom:50%;" />

<h3 id="3-避免指令重排"><a href="#3-避免指令重排" class="headerlink" title="3.避免指令重排"></a>3.避免指令重排</h3><p>指令重排：你写的程序，计算机并不是按照你写的那样去执行的。</p>
<p>源代码——》编译器优化的重排——》指令并行也可能会重排——》内存系统也会重排——》执行</p>
<p>避免指令重排：内存屏障（在单例模式中使用频繁）</p>
<h1 id="深入理解单例模式"><a href="#深入理解单例模式" class="headerlink" title="深入理解单例模式"></a>深入理解单例模式</h1><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  饿汉式单例</span></span><br><span class="line"><span class="comment"> *  在还没有用的时候就把对象都创建出来了，可能会造成浪费空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">HUNGRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例</span></span><br><span class="line"><span class="comment"> *  单线程下ok</span></span><br><span class="line"><span class="comment"> *  多线程下有问题 ——》 加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子性操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检测锁模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  不是原子性操作</span></span><br><span class="line"><span class="comment">                     *      1. 分配内存空间</span></span><br><span class="line"><span class="comment">                     *      2. 执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     *      3. 把对象指向这个空间</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    lazyMan = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试多线程并发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                LazyMan.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="深入理解CAS"><a href="#深入理解CAS" class="headerlink" title="深入理解CAS"></a>深入理解CAS</h1><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         *  CAS（CompareAndSet）：比较并交换</span></span><br><span class="line"><span class="comment">         *  public final boolean compareAndSet(int expect, int update)</span></span><br><span class="line"><span class="comment">         *  except:期望</span></span><br><span class="line"><span class="comment">         *  update:更新</span></span><br><span class="line"><span class="comment">         *  如果期望的值达到了，就更新</span></span><br><span class="line"><span class="comment">         *  CAS 是 CPU 的并发原语</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        atomicInteger.compareAndSet(<span class="number">2020</span>,<span class="number">2021</span>);</span><br><span class="line">        atomicInteger.get();</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsafe类"><a href="#unsafe类" class="headerlink" title="unsafe类"></a>unsafe类</h3><p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200509110744442.png" alt="image-20200509110744442"></p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200509111600981.png" alt="image-20200509111600981"></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>自旋锁循环会耗时</li>
<li>一次性只能保证一个共享变量的原子性</li>
<li>ABA 问题</li>
</ol>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>ABA问题：狸猫换太子</p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200509112905245.png" alt="image-20200509112905245"></p>
<p>解决方法：引入 <strong>原子引用</strong>（乐观锁）</p>
<h1 id="各种锁的理解"><a href="#各种锁的理解" class="headerlink" title="各种锁的理解"></a>各种锁的理解</h1><h3 id="1-公平锁、非公平锁"><a href="#1-公平锁、非公平锁" class="headerlink" title="1.公平锁、非公平锁"></a>1.公平锁、非公平锁</h3><ul>
<li>公平锁：非常公平，不能插队（必须先来后到）</li>
<li>非公平锁：非常霸道，可以插队（T1：3h，T2：3s），默认都是非公平锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">* given fairness policy.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2.可重入锁"></a>2.可重入锁</h3><p>可重入锁（递归锁）：拿到了外面的锁之后就可以<strong>自动获得</strong>里面的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//synchronized版</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; sms&quot;</span>);</span><br><span class="line">        call();     <span class="comment">//这也有锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200509120043095.png" alt="image-20200509120043095"></p>
<h3 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3.自旋锁"></a>3.自旋锁</h3><p><strong>SpinLock</strong></p>
<p><img src="/%E3%80%90JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%80/image-20200509120442162.png" alt="image-20200509120442162"></p>
<h3 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h3><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV1B7411L7tE">https://www.bilibili.com/video/BV1B7411L7tE</a></p>
<p>Java官方文档：<a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p>
<p>EnjoyMoving：<a href="https://zhuanlan.zhihu.com/p/29881777">https://zhuanlan.zhihu.com/p/29881777</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>狂神说Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaScript快速入门】</title>
    <url>/2023/03/01/%E3%80%90JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/</url>
    <content><![CDATA[<h1 id="1-什么是JavaScript"><a href="#1-什么是JavaScript" class="headerlink" title="1.什么是JavaScript"></a>1.什么是JavaScript</h1><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h3 id="2-1-引入JavaScript"><a href="#2-1-引入JavaScript" class="headerlink" title="2.1 引入JavaScript"></a>2.1 引入JavaScript</h3><h3 id="2-2-基本语法"><a href="#2-2-基本语法" class="headerlink" title="2.2 基本语法"></a>2.2 基本语法</h3><h3 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>&#x3D;&#x3D;依旧不能用数字开头&#x3D;&#x3D;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A;</span><br><span class="line"><span class="keyword">var</span> $a;</span><br><span class="line"><span class="keyword">var</span> _a;</span><br><span class="line"><span class="keyword">var</span> 英雄联盟 = <span class="string">&quot;不屈黑铁&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><p>与Java基本一致，不区分整型浮点型</p>
<p>若要判断两个浮点型是否相等：<code>Math.abs(a - b) &lt; 0.00001</code></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单双引号都可</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><ul>
<li>true</li>
<li>false</li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul>
<li>&amp;&amp;</li>
<li>||</li>
<li>!</li>
</ul>
<h4 id="比较运算符（重要！）"><a href="#比较运算符（重要！）" class="headerlink" title="比较运算符（重要！）"></a>比较运算符（重要！）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a &gt; b;</span><br><span class="line">a &lt; b;</span><br><span class="line">a &gt;= b;</span><br><span class="line">a &lt;= b;</span><br><span class="line">a = b;		<span class="comment">//赋值</span></span><br><span class="line">a == b;		<span class="comment">//等于（数值相同，类型不同，也是true）</span></span><br><span class="line">a === b;	<span class="comment">//绝对等于（数值相同，类型不同，结果是false）</span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>用中括号表示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200504135210567.png" alt="image-20200504135210567"></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>用大括号表示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person person = new Person();</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;wxs&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">tags</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;java&#x27;</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200504134749562.png" alt="image-20200504134749562"></p>
<blockquote>
<p>严格检查模式（必须支持 es6 ）：</p>
<p>​	在 JavaScript 的最前面加上一行代码：<code>“use strict”</code>，预防 JavaScript 的随意性所产生的一些问题</p>
<p><strong>全局变量建议使用 let 去定义</strong>： <code>let a = 3;</code> </p>
</blockquote>
<h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h1><h3 id="3-1-字符串"><a href="#3-1-字符串" class="headerlink" title="3.1 字符串"></a>3.1 字符串</h3><ul>
<li><p>多行字符串编写 </p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg =</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">	hello</span></span><br><span class="line"><span class="string">	world</span></span><br><span class="line"><span class="string">	你好</span></span><br><span class="line"><span class="string">	世界</span></span><br><span class="line"><span class="string">	`</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;hello $&#123;name&#125;&#x27;</span>;	<span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串长度</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">str.<span class="property">length</span>;	<span class="comment">//注意这里是属性不是方法，没有括号</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>字符串是不可变的</p>
</li>
<li><p>大小写转换</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">str.<span class="title function_">toUpperCase</span>();	<span class="comment">//HELLO</span></span><br><span class="line">str.<span class="title function_">toLowerCase</span>();	<span class="comment">//hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找下标和截取字串</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">str.<span class="title function_">indexOf</span>(e);		<span class="comment">//1</span></span><br><span class="line">str.<span class="title function_">substring</span>(<span class="number">1</span>,<span class="number">3</span>);	<span class="comment">//&#x27;ell&#x27;,包头不包尾</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-数组"><a href="#3-2-数组" class="headerlink" title="3.2 数组"></a>3.2 数组</h3><p><strong>Array 可以包含任意数据类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;hh&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>长度</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="property">length</span>		<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>  注意：直接给 <code>arr.length</code> 赋值，数组大小会发生变化！</p>
<p>  ​			arr中出现空位会用 undefined 占位</p>
</li>
<li><p>查找下标</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">indexOf</span>(<span class="number">2</span>)	<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>截取Array中的一部分，返回一个新数组</strong></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">3</span>)	<span class="comment">//[1,2,3]，与substring相似</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>push、pop</p>
<p>  <img src="/%E3%80%90JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200504164228892.png" alt="image-20200504164228892"></p>
</li>
<li><p>unshift、shift</p>
<p>  <img src="/%E3%80%90JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200504164503808.png" alt="image-20200504164503808"></p>
</li>
<li><p>排序 sort()、反转 reverse()</p>
</li>
<li><p>拼接 concat()</p>
<p>  <img src="/%E3%80%90JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200504164752812.png" alt="image-20200504164752812"></p>
<p>  <strong>并没有修改数组，只是会返回一个新的数组</strong></p>
</li>
<li><p>连接符 join()</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>);				<span class="comment">//返回一个新的字符串</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-对象"><a href="#3-3-对象" class="headerlink" title="3.3 对象"></a>3.3 对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了一个person对象，有四个属性</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Allen&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">hobby</span>: [<span class="string">&#x27;sing&#x27;</span>,<span class="string">&#x27;jump&#x27;</span>,<span class="string">&#x27;rap&#x27;</span>,<span class="string">&#x27;basketball&#x27;</span>]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用一个不存在的对象属性，不会报错，会返回 <code>undefined</code></p>
</li>
<li><p>可以动态删减属性 <code>delete person.hobby</code></p>
</li>
<li><p>动态的添加属性 <code>person.haha = “haha”</code></p>
</li>
<li><p>判断某个 属性&#x2F;方法 是否在某个对象中</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> person;		<span class="comment">//true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> person;	<span class="comment">//继承了父类的方法</span></span><br><span class="line"></span><br><span class="line">person.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>);	<span class="comment">//false,判断自身有没有该方法或属性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-4-流程控制"><a href="#3-4-流程控制" class="headerlink" title="3.4 流程控制"></a>3.4 流程控制</h3><p>与 Java 语法基本一致</p>
<ul>
<li><p>if</p>
</li>
<li><p>while</p>
</li>
<li><p>for</p>
</li>
<li><p><strong>forEach</strong></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ages = [<span class="number">10</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>];</span><br><span class="line"><span class="comment">//需要传入一个函数</span></span><br><span class="line">ages.<span class="title function_">forEach</span>(<span class="params"><span class="keyword">function</span>(value)</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for in</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ages = [<span class="number">10</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>];</span><br><span class="line"><span class="comment">//注意取出的是索引！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> ages)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(age[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for of</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ages = [<span class="number">10</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>];</span><br><span class="line"><span class="comment">//注意取出的是值！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> ages)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-Map-和-Set"><a href="#3-5-Map-和-Set" class="headerlink" title="3.5 Map 和 Set"></a>3.5 Map 和 Set</h3><p><strong>ES6 的新特性</strong></p>
<ul>
<li>Map</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;tom&#x27;</span>,<span class="number">100</span>],[<span class="string">&#x27;jack&#x27;</span>,<span class="number">90</span>]]);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;dog&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> e <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Set</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);	<span class="comment">//[1,2,3,4]</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">set.<span class="title function_">delete</span>(<span class="number">2</span>);</span><br><span class="line">set.<span class="title function_">has</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h1 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h1><h3 id="4-1-定义函数"><a href="#4-1-定义函数" class="headerlink" title="4.1 定义函数"></a>4.1 定义函数</h3><p>拿绝对值函数举例：</p>
<ul>
<li>方式一（推荐，学习无成本）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="comment">//手动定义异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;not a number&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> abs = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="comment">//手动定义异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;not a number&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>function(x)&#123;……&#125;</code> 这是一个匿名函数，但是可以把结果赋值给 abs，通过 abs 就可以调用函数</p>
<p><strong>arguments：</strong><code>arguments</code> 是JS免费赠送的关键字</p>
<p>​						通过 <code>arguments</code> 获得所有传入的参数，是一个数组</p>
<p><strong>rest：</strong>获取除了使用的参数外其他传入的参数（ES6新特性）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a,b,...rest</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(rest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-变量作用域"><a href="#4-2-变量作用域" class="headerlink" title="4.2 变量作用域"></a>4.2 变量作用域</h3><ul>
<li><p>var 定义的变量，在函数体中声明，则在函数体外不可用（不过可以通过闭包在函数体外进行使用）</p>
</li>
<li><p>内部函数可以访问外部函数的成员，反之则不行</p>
</li>
<li><p>JavaScript 所有变量声明提到最前面（习惯）</p>
</li>
<li><p>默认所有的全局变量，都自动绑定在 <code>window</code> 对象下</p>
</li>
<li><p><strong>把自己的代码全放到自己定义的唯一空间名字中</strong>，降低全局命名冲突的问题</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">MyApp</span> = &#123;&#125;;</span><br><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="title class_">MyApp</span>.<span class="property">name</span> = <span class="string">&#x27;wxs&#x27;</span>;</span><br><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="title class_">MyApp</span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>建议使用 <code>let</code> 关键字定义局部作用域</strong></p>
</li>
<li><p>在ES6引入了常量关键字（只读变量） <code>const</code></p>
</li>
</ul>
<h3 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3 方法"></a>4.3 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;wxs&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1999</span>,</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="attr">age</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">birth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用属性</span></span><br><span class="line">person.<span class="property">name</span>;</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">person.<span class="title function_">age</span>();</span><br></pre></td></tr></table></figure>



<ul>
<li>apply：控制 <code>this</code> 指向</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>() - <span class="variable language_">this</span>.<span class="property">birth</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第一个参数为 this 需要指向的对象</span></span><br><span class="line"><span class="comment">* 第二个参数为传入的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getAge.<span class="title function_">apply</span>(person,[]);</span><br></pre></td></tr></table></figure>



<h1 id="5-内部对象"><a href="#5-内部对象" class="headerlink" title="5.内部对象"></a>5.内部对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准对象</span></span><br><span class="line"><span class="string">&quot;number&quot;</span></span><br><span class="line"><span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="string">&quot;boolean&quot;</span></span><br><span class="line"><span class="string">&quot;Object&quot;</span></span><br><span class="line"><span class="string">&quot;function&quot;</span></span><br><span class="line"><span class="string">&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1 Date"></a>5.1 Date</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">now.<span class="title function_">getFullYear</span>();</span><br><span class="line">now.<span class="title function_">getMonth</span>()      <span class="comment">//月 0-11</span></span><br><span class="line">now.<span class="title function_">getDate</span>();      <span class="comment">//日</span></span><br><span class="line">now.<span class="title function_">getDay</span>();       <span class="comment">//星期几</span></span><br><span class="line">now.<span class="title function_">getHours</span>();</span><br><span class="line">now.<span class="title function_">getMinutes</span>();</span><br><span class="line">now.<span class="title function_">getSeconds</span>();</span><br><span class="line"></span><br><span class="line">now.<span class="title function_">getTime</span>();      <span class="comment">//时间戳 全世界统一 1970.1.1 0：00：00 到现在的毫秒数</span></span><br><span class="line">now.<span class="title function_">toLocaleDateString</span>();</span><br></pre></td></tr></table></figure>

<h3 id="5-2-JSON"><a href="#5-2-JSON" class="headerlink" title="5.2 JSON"></a>5.2 JSON</h3><ul>
<li>JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。</li>
<li>在 JavaScript 中一切皆为对象，任何 js 支持的类型都可以用 JSON 表示</li>
<li>格式：<ul>
<li>对象都用 {}</li>
<li>数组都用 []</li>
<li>键值对都用 key:value</li>
</ul>
</li>
</ul>
<h1 id="6-DOM"><a href="#6-DOM" class="headerlink" title="6.DOM"></a>6.DOM</h1><p>DOM(Document Object Model)</p>
<p><strong>HTML DOM</strong> 模型被构造为<strong>对象</strong>的树：</p>
<p><img src="/%E3%80%90JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/pic_htmltree.gif" alt="DOM HTML tree"></p>
<blockquote>
<p>通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML。</p>
<ul>
<li>JavaScript 能够改变页面中的所有 HTML 元素</li>
<li>JavaScript 能够改变页面中的所有 HTML 属性</li>
<li>JavaScript 能够改变页面中的所有 CSS 样式</li>
<li>JavaScript 能够对页面中的所有事件做出反应</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>……</p>
<h1 id="7-jQuary"><a href="#7-jQuary" class="headerlink" title="7.jQuary"></a>7.jQuary</h1><p>jQuery 是 JavaScript 的一个库，里面包含了大量 JavaScript 的函数</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ul>
<li>下载：<a href="https://jquery.com/download/">https://jquery.com/download/</a></li>
<li>CND：<a href="https://www.bootcdn.cn/">https://www.bootcdn.cn/</a></li>
</ul>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    公式： $(selector).action</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test-jquery&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//选择器就是CSS选择器</span></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&#x27;#test-jquery&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;hello,jQuery&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.0/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行效果：<img src="/%E3%80%90JavaScript%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200507221332379.png" alt="image-20200507221332379"></p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原生js</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).<span class="title function_">click</span>();         <span class="comment">//标签选择器</span></span><br><span class="line">$(<span class="string">&#x27;#id1&#x27;</span>).<span class="title function_">click</span>();      <span class="comment">//id选择器</span></span><br><span class="line">$(<span class="string">&#x27;.class1&#x27;</span>).<span class="title function_">click</span>()    <span class="comment">//class选择器</span></span><br></pre></td></tr></table></figure>

<p>文档工具站：<a href="http://jquery.cuishifeng.cn/">http://jquery.cuishifeng.cn/</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：</p>
<p>菜鸟教程：<a href="https://www.runoob.com/js/js-htmldom.html">https://www.runoob.com/js/js-htmldom.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>狂神说Java</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode刷题笔记】</title>
    <url>/2023/03/12/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91/</url>
    <content><![CDATA[<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><p>在计算机科学中，trie，又称<strong>前缀树或字典树</strong>，是一种<strong>有序树</strong>，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230312151934.png"><br>简单实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前缀树结构</span></span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    children <span class="keyword">map</span>[<span class="type">rune</span>]*Trie</span><br><span class="line">    isEnd    <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTrie</span><span class="params">()</span></span> *Trie &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Trie&#123;children: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]*Trie)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line">    current := t</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> word &#123;</span><br><span class="line">        <span class="keyword">if</span> current.children[r] == <span class="literal">nil</span> &#123;</span><br><span class="line">            current.children[r] = &amp;Trie&#123;children: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]*Trie)&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.children[r]</span><br><span class="line">    &#125;</span><br><span class="line">    current.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    current := t</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> word &#123;</span><br><span class="line">        <span class="keyword">if</span> current.children[r] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current.children[r]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.isEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LeetCode范例：</p>
<ul>
<li><a href="https://leetcode.cn/problems/UhWRSj/?favorite=e8X3pBZi">剑指 Offer II 063. 替换单词</a></li>
<li><a href="https://leetcode.cn/problems/iSwD2y/description/?favorite=e8X3pBZi">剑指 Offer II 065. 最短的单词编码</a></li>
</ul>
<blockquote>
<p>注意事项：<br>标记 <code>isEnd</code> 位于当前节点的下一节点，即 <code>a-&gt;b-&gt;c-&gt;isEnd</code></p>
</blockquote>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组子集问题"><a href="#数组子集问题" class="headerlink" title="数组子集问题"></a>数组子集问题</h4><p><a href="https://leetcode.cn/problems/TVdhkn/description/?favorite=e8X3pBZi">剑指 Offer II 079. 所有子集 - 力扣（Leetcode）</a><br>思路：<br>令 <code>n = nums.length</code>，由于 <code>n &lt;= 10</code>，数组长度不长，所以可以考虑用一串长度为 <code>n</code> 的二进制串来表示各位要不要取（0：不取，1：取），那么共有 $2^n$ 种状态，以 <code>nums = [1, 2, 3]</code> 为例：</p>
<table>
<thead>
<tr>
<th align="center">二进制串</th>
<th align="left">子数组</th>
<th align="center">二进制串对应十进制数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">000</td>
<td align="left">[]</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">001</td>
<td align="left">[3]</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">010</td>
<td align="left">[2]</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">011</td>
<td align="left">[2,3]</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">100</td>
<td align="left">[1]</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">101</td>
<td align="left">[1,3]</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">110</td>
<td align="left">[1,2]</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">111</td>
<td align="left">[1,2,3]</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">那么遍历每种状态即可</td>
<td align="left"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">代码实现如下：</td>
<td align="left"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 遍历每种状态 [0, 2^n)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++ &#123;</span><br><span class="line">        subArr := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="comment">// 遍历nums数组，将二进制串中的 1 对应的数加入结果中</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i &amp; (<span class="number">1</span> &lt;&lt; j) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                subArr = <span class="built_in">append</span>(subArr, nums[j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, subArr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组全排列"><a href="#数组全排列" class="headerlink" title="数组全排列"></a>数组全排列</h4><p><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（LeetCode）</a><br>这类问题需要用到<strong>回溯算法</strong>，在解决之前最好先自己画一下<strong>回溯树</strong>来捋清楚关系！<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230312152101.png"></p>
<blockquote>
<p>图片来自<a href="https://leetcode.cn/problems/permutations/solutions/9914/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/?orderBy=most_votes">46. 全排列 题解 - 力扣（LeetCode）</a></p>
</blockquote>
<p>回溯模板：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> 满足终止条件 &#123;</span><br><span class="line">		将当前结果添加到最终结果中</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素(树中节点孩子的数量就是集合的大小)) &#123;</span><br><span class="line">        处理节点</span><br><span class="line">        backtrack()</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化变量</span></span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;  </span><br><span class="line">    n := <span class="built_in">len</span>(nums)  </span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)  </span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义递归函数</span></span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  </span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	    <span class="comment">// 触发终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == n &#123;  </span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, n)  </span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)   </span><br><span class="line">			res = <span class="built_in">append</span>(res, tmp)  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历元素  </span></span><br><span class="line">        <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;  </span><br><span class="line">            <span class="keyword">if</span> visited[i] &#123;  </span><br><span class="line">                <span class="keyword">continue</span>  </span><br><span class="line">            &#125;  </span><br><span class="line">            path = <span class="built_in">append</span>(path, num)  </span><br><span class="line">            visited[i] = <span class="literal">true</span>  </span><br><span class="line">            backtrack()  </span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]  </span><br><span class="line">            visited[i] = <span class="literal">false</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    backtrack()  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组中第-K-个最大元素"><a href="#数组中第-K-个最大元素" class="headerlink" title="数组中第 K 个最大元素"></a>数组中第 K 个最大元素</h4><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a><br>视频讲解：<a href="https://www.bilibili.com/video/BV1La411J7q9/">7-2「力扣」第 215 题：数组中的第 K个最大元素_哔哩哔哩_bilibili</a><br>求解一个数组中的第 $k$ 大元素，最朴素的想法是对数组进行排序，如何取数组中的第 $n-k$ 个元素即为第 $k$ 大元素。但是这样解决，就算使用高效的<strong>快速排序</strong>，时间复杂度也只能是 $O(nlogn)$，无法达到题目要求的 $O(n)$，故可以在快排的基础上进行改进（快速选择），来达到 $O(n)$ 的复杂度。</p>
<p>我们知道快排中的 <code>patition</code> 是用来选出一个枢轴元素<code>（pivot）</code>，将数组中的元素划分为大于 <code>nums[pivot]</code> 及小于 <code>nums[pivot]</code>两部分，如果此时的 <code>pivot</code> 正好等于  $n-k$ ，则说明此时的 <code>pivot</code> 处的元素就是第 $k$ 大元素。循着这个逻辑就可以利用二分思想缩小范围，直到  <code>pivot</code> 正好等于  $n-k$。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h4><p><a href="https://leetcode.cn/problems/lru-cache/description/">146. LRU 缓存 - 力扣（LeetCode）</a></p>
<p>实现 LRUCache 主要需要用到<strong>哈希链表</strong>，所以本题也可以转换为实现一个 <code>LinkedHashMap</code><br>哈希链表由一个 <strong>Map</strong> 和一个 <strong>双向链表</strong> 组成，双向链表是有序的，Map 可以帮助快速访问到链表中的结点。双向链表中包含了 Cache 中所需的 key、val 字段，Map 对 key 及对应的结点进行了映射 （<code>key</code> -&gt; <code>*Node</code>）<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230314145855.png"><br>具体代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;  </span><br><span class="line">   key   <span class="type">int</span>  </span><br><span class="line">   value <span class="type">int</span>  </span><br><span class="line">   next *Node  </span><br><span class="line">   pre *Node  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 实现双向链表  </span></span><br><span class="line"><span class="keyword">type</span> DoubleLinkedList <span class="keyword">struct</span> &#123;  </span><br><span class="line">   head *Node  </span><br><span class="line">   tail *Node  </span><br><span class="line">   size <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitList</span><span class="params">()</span></span> DoubleLinkedList &#123;  </span><br><span class="line">   head, tail := &amp;Node&#123;key:<span class="number">0</span>,value:<span class="number">0</span>&#125;, &amp;Node&#123;key:<span class="number">0</span>,value:<span class="number">0</span>&#125;  </span><br><span class="line">   head.next = tail  </span><br><span class="line">   tail.pre = head  </span><br><span class="line">   <span class="keyword">return</span> DoubleLinkedList&#123;  </span><br><span class="line">      head: head,  </span><br><span class="line">      tail: tail,  </span><br><span class="line">      size: <span class="number">0</span>,  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dll *DoubleLinkedList)</span></span> AddLast(node *Node) &#123;  </span><br><span class="line">   pre := dll.tail.pre  </span><br><span class="line">   pre.next = node  </span><br><span class="line">   node.pre = pre  </span><br><span class="line">   node.next = dll.tail  </span><br><span class="line">   dll.tail.pre = node  </span><br><span class="line">   dll.size++  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dll *DoubleLinkedList)</span></span> Remove(node *Node) &#123;  </span><br><span class="line">   node.pre.next = node.next  </span><br><span class="line">   node.next.pre = node.pre  </span><br><span class="line">   dll.size--  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dll *DoubleLinkedList)</span></span> RemoveFirst() *Node &#123;  </span><br><span class="line">   <span class="keyword">if</span> dll.head.next == dll.tail &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">   &#125;  </span><br><span class="line">   first := dll.head.next  </span><br><span class="line">   dll.Remove(first)  </span><br><span class="line">   <span class="keyword">return</span> first  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dll *DoubleLinkedList)</span></span> Size() <span class="type">int</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> dll.size  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;  </span><br><span class="line">   <span class="comment">// &#123;key : *Node&#125;  </span></span><br><span class="line">   mp <span class="keyword">map</span>[<span class="type">int</span>]*Node  </span><br><span class="line">   cache DoubleLinkedList  </span><br><span class="line">   capacity <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;  </span><br><span class="line">   <span class="keyword">return</span> LRUCache&#123;  </span><br><span class="line">      mp: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node),  </span><br><span class="line">      cache: InitList(),  </span><br><span class="line">      capacity: capacity,  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 插入的key在缓存中已有时，更新key  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> UpdateKey(key <span class="type">int</span>) &#123;  </span><br><span class="line">   <span class="comment">// 获取key对应的结点  </span></span><br><span class="line">   node := this.mp[key]  </span><br><span class="line">   <span class="comment">// 从链表中移除对应结点  </span></span><br><span class="line">   this.cache.Remove(node)  </span><br><span class="line">   <span class="comment">// 在链表尾部插入对应结点  </span></span><br><span class="line">   this.cache.AddLast(node)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三个方法是对 LRUCache 中 map 和 cache 方法的进一步封装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加某个key  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> AddKey(key, val <span class="type">int</span>) &#123;  </span><br><span class="line">   node := &amp;Node&#123;  </span><br><span class="line">      key: key,  </span><br><span class="line">      value: val,  </span><br><span class="line">   &#125;  </span><br><span class="line">   this.cache.AddLast(node)  </span><br><span class="line">   this.mp[key] = node  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 删除某个key  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> DeleteKey(key <span class="type">int</span>) &#123;  </span><br><span class="line">   node := this.mp[key]  </span><br><span class="line">   this.cache.Remove(node)  </span><br><span class="line">   <span class="built_in">delete</span>(this.mp, key)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 删除最近最久未使用key  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> DeleteLRU() &#123;  </span><br><span class="line">   LRUNode := this.cache.RemoveFirst()  </span><br><span class="line">   <span class="built_in">delete</span>(this.mp, LRUNode.key)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> this.mp[key] == <span class="literal">nil</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>  </span><br><span class="line">   &#125;  </span><br><span class="line">   this.UpdateKey(key)  </span><br><span class="line">   <span class="keyword">return</span> this.mp[key].value  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;  </span><br><span class="line">   <span class="keyword">if</span> this.mp[key] != <span class="literal">nil</span> &#123;  </span><br><span class="line">      this.DeleteKey(key)  </span><br><span class="line">      this.AddKey(key, value)  </span><br><span class="line">      <span class="keyword">return</span>  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">if</span> this.cache.Size() &gt;= this.capacity &#123;  </span><br><span class="line">      this.DeleteLRU()  </span><br><span class="line">   &#125;  </span><br><span class="line">   this.AddKey(key, value)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h5 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h5><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/?orderBy=most_votes">300. 最长递增子序列 - 力扣（LeetCode）</a><br>这种子序列问题一般联想到<strong>动态规划</strong>方法或者<strong>贪心</strong>算法，本题使用动态规划算法<br>动态规划步骤：</p>
<ol>
<li>定义状态<br> 令 $dp[i]$ 表示以 $nums[i]$ 结尾的【最长上升子序列】的长度（这个定义中 $nums[i]$ 必须是被选取的）</li>
<li>转台转移方程<br> $dp[i]&#x3D; \max_{0≤j&lt;i,nums[j]&lt;nums[i]} ​dp[j]+1$</li>
<li>初始化<br> $dp[i]&#x3D;1$</li>
<li>输出<br> 最后一个状态只表示以 $nums[len(nums)-1]$ 结尾的【最长上升子序列】的长度，应该返回的是 $dp[i]$ 中的最大值</li>
<li>空间优化<br> 遍历到一个新数的时候，之前所有的状态值都得保留，因此无法优化空间。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[i] &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        res = max(res, num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h5 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h5><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a><br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230311130411.png"><br>两种思路：</p>
<ol>
<li>使用<strong>优先队列</strong>（堆）存储滑动窗口中最大值的下标，然后滑动窗口每次移动，调整堆中的元素</li>
<li>使用<strong>单调栈</strong>！维护一个单调递减的栈。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dq <span class="keyword">struct</span> &#123;  </span><br><span class="line">   queue []<span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDQ</span><span class="params">()</span></span> *dq &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;dq&#123;  </span><br><span class="line">      queue: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *dq)</span></span> Front() <span class="type">int</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> q.queue[<span class="number">0</span>]  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *dq)</span></span> Rear() <span class="type">int</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> q.queue[<span class="built_in">len</span>(q.queue)<span class="number">-1</span>]  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *dq)</span></span> Empty() <span class="type">bool</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *dq)</span></span> Push(val <span class="type">int</span>) &#123;  </span><br><span class="line">   <span class="keyword">for</span> !q.Empty() &amp;&amp; val &gt; q.Rear() &#123;  </span><br><span class="line">      q.queue = q.queue[:<span class="built_in">len</span>(q.queue)<span class="number">-1</span>]  </span><br><span class="line">   &#125;  </span><br><span class="line">   q.queue = <span class="built_in">append</span>(q.queue, val)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *dq)</span></span> Pop(val <span class="type">int</span>) &#123;  </span><br><span class="line">   <span class="keyword">if</span> !q.Empty() &amp;&amp; val == q.Front() &#123;  </span><br><span class="line">      q.queue = q.queue[<span class="number">1</span>:]  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;  </span><br><span class="line">   queue := InitDQ()  </span><br><span class="line">   n := <span class="built_in">len</span>(nums)  </span><br><span class="line">   res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;  </span><br><span class="line">      queue.Push(nums[i])  </span><br><span class="line">   &#125;  </span><br><span class="line">   res = <span class="built_in">append</span>(res, queue.Front())  </span><br><span class="line">   <span class="keyword">for</span> i := k; i &lt; n; i++ &#123;  </span><br><span class="line">      queue.Pop(nums[i-k])  </span><br><span class="line">      queue.Push(nums[i])  </span><br><span class="line">      res = <span class="built_in">append</span>(res, queue.Front())  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> res  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】JavaEE</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91JavaEE/</url>
    <content><![CDATA[<h2 id="java环境变量配置"><a href="#java环境变量配置" class="headerlink" title="java环境变量配置"></a>java环境变量配置</h2><ul>
<li><p>进入配置文件</p>
<p><img src="/%E3%80%90Linux%E3%80%91JavaEE/image-20200413163743711.png" alt="image-20200413163743711"></p>
</li>
<li><p>配置环境变量</p>
<p><img src="/%E3%80%90Linux%E3%80%91JavaEE/image-20200413163802504.png" alt="image-20200413163802504"></p>
</li>
<li><p>注销用户，环境变量才能生效</p>
</li>
</ul>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><pre><code>运行tomcat需要在其文件夹bin目录下，执行：  
    ./startup.sh

使用windows系统访问在Linux部署的8080端口：
    1.vim /etc/sysconfig/iptables
    2.如图
    3.重启防火墙
</code></pre>
<p><img src="/%E3%80%90Linux%E3%80%91JavaEE/image-20200413163825021.png" alt="image-20200413163825021"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】RPM和RYUM</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91RPM%E5%92%8CRYUM/</url>
    <content><![CDATA[<h2 id="RPM包的管理"><a href="#RPM包的管理" class="headerlink" title="RPM包的管理"></a>RPM包的管理</h2><pre><code>rpm包的简单查询：
    查询已安装的rpm列表： rpm -qa|grep xx
    查询rpm包安装到哪：   rpm -ql xxx
    根据文件查询软件包：  rpm -qf 软件路径

rpm包卸载
    rpm -e rpm包名
    rpm -e --nodeps 包名 （强制删除）
    
rpm包安装
    rpm -ivh RPM包全路径名称
        i：安装
        v：提示
        h：进度条
</code></pre>
<h2 id="YUM包的管理（需要联网）"><a href="#YUM包的管理（需要联网）" class="headerlink" title="YUM包的管理（需要联网）"></a>YUM包的管理（需要联网）</h2><pre><code>查询：
    yum list | grep xxx
安装：
    yum install xxx
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】vi和vim</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91vi%E5%92%8Cvim/</url>
    <content><![CDATA[<h2 id="vi-x2F-vim的进入与退出"><a href="#vi-x2F-vim的进入与退出" class="headerlink" title="vi&#x2F;vim的进入与退出"></a>vi&#x2F;vim的进入与退出</h2><pre><code>进入：
    vim xxx
插入：
    i：开始编辑
    a：从下一行开始编辑
退出插入模式：
    Esc
命令行模式：
    ： 输入命令
    qw 保存并推出
    q  在没有修改的情况下退出
    q! 强制退出，不保存
</code></pre>
<h2 id="vi-x2F-vim的快捷键"><a href="#vi-x2F-vim的快捷键" class="headerlink" title="vi&#x2F;vim的快捷键"></a>vi&#x2F;vim的快捷键</h2><pre><code>1.(正常模式)
   拷贝当前行   yy
   拷贝向下五行 5yy
   粘贴         p

2. 删除当前行   dd
   删除向下五行 5dd

3. 在文件中查找某个词(命令行下) 
        /xxx 
        输入 n 查找下一个
    
4. 设置显示/取消文件行号(命令行下)
        set nu
        set nonu 

5. 跳转到文档的首行或尾行(正常模式)
    首行：  gg
    尾行：  G
    
6. 撤销动作 u (正常模式)

7. 移动光标至指定行(正常模式 2、3)
    1. 显示行号
    2. 输入行号
    3. shift + g
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】定时任务调度</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h2><pre><code>基本语法：
    crontab [选项]
    选项：
        -e：编辑
        -l：查询
        -r：删除当前用户所有的crontab任务
参数说明：
</code></pre>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个 *</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个 *</td>
<td>一天当中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个 *</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个 *</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个 *</td>
<td>一周当中的星期几</td>
<td>0- 7</td>
</tr>
</tbody></table>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><pre><code>1.写shell脚本
2.将.sh文件设为可执行文件
3.crontab -e
4.* * * * * xx.sh
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】实用指令</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h4><pre><code>0：关机
1：单用户（找回密码）
2：多用户无网络服务
3：多用户有网络服务 （常用）
4：保留
5：图形界面（常用）
6：重启

运行级别配置文件：/etc/inittab

命令：init [012356]

面试题：如何找回丢失的root密码？
思路：  进入单用户模式，然后修改root密码
操作： 
    1.在引导时按回车
    2.看到界面后输 e
    3.选中第二行（编辑内核），再输入 e
    4.在这行最后输入 1，再回车
    5.再次输入 b
    6.进入单用户模式，使用passwd修改密码
</code></pre>
<h4 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h4><pre><code>1.man
    语法：
        man [命令或配置文件] 
2.help
    语法：
        help 命令
</code></pre>
<h4 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h4><pre><code>1.pwd 显示当前工作目录的绝对路径

2.ls
    ls [选项] [目录或是文件]
    选项：
        -a ：显示所有文件
        -l ：以列表形式显示
        ……

3.cd 切换目录
    cd ~ || cd ： 回到自己家目录
    cd ..      ： 回到上级目录
    
    绝对路径： /home
    相对路径： ../home

4.mkdir 创建目录
    mkdir [选项] 要创建的目录
    选项：
        -p：创建多级目录

5.rmdir 删除目录
    rmdir [选项] 要删除的目录
    
    rm -rf 要删除的目录 
    
6.touch 创建空文件
    touch 文件名
    可以一次性创建多个文件
    
7.cp
    cp [选项] 准备拷的文件 目标文件
    选项：
        -r：递归复制整个文件夹
    
    \cp -r test/ zwj/
        强制覆盖相同的文件并且不会提示

8.rm 移除文件或目录
    rm [选项] 要删除的文件或目录
    选项：
        -r：递归删除整个文件夹
        -f：强制删除不提示
        
9.mv 移动文件与目录或重命名
    mv 旧文件名 新文件名 （重命名）
    mv 文件名 新的文件所在路径 （移动文件）

10.cat 查看文件内容
    实例： cat -n /etc/profile | more
        -n：显示行数
        | more：分页显示（管道命令）
        
11.more 以全屏的方式按页显示文本文件的内容

12.less 分屏查看内容，功能与more相似，对于显示大文件有较高效率
    空格：翻页
    /xxx: 向下查找
    ?xxx：向上查找

13.&gt; 和 &gt;&gt; 输出重定向和追加
    ls -l &gt; a.txt
        将 ls -l 所显示的内容写到 a.txt 中
        &gt; :覆盖原来的
        &gt;&gt;:追加到后面
    cat a.txt &gt; b.txt
        将 a.txt 中的内容（覆盖）写入 b.txt 中
    echo &quot;hello world&quot; &gt;&gt; c.txt
        将 xxx 写入 c.txt 中
    
    （cal：显示当前日历）
    
14.echo 输出内容到控制台
    echo [选项] [输出内容]
    
    echo $PATH 输出环境变量路径
    
15.head 查看文件前10行内容
    head -n 5 文件
        指定显示前五行

16.tail 显示文件后10行
    tail -n 5 文件
    tail -f 显示文件的实时更新
    
17.ln 软链接，类似于windows里的快捷方式
    ln -s [原文件或目录] [软链接名]
    
18.history 查看已经执行过的指令
    history
        显示所有执行过的命令
    history 10
        显示最近使用的10个指令
    
    !267
        执行编号为267的指令
</code></pre>
<h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><pre><code>1.date
    date
    date &quot;+%Y-%m-%d %H:%M:%S&quot;
    
    date -s 字符串时间
        设置时间

2.cal
    cal
    cal 2020
</code></pre>
<h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><pre><code>find
    find [搜索范围/目录] [选项]
    选项：
        -name 按文件名查找
        
        -user 按文件拥有者查找
        
        -size 按文件大小查找(n是数字)
            +n 大于
            -n 小于
            n  等于

locate  快速定位文件路径
    先 updatedb (创建数据库)
    再 locate 文件名

grep 过滤查找
    &quot;|&quot; 管道符号：表示将前一个命令的输出结果传递给后一个命令
    grep [选项] 查找内容 源文件
    选项：
        -n：显示匹配行及行号
        -i：忽略字母大小写
</code></pre>
<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><pre><code>gzip：压缩文件，不保留原来文件
    gzip 文件名
gunzip：解压文件
    gunzip 文件名.gz

zip：压缩文件
    zip [选项] xxx.zip 要压缩的文件
    选项：
        -r：递归压缩，压缩整个目录
unzip：解压文件
    unzip [选项] xxx.zip
        -d：指定压缩目录
        
tar：打包指令
    tar [选项] xxx.tar.gz 打包的文件
    选项：
        -c：产生 .tar 打包文件
        -v：显示详细信息
        -f：指定压缩后的文件名
        -z：打包同时压缩
        -x：解包 .tar 文件
</code></pre>
<p><img src="/%E3%80%90Linux%E3%80%91%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/image-20200413162042684.png" alt="image-20200413162042684"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】文件目录</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p><img src="/%E3%80%90Linux%E3%80%91%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/image-20200413162623021.png" alt="image-20200413162623021"></p>
<pre><code>/bin(Binary):
    存放经常使用的命令

/boot：
    存放启动Linux时使用的一些核心文件，包括一些连接文件和镜像文件
    
/dev(Device)：
    存放Linux的外部设备
    
/etc：
    存放所有系统管理所需要的配置文件和子目录
    
/home：
    用户的主目录
    每个用户都有一个自己的目录
    
/lib：
    存放系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。
    几乎所有的文件都要用到这些共享库
    
/lost+found
    非法关机后存放一些文件
    
/media：
    自动识别一些设备，如U盘、DVD
    识别后将识别设备挂载在该目录下
    
/mnt：
    让用户临时挂载别的文件系统
    
/opt：
    给主机额外安装软件所摆放的目录
    
/proc：
    虚拟目录，是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息
    
/root：
    该目录为系统管理员，也称作超级权限者的用户主目录。
    
/sbin：
    s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。

/selinux：
    Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。

/srv：
    该目录存放一些服务启动之后需要提取的数据。

/sys：
    系统文件

/tmp：
    临时文件夹
    
/user：
    这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。

/var：
    这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。
    
/run：
    是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】磁盘分区和挂载</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%92%8C%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h2><pre><code>分区方式：
    1.mbr分区
    2.gtp分区
</code></pre>
<p><img src="/%E3%80%90Linux%E3%80%91%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%92%8C%E6%8C%82%E8%BD%BD/image-20200413162818574.png" alt="image-20200413162818574"></p>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><pre><code>给Linux增加一块硬盘，并挂载在/home/bin
</code></pre>
<h4 id="如何添加一块硬盘"><a href="#如何添加一块硬盘" class="headerlink" title="如何添加一块硬盘"></a>如何添加一块硬盘</h4><pre><code>1.虚拟机添加硬盘
2.分区
    fdisk /dev/sdb
    m
    n
    ……
    w
3.格式化
    mkfs -t ext4 /dev/sdb1
4.挂载
    先创建一个目录
    挂载：mount /dev/sdb1 /home/newdisk
5.设置可以自动挂载  
    vim /etc/fstab
    /dev/sdb1            /home/newdisk           ext4    defaults        0 0

删除挂载：
    umount /dev/sdb1
</code></pre>
<h4 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h4><pre><code>查询系统整体磁盘使用情况：
    df -l
查询指定目录的磁盘占用情况
    du -h /目录
        -s：指定目录占用大小汇总
        -h：带计量单位
        -a：含文件
        -c：列出明细同时，增加汇总值
        --max-depth=1：查询子目录深度
</code></pre>
<h4 id="工作实用指令："><a href="#工作实用指令：" class="headerlink" title="工作实用指令："></a>工作实用指令：</h4><pre><code>1. 统计/home目录下文件个数
    ls -l /home | grep &quot;^-&quot; | wc -l
2. 统计/home目录下目录个数
    ls -l /home | grep &quot;^d&quot; | wc -l
3. 统计/home文件夹下文件的个数，包括子文件夹
    ls -lR /home | grep &quot;^-&quot; | wc -l
4. 统计文件夹下目录个数，包括子文件夹里的
    ls -lR /home | grep &quot;^d&quot; | wc -l
5. 以树状图形式显示目录
    yum install tree
    tree
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】用户管理</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h2><pre><code>shutdown
    shutdown -h now：立即关机
    shutdown -h 1：  一分钟后关机
    shutdown -r now： 立即重启
halt
    直接使用，效果等价于关机
reboot
    重启系统
sync
    将内存的东西保存到磁盘上
    （关机前使用）
</code></pre>
<h2 id="登陆和注销"><a href="#登陆和注销" class="headerlink" title="登陆和注销"></a>登陆和注销</h2><pre><code>尽量少用root账号登陆
su -用户名
    切换用户
注销用户：
    logout
    在图形用户界面是无效的
</code></pre>
<h2 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h2><h4 id="添加用户-x2F-用户组"><a href="#添加用户-x2F-用户组" class="headerlink" title="添加用户&#x2F;用户组"></a>添加用户&#x2F;用户组</h4><pre><code>useradd [可选项] 用户名
可选项：
    -d 指定目录
    
groupadd 组名
    增加用户组
    
useradd -g 用户组 用户名
    增加用户时指定组
</code></pre>
<h4 id="指定-x2F-修改密码"><a href="#指定-x2F-修改密码" class="headerlink" title="指定&#x2F;修改密码"></a>指定&#x2F;修改密码</h4><pre><code>passwd 用户名
</code></pre>
<h4 id="删除用户-x2F-用户组"><a href="#删除用户-x2F-用户组" class="headerlink" title="删除用户&#x2F;用户组"></a>删除用户&#x2F;用户组</h4><pre><code>userdel 用户名
    删除用户，但保留家目录
userdel -r 用户名
    删除用户，不保留家目录
删除用户时，一般不删家目录

groupdel 组名
    删除用户组
</code></pre>
<h4 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h4><pre><code>id 用户名
</code></pre>
<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><pre><code>su - 用户名
高权限到低权限不需要密码
exit 返回到原来的用户
</code></pre>
<h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><pre><code>usermod -g 新用户组 用户名
</code></pre>
<h4 id="用户和组的相关文件"><a href="#用户和组的相关文件" class="headerlink" title="用户和组的相关文件"></a>用户和组的相关文件</h4><pre><code>/etc/passwd 用户配置文件
/etc/group  组配置文件（加密过了）
/etc/shadow 口令配置文件
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】组管理与权限管理</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91%E7%BB%84%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><h4 id="文件-x2F-目录所有者"><a href="#文件-x2F-目录所有者" class="headerlink" title="文件&#x2F;目录所有者"></a>文件&#x2F;目录所有者</h4><pre><code>查看文件的所有者
    ls -ahl
    ll

修改文件所有者
    chown 用户名 文件名
        -R：递归修改整个文件夹
</code></pre>
<h4 id="文件-x2F-目录所在组"><a href="#文件-x2F-目录所在组" class="headerlink" title="文件&#x2F;目录所在组"></a>文件&#x2F;目录所在组</h4><pre><code>修改文件所在组
    chgrp 组名 文件名
</code></pre>
<h4 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h4><pre><code>usermod -g 组名 用户名
</code></pre>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><pre><code>文件类型：
    -：普通文件
    d：目录
    l：链接文件
    c：字符设备（键盘、鼠标）
    b: 块文件（硬盘）
文件所有者权限
    r：读   4
    w：写   2
    x：执行 1
文件所在组的用户拥有的权限
    r
    w
    x
文件其他组的用户拥有的权限
    r
    w
    x
文件硬链接数目或文件子目录个数
</code></pre>
<p><img src="/%E3%80%90Linux%E3%80%91%E7%BB%84%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20200413162237397.png" alt="image-20200413162237397"></p>
<pre><code>rwx权限作用于文件和作用于目录不同
    作用于文件：w不一定能删，只是有前提
    作用于目录：可以写入修改删除
</code></pre>
<h4 id="修改、管理权限"><a href="#修改、管理权限" class="headerlink" title="修改、管理权限"></a>修改、管理权限</h4><pre><code>u：所有者 g：所有组 o：其他人 a：所有人
+：增加权限     -：减少权限

1.chmod u=rwx，g=rx，o=x 文件目录名
  chmod 751 文件目录名
2.chmod o+w 文件目录名
3.chmod a-x 文件目录名
</code></pre>
<p><img src="/%E3%80%90Linux%E3%80%91%E7%BB%84%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86.assets/image-20200413162311127.png" alt="image-20200413162311127"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】网络配置</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="查看网络IP和网关"><a href="#查看网络IP和网关" class="headerlink" title="查看网络IP和网关"></a>查看网络IP和网关</h2><h4 id="查看虚拟网络编辑器"><a href="#查看虚拟网络编辑器" class="headerlink" title="查看虚拟网络编辑器"></a>查看虚拟网络编辑器</h4><p><img src="/%E3%80%90Linux%E3%80%91%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20200413163022103.png" alt="image-20200413163022103"></p>
<h2 id="Linux网路环境配置"><a href="#Linux网路环境配置" class="headerlink" title="Linux网路环境配置"></a>Linux网路环境配置</h2><pre><code>第一种方式（自动获取）：
    系统——首选项——网络连接……
第二种方式（指定固定IP)
    直接修改配置文件来指定IP，并可以连接到外网
</code></pre>
<p><img src="/%E3%80%90Linux%E3%80%91%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20200413163103057.png" alt="image-20200413163103057"></p>
<p><img src="/%E3%80%90Linux%E3%80%91%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20200413163118404.png" alt="image-20200413163118404"></p>
<pre><code>修改后一定要重启服务：
    service network restart
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】进程管理</title>
    <url>/2020/04/13/%E3%80%90Linux%E3%80%91%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h2><pre><code>指令：ps
参数：
    -a： 显示所有进程
    -u： 以用户格式显示
    -x： 显示后台运行的参数
    -ef：查看父进程

pstree(以树状形式查看进程)
    -u 以用户格式显示
</code></pre>
<h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><pre><code>kill [选项] 进程号
killall 进程名

选项：
    -9：强制终止
</code></pre>
<h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><pre><code>service 服务名 [start|stop|restart|reload|status]
CentOS7.0后，不再使用 service，改用 systemctl

查看服务名：
    1.setup
    2.ls -l /etc/init.d/
    
开机流程：
    1.开机
    2.BIOS
    3./boot
    4.init进程1
    5.运行级别
    6.运行级别对应服务
    
给每个运行级别设置自启动/关闭——chkconfig 
    1.查看服务
        chkconfig --list | grep xx
    2.chkconfig 服务名 --list
    3.设置是否自启动
        chkconfig --level 5 服务名 on/off
        
        checkconfig --add 服务名：加入服务
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【MyBatisPlus】</title>
    <url>/2023/03/01/%E3%80%90MyBatisPlus%E3%80%91/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h3 id="为什么学"><a href="#为什么学" class="headerlink" title="为什么学"></a>为什么学</h3><p>学习每门新技术之前我们都需要先问自己一个问题： <strong>学它干嘛？！</strong></p>
<p>MyBatisPlus是在MyBatis基础上进行了一系列的简化操作，可以节省我们大量的工作时间，<strong>自动化完成所有的CRUD操作</strong>（可以偷懒不写SQL语句）。</p>
<p>同类型框架：JPA、th-mapper</p>
<p>在了解了为什么要学习它之后我们开始正式的学习之旅~~~</p>
<p>先去官网康一康（好习惯！）：<a href="https://mp.baomidou.com/">https://mp.baomidou.com/</a></p>
<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430135454417.png" alt="image-20200430135454417"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430135642971.png" alt="image-20200430135642971"></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><a href="https://mp.baomidou.com/guide/quick-start.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B">https://mp.baomidou.com/guide/quick-start.html#初始化工程</a></p>
<blockquote>
<p>使用第三方组件：</p>
<ol>
<li>导入对应依赖</li>
<li>研究依赖如何配置</li>
<li>研究代码如何编写</li>
<li>提高拓展技术能力</li>
</ol>
</blockquote>
<h3 id="1-创建数据库-mybatis-plus"><a href="#1-创建数据库-mybatis-plus" class="headerlink" title="1.创建数据库 mybatis_plus"></a>1.创建数据库 <code>mybatis_plus</code></h3><table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
<th align="center">age</th>
<th align="center">email</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Jone</td>
<td align="center">18</td>
<td align="center"><a href="mailto:&#116;&#x65;&#x73;&#x74;&#49;&#64;&#x62;&#x61;&#111;&#109;&#x69;&#100;&#x6f;&#x75;&#46;&#99;&#111;&#x6d;">&#116;&#x65;&#x73;&#x74;&#49;&#64;&#x62;&#x61;&#111;&#109;&#x69;&#100;&#x6f;&#x75;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Jack</td>
<td align="center">20</td>
<td align="center"><a href="mailto:&#116;&#x65;&#x73;&#116;&#x32;&#x40;&#x62;&#x61;&#111;&#x6d;&#x69;&#x64;&#111;&#x75;&#46;&#x63;&#x6f;&#x6d;">&#116;&#x65;&#x73;&#116;&#x32;&#x40;&#x62;&#x61;&#111;&#x6d;&#x69;&#x64;&#111;&#x75;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Tom</td>
<td align="center">28</td>
<td align="center"><a href="mailto:&#x74;&#101;&#115;&#x74;&#51;&#x40;&#x62;&#97;&#111;&#109;&#105;&#x64;&#111;&#117;&#x2e;&#x63;&#x6f;&#109;">&#x74;&#101;&#115;&#x74;&#51;&#x40;&#x62;&#97;&#111;&#109;&#105;&#x64;&#111;&#117;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Sandy</td>
<td align="center">21</td>
<td align="center"><a href="mailto:&#x74;&#101;&#x73;&#x74;&#x34;&#x40;&#x62;&#x61;&#111;&#109;&#x69;&#100;&#x6f;&#117;&#x2e;&#x63;&#x6f;&#x6d;">&#x74;&#101;&#x73;&#x74;&#x34;&#x40;&#x62;&#x61;&#111;&#109;&#x69;&#100;&#x6f;&#117;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">Billie</td>
<td align="center">24</td>
<td align="center"><a href="mailto:&#x74;&#x65;&#x73;&#x74;&#x35;&#x40;&#x62;&#97;&#x6f;&#x6d;&#x69;&#100;&#111;&#x75;&#46;&#x63;&#x6f;&#109;">&#x74;&#x65;&#x73;&#x74;&#x35;&#x40;&#x62;&#97;&#x6f;&#x6d;&#x69;&#100;&#111;&#x75;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">	id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">	age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">	email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-初始化项目（使用SpringBoot初始化）"><a href="#2-初始化项目（使用SpringBoot初始化）" class="headerlink" title="2.初始化项目（使用SpringBoot初始化）"></a>2.初始化项目（使用SpringBoot初始化）</h3><img src="【MyBatisPlus】/image-20200430172958328.png" alt="image-20200430172958328" style="zoom:67%;" />

<h3 id="3-导入依赖"><a href="#3-导入依赖" class="headerlink" title="3.导入依赖"></a>3.导入依赖</h3><p>&#x3D;&#x3D;注意！mybatis-plus和mybatis只能导入一个，否则容易发生包冲突&#x3D;&#x3D;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-配置数据源"><a href="#4-配置数据源" class="headerlink" title="4.配置数据源"></a>4.配置数据源</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?userUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">abc123aa</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># mysql8的驱动,com.mysql.cj.jdbc.Driver，需要增加时区配置，serverTimezone=GMT%2B8 时区配置</span></span><br></pre></td></tr></table></figure>

<h3 id="5-编写三层架构"><a href="#5-编写三层架构" class="headerlink" title="5.编写三层架构"></a>5.编写三层架构</h3><p>以前：pojo -&gt; dao(连接mybatis，配置mapper.xml) -&gt; service -&gt; controller</p>
<p>现在：</p>
<ul>
<li><p>pojo</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mapper接口</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承父类BastMapper&lt;&gt;</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  我们来简单看一看这个<code>BaseMapper&lt;&gt;</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T var1, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; var2)</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">selectById</span><span class="params">(Serializable var1)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; var1, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; var2)</span>;</span><br><span class="line"></span><br><span class="line">    IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; var1, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; var2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.wxshhh.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisPlusApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisPlusApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//参数是一个 Wrapper（条件构造器）</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//语法糖</span></span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430175311181.png" alt="image-20200430175311181"></p>
</li>
</ul>
<h1 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h1><p>我们所有的sql现在是不可见的，我们需要知道他们是怎么执行的，所有需要配置日志</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置日志</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430175911723.png" alt="image-20200430175911723"></p>
<p>配置完毕日志之后，后面的学习就需要注意自动生成的SQL了！</p>
<h1 id="CRUD扩展"><a href="#CRUD扩展" class="headerlink" title="CRUD扩展"></a>CRUD扩展</h1><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;wxs&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;993012459@qq.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> userMapper.insert(user);       <span class="comment">//自动生成id</span></span><br><span class="line">    System.out.println(insert);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430180453064.png" alt="image-20200430180453064"></p>
<h3 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h3><p> 分布式系统唯一ID生成方案汇总：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p>
<ol>
<li><p>数据库自增长序列或字段</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>

<p> <img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430181955504.png" alt="image-20200430181955504"></p>
<p> <strong>同时需要把数据库中的 自增 勾选上！</strong></p>
</li>
<li><p>UUID</p>
</li>
<li><p>UUID变种</p>
</li>
<li><p>Redis生成ID</p>
</li>
<li><p><strong>Twitter的snowflake算法</strong></p>
<p> snowflake是Twitter开源的分布式ID生成算法，结果是一个<strong>long型的ID</strong>。其核心思想是：使用41bit作为<strong>毫秒数</strong>，10bit作为<strong>机器的ID</strong>（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的<strong>流水号</strong>（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个<strong>符号位</strong>，永远是0。</p>
</li>
</ol>
<img src="【MyBatisPlus】/image-20200430182503691.png" alt="image-20200430182503691"  />

 

<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;993012450@qq.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> userMapper.updateById(user);      <span class="comment">//注意，这里传入的参数是User类型的</span></span><br><span class="line">    System.out.println(insert);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有sql都是自动动态配置的！</p>
<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430183443405.png" alt="image-20200430183443405"></p>
<h3 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h3><p>阿里巴巴开发手册：所有的数据库表中，<code>gmt_create</code>、<code>gmt_modified</code>几乎都要配置上！（需要自动化）</p>
<p>创建时间、修改时间……这些操作一般都是自动化完成的，不希望手动进行更新！</p>
<h5 id="1-数据库级别"><a href="#1-数据库级别" class="headerlink" title="1.数据库级别"></a>1.数据库级别</h5><ul>
<li><p>在表中新增字段 <code>create_time</code>、<code>update_time</code></p>
<p>  <img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430184333565.png" alt="image-20200430184333565"></p>
</li>
<li><p>再次测试插入方法（先同步实体类）</p>
  <img src="【MyBatisPlus】/image-20200430184517341.png" alt="image-20200430184517341"  />

<p>  <img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430184656236.png" alt="image-20200430184656236"></p>
<p>  <img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430184713299.png" alt="image-20200430184713299"></p>
</li>
</ul>
<h5 id="2-代码级别"><a href="#2-代码级别" class="headerlink" title="2. 代码级别"></a>2. 代码级别</h5><ul>
<li><p>删除数据库的默认值、更新操作</p>
<p>  <img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430184851761.png" alt="image-20200430184851761"></p>
</li>
<li><p>实体类的字段属性上增加注解</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写处理器来处理注解</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">//一定不要忘记把处理器加到容器当中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaBojectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill.....&quot;</span>);</span><br><span class="line">        <span class="comment">//default MetaObjectHandler setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject)</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill.....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>面试常客！！！</p>
<blockquote>
<p>乐观锁：顾名思义，十分乐观，总是认为不会出现问题，无论干什么都不会去上锁。如果出现了问题，再次更新值测试。</p>
<p>悲观锁：顾名思义，顾名思义，总是认为会出现问题，无论干什么都会去上锁。再去操作。</p>
</blockquote>
<p>我们主要研究乐观锁机制！</p>
<p>意图：当要更新一条记录的时候，希望这条记录没有被别人更新</p>
<h5 id="乐观锁实现方式："><a href="#乐观锁实现方式：" class="headerlink" title="乐观锁实现方式："></a>乐观锁实现方式：</h5><ul>
<li>取出记录时，获取当前version</li>
<li>更新时，带上这个version</li>
<li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li>
<li>如果version不对，就更新失败</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- A线程</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;wxs&quot;,version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- B线程 （抢先完成，version = 2，导致 A 的修改失败）</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;hhh&quot;,version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="测试一下乐观锁插件"><a href="#测试一下乐观锁插件" class="headerlink" title="测试一下乐观锁插件"></a>测试一下乐观锁插件</h5><ol>
<li><p>给数据库中添加 <code>version</code> 字段</p>
<p> <img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200430191805218.png" alt="image-20200430191805218"></p>
</li>
<li><p>实体类加对应字段</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span>    <span class="comment">//乐观锁version注解</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册组件</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.wxshhh.mapper&quot;)</span>	<span class="comment">//包扫描可以放在配置类中</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 特别说明:</p>
<blockquote>
<ul>
<li><strong>支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</strong></li>
<li>整数类型下 <code>newVersion = oldVersion + 1</code></li>
<li><code>newVersion</code> 会回写到 <code>entity</code> 中</li>
<li>仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法</li>
<li><strong>在 <code>update(entity, wrapper)</code> 方法下, <code>wrapper</code> 不能复用!!!</strong></li>
</ul>
</blockquote>
</li>
<li><p>测试</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">optimisticLocker</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程一</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user1.setName(<span class="string">&quot;T1&quot;</span>);</span><br><span class="line">    user1.setEmail(<span class="string">&quot;123456@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程二</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user2.setName(<span class="string">&quot;T2&quot;</span>);</span><br><span class="line">    user2.setEmail(<span class="string">&quot;123456@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟线程二的插队操作</span></span><br><span class="line">    userMapper.updateById(user2);</span><br><span class="line">    <span class="comment">//如果没有乐观锁，就会覆盖插队线程的值</span></span><br><span class="line">    userMapper.updateById(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 执行结果：</p>
<p> <img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200501103802910.png" alt="image-20200501103802910"></p>
<p> <strong>结论：多线程下的操作一定要加锁</strong></p>
</li>
</ol>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单个查询</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量查询</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过map进行简单的条件查询</span></span><br><span class="line">HashMap&lt;String，Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>,<span class="number">3</span>);</span><br><span class="line">userMapper.selectByMap(map);</span><br></pre></td></tr></table></figure>

<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul>
<li>原始的使用 limit 进行分页</li>
<li>pageHelper 第三方插件</li>
<li>MybatisPlus 内置了分页插件</li>
</ul>
<p>使用方法：</p>
<ol>
<li>导入分页插件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.wxshhh.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PaginationInterceptor</span> <span class="variable">paginationInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">        <span class="comment">// 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false</span></span><br><span class="line">        <span class="comment">// paginationInterceptor.setOverflow(false);</span></span><br><span class="line">        <span class="comment">// 设置最大单页限制数量，默认 500 条，-1 不受限制</span></span><br><span class="line">        <span class="comment">// paginationInterceptor.setLimit(500);</span></span><br><span class="line">        <span class="comment">// 开启 count 的 join 优化,只针对部分 left join</span></span><br><span class="line">        paginationInterceptor.setCountSqlParser(<span class="keyword">new</span> <span class="title class_">JsqlParserCountOptimize</span>(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.wxshhh.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>直接使用Page对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数一：当前页</span></span><br><span class="line"><span class="comment">     * 参数二：页面大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除操作大致与查询操作相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单个查询</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量查询</span></span><br><span class="line">List&lt;User&gt; users = userMapper.deleteBatchIds(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过map进行简单的条件查询</span></span><br><span class="line">HashMap&lt;String，Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>,<span class="number">3</span>);</span><br><span class="line">userMapper.deleteByMap(map);</span><br></pre></td></tr></table></figure>



<h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><ul>
<li><p>物理删除：从数据库中直接移除</p>
</li>
<li><p>逻辑删除：在数据库中没有被移除，而是通过一个变量让它失效（deleted &#x3D; 0 &#x3D;&gt; deleted &#x3D; 1）</p>
<p>  管理员可以查看被删除的记录！防止数据的丢失，类似于回收站的功能</p>
</li>
</ul>
<p>测试：</p>
<ol>
<li><p>数据表中增加 <code>deleted</code> 字段</p>
<p> <img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200501110854138.png" alt="image-20200501110854138"></p>
</li>
<li><p>pojo中增加字段</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> deleted;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.1.1版本之后不再需要这一步</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ISqlInjector <span class="title function_">sqlInjector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogicSqlInjector</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">flag</span>  <span class="comment">#全局逻辑删除字段值 3.3.0开始支持，详情看下面。</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>本质走的是更新操作，更新了 <code>deleted</code> 的值</p>
<p>效果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> deleted<span class="operator">=</span><span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> deleted<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="comment">-- 查找</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> deleted<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200501112816306.png" alt="image-20200501112816306"></p>
<h3 id="性能分析插件"><a href="#性能分析插件" class="headerlink" title="性能分析插件"></a>性能分析插件</h3><p>在平时开发中会遇到一些慢 sql </p>
<p>MybatisPlus也提供了性能分析插件，如果超过某个时间，就停止运行！</p>
<ol>
<li><p>导入插件</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Spring boot方式</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.wxshhh.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SQL执行效率插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span><span class="comment">// 设置 dev test 环境开启</span></span><br><span class="line">    <span class="keyword">public</span> PerformanceInterceptor <span class="title function_">performanceInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PerformanceInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意！</p>
<p>要在SpringBoot中配置环境为 dev 或者 test</p>
<p>参数说明：</p>
<ul>
<li>参数：maxTime SQL 执行最大时长，超过自动停止运行，有助于发现问题。</li>
<li>参数：format SQL SQL是否格式化，默认false。</li>
<li>该插件只用于开发环境，不建议生产环境使用。</li>
</ul>
</blockquote>
</li>
<li><p>测试使用</p>
<p> ……</p>
</li>
</ol>
<h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p>&#x3D;&#x3D;十分重要：Wrapper&#x3D;&#x3D;</p>
<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200501114921089.png" alt="image-20200501114921089"></p>
<h4 id="isNotNull、ge"><a href="#isNotNull、ge" class="headerlink" title="isNotNull、ge"></a>isNotNull、ge</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询name不为空、邮箱不为空、年龄大于12岁的用户</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.isNotNull(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">            .isNotNull(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">            .ge(<span class="string">&quot;age&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【MyBatisPlus】/image-20200501114812445.png" alt="image-20200501114812445"  />

<h4 id="eq"><a href="#eq" class="headerlink" title="eq"></a>eq</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询名字等于 wxs</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();     <span class="comment">//selectOne()</span></span><br><span class="line">    wrapper.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wxs&quot;</span>);							   <span class="comment">//eq()</span></span><br><span class="line">    userMapper.selectOne(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200501115343974.png" alt="image-20200501115343974"></p>
<h4 id="between"><a href="#between" class="headerlink" title="between"></a>between</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询年龄在20-25岁之间的人数</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">25</span>);								   <span class="comment">//between()</span></span><br><span class="line">    System.out.println(userMapper.selectCount(wrapper));           <span class="comment">//selectCount()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200501120000710.png" alt="image-20200501120000710"></p>
<h4 id="like、notLike、LeftLike、RightLike"><a href="#like、notLike、LeftLike、RightLike" class="headerlink" title="like、notLike、LeftLike、RightLike"></a>like、notLike、LeftLike、RightLike</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//模糊查询：名字里不包含e、包含h、邮箱以w开头的用户</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//左和右：%e%</span></span><br><span class="line">    wrapper.notLike(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;e&quot;</span>)</span><br><span class="line">        .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;h&quot;</span>)</span><br><span class="line">        .likeRight(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200501120906933.png" alt="image-20200501120906933"></p>
<h4 id="inSql"><a href="#inSql" class="headerlink" title="inSql"></a>inSql</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//id在子查询中查出来</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();      </span><br><span class="line">    wrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where id &lt; 3&quot;</span>);</span><br><span class="line">    userMapper.selectObjs(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200501121345698.png" alt="image-20200501121345698"></p>
<h3 id="自动代码生成器"><a href="#自动代码生成器" class="headerlink" title="自动代码生成器"></a>自动代码生成器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wxshhh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoCode</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建一个 代码生成器 对象</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">autoGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置策略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        globalConfig.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        globalConfig.setAuthor(<span class="string">&quot;wxshhh&quot;</span>);</span><br><span class="line">        globalConfig.setOpen(<span class="literal">false</span>);            <span class="comment">//是否打开资源管理器</span></span><br><span class="line">        globalConfig.setFileOverride(<span class="literal">false</span>);    <span class="comment">//是否覆盖</span></span><br><span class="line">        globalConfig.setServiceName(<span class="string">&quot;%sService&quot;</span>);   <span class="comment">//去掉Service的I前缀</span></span><br><span class="line">        globalConfig.setIdType(IdType.AUTO);</span><br><span class="line">        globalConfig.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        globalConfig.setSwagger2(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        autoGenerator.setGlobalConfig(globalConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2,数据源设置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dataSourceConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dataSourceConfig.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_plus?userUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;</span>);</span><br><span class="line">        dataSourceConfig.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSourceConfig.setPassword(<span class="string">&quot;abc123aa&quot;</span>);</span><br><span class="line">        dataSourceConfig.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSourceConfig.setDbType(DbType.MYSQL);</span><br><span class="line"></span><br><span class="line">        autoGenerator.setDataSource(dataSourceConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.包的配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">packageConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        packageConfig.setModuleName(<span class="string">&quot;blog&quot;</span>);</span><br><span class="line">        packageConfig.setParent(<span class="string">&quot;com.wxshhh&quot;</span>);</span><br><span class="line">        packageConfig.setEntity(<span class="string">&quot;entity&quot;</span>);          <span class="comment">//实体类的名字</span></span><br><span class="line">        packageConfig.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        packageConfig.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        packageConfig.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line"></span><br><span class="line">        autoGenerator.setPackageInfo(packageConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4,策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        strategy.setInclude(<span class="string">&quot;user&quot;</span>);                            <span class="comment">//***重点！ 设置要映射的表明</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setSuperEntityClass(<span class="string">&quot;你自己的父类实体,没有就不用设置!&quot;</span>);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="literal">true</span>);                    <span class="comment">//自动 lombok</span></span><br><span class="line">        strategy.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line"></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);                <span class="comment">//乐观锁</span></span><br><span class="line"></span><br><span class="line">        strategy.setRestControllerStyle(<span class="literal">true</span>);                  <span class="comment">//rest风格</span></span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="literal">true</span>);         <span class="comment">//localhost:8080/hell_id_2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置自动填充</span></span><br><span class="line">        <span class="type">TableFill</span> <span class="variable">gmtCreate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;gmt_create&quot;</span>, FieldFill.INSERT);</span><br><span class="line">        <span class="type">TableFill</span> <span class="variable">gmtModified</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;gmt_modified&quot;</span>, FieldFill.INSERT_UPDATE);</span><br><span class="line">        strategy.setTableFillList(Arrays.asList(gmtCreate, gmtModified));</span><br><span class="line"></span><br><span class="line">        autoGenerator.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        autoGenerator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90MyBatisPlus%E3%80%91/image-20200501130308486.png" alt="image-20200501130308486"></p>
<p><strong>神器!!!</strong></p>
<p>完结撒花~~~~~~~~~</p>
<p><strong>狂神，永远滴神！！！</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV17E411N7KN">https://www.bilibili.com/video/BV17E411N7KN</a></p>
<p>MybatisPlus官网：<a href="https://mp.baomidou.com/guide/quick-start.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B">https://mp.baomidou.com/guide/quick-start.html#初始化工程</a></p>
<p> 分布式系统唯一ID生成方案汇总：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>狂神说Java</tag>
        <tag>MyBatisPlus</tag>
      </tags>
  </entry>
  <entry>
    <title>【MySQL回顾】事务篇</title>
    <url>/2023/03/01/%E3%80%90MySQL%E5%9B%9E%E9%A1%BE%E3%80%91%E4%BA%8B%E5%8A%A1%E7%AF%87/</url>
    <content><![CDATA[<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p>事务是访问并可能更新数据库中各种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%A1%B9/3227309">数据项</a>的一个程序执行单元(unit)。</p>
<blockquote>
<p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
</blockquote>
<blockquote>
<p><strong>MySQL 事务主要用于处理操作量大，复杂度高的数据。</strong></p>
<p>比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>
</blockquote>
<h1 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h1><p>一般来说，事务是必须满足4个条件<strong>（ACID）</strong>:</p>
<ul>
<li><p><strong>原子性</strong>(<strong>A</strong>tomicity):</p>
<ul>
<li><p><strong>事务是最小的执行单位，不允许分割</strong></p>
</li>
<li><p>一个事务（transaction）中的所有操作，<strong>要么全部完成，要么全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被<strong>回滚（Rollback）</strong>到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</li>
</ul>
</li>
<li><p><strong>一致性</strong>(<strong>C</strong>onsistency)</p>
<ul>
<li><strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</strong>这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
</ul>
</li>
<li><p><strong>隔离性</strong>(<strong>I</strong>solation)</p>
<ul>
<li>并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
</ul>
</li>
<li><p><strong>持久性</strong>(<strong>D</strong>urability)</p>
<ul>
<li>事务处理结束后，<strong>对数据的修改就是永久的</strong>，即便系统故障也不会丢失。</li>
</ul>
</li>
</ul>
<h1 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h1><p>并发处理事务时,经常回操纵相同的数据处理不同的事务,可能会产生以下问题：</p>
<ul>
<li><strong>脏读（dirty read）</strong>：当一个事务访问数据并对其进行<strong>修改</strong>后，还<strong>未提交到数据库</strong>时另一个事务访问了改数据，读到的数据是<strong>未经更新的数据</strong>（脏数据），依据脏数据进行的操作可能有误。</li>
<li><strong>丢失修改（Lost to modify）</strong>：两个事务同时访问一个数据时，都对数据做出了修改，第一个事务所修改的数据丢失。</li>
<li><strong>不可重复读（Unrepeatable read）</strong>：在一个事务（A）内两次读取数据的过程中另一个事务（B）访问并修改了该数据，使得 A 读取到的两次数据不一致。</li>
<li><strong>幻读（Phantom read）</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读的区别：</strong></p>
<ul>
<li>不可重复读重点在修改</li>
<li>幻读重点在添加或删除</li>
</ul>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>SQL标准定义了<strong>四个事务隔离级别</strong>：</p>
<ul>
<li><p><strong>READ-UNCOMMITTED(读取未提交)：</strong></p>
<p>  最低的事务隔离级别，允许读取尚未提交的数据</p>
</li>
<li><p><strong>READ-COMMITTED(读取已提交)：</strong></p>
<p>  允许读取并发已提交的事务</p>
</li>
<li><p><strong>REPEATABLE-READ(可重复读)：</strong></p>
<p>  对同意字段读取的结果是一致的，除非是被本身事务所修改</p>
</li>
<li><p><strong>SERIALIZABLE(可串行化)：</strong></p>
<p>  最高隔离级别，所有事务依次执行，事物之间不能互相干扰</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ-UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">READ-COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">REPEATABLE-READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<blockquote>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p>
<p>我们可以通过命令<code>SELECT @@transaction_isolation;</code>来查看当前的事务隔离级别。</p>
<p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的**SERIALIZABLE(可串行化)**隔离级别。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p>
</blockquote>
<h1 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h1><p>我们可以通过下面的命令来设置隔离级别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]</span><br></pre></td></tr></table></figure>

<p>控制并发的语句：</p>
<ul>
<li><code>START TARNSACTION</code> |<code>BEGIN</code>：显式地开启一个事务。</li>
<li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li>
<li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>javaGuide: <a href="https://snailclimb.gitee.io/javaguide/#/docs/database/">https://snailclimb.gitee.io/javaguide/#/docs/database/</a></p>
<p>菜鸟教程: <a href="https://www.runoob.com/mysql/mysql-transaction.html">https://www.runoob.com/mysql/mysql-transaction.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>【MySQL回顾】基础操作篇</title>
    <url>/2023/03/01/%E3%80%90MySQL%E5%9B%9E%E9%A1%BE%E3%80%91%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%AF%87/</url>
    <content><![CDATA[<h1 id="快速回顾"><a href="#快速回顾" class="headerlink" title="快速回顾"></a>快速回顾</h1><table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">语法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AND &#x2F; OR</td>
<td align="left">SELECT column_name(s) FROM table_name WHERE condition AND|OR condition</td>
</tr>
<tr>
<td align="left">ALTER TABLE (add column)</td>
<td align="left">ALTER TABLE table_name ADD column_name datatype</td>
</tr>
<tr>
<td align="left">ALTER TABLE (drop column)</td>
<td align="left">ALTER TABLE table_name DROP COLUMN column_name</td>
</tr>
<tr>
<td align="left">AS (alias for column)</td>
<td align="left">SELECT column_name AS column_alias FROM table_name</td>
</tr>
<tr>
<td align="left">AS (alias for table)</td>
<td align="left">SELECT column_name FROM table_name AS table_alias</td>
</tr>
<tr>
<td align="left">BETWEEN</td>
<td align="left">SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2</td>
</tr>
<tr>
<td align="left">CREATE DATABASE</td>
<td align="left">CREATE DATABASE database_name</td>
</tr>
<tr>
<td align="left">CREATE INDEX</td>
<td align="left">CREATE INDEX index_name ON table_name (column_name)</td>
</tr>
<tr>
<td align="left">CREATE TABLE</td>
<td align="left">CREATE TABLE table_name ( column_name1 data_type, column_name2 data_type, ……. )</td>
</tr>
<tr>
<td align="left">CREATE UNIQUE INDEX</td>
<td align="left">CREATE UNIQUE INDEX index_name ON table_name (column_name)</td>
</tr>
<tr>
<td align="left">CREATE VIEW</td>
<td align="left">CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition</td>
</tr>
<tr>
<td align="left">DELETE FROM</td>
<td align="left">DELETE FROM table_name (<strong>Note:</strong> Deletes the entire table!!)<em>or</em>DELETE FROM table_name WHERE condition</td>
</tr>
<tr>
<td align="left">DROP DATABASE</td>
<td align="left">DROP DATABASE database_name</td>
</tr>
<tr>
<td align="left">DROP INDEX</td>
<td align="left">DROP INDEX table_name.index_name</td>
</tr>
<tr>
<td align="left">DROP TABLE</td>
<td align="left">DROP TABLE table_name</td>
</tr>
<tr>
<td align="left">GROUP BY</td>
<td align="left">SELECT column_name1,SUM(column_name2) FROM table_name GROUP BY column_name1</td>
</tr>
<tr>
<td align="left">HAVING</td>
<td align="left">SELECT column_name1,SUM(column_name2) FROM table_name GROUP BY column_name1 HAVING SUM(column_name2) condition value</td>
</tr>
<tr>
<td align="left">IN</td>
<td align="left">SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,..)</td>
</tr>
<tr>
<td align="left">INSERT INTO</td>
<td align="left">INSERT INTO table_name VALUES (value1, value2,….)<em>or</em>INSERT INTO table_name (column_name1, column_name2,…) VALUES (value1, value2,….)</td>
</tr>
<tr>
<td align="left">LIKE</td>
<td align="left">SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern</td>
</tr>
<tr>
<td align="left">ORDER BY</td>
<td align="left">SELECT column_name(s) FROM table_name ORDER BY column_name [ASC|DESC]</td>
</tr>
<tr>
<td align="left">SELECT</td>
<td align="left">SELECT column_name(s) FROM table_name</td>
</tr>
<tr>
<td align="left">SELECT *</td>
<td align="left">SELECT * FROM table_name</td>
</tr>
<tr>
<td align="left">SELECT DISTINCT</td>
<td align="left">SELECT DISTINCT column_name(s) FROM table_name</td>
</tr>
<tr>
<td align="left">SELECT INTO (used to create backup copies of tables)</td>
<td align="left">SELECT * INTO new_table_name FROM original_table_name <em>or</em> SELECT column_name(s) INTO new_table_name FROM original_table_name</td>
</tr>
<tr>
<td align="left">TRUNCATE TABLE (deletes only the data inside the table)</td>
<td align="left">TRUNCATE TABLE table_name</td>
</tr>
<tr>
<td align="left">UPDATE</td>
<td align="left">UPDATE table_name SET column_name&#x3D;new_value [, column_name&#x3D;new_value] WHERE column_name&#x3D;some_value</td>
</tr>
<tr>
<td align="left">WHERE</td>
<td align="left">SELECT column_name(s) FROM table_name WHERE condition</td>
</tr>
</tbody></table>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start mysql		-- 启动服务（windows命令行操作）</span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码		-- 连接服务器</span><br></pre></td></tr></table></figure>

<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h3 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h3><p><code>CREATE DATABASE[IF NOT EXISTS] 数据库名 数据库选项</code></p>
<h3 id="查看库"><a href="#查看库" class="headerlink" title="查看库"></a>查看库</h3><p><code>SHOW DATABASES[ LIKE &#39;PATTERN&#39;]</code></p>
<h3 id="修改库"><a href="#修改库" class="headerlink" title="修改库"></a>修改库</h3><p><code>ALTER DATABASE 库名 选项信息</code></p>
<h3 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h3><p><code>DROP DATABASE[ IF EXISTS] 数据库名</code></p>
<h1 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h1><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [TEMPORARY] TABLE[IF NOT EXISTS] [库名]表名 ( 表的结构定义 )[表选项]</span><br><span class="line">-- 表选项：</span><br><span class="line">	CHARSET = charset_name		-- 字符集</span><br><span class="line">	ENGINE = engine_name		-- 存储引擎</span><br><span class="line">	AUTO_INCREMENT = 行数		   -- 自增起始数 		   </span><br><span class="line">	DATA DIRECTORY = &#x27;目录&#x27;	   -- 数据文件目录</span><br><span class="line">	INDEX DIRECTORY = &#x27;目录&#x27;	   -- 索引文件目录</span><br><span class="line">	COMMENT = &#x27;string&#x27;			-- 表注释</span><br></pre></td></tr></table></figure>

<h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名 -- 信息更详细</span><br><span class="line">DESC 表名 			 -- 查看表结构</span><br><span class="line">SHOW TABLE STATUS [FROM db_name] [LIKE &#x27;pattern&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 操作名</span><br><span class="line">-- 操作名</span><br><span class="line">	ADD[ COLUMN] AFTER|First       	  -- 增加字段</span><br><span class="line">	ADD PRIMARY KEY(字段名)   		 	-- 创建主键</span><br><span class="line">	ADD UNIQUE|INDEX [索引名] (字段名)  -- 创建唯一索引或者普通索引</span><br><span class="line">	DROP[ COLUMN] 字段名      			-- 删除字段</span><br><span class="line">	MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span><br><span class="line">	CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改</span><br><span class="line">	DROP PRIMARY KEY    			  -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span><br><span class="line">	DROP INDEX 索引名 					-- 删除索引</span><br><span class="line">	DROP FOREIGN KEY 外键    			 -- 删除外键</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE[ IF EXISTS] 表名</span><br><span class="line">TRUNCATE [TABLE] 表名</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<table>
<thead>
<tr>
<th align="center">truncate</th>
<th align="center">delete</th>
</tr>
</thead>
<tbody><tr>
<td align="center">删除表再创建</td>
<td align="center">逐条删除</td>
</tr>
<tr>
<td align="center">重置auto_increment的值</td>
<td align="center">不重置auto_increment的值</td>
</tr>
<tr>
<td align="center">不知道删除了几条</td>
<td align="center">知道删除了几条</td>
</tr>
<tr>
<td align="center">保留分区</td>
<td align="center">不保留分区</td>
</tr>
</tbody></table>
<h3 id="其他表操作"><a href="#其他表操作" class="headerlink" title="其他表操作"></a>其他表操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 LIKE 要复制的表名						-- 复制表结构</span><br><span class="line">CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名		-- 复制表的结构与数据</span><br><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...	 -- 检查表是否有错误</span><br><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...	-- 优化表</span><br><span class="line">REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]											-- 修复表</span><br><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...	-- 分析表</span><br></pre></td></tr></table></figure>

<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line"></span><br><span class="line">INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]</span><br></pre></td></tr></table></figure>

<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名[ 删除条件子句]		-- 没有删除条件子句，则会删除全部</span><br></pre></td></tr></table></figure>

<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]</span><br></pre></td></tr></table></figure>

<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	ALL|DISTINCT：</span><br><span class="line">		ALL：显示全部，默认为ALL</span><br><span class="line">		DISTINCT：去除重复数据</span><br><span class="line">	select_expr：</span><br><span class="line">		1.可以用 * 表示所有字段。</span><br><span class="line">        2.可以使用表达式（计算公式、函数调用、字段也是个表达式）</span><br><span class="line">        3.可以为每个列使用别名</span><br><span class="line">    GROUP BY：</span><br><span class="line">		分组子句</span><br><span class="line">    合计函数：</span><br><span class="line">    	需要配合GROUP BY使用</span><br><span class="line">    	count、sum、max、min、avg……</span><br><span class="line">    HAVING：</span><br><span class="line">    	相当于命令行中的管道符 “|”，懂我意思吧</span><br><span class="line">  	ORDER BY：</span><br><span class="line">  		升序：ASC</span><br><span class="line">  		降序：DESC</span><br><span class="line">  	LIMIT：</span><br><span class="line">  		限制结果条数</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h1 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h1><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.length 获取参数值的字节个数</span><br><span class="line">SELECT LENGTH(&#x27;join&#x27;);</span><br><span class="line">SELECT LENGTH(&#x27;张三丰&#x27;)  #一个汉字占三个字节;</span><br><span class="line"></span><br><span class="line">#2.concat 拼接字符串</span><br><span class="line">SELECT　CONCAT(last_name,&#x27;_&#x27;,first_name) 姓名 FROM employees；</span><br><span class="line"></span><br><span class="line">#3.upper、lower</span><br><span class="line">SELECT UPPER(&#x27;john&#x27;);</span><br><span class="line">SELECT LOWER(&#x27;JOHN&#x27;);</span><br><span class="line"></span><br><span class="line">#4.substr、substring</span><br><span class="line">#索引从1开始</span><br><span class="line">SELECT SUBSTR(&#x27;李莫愁爱上陆展元&#x27;，7) out_put;   #截取从指定索引处后面的所有字符</span><br><span class="line">SELECT SUBSTR(&#x27;李莫愁爱上陆展元&#x27;，1，3) out_put;    #截取从索引处开始指定字符长度的字符</span><br><span class="line"></span><br><span class="line">#5.instr 返回子串在大字符串中的起始索引，找不到则返回0</span><br><span class="line">SELECT INSTR(&#x27;杨不悔爱上了殷六侠&#x27;，&#x27;殷六侠&#x27;) AS out_put FROM employees;</span><br><span class="line"></span><br><span class="line">#6.trim 去除两边字符</span><br><span class="line">SELECT TRIM(&#x27;   张翠山   &#x27;);</span><br><span class="line">SELECT TRIM(&#x27;a&#x27; FROM &#x27;aaa张翠山aaa&#x27;);</span><br><span class="line"></span><br><span class="line">#7.lpad、rpad 用指定的字符左/右填充指定的长度</span><br><span class="line">SELECT LPAD(&#x27;殷素素&#x27;，10，&#x27;*&#x27;);</span><br><span class="line"></span><br><span class="line">#8.replac 替换</span><br><span class="line">SELECT REPLACE(&#x27;（周芷若）张无忌爱上了周芷若&#x27;，&#x27;周芷若&#x27;，&#x27;赵敏&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">round()		#取整</span><br><span class="line">ceil()		#向上取整</span><br><span class="line">floor()		#向下取整</span><br><span class="line">truncate()  #截断</span><br><span class="line">mod()       #取余</span><br></pre></td></tr></table></figure>

<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">now()</span><br><span class="line">curdate()</span><br><span class="line">curtime()</span><br><span class="line">year()</span><br><span class="line">mouth()</span><br><span class="line">mouthname()       #英文月份名</span><br><span class="line">day()</span><br><span class="line">hour()</span><br><span class="line">minute()</span><br><span class="line">second()</span><br><span class="line"></span><br><span class="line">str_to_date(&#x27;9-13-1999&#x27;,&#x27;%m-%d-%Y&#x27;)    #将日期格式的字符转化成指定格式的日期</span><br><span class="line">date_fromat(&#x27;2018/6/6&#x27;,&#x27;%Y年%m月%d日&#x27;)  #将日期转换成字符</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">格式符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%Y</td>
<td align="center">四位年份</td>
</tr>
<tr>
<td align="center">%y</td>
<td align="center">两位年份</td>
</tr>
<tr>
<td align="center">%m</td>
<td align="center">月份（01，02…)</td>
</tr>
<tr>
<td align="center">%c</td>
<td align="center">月份（1，2…)</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">日（01，02，…）</td>
</tr>
<tr>
<td align="center">%H</td>
<td align="center">小时（24小时）</td>
</tr>
<tr>
<td align="center">%h</td>
<td align="center">小时（12小时）</td>
</tr>
<tr>
<td align="center">%i</td>
<td align="center">分钟</td>
</tr>
<tr>
<td align="center">%s</td>
<td align="center">秒</td>
</tr>
</tbody></table>
<h3 id="控制函数"><a href="#控制函数" class="headerlink" title="控制函数"></a>控制函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.if()    #相当于java三目运算</span><br><span class="line">    if(10&gt;5,&#x27;大&#x27;，&#x27;小&#x27;)</span><br><span class="line"></span><br><span class="line">2.case</span><br><span class="line">    case 要判断的字段或表达式</span><br><span class="line">    when 常量1 then 要显示的值1或语句1</span><br><span class="line">    when 常量2 then 要显示的值2或语句2</span><br><span class="line">    ...</span><br><span class="line">    else 要显示的值n或语句n</span><br><span class="line">    end;</span><br></pre></td></tr></table></figure>

<h2 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">功能：用作统计使用，又称聚合函数或统计函数</span><br><span class="line"></span><br><span class="line">分类：sum、avg、max、min、count</span><br><span class="line"></span><br><span class="line">特点： 1.sum、avg一般用于处理数值型</span><br><span class="line">        count、min、max可以处理任何类型</span><br><span class="line">      2.分组函数都忽略null值</span><br><span class="line">      3.可以和distinct搭配实现去重</span><br><span class="line">        select sum(distinct salary),sum(salary) from employees;</span><br><span class="line">      4.count函数详细介绍</span><br><span class="line">        select (*) from employees;</span><br><span class="line">        //统计行数</span><br><span class="line">      5.和分组函数一同查询的字段要求是group by后的字段</span><br></pre></td></tr></table></figure>

<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><blockquote>
<p>w3school：<a href="https://www.w3school.com.cn/sql/sql_quickref.asp">https://www.w3school.com.cn/sql/sql_quickref.asp</a></p>
<p>格物：<a href="https://shockerli.net/post/1000-line-mysql-note/">https://shockerli.net/post/1000-line-mysql-note/</a></p>
<p>javaGuide：<a href="https://snailclimb.gitee.io/javaguide/#/docs/database">https://snailclimb.gitee.io/javaguide/#/docs/database</a></p>
<p>尚硅谷：<a href="https://www.bilibili.com/video/BV12b411K7Zu?from=search&seid=12749719158094983926">https://www.bilibili.com/video/BV12b411K7Zu?from=search&amp;seid=12749719158094983926</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>【MySQL回顾】索引篇</title>
    <url>/2023/03/01/%E3%80%90MySQL%E5%9B%9E%E9%A1%BE%E3%80%91%E7%B4%A2%E5%BC%95%E7%AF%87/</url>
    <content><![CDATA[<h1 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h1><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>索引是一种用于<strong>快速查询和检索数据</strong>的<strong>数据结构</strong>。</p>
<p>常见的索引结构有：</p>
<ul>
<li>B+树</li>
<li>Hash</li>
</ul>
<p>索引就相当于是我们所使用<strong>字典的目录</strong>，我们可以通过目录轻松找到想要查找的字词的位置。</p>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><ul>
<li><p>优点：</p>
<p>  可以通过减少检索的数据量来<strong>大大加快检索速度</strong></p>
<p>  可以通过创建<strong>唯一性索引</strong>保证数据库中每一行数据的唯一性</p>
</li>
<li><p>缺点：</p>
<p>  创建索引和维护索引需要<strong>耗费许多时间</strong></p>
<p>  <strong>占用物理内存</strong></p>
</li>
</ul>
<h1 id="B-树索引和Hash索引"><a href="#B-树索引和Hash索引" class="headerlink" title="B+树索引和Hash索引"></a>B+树索引和Hash索引</h1><h3 id="B树、B-树扫盲"><a href="#B树、B-树扫盲" class="headerlink" title="B树、B+树扫盲"></a>B树、B+树扫盲</h3><ul>
<li><p>B树</p>
<ul>
<li><p>基本原理：</p>
<p>  二叉查找树的升级版，<strong>改二叉为多叉</strong>，每个节点存储更多的指针信息，以降低I&#x2F;O操作数（解决了当数据量十分庞大时<strong>平衡二叉树深度过深</strong>的问题）</p>
</li>
<li><p><img src="/%E3%80%90MySQL%E5%9B%9E%E9%A1%BE%E3%80%91%E7%B4%A2%E5%BC%95%E7%AF%87/image-20200423153702081.png" alt="image-20200423153702081"></p>
</li>
<li><p>在搜索B树时，很明显，访问节点（即读取磁盘）的次数与树的高度呈正比</p>
</li>
</ul>
</li>
<li><p>B+树</p>
<ul>
<li>B+树是B树的一种变形，它更适合实际应用中操作系统的文件索引和数据库索引</li>
<li>B+树的<strong>叶子节点有一条引用链</strong>指向与它相邻的叶子节点</li>
<li><img src="/%E3%80%90MySQL%E5%9B%9E%E9%A1%BE%E3%80%91%E7%B4%A2%E5%BC%95%E7%AF%87/image-20200423154336991.png" alt="image-20200423154336991"></li>
</ul>
</li>
<li><p>B树和B+树的比较：</p>
<table>
<thead>
<tr>
<th align="center">B树</th>
<th align="center">B+树</th>
</tr>
</thead>
<tbody><tr>
<td align="center">子树的个数总比关键字个数多1个</td>
<td align="center">关键字的个数与其子树的个数相同</td>
</tr>
<tr>
<td align="center">所有节点既存放 键(key) 也存放 数据(data)</td>
<td align="center">只有叶子节点存放 key 和 data，其他内节点相当于索引</td>
</tr>
<tr>
<td align="center">可能未到达叶子节点检索就结束了</td>
<td align="center">检索效率稳定，任何查找都是从根节点到叶子节点的过程</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="哈希索引和B-树索引的比较"><a href="#哈希索引和B-树索引的比较" class="headerlink" title="哈希索引和B+树索引的比较"></a>哈希索引和B+树索引的比较</h3><table>
<thead>
<tr>
<th align="center">哈希索引</th>
<th align="center">B+树索引</th>
</tr>
</thead>
<tbody><tr>
<td align="center">哈希索引对单个数据定位较快</td>
<td align="center">哈希索引对单个数据定位较慢</td>
</tr>
<tr>
<td align="center">不支持顺序查询</td>
<td align="center">支持顺序查询（叶子节点相连）</td>
</tr>
<tr>
<td align="center">不支持范围查询</td>
<td align="center">支持范围查询</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<p>​	在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；</p>
<p>​	其余大部分场景，建议选择B+Tree索引。</p>
<h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><h3 id="主键索引和辅助索引"><a href="#主键索引和辅助索引" class="headerlink" title="主键索引和辅助索引"></a>主键索引和辅助索引</h3><ul>
<li><strong>主键索引</strong>（Primary Key）：<ul>
<li><strong>数据表的主键列</strong>使用的就是主键索引。</li>
<li>一张数据表有只能有一个主键，并且主键不能为null，不能重复。</li>
</ul>
</li>
<li><strong>辅助索引</strong>（二级索引）：<ul>
<li>二级索引的<strong>叶子节点存储的数据是主键</strong>，通过二级索引，可以<strong>定位主键</strong>的位置。</li>
<li>唯一索引，普通索引，前缀索引等索引属于二级索引。</li>
<li><img src="【MySQL回顾】索引篇/image-20200423160344472.png" alt="image-20200423160344472" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><ul>
<li><p><strong>聚集索引</strong>：聚集索引即<strong>索引结构和数据一起存放</strong>的索引。<strong>主键索引</strong>属于聚集索引。</p>
<p>  优点：查询速度非常快</p>
<p>  缺点：</p>
<pre><code>      1. 依赖于有序的数据
        2. 更新代价大
</code></pre>
</li>
<li><p><strong>非聚集索引</strong>：索引结构和数据分开存放的索引。<strong>二级索引</strong>属于非聚集索引。</p>
<p>  优点：更新代价小</p>
<p>  缺点：</p>
<pre><code>  1. 依赖于有序的数据
   2. 可能会二次查询(**回表**)
</code></pre>
</li>
</ul>
<img src="【MySQL回顾】索引篇/image-20200423161249338.png" alt="image-20200423161249338" style="zoom:67%;" />

<ul>
<li><p>非聚集索引一定回表查询吗？(覆盖索引)</p>
<p>  不一定，当索引的key本身就是查询的字段的时候，无需回表！</p>
</li>
</ul>
<h1 id="索引创建注意点"><a href="#索引创建注意点" class="headerlink" title="索引创建注意点"></a>索引创建注意点</h1><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>最左前缀原则：在创建联合索引时，尽量把<strong>查询最频繁</strong>的那个字段作为<strong>最左(第一个)字段</strong>。查询的时候也尽量以这个字段为第一条件。</p>
<h3 id="适合创建索引的字段"><a href="#适合创建索引的字段" class="headerlink" title="适合创建索引的字段"></a>适合创建索引的字段</h3><ol>
<li>不为Null的字段</li>
<li>被频繁查询的字段</li>
<li>被作为条件查询的字段</li>
<li>被经常用于连接的字段</li>
</ol>
<h3 id="不适合创建索引的字段"><a href="#不适合创建索引的字段" class="headerlink" title="不适合创建索引的字段"></a>不适合创建索引的字段</h3><ol>
<li><p>被频繁更新的字段</p>
</li>
<li><p>不经常查询的字段</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>格物：<a href="https://shockerli.net/post/1000-line-mysql-note/">https://shockerli.net/post/1000-line-mysql-note/</a></p>
<p>javaGuide：<a href="https://snailclimb.gitee.io/javaguide/#/docs/database">https://snailclimb.gitee.io/javaguide/#/docs/database</a></p>
<p>guoziqing506：<a href="https://blog.csdn.net/guoziqing506">https://blog.csdn.net/guoziqing506</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>【OCaml使用手册】</title>
    <url>/2023/03/12/%E3%80%90OCaml%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%E3%80%91/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230311204621.png"></p>
<p>本文用于课程《程序设计语言原理》的学习。<br>参考：<a href="https://juejin.cn/user/211570032640152">乔治会写代码了吗 的个人主页 - 动态 - 掘金</a><br>官网：<a href="https://ocaml.org/">Welcome to a World of OCaml</a></p>
<blockquote>
<p>OCaml is a general-purpose, industrial-strength programming language with an emphasis on expressiveness and safety.</p>
<p>OCaml 最早称为 Objective Caml，是 Caml 编程语言的主要实现，开发工具包含交互式顶层解释器，字节码编译器以及最优本地代码编译器。Ocaml 有一个巨大标准库，使得可以像 Python 或者 Perl 语言一样可以方便地开发各种应用程序。</p>
</blockquote>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h5 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h5><p>整型操作需要使用：<code>+</code> 、<code>-</code>、<code>*</code>、<code>/</code>(向下取整)<br>浮点数操作需要使用：<code>+.</code> 、<code>-.</code>、<code>*.</code>、<code>/.</code><br>区域操作：<code>mod</code><br>布尔运算：<code>&amp;&amp;</code>、<code>||</code>、<code>not</code><br>等于和不等于：<code>=</code>、<code>&lt;&gt;</code><br>字符串相加：^（字符为 <code>&#39;a&#39;</code>，而字符串为 <code>&quot;a&quot;</code>）</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">3</span>;;</span><br><span class="line"></span><br><span class="line"><span class="number">3.0</span> +. <span class="number">2.4</span>;;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="keyword">mod</span> <span class="number">2</span>;;</span><br><span class="line"></span><br><span class="line"><span class="number">4.3</span> mod_float <span class="number">3.2</span>;;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> || <span class="number">2</span>;;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> = <span class="number">3</span>;;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> &lt;&gt; <span class="number">4</span>;;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;a&quot;</span> ^ <span class="string">&quot;b&quot;</span>;;</span><br></pre></td></tr></table></figure>

<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>固定格式：<code>DEST_of_ORIG</code><br>例如：<code>int_of_float</code> 表示浮点数到整型的转换</p>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>在 OCaml 中，使用关键字 <code>let</code> 定义一个函数</p>
<ul>
<li>函数定义：</li>
</ul>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">(*不指定类型的函数 参数之间由空格空开 等号为函数返回值*)</span></span><br><span class="line">  <span class="keyword">let</span> f x y = x + y;;</span><br><span class="line"></span><br><span class="line"><span class="comment">(*指定类型的函数*)</span></span><br><span class="line"><span class="keyword">let</span> f (x : <span class="built_in">int</span>) (y : <span class="built_in">int</span>) : <span class="built_in">int</span> = x + y</span><br><span class="line"></span><br><span class="line"><span class="comment">(*同时定义多个函数，使用 and 连接*)</span></span><br><span class="line"><span class="keyword">let</span> identite x = x <span class="keyword">and</span> carre x = x * x <span class="keyword">and</span> cube x = x * x * x</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数调用：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">f <span class="number">1</span> <span class="number">2</span>;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>let</code> 定义函数常量</p>
</li>
</ul>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pi = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>
<ul>
<li>关键字 <code>in</code></li>
</ul>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(*不能使用靠前的函数来定义后面的函数 下面语法会报错*)</span></span><br><span class="line"><span class="keyword">let</span> carre x = x * x <span class="keyword">and</span> cube x = (carre x) * x;;</span><br><span class="line"><span class="comment">(*使用关键字 in 可以使用前面定义好的函数*)</span></span><br><span class="line"><span class="keyword">let</span> carre x = x * x <span class="keyword">in</span></span><br><span class="line">    cube x = (carre x) * x;;</span><br><span class="line"></span><br><span class="line"><span class="comment">(*示例函数，用来求两个浮点数的平方和的平方根*)</span></span><br><span class="line"><span class="keyword">let</span> norme (x : <span class="built_in">float</span>) (y : <span class="built_in">float</span>) :<span class="built_in">float</span> = </span><br><span class="line">    <span class="keyword">let</span> carre a = a * a <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> x_carre = carre x <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> y_carre = carre y <span class="keyword">in</span></span><br><span class="line">    sqrt (x_carre + y_carre);; <span class="comment">(*sqrt是内置求平方根函数*)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="条件及匹配模式"><a href="#条件及匹配模式" class="headerlink" title="条件及匹配模式"></a>条件及匹配模式</h3><h5 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if 和 else"></a>if 和 else</h5><p>OCaml中的条件语句是作为表达式来用的，最终会得到一个结果</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(*x为bool类型的表达式 a、b类型要一致 else必须有！*)</span></span><br><span class="line"><span class="comment">(*示例1：if-else*)</span></span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">then</span> a <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">(*示例2：if-else if-else*)</span></span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">then</span></span><br><span class="line">    a</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> y <span class="keyword">then</span></span><br><span class="line">    b</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    c</span><br><span class="line"></span><br><span class="line"><span class="comment">(*示例3：将返回结果赋给变量*)</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="keyword">if</span> <span class="literal">true</span> <span class="keyword">then</span></span><br><span class="line">    <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(*示例4：使用圆括号包住嵌套的条件语句*)</span></span><br><span class="line"><span class="keyword">let</span> number_departement = <span class="number">38</span> </span><br><span class="line"><span class="keyword">let</span> name_departement = <span class="keyword">if</span> number_departement = <span class="number">38</span> <span class="keyword">then</span></span><br><span class="line">    <span class="string">&quot;Isere&quot;</span> </span><br><span class="line"><span class="keyword">else</span> ( </span><br><span class="line">    <span class="keyword">if</span> number_departement = <span class="number">19</span> <span class="keyword">then</span></span><br><span class="line">         <span class="string">&quot;Correze&quot;</span> </span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="string">&quot;Unknown&quot;</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h5><p>除了 <code>if</code>&#x2F;<code>else</code> 之外，OCaml 还为我们提供另一种更强有力的创造条件的方式：<strong>匹配模式</strong>（有点像其他语言中 <code>switch</code> 的感觉）。通常而言是列出所有可能的情况,并将一种情况与一个值联结在一起，这和 <code>if</code>&#x2F;<code>else</code> 是有些相像的。 匹配模式有趣的地方就在于，它可以准确地辨认出<strong>模式</strong>，而不仅仅是简单的等式。</p>
<p>OCaml中，匹配模式的语法会使用关键词 <code>match</code> 和 <code>with</code> ：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* x：将要被测试的值，如果值与列表中的某一项相匹配就返回对应情况的结果 *)</span></span><br><span class="line"><span class="keyword">match</span> x <span class="keyword">with</span></span><br><span class="line">| case1 -&gt; result1</span><br><span class="line">| case2 -&gt; result2</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 示例，返回结果为：&quot;Isere&quot; *)</span></span><br><span class="line"><span class="keyword">let</span> number_departement = <span class="number">38</span></span><br><span class="line"><span class="keyword">let</span> name_departement = </span><br><span class="line">  <span class="keyword">match</span> number_departement <span class="keyword">with</span></span><br><span class="line">  | <span class="number">1</span> -&gt; <span class="string">&quot;Ain&quot;</span> </span><br><span class="line">  | <span class="number">19</span> -&gt; <span class="string">&quot;Correze&quot;</span> </span><br><span class="line">  | <span class="number">38</span> -&gt; <span class="string">&quot;Isere&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(*</span></span><br><span class="line"><span class="comment">如果未找到相匹配的值，则会报错：Exception: Match_failure，为了避免这种情况，可以加一个 _ 来表示默认情况</span></span><br><span class="line"><span class="comment">*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name_departement number = </span><br><span class="line">  <span class="keyword">match</span> number <span class="keyword">with</span> </span><br><span class="line">  | <span class="number">1</span> -&gt; <span class="string">&quot;Ain&quot;</span> </span><br><span class="line">  | <span class="number">19</span> -&gt; <span class="string">&quot;Correze&quot;</span> </span><br><span class="line">  | <span class="number">38</span> -&gt; <span class="string">&quot;Isere&quot;</span> </span><br><span class="line">  | _ -&gt; <span class="string">&quot;Unknown&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="建立数据模型"><a href="#建立数据模型" class="headerlink" title="建立数据模型"></a>建立数据模型</h3><p>我们目前为止只是使用了一些简单的数据类型，如果实现更复杂的功能，就要自己创建更为复杂的数据类型（类似于其他语言中的类或者结构体）</p>
<h5 id="同义类型"><a href="#同义类型" class="headerlink" title="同义类型"></a>同义类型</h5><p>类似于取别名</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 基本语法 *)</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">NAME</span> = <span class="type">TYPE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 举例 *)</span></span><br><span class="line"><span class="keyword">type</span> speed = <span class="built_in">float</span></span><br><span class="line"><span class="keyword">type</span> time = <span class="built_in">float</span></span><br><span class="line"><span class="keyword">type</span> distance = <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s (d : distance) (t : time) :speed = d /. t</span><br><span class="line"><span class="comment">(* 函数类型：distance -&gt; time -&gt; speed *)</span></span><br></pre></td></tr></table></figure>

<h5 id="乘积类型"><a href="#乘积类型" class="headerlink" title="乘积类型"></a>乘积类型</h5><p>乘积类型是将几个不同的值组合起来，我们也称之为多元组&#x2F;元组</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 基本语法 *)</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">NAME</span> = <span class="type">TYPE</span>*<span class="type">TYPE</span>*<span class="type">TYPE</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">(* 定义乘积类型, 时间类型：时:分:秒 *)</span></span><br><span class="line"><span class="keyword">type</span> time = <span class="built_in">int</span> * <span class="built_in">int</span> * <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* end_of_class 类型跟 time 类型是等价的 *)</span></span><br><span class="line"><span class="keyword">let</span> end_of_class = (<span class="number">16</span>, <span class="number">45</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">(* 类型为 int*int*int *)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 也可以解构使用，类似python拆箱 *)</span></span><br><span class="line"><span class="keyword">let</span> (hour, minute, second) = end_of_class</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 直接在函数的参数中使用解构方法 *)</span></span><br><span class="line"><span class="keyword">let</span> add_a_hour (hour, minute, second: time) = (hour + <span class="number">1</span>, minute, second)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 模式匹配中使用解构方法 *)</span></span><br><span class="line"><span class="keyword">let</span> meal (hour: time) : <span class="built_in">string</span> = </span><br><span class="line">  <span class="keyword">match</span> hour <span class="keyword">with</span></span><br><span class="line">  | (<span class="number">7</span>, _, _) | (<span class="number">8</span>, _, _) -&gt; <span class="string">&quot;Breakfast&quot;</span></span><br><span class="line">  | (<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>) -&gt; <span class="string">&quot;Lunch&quot;</span></span><br><span class="line">  | (<span class="number">16</span>, <span class="number">30</span>, <span class="number">0</span>) -&gt; <span class="string">&quot;Snack&quot;</span></span><br><span class="line">  | (<span class="number">19</span>, <span class="number">30</span>, <span class="number">0</span>) -&gt; <span class="string">&quot;Dinner&quot;</span></span><br><span class="line">  | (h, _, _) -&gt; (string_of_int h) ^ <span class="string">&quot;hours? It&#x27;s not time to eat!&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="加法类型"><a href="#加法类型" class="headerlink" title="加法类型"></a>加法类型</h5><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 基本语法 *)</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">NAME</span> = <span class="type">CONSTRUCTORS_1</span> |<span class="type">CONSTRUCTORS_2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 例子 *)</span></span><br><span class="line"><span class="keyword">type</span> size = <span class="type">Small</span> | <span class="type">Medium</span> | <span class="type">Large</span></span><br></pre></td></tr></table></figure>

<h5 id="关联数据和constructor"><a href="#关联数据和constructor" class="headerlink" title="关联数据和constructor"></a>关联数据和constructor</h5><p>我们还可以选择将信息和<code>constructor</code>关联在一起。为了能够更精确描述信息们的类型，我们在<code>constructor</code>的名字后使用关键词<code>of</code>，<code>of</code>后面可以接我们的目标类型。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> resultat = | <span class="type">Ok</span> <span class="keyword">of</span> <span class="built_in">float</span> <span class="comment">(* 我们将float与builder OK关联 *)</span> | <span class="type">Error</span> <span class="comment">(* 我们可以使用这个类型来实现一个不会崩溃的除法函数。 * 如果出现错误，它将会返回Error，处理除法失败的情况也是必要的 *)</span> <span class="keyword">let</span> div (x : <span class="built_in">float</span>) (d : <span class="built_in">float</span>) : resultat = <span class="keyword">if</span> d = <span class="number">0.0</span> <span class="keyword">then</span> <span class="type">Error</span> <span class="comment">(* Division by 0 impossible *)</span> <span class="keyword">else</span> <span class="type">Ok</span>(x /. d) <span class="comment">(* 就是在这里使用与数据关联的builder *)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>OCaml</tag>
        <tag>程序语言设计原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis学习笔记】</title>
    <url>/2023/03/02/%E3%80%90Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>官网：<a href="https://redis.io/">Redis</a><br>go-redis：<a href="https://pkg.go.dev/github.com/go-redis/redis/v8#section-readme">redis package - github.com&#x2F;go-redis&#x2F;redis&#x2F;v8 - Go Packages</a></p>
</blockquote>
<h2 id="1-Linux-安装及使用"><a href="#1-Linux-安装及使用" class="headerlink" title="1. Linux 安装及使用"></a>1. Linux 安装及使用</h2><ul>
<li><p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt-get install redis</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">redis-cli ping</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动redis，测试是否联通：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定配置文件启动redis-server</span></span><br><span class="line">root@hecs-264482:~<span class="comment"># redis-server /etc/redis/redis.conf</span></span><br><span class="line">% 指定端口号启动redis-cli</span><br><span class="line">root@hecs-264482:~<span class="comment"># redis-cli -p 6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否联通</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有的key</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1. <span class="string">&quot;username&quot;</span></span><br><span class="line">2. <span class="string">&quot;mylist&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务是否已经启动：<br>  <code>ps -ef|grep redis</code><br>  <img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230302181609.png">xo_gallery&#x2F;main&#x2F;gallery&#x2F;20230302181609.png)</p>
</li>
<li><p>关闭redis：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-Redis-基本知识"><a href="#2-Redis-基本知识" class="headerlink" title="2. Redis 基本知识"></a>2. Redis 基本知识</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换数据库（Redis共有16个数据库）</span></span><br><span class="line">select 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前数据库的所有键</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前数据库的大小</span></span><br><span class="line">dbsize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空数据库</span></span><br><span class="line">flushdb</span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Redis 是单线程的！</strong><br>Redis 是基于内存操作，CPU不是Redis的性能瓶颈<br><strong>Redis是单线程的为什么还会这么快？</strong><br>核心：Redis 是将所有数据全部存入内存中的，所以说用单线程去操作就是最快的！<br>（因为在多线程中，CPU需要频繁的上下文切换，切换操作同样需要一定的时间，对于内存系统，没有上下文切换时效率就是最高的！）</p>
</blockquote>
<h3 id="五大基本数据类型"><a href="#五大基本数据类型" class="headerlink" title="五大基本数据类型"></a>五大基本数据类型</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="built_in">set</span> key value</span><br><span class="line"></span><br><span class="line">get key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置失效时间</span></span><br><span class="line">expire key sec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看剩余时间</span></span><br><span class="line">tll key</span><br><span class="line"></span><br><span class="line">exists key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加字符，如果不存在，则新建一个</span></span><br><span class="line">append key world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求字符串长度</span></span><br><span class="line">strlen key</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 自增/自减 1</span></span><br><span class="line">incr views</span><br><span class="line">decr views</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自增/自减指定步长</span></span><br><span class="line">incrby views 10</span><br><span class="line">decrby views 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取字符串 [start, end]</span></span><br><span class="line">getrange key start end</span><br><span class="line"><span class="comment"># 替换指定位置开始的字符串</span></span><br><span class="line">setrange key offset value</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 设置过期时间</span></span><br><span class="line">setex key second value</span><br><span class="line"><span class="comment"># 不存在再设置，存在则不设置</span></span><br><span class="line">setnx key val</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 批量设置值</span></span><br><span class="line">mset k1 v1 k2 v2 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量获取值</span></span><br><span class="line">mget k1 k2 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时设置值，原子性操作，要么同时成功，要么同时失败</span></span><br><span class="line">msetnx k1 v1 k2 v2 ...</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 设置对象 </span></span><br><span class="line"><span class="built_in">set</span> user:1 <span class="string">&quot;&#123;name:wxs, age:3&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">mset user:1:name wxs user:1:age 23</span><br><span class="line">mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;wxs&quot;</span></span><br><span class="line">2) <span class="string">&quot;23&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 获取值并设置值</span></span><br><span class="line">getset key value</span><br></pre></td></tr></table></figure>

<h4 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 列表左侧/右侧添加元素</span></span><br><span class="line">LPUSH key val</span><br><span class="line">RPUSH key val</span><br><span class="line"><span class="comment"># 列表左侧/右侧移除元素</span></span><br><span class="line">LPOP key</span><br><span class="line">RPOP key</span><br><span class="line"><span class="comment"># 查看列表长度</span></span><br><span class="line">LLEN key</span><br><span class="line"><span class="comment"># 移除列表指定元素</span></span><br><span class="line">LREM key conut val</span><br><span class="line"><span class="comment"># 截取列表内容 key[start,end]</span></span><br><span class="line">LTRIM key start end</span><br><span class="line"><span class="comment"># 设置已经存在列表中的某个位置的值（key不存在则报错，所以要先判断列表存在不存在）</span></span><br><span class="line">LSET key index val</span><br><span class="line"><span class="comment"># 在列表某个值前/后插入元素</span></span><br><span class="line">LINSERT key BEFORE|AFTER val newVal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 移除列表最后一个元素，并移动到其他列表中</span></span><br><span class="line">RPOPLPUSH src dest</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**实际上是一个链表**</span><br><span class="line"></span><br><span class="line">在两边插入值/改动值效率最高！操作中间元素效率偏低</span><br><span class="line"></span><br><span class="line">既可以作为队列（消息队列），又可以作为栈</span><br></pre></td></tr></table></figure>

<h4 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. Set</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 集合内添加元素</span></span><br><span class="line">SADD key val</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集合内元素</span></span><br><span class="line">SMEMBERS key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集合内是否存在某个值（1：存在，0：不存在）</span></span><br><span class="line">SISMEMBER key val</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集合长度</span></span><br><span class="line">SCARD key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集合中删除元素</span></span><br><span class="line">SREM key val</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 随机取出元素</span></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机删除元素</span></span><br><span class="line">SPOP key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个值从一个集合中移动到另一个集合中</span></span><br><span class="line">SMOVE key1 key2 val</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 求差集</span></span><br><span class="line">SDIFF key1 key2 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求交集（例如求共同关注）</span></span><br><span class="line">SINSERT key1 key2 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求并集</span></span><br><span class="line">SUNION key1 key2 ...</span><br></pre></td></tr></table></figure>

<h4 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4. Hash"></a>4. Hash</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="comment"># 往Hash表key中添加字段（field，val）</span></span><br><span class="line">hset key field val</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Hash表中的字段field</span></span><br><span class="line">hget key field</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量设置/获取键值对</span></span><br><span class="line">hmset key field val [field val...]</span><br><span class="line">hmget key field [field...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有键值对</span></span><br><span class="line">hgetall key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Hash表指定的key-val</span></span><br><span class="line">hdel key field</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Hash表长度</span></span><br><span class="line">hlen key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断Hash表中的key是否存在</span></span><br><span class="line">hexists key field</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的key/val</span></span><br><span class="line">hkeys key</span><br><span class="line">hvals key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自增/自减Hash表字段</span></span><br><span class="line">hincrby key field increment</span><br><span class="line">hdecrby key field decrement</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不存在则设置成功，存在则设置失败</span></span><br><span class="line">hsetnx key field val</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hash更适合于对象的存储！</span><br></pre></td></tr></table></figure>

<h4 id="5-Zset"><a href="#5-Zset" class="headerlink" title="5. Zset"></a>5. Zset</h4><p>在 set 的基础上增加了一个值，变成一个<strong>有序集合</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加值</span></span><br><span class="line">zadd key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集合</span></span><br><span class="line">zrange key start end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现排序 (min/max 可以是 -inf/+inf：即正/负无穷)</span></span><br><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除元素</span></span><br><span class="line">zrem key member</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取有序集合中的个数</span></span><br><span class="line">zcard key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某个区间的值</span></span><br><span class="line">zcount key min max</span><br></pre></td></tr></table></figure>

<h3 id="三种特殊类型"><a href="#三种特殊类型" class="headerlink" title="三种特殊类型"></a>三种特殊类型</h3><h4 id="1-Geospatial"><a href="#1-Geospatial" class="headerlink" title="1. Geospatial"></a>1. Geospatial</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只有六个命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加地理位置 (经度、纬度、成员)</span></span><br><span class="line"><span class="comment"># 两级无法添加，一半会下载城市数据，直接编写代码一次性读入</span></span><br><span class="line">geoadd key longitude latitude member ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取经纬度</span></span><br><span class="line">geopos key member ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两地距离，unit为单位，可以是 m、km...</span></span><br><span class="line">geodist key member1 member2 [unit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过半径查询某经纬度周围的成员（可以用来实现查看附近的人的操作）</span></span><br><span class="line">georadius key longitude latitude radius [unit] [withcoord] [withdist] [count num]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过半径查询某成员周围的成员</span></span><br><span class="line">georadiusbymember key member radius [unit] [withcoord] [withdist] [count num]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将二维经纬度信息转化为一维字符串</span></span><br><span class="line">geohash key member ...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">collapse: open</span><br><span class="line"></span><br><span class="line">Geospatial 底层的实现原理其实就是 **Zset**</span><br><span class="line"></span><br><span class="line">我们可以通过 Zset 命令来操作 Geo</span><br></pre></td></tr></table></figure>

<h4 id="2-Hyperloglog"><a href="#2-Hyperloglog" class="headerlink" title="2. Hyperloglog"></a>2. Hyperloglog</h4><p>概念引入：基数（不重复的元素）f<br>Hyperloglog 可以用来<strong>统计基数</strong><br>可以用来统计网站的访问人数（UV），可以过滤同一用户的多次访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">pfadd key val ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计长度</span></span><br><span class="line">pfcount key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并多个 key</span></span><br><span class="line">pfmerge destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hyperloglog 类似于特化的 Set，能够保存大量元素并统计去重后得元素个数</span><br><span class="line"></span><br><span class="line">优点是**占用固定内存**，存放 $2^&#123;64&#125;$ 个元素也只需占用 12KB 内存</span><br><span class="line"></span><br><span class="line">缺点是功能单一，且存在一定的**错误率**（0.81%）</span><br><span class="line"></span><br><span class="line">如果允许**容错**，就一定可以使用 Hyperloglog！</span><br></pre></td></tr></table></figure>

<h4 id="3-Bitmap"><a href="#3-Bitmap" class="headerlink" title="3. Bitmap"></a>3. Bitmap</h4><p>位存储，类似于用 0&#x2F;1 来当作 bool 变量存储逻辑值<br>如：全国 14 亿人每个人是否阳过，就可以用 14 亿个 bit 来存储信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置位的值</span></span><br><span class="line">setbit key index val</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个位的值</span></span><br><span class="line">getbit key index</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看值为 1 的位数</span></span><br><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure>

<h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h2><h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><p>事务本质：<strong>一组命令的集合</strong><br>一个事务中的所有命令都会被序列化，在事务执行过程中会按照顺序执行！<br>特性：<strong>一次性、顺序性、排他性</strong><br>MySQL中的事务：ACID<br><strong>Redis 单条命令是保证原子性的，但是事务不保证原子性</strong><br>Redis 事务<strong>没有隔离级别的概念</strong>，所以不存在类似 MySQL 中的幻读、脏读等情况<br>所有的命令在事务中<strong>并没有直接被执行</strong>！只有发起执行命令的时候才会执行<br>Redis 的事务：</p>
<ul>
<li>开启事务（<code>multi</code>）</li>
<li>命令入队（<code>...</code>）</li>
<li>执行事务（<code>exec</code>）</li>
<li>放弃事务（<code>discard</code>）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  127.0.0.1:6379&gt; multi</span><br><span class="line">  OK</span><br><span class="line">  127.0.0.1:6379(TX)&gt; set k1 v1</span><br><span class="line">  QUEUED</span><br><span class="line">  127.0.0.1:6379(TX)&gt; set k2 v2</span><br><span class="line">  QUEUED</span><br><span class="line">  127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">  QUEUED</span><br><span class="line">  127.0.0.1:6379(TX)&gt; set k3 v3</span><br><span class="line">  QUEUED</span><br><span class="line">  127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) OK</span><br><span class="line"></span><br><span class="line">2) OK</span><br><span class="line"></span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line"></span><br><span class="line">4) OK</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```ad-tip</span><br><span class="line">&quot;编译型异常&quot;（代码语法就有问题，会被直接检查出来）：事务中的**所有命令都不会执行**（如命令缺少参数等）</span><br><span class="line"></span><br><span class="line">&quot;运行时异常&quot;：在执行命令时，有问题的命令会抛出异常，**其他命令会正常执行**（如对字符串执行加1操作等）</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Redis-实现乐观锁"><a href="#Redis-实现乐观锁" class="headerlink" title="Redis 实现乐观锁"></a>Redis 实现乐观锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><ul>
<li>很悲观，认为什么时候都可能会出现问题，所以无论做什么都会加锁！</li>
<li>这样会大大影响程序执行效率</li>
</ul>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul>
<li>很乐观，认为什么时候都不不会出问题，所以不会上锁！</li>
<li>更新数据的时候会做出判断，在此期间是否有人修改过数据（在 MySQL 中通过 <code>version</code> 字段实现）</li>
</ul>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><ul>
<li><p>在事务开启前，对 key 进行监控（相当于 加锁&#x2F;<code>getVersion()</code> ）</p>
</li>
<li><p>如果启动事务后，被监控的 key 被其他线程修改，则事务必定执行失败！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set money 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监控 key</span></span><br><span class="line"></span><br><span class="line">watch money</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启事务</span></span><br><span class="line"></span><br><span class="line">multi</span><br><span class="line"></span><br><span class="line">incrby money 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时其他线程对 money 进行了修改</span></span><br><span class="line"></span><br><span class="line">exec</span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行失败以后，重新执行需要先放弃监控</span></span><br><span class="line"></span><br><span class="line">unwatch money</span><br><span class="line"></span><br><span class="line">watch  money</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-Redis-持久化"><a href="#4-Redis-持久化" class="headerlink" title="4. Redis 持久化"></a>4. Redis 持久化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**工作和面试的重点！**</span><br></pre></td></tr></table></figure>

<p>Redis 是<strong>内存数据库</strong>，如果不将内存中的数据库状态保存到磁盘中，一旦服务器进程退出，服务器中的数据库状态也会消失，所以 Redis 提供了持久化功能</p>
<h3 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h3><p>在 RDB 模式下，Redis 会将数据库状态保存在文件：dump.rdb 中，在 Redis 启动时会自动检查 dump.rdb 文件，恢复其中的数据！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dump.rdb文件位置：</span></span><br><span class="line"><span class="comment"># 在redis客户端：</span></span><br><span class="line">127.0.0.1:6379&gt; config get <span class="built_in">dir</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/var/lib/redis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端：</span></span><br><span class="line">find / -name dump.rdb</span><br><span class="line">/var/lib/redis/dump.rdb</span><br></pre></td></tr></table></figure>

<p>RDB工作流程：<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230302181823.png"><br>触发生成 dump.rdb 的规则：</p>
<ol>
<li><p>满足配置文件中设置的 <code>save</code> 规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每3600s对key有1次操作就生成一次 dump.rdb，以此类推</span></span><br><span class="line">save 3600 1 300 100 60 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 <code>flushall</code> 命令</p>
</li>
<li><p>退出 <code>redis</code></p>
</li>
</ol>
<p>优点：<br>    1. 适合大规模的数据恢复<br>    2. 如果对数据完整性要求不高时可以使用<br>缺点：<br>    1. 需要一定的时间间隔进行操作，如果在时间间隔内 redis 宕机，则数据就消失了<br>    2. fork 进程的时候需要占用一定内存空间</p>
<h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><p>将<strong>所有命令</strong>（不包括读操作）以<strong>日志的形式记录下来</strong>，保存在一个文件中（appendonly.aof），Redis 会在<strong>启动之初</strong>根据这个日志文件的内容将写指令从前到后执行一次以完成数据恢复工作！</p>
<p>默认是不开启的，只需要将 redis.conf 文件中的 <code>appendonly no</code> 改为 <code>yes</code> ，重启即可生效。</p>
<p>如果 appendonly.aof 有错误，Redis 是启动不起来的，我们可以通过工具 <code>redis-check-aof --fix</code> 来修复文件 </p>
<p>AOF 工作流程：<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230302181906.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 三种同步方式 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写规则</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<p>三种同步方式各自优点：<br>    1. 每次修改都同步，文件完整性更好<br>    2. 每秒同步一次，可能会丢失 1s 的数据<br>    3. 从不同步，效率最高<br>缺点：<br>    1. 对于数据文件来说，AOF 远远大于 RDB，修复的速度也比 rdb 慢<br>    2. AOF 运行效率比 RDB 慢</p>
<p>拓展：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">collapse: open</span><br><span class="line">1、RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储</span><br><span class="line"></span><br><span class="line">2、AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Rdis协议追加保存每次写的操作到文件末尾，Redisi还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</span><br><span class="line"></span><br><span class="line">3、**只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化**</span><br><span class="line"></span><br><span class="line">4、同时开启两种持久化方式</span><br><span class="line"></span><br><span class="line">    在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</span><br><span class="line"></span><br><span class="line">    RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合</span><br><span class="line"></span><br><span class="line">    用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的BUG,留着作为一个万一的手段。</span><br><span class="line"></span><br><span class="line">5、性能建议</span><br><span class="line"></span><br><span class="line">    因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。</span><br><span class="line"></span><br><span class="line">    如果Enable AOF,好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只Ioad自己的AOF文件就可以了，代价一是带来了持续的IO,二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</span><br><span class="line"></span><br><span class="line">    如果不Enable AOF,仅靠Master-Slave Repllcation实现高可用性也可以，能省掉一大笔IO，也减少了rewriteB时带来的系统波动，代价是如果 Master/Slave 同时宕机，会丢失十几分钟的数据，启动脚本要比较两个 Master/Slave 中的 RDB 文件，载入较新的那个。（微博就是这种架构）</span><br></pre></td></tr></table></figure>

<h2 id="5-Redis-发布订阅"><a href="#5-Redis-发布订阅" class="headerlink" title="5. Redis 发布订阅"></a>5. Redis 发布订阅</h2><p>Redis 发布订阅(pub&#x2F;sub)是一种<strong>消息通信模式</strong>：发送者(pub)发送消息，订阅者(sub)接受消息。类似于微博、微信等的关注系统。<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230302181944.png"><br>发布订阅命令：<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230302182008.png"><br>订阅端：<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230302182026.png"><br>发布端：<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230302182048.png"></p>
<p>使用场景：</p>
<ol>
<li>实时消息系统</li>
<li>实时聊天（频道当作聊天室，将信息回显给所有订阅者）</li>
<li>订阅、关注系统</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">稍微复杂的场景，就会使用一些消息中间件，如 MQ、KAFKA 等</span><br></pre></td></tr></table></figure>

<h2 id="6-主存复制💖"><a href="#6-主存复制💖" class="headerlink" title="6. 主存复制💖"></a>6. 主存复制💖</h2><h2 id="7-Redis-缓存穿透和雪崩"><a href="#7-Redis-缓存穿透和雪崩" class="headerlink" title="7. Redis 缓存穿透和雪崩"></a>7. Redis 缓存穿透和雪崩</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>狂神说Java</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringBoot整合】缓存篇</title>
    <url>/2023/03/01/%E3%80%90SpringBoot%E6%95%B4%E5%90%88%E3%80%91%E7%BC%93%E5%AD%98%E7%AF%87/</url>
    <content><![CDATA[<h1 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h1><ol>
<li><p>导入数据库文件</p>
 <img src="【SpringBoot整合】缓存篇/image-20200426210138694.png" alt="image-20200426210138694" style="zoom: 67%;" />
</li>
<li><p>创建JavaBean封装数据</p>
 <img src="【SpringBoot整合】缓存篇/image-20200426210225693.png" alt="image-20200426210225693" style="zoom:67%;" />
</li>
<li><p>整合Mybatis操作数据库</p>
<ol>
<li><p>配置数据源</p>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_cache</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">abc123aa</span></span><br><span class="line"><span class="attr">spring.datasource.data-username</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#开启驼峰命名匹配规则</span></span><br><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用注解版的Mybatis</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM employee WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">getEmpById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE employee SET lastName=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125;,d_id=#&#123;dId&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateEmp</span><span class="params">(Employee employee)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE employee FROM WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteEmpById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO employee(lastName,email,gender,d_id) VALUES(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;dId&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEmp</span><span class="params">(Employee employee)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.cache.mapper&quot;)</span>		<span class="comment">//指定需要扫描的mapper接口所在的包</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span>		<span class="comment">//开启基于注解的Cache</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot01CacheApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot01CacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="开启缓存"><a href="#开启缓存" class="headerlink" title="开启缓存"></a>开启缓存</h1><ol>
<li><p>开启基于注解的缓存 <code>@EnableCaching</code></p>
</li>
<li><p>标注缓存注解</p>
<p> <code>@Cacheable</code>：<strong>将方法的运行结果进行缓存，以后再要相同的数据，直接从缓存中取，不调用方法</strong></p>
<p> ​	几个属性：</p>
<p> ​		<code>cacheNames/value</code>：指定缓存组件的名字</p>
<p> ​		<code>key</code>：缓存数据使用的key，<strong>默认是方法的参数值</strong></p>
<p> ​		<code>keyGenerator：key</code>的生成器，可以自己指定key的生成器的组件id（key和keyGenerator二选一使用）		<code>cacheManager</code>：指定缓存管理器</p>
<p> ​		<code>condition</code>：指定符合条件的情况下才缓存 <code>condition = #id &gt; 0</code></p>
<p> ​		<code>unless</code>：与condition相反</p>
<p> ​		<code>sync</code>：使用异步模式</p>
<p> <code>@CacheEvict</code>：<strong>缓存清楚</strong></p>
<p> ​	几个属性：</p>
<p> ​		<code>key</code>：指定要清楚的数据</p>
<p> ​		<code>allEntries = true</code>：指定清楚缓存中的所有数据</p>
<p> ​		<code>beforeInvocation</code>：缓存的清楚是否在方法执行之前进行</p>
<p> <code>@CachePut</code>：</p>
<p> ​	既调用方法，又更新缓存数据（<strong>先调用方法，将方法的结果放入缓存中</strong>）</p>
<p> <code>@CacheConfig</code>：抽取缓存的公共配置（在类上标注）</p>
<p> ​	<code>@CacheConfig(cacheNames = &quot;emp&quot;)</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将方法的运行结果进行缓存，以后再要相同的数据，直接从缓存中获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;emp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">getEmp</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询&quot;</span>+id+<span class="string">&quot;号员工&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> employeeMapper.getEmpById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;emp&quot;,key = &quot;#employee.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">updateEmp</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;update emp~&quot;</span>);</span><br><span class="line">        employeeMapper.updateEmp(employee);</span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;emp&quot;,beforeInvocation = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteEmp</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete emp&quot;</span>);</span><br><span class="line">        employeeMapper.deleteEmpById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ​</p>
</li>
</ol>
<p>	</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol>
<li><p>自动配置类：<code>CacheAutoConfiguration</code></p>
</li>
<li><p>缓存的配置类：</p>
 <img src="【SpringBoot整合】缓存篇/image-20200426212644012.png" alt="image-20200426212644012"  />
</li>
<li><p>默认生效的类：<code>org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration</code></p>
</li>
</ol>
<p>……</p>
<h1 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h1><h3 id="1-安装Redis"><a href="#1-安装Redis" class="headerlink" title="1.安装Redis"></a>1.安装Redis</h3><ul>
<li>使用<strong>docker</strong>拉取<strong>redis</strong>镜像</li>
</ul>
<img src="【SpringBoot整合】缓存篇/image-20200428132204888.png" alt="image-20200428132204888" style="zoom: 80%;" />

<p>​	在拉取镜像过程中，添加国内的<strong>阿里云镜像加速器</strong>可以提高拉取速度！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	添加如下字段</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	&#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://9cpn8tt6.mirror.aliyuncs.com&quot;</span>]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	&#125;</span></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<ul>
<li><p>启动redis</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name myredis redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d:后台的方式启动</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p:暴露端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6379:6379：将虚拟机的6379映射到容器的6379端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name myredis：起别名myredis</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis：要运行的镜像</span></span><br></pre></td></tr></table></figure>

<p>  查看运行状况：</p>
</li>
</ul>
<p><img src="/%E3%80%90SpringBoot%E6%95%B4%E5%90%88%E3%80%91%E7%BC%93%E5%AD%98%E7%AF%87/image-20200428133048477.png" alt="image-20200428133048477"></p>
<ul>
<li>使用 <strong>Redis Desktop Manger</strong> 建立连接</li>
</ul>
<img src="【SpringBoot整合】缓存篇/image-20200428133225557.png" alt="image-20200428133225557" style="zoom:67%;" />

<h3 id="2-引入redis的starter"><a href="#2-引入redis的starter" class="headerlink" title="2.引入redis的starter"></a>2.引入redis的starter</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用redis时，在<code>RedisAutoConfiguration</code>中注入了两个非常重要的组件：</p>
<ul>
<li><code>RedisTemplate</code></li>
<li><code>StringRedisTemplate</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">         RedisConnectionFactory redisConnectionFactory)</span></span><br><span class="line">         <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">      RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;Object, Object&gt;();</span><br><span class="line">      template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(StringRedisTemplate.class)</span></span><br><span class="line">   <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">         RedisConnectionFactory redisConnectionFactory)</span></span><br><span class="line">         <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">      <span class="type">StringRedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">      template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis常见五大数据类型：</p>
<p>​	String、List、Set、Hash、ZSet（有序集合）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoWired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate；</span><br><span class="line">    </span><br><span class="line">stringRedisTemplate.opsForValue()；	<span class="comment">//字符串</span></span><br><span class="line">stringRedisTemplate.opsForList()；	<span class="comment">//列表</span></span><br><span class="line">stringRedisTemplate.opsForSet()；	<span class="comment">//集合</span></span><br><span class="line">stringRedisTemplate.opsForHash()；	<span class="comment">//散列</span></span><br><span class="line">stringRedisTemplate.opsForZSet()；	<span class="comment">//有序集合</span></span><br></pre></td></tr></table></figure>



<h3 id="3-配置redis"><a href="#3-配置redis" class="headerlink" title="3.配置redis"></a>3.配置redis</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">192.168.5.129</span></span><br></pre></td></tr></table></figure>

<h3 id="4-测试缓存"><a href="#4-测试缓存" class="headerlink" title="4.测试缓存"></a>4.测试缓存</h3><ul>
<li>原理：<ol>
<li>引入redis的starter，容器中保存的是 <code>RedisCacheManager</code></li>
<li><code>RedisCacheManager</code> 帮我们创建 <code>RedisCache</code> 来作为缓存组件</li>
<li><code>RedisCache</code> 通过 redis 操纵缓存</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>尚硅谷</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring注解驱动开发】中篇</title>
    <url>/2023/03/01/%E3%80%90Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%91%E4%B8%AD%E7%AF%87/</url>
    <content><![CDATA[<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h4 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h4><p>在程序运行过程中将<strong>某段代码切入到指定方法&#x2F;指定位置运行</strong>的编程方式</p>
<p>&#x3D;&#x3D;底层：动态代理&#x3D;&#x3D;</p>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ol>
<li><p>导入aop模块：spring-aspects</p>
</li>
<li><p>定义一个<strong>业务逻辑类</strong>（MathCalculator），要求在业务逻辑种进行日志打印（方法运行之前、方法运行之后、出现异常……）</p>
</li>
<li><p>定义一个<strong>日志切面类</strong>（LogAspect），里面的方法需要动态感知 MathCalculator.div 运行到哪里并打印相关信息</p>
<p> 通知方法：</p>
<ul>
<li>前置通知( <strong>@Before</strong> )：LogStart</li>
<li>后置通知( <strong>@After</strong> )：LogEnd</li>
<li>返回通知( <strong>@AfterReturning</strong> )：LogReturn</li>
<li>异常通知( <strong>@AfterThrowing</strong> )：LogException</li>
<li>环绕通知( <strong>@Around</strong> )：动态代理，手动推进目标方法运行（ joinPoint.proceed() ）</li>
</ul>
</li>
<li><p>给日志切面类标注通知注解</p>
</li>
<li><p>将 <strong>业务逻辑类</strong> 和 <strong>日志切面类</strong> 都加入到容器中</p>
</li>
<li><p><strong>告诉Spring哪个类是切面类</strong>：给切面类上加注解<code>@Aspect</code></p>
</li>
<li><p><strong>在配置类上加注解</strong>：<code>@EnableAspectJAutoProxy</code></p>
<p> Spring中很多的 <code>@Enablexxx</code></p>
</li>
</ol>
<p>直接上代码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//业务逻辑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public int com.wxs.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注意！！！</span></span><br><span class="line"><span class="comment">        参数joinPoint参数必须放在第一位Spring才能识别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logStart</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;除法运行参数是：&quot;</span> + joinPoint.getArgs().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logEnd</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;正常运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointCut()&quot;,returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logReturn</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;除法的结果是：&quot;</span>+ result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointCut()&quot;,throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出现的异常&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主配置类</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfigOfAOP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MathCalculator <span class="title function_">mathCalculator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MathCalculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogAspect <span class="title function_">logAspect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogAspect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h4><p>&#x3D;&#x3D;源码分析：看给容器中注册了什么组件、组件如何工作、有什么功能&#x3D;&#x3D;</p>
<ol>
<li><p><code>@EnalbleAspectJAutoProxy</code></p>
<p> <code>@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)</code>：给容器中导入 AspectJAutoProxyRegistrar</p>
<p> 利用 AspectJAutoProxyRegistrar 自定义给容器中注册bean</p>
<p> 给容器中注册一个名叫 <strong>internalAutoProxyCreator</strong> ，</p>
<p> 类型为 <strong>AnnotationAwareAspectJAutoProxyCreator</strong> 的组件</p>
</li>
<li><p>接下来我们就详细看一下 <strong>AnnotationAwareAspectJAutoProxyCreator</strong> 是个什么东西：</p>
<p> 先康康继承树：</p>
<p> <img src="/%E3%80%90Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%91%E4%B8%AD%E7%AF%87/image-20200415122727767.png" alt="image-20200415122727767"></p>
<p> 重点关注 <strong>后置处理器</strong> 和 <strong>自动装配BeanFactory</strong>  </p>
<p> 我们<strong>从上往下</strong>慢慢看！</p>
<h5 id="1-先从父类-AbstractAutoProxyCreator-开始看！"><a href="#1-先从父类-AbstractAutoProxyCreator-开始看！" class="headerlink" title="1.先从父类 AbstractAutoProxyCreator 开始看！"></a>1.先从父类 <strong>AbstractAutoProxyCreator</strong> 开始看！</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现BeanFactory的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//有后置处理器相关的方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span>    </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span>     </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span>    </span><br></pre></td></tr></table></figure>

<h5 id="2-再看-AbstractAdvisorAutoProxyCreator-！"><a href="#2-再看-AbstractAdvisorAutoProxyCreator-！" class="headerlink" title="2.再看 AbstractAdvisorAutoProxyCreator ！"></a>2.再看 <strong>AbstractAdvisorAutoProxyCreator</strong> ！</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写了setBeanFactory方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//内部调用了initBeanFactory方法</span></span><br><span class="line">        <span class="built_in">this</span>.initBeanFactory((ConfigurableListableBeanFactory)beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-继续向下看子类-AspectJAwareAdvisorAutoProxyCreator-！"><a href="#3-继续向下看子类-AspectJAwareAdvisorAutoProxyCreator-！" class="headerlink" title="3.继续向下看子类 AspectJAwareAdvisorAutoProxyCreator ！"></a>3.继续向下看子类 <strong>AspectJAwareAdvisorAutoProxyCreator</strong> ！</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//emmmmm，方法都跟 后置处理器 或者 自动装配BeanFactory 没啥关系，就不看了</span></span><br></pre></td></tr></table></figure>

<h5 id="4-最后看-AnnotationAwareAspectJAutoProxyCreator-！"><a href="#4-最后看-AnnotationAwareAspectJAutoProxyCreator-！" class="headerlink" title="4.最后看 AnnotationAwareAspectJAutoProxyCreator ！"></a>4.最后看 AnnotationAwareAspectJAutoProxyCreator ！</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//又重写了该方法，相当于父类 setBeanFactory() 时还得调它</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span><br></pre></td></tr></table></figure>

<p> <strong>流程：</strong></p>
<p> <img src="/%E3%80%90Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%91%E4%B8%AD%E7%AF%87/image-20200415125231299.png" alt="image-20200415125231299"></p>
<h5 id="1-传入主配置类，创建ioc容器"><a href="#1-传入主配置类，创建ioc容器" class="headerlink" title="1.传入主配置类，创建ioc容器"></a>1.传入主配置类，创建ioc容器</h5><p> <code>AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);</code></p>
<h5 id="2-注册配置类，调用-refresh-，刷新容器（就跟初始化容器一样）"><a href="#2-注册配置类，调用-refresh-，刷新容器（就跟初始化容器一样）" class="headerlink" title="2.注册配置类，调用 refresh()，刷新容器（就跟初始化容器一样）"></a>2.注册配置类，调用 <code>refresh()</code>，刷新容器（就跟初始化容器一样）</h5><h5 id="3-refresh-中："><a href="#3-refresh-中：" class="headerlink" title="3. refresh() 中："></a>3. refresh() 中：<img src="/%E3%80%90Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%91%E4%B8%AD%E7%AF%87/image-20200415124948236.png" alt="image-20200415124948236"></h5><p> ​	<strong>注册 bean 的后置处理器</strong>来方便拦截 bean 的创建，进去康康</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.先获取ioc容器中需要创建对象的所有 BeanPostProcessor</span></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.给容器中加别的BeanPostProcessor</span></span><br><span class="line">beanFactory.addBeanPostProcessor</span><br><span class="line">   (<span class="keyword">new</span> <span class="title class_">PostProcessorRegistrationDelegate</span>.BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.优先注册实现了接口 PriorityOrdered 的 BeanPostProcessor</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">    pp = (BeanPostProcessor)beanFactory</span><br><span class="line">        .getBean(ppName,BeanPostProcessor.class);</span><br><span class="line">    priorityOrderedPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.再注册实现了 Ordered 接口的 BeanPostProcessor</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">    orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5.最后注册没实现优先级接口的 BeanPostProcessor</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6.注册BeanPostProcessor，实际上是创建 BeanPostProcessor 对象，保存在容器中</span></span><br></pre></td></tr></table></figure>

<p> 创建 <strong>internalAutoProxyCreator</strong> 的 <strong>BeanPostProcessor</strong></p>
<pre><code> 1. 创建 Bean 的实例
</code></pre>
<ol start="2">
<li><p><code>populateBean()</code>：给 bean 的各种属性赋值</p>
</li>
<li><p><code>initializeBean()</code>：初始化 bean</p>
<ol>
<li><code>invokeAwareMethods()</code>：处理Aware接口的方法回调</li>
<li><code>applyBeanPostProcessorsBeforeInitialization()</code>：应用后置处理器的 <code>beforeInitialization()</code></li>
<li><code>invokeInitMethods()</code>：执行自定义初始化方法</li>
<li><code>applyBeanPostProcessorsAfterInitialization()</code>：应用后置处理器的 <code>afterInitialization()</code></li>
</ol>
</li>
<li><p>BeanPostProcessor 创建成功</p>
<p> 把 BeanPostProcessor 注册到 BeanFactory中：<code>beanFactory.addBeanPostProcessor(postProcessor)</code></p>
</li>
</ol>
<h5 id="4-finishBeanFactoryInitialization-beanFactory-：完成-BeanFactory初始化工作"><a href="#4-finishBeanFactoryInitialization-beanFactory-：完成-BeanFactory初始化工作" class="headerlink" title="4.finishBeanFactoryInitialization(beanFactory)：完成 BeanFactory初始化工作"></a>4.finishBeanFactoryInitialization(beanFactory)：完成 BeanFactory初始化工作</h5><ol>
<li><p>遍历获取容器中所有的 Bean ，依次创建对象</p>
<p><code>getBean()</code>—&gt;<code>doGetBean()</code>—&gt;<code>getSingleton()</code></p>
</li>
<li><p>创建 bean</p>
<ol>
<li><p>先去缓存中康康，如果没有再创建 bean</p>
</li>
<li><p><code>createBean()</code>：创建 bean</p>
<ol>
<li><p><code>resolveBeforeInstantiation(beanName, mbd)</code></p>
<p> 希望后置处理器在此处能返回一个代理对象，如果能返回代理对象就使用，不能就继续执行下面的操作</p>
</li>
<li><p><code>doCreateBean(beanName, mbdToUse，args)</code>：真正去创建一个bean实例</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>尚硅谷</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring注解驱动开发】前篇</title>
    <url>/2020/04/15/%E3%80%90Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%91%E5%89%8D%E7%AF%87/</url>
    <content><![CDATA[<h2 id="Bean的初始化和生命周期"><a href="#Bean的初始化和生命周期" class="headerlink" title="Bean的初始化和生命周期"></a>Bean的初始化和生命周期</h2><h4 id="bean-的生命周期"><a href="#bean-的生命周期" class="headerlink" title="bean 的生命周期"></a>bean 的生命周期</h4><ul>
<li><p>bean 创建—&gt;初始化—&gt;销毁的过程  </p>
</li>
<li><p>Spring 容器管理 bean 的生命周期</p>
</li>
</ul>
<h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><ul>
<li><p>单实例：<strong>容器启动</strong>时创建对象</p>
</li>
<li><p>多实例：<strong>获取对象</strong>时创建对象</p>
</li>
<li><p>初始化：</p>
<ul>
<li>对象创建完成 ，并赋值，调用初始化方法</li>
</ul>
</li>
<li><p>销毁：</p>
<ul>
<li>单实例：容器关闭时销毁</li>
<li>多实例：容器不会管理该bean，不会调用销毁方法</li>
</ul>
</li>
</ul>
<h4 id="自定义初始化和销毁方法"><a href="#自定义初始化和销毁方法" class="headerlink" title="自定义初始化和销毁方法"></a>自定义初始化和销毁方法</h4><h5 id="1-指定初始化和销毁方法"><a href="#1-指定初始化和销毁方法" class="headerlink" title="1.指定初始化和销毁方法"></a>1.指定初始化和销毁方法</h5><ul>
<li><p>之前的初始化方法：<code>&lt;bean init-method=&quot;&quot; destory-method=&quot;&quot;&gt;&lt;/bean&gt;</code>  </p>
</li>
<li><p>基于注解的初始化方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;容器创建完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法被创建了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法被销毁了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//告诉spring这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置初始化和销毁方法</span></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">car</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-让Bean实现-InitializingBean接口-和-DisposableBean接口"><a href="#2-让Bean实现-InitializingBean接口-和-DisposableBean接口" class="headerlink" title="2.让Bean实现 InitializingBean接口 和 DisposableBean接口"></a>2.让Bean实现 <strong>InitializingBean接口</strong> 和 <strong>DisposableBean接口</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁方法~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化方法~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-可以用-JSR250："><a href="#3-可以用-JSR250：" class="headerlink" title="3.可以用 JSR250："></a>3.可以用 JSR250：</h5><p>​	<code>@PostConstruct</code>：在bean创建完成并属性复制完成，执行初始化方法</p>
<p>​	<img src="/%E3%80%90Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%91%E5%89%8D%E7%AF%87/image-20200413170120664.png" alt="image-20200413170120664"></p>
<p>​	<code>PreDestroy</code>：在容器销毁bean之前通知我们进行销毁工作</p>
<p>​	<img src="/%E3%80%90Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%91%E5%89%8D%E7%AF%87/image-20200413170249851.png" alt="image-20200413170249851"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;@PostConstruct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;@PreDestroy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-BeanPostProcessor"><a href="#4-BeanPostProcessor" class="headerlink" title="4.BeanPostProcessor"></a>4.BeanPostProcessor</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">//在初始化之前进行工作</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">//在初始化之后进行工作</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>BeanPostProcessor 原理：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 遍历容器中的所有 BeanPostProcessor</span></span><br><span class="line"><span class="comment"> 挨个执行 beforeInitialization</span></span><br><span class="line"><span class="comment"> 一旦返回 null</span></span><br><span class="line"><span class="comment"> return，跳出 for 循环</span></span><br><span class="line"><span class="comment"> 不会执行后面的 BeanPostProcessor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给 bean 进行赋值</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">//initializeBean</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">//beforeInitialization</span></span><br><span class="line">    wrappedBean = <span class="built_in">this</span>.applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line">    <span class="comment">//执行自定义初始化方法</span></span><br><span class="line">    <span class="built_in">this</span>.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    <span class="comment">//afterInitialization</span></span><br><span class="line">    wrappedBean = <span class="built_in">this</span>.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>​	<strong>Spring底层对 BeanPostProcessor 的使用：</strong></p>
<p>​		bean赋值、注入其他组件、<code>@Autowired</code>、生命周期注解功能、<code>@Async</code>、···</p>
<h2 id="属性赋值：-Value"><a href="#属性赋值：-Value" class="headerlink" title="属性赋值：@Value"></a>属性赋值：@Value</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	1.基本数值</span></span><br><span class="line"><span class="comment">    	2.SpEL：#&#123;&#125;</span></span><br><span class="line"><span class="comment">    	3.$&#123;&#125;：取出配置文件中的值（在运行环境变量中的值）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@value(&quot;wxs&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@value(&quot;#&#123;20-2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//告诉spring这是一个配置类</span></span><br><span class="line"><span class="meta">@PropertySource(value=&#123;&quot;classpath:/person.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给容器注册一个bean，id默认为方法名</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#classpath:/person.properties</span></span><br><span class="line"><span class="attr">person.hobby</span> = <span class="string">singJumpRapAndBasketball</span></span><br></pre></td></tr></table></figure>
<h2 id="环境切换：-Profile"><a href="#环境切换：-Profile" class="headerlink" title="环境切换：@Profile"></a>环境切换：@Profile</h2><ul>
<li><code>@Profile</code> 注解：<strong>逻辑组名称</strong>，只有当这些Profile被激活的时候，才会将Profile中所对应的Bean注册到Spring容器中。<ul>
<li>加了环境标识的bean，只有环境被激活才会被注册到容器中</li>
<li>写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效</li>
<li>没有标注环境标识的bean，在任何环境下都加载</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> DataSource <span class="title function_">dataSourceDev</span><span class="params">()</span>&#123;</span><br><span class="line">    	...   </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> DataSource <span class="title function_">dataSourceTest</span><span class="params">()</span>&#123;</span><br><span class="line">    	...   </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> DataSource <span class="title function_">dataSourceProd</span><span class="params">()</span>&#123;</span><br><span class="line">    	...   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>激活方法：</p>
<ol>
<li><p>使用命令行动态参数： 设置虚拟机参数 -Dspring.profiles.active&#x3D;test&#x2F;dev&#x2F;prod</p>
</li>
<li> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ApplicationContext</span></span><br><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MainConfig.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置需要激活的环境</span></span><br><span class="line">context.getEnvironment().setDefaultProfiles(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//注册主配置类</span></span><br><span class="line">context.register(MainConfig.class);</span><br><span class="line"><span class="comment">//启动刷新容器</span></span><br><span class="line">context.refresh();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="Spring容器创建原理【源码分析】"><a href="#Spring容器创建原理【源码分析】" class="headerlink" title="Spring容器创建原理【源码分析】"></a>Spring容器创建原理【源码分析】</h2><p>Spring 通过<code>AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfigOfAOP.class)</code>来创建容器，</p>
<p>我们就进到 <strong>AnnotationConfigApplicationContext</strong> 中一探究竟！</p>
<p>&#x3D;&#x3D;注：以下代码均只截取了源码中重要的部分，并不是完整的源码&#x3D;&#x3D;</p>
<p><img src="/%E3%80%90Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%91%E5%89%8D%E7%AF%87/image-20200419083939764.png" alt="image-20200419083939764"></p>
<p><strong>重点关注容器的刷新过程！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//refresh() 中调用的主要方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.prepareRefresh();</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainFreshBeanFactory();</span><br><span class="line">    <span class="built_in">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">    <span class="built_in">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">    <span class="built_in">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">    <span class="built_in">this</span>.initMessageSource();</span><br><span class="line">    <span class="built_in">this</span>.initApplicationEventMulticaster();</span><br><span class="line">    <span class="built_in">this</span>.onRefresh();</span><br><span class="line">    <span class="built_in">this</span>.registerListeners();</span><br><span class="line">    <span class="built_in">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    <span class="built_in">this</span>.finishRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.destroyBeans();</span><br><span class="line">    <span class="built_in">this</span>.cancelRefresh(var9);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.resetCommonCaches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-prepareRefresh-：刷新前的预处理"><a href="#1-prepareRefresh-：刷新前的预处理" class="headerlink" title="1. prepareRefresh()：刷新前的预处理"></a>1. prepareRefresh()：刷新前的预处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//设置容器启动时间</span></span><br><span class="line">    <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//将容器状态切换为激活状态</span></span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">true</span>);	</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化一些属性设置（该方法为空，需要子类重写该方法来个性化属性设置方法）</span></span><br><span class="line">    <span class="built_in">this</span>.initPropertySources();</span><br><span class="line">    <span class="comment">//校验属性的合法性等</span></span><br><span class="line">    <span class="built_in">this</span>.getEnvironment().validateRequiredProperties();</span><br><span class="line">	<span class="comment">//创建集合保存容器中的一些早期事件</span></span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-obtainFreshBeanFactory-：获取BeanFactory"><a href="#2-obtainFreshBeanFactory-：获取BeanFactory" class="headerlink" title="2. obtainFreshBeanFactory()：获取BeanFactory"></a>2. obtainFreshBeanFactory()：获取BeanFactory</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	刷新BeanFactory：</span></span><br><span class="line"><span class="comment">    		1.创建对象：this.beanFactory = new DefaultListableBeanFactory();</span></span><br><span class="line"><span class="comment">    		2.设置id：this.beanFactory.setSerializationId(this.getId());</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.refreshBeanFactory();</span><br><span class="line">    <span class="comment">//返回刚才 GenericApplicationContext 创建的 BeanFactory 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-prepareBeanFactory-beanFactory-：BeanFactory的预准备"><a href="#3-prepareBeanFactory-beanFactory-：BeanFactory的预准备" class="headerlink" title="3. prepareBeanFactory(beanFactory)：BeanFactory的预准备"></a>3. prepareBeanFactory(beanFactory)：BeanFactory的预准备</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">//设置BeanFactory的类加载器、支持表达式解析器……</span></span><br><span class="line">    beanFactory.setBeanClassLoader(<span class="built_in">this</span>.getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, <span class="built_in">this</span>.getEnvironment()));</span><br><span class="line">    <span class="comment">//添加BeanPostProcessor（ApplicationContextAwareProcessor）</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">    <span class="comment">//设置忽略的自动装配接口</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">    <span class="comment">//设置可以解析的自动装配</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//添加BeanPostProcessor（ApplicationListenerDetector）</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line">    <span class="comment">//添加编译时的AspectJ支持</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//给BeanFactory中注册一些能用的组件</span></span><br><span class="line">    <span class="comment">//environment【ConfigurableEnvironment】</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;environment&quot;</span>, <span class="built_in">this</span>.getEnvironment());</span><br><span class="line">	<span class="comment">//systemProperties【Map&lt;String, Object&gt;】</span></span><br><span class="line">    beanFactory.registerSingleton</span><br><span class="line">        (<span class="string">&quot;systemProperties&quot;</span>, <span class="built_in">this</span>.getEnvironment().getSystemProperties());</span><br><span class="line">    <span class="comment">//systemEnvironment【Map&lt;String, Object&gt;】</span></span><br><span class="line">    beanFactory.registerSingleton</span><br><span class="line">        (<span class="string">&quot;systemEnvironment&quot;</span>, <span class="built_in">this</span>.getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-postProcessBeanFactory-beanFactory-：BeanFactory准备完成后进行的后置处理工作"><a href="#4-postProcessBeanFactory-beanFactory-：BeanFactory准备完成后进行的后置处理工作" class="headerlink" title="4. postProcessBeanFactory(beanFactory)：BeanFactory准备完成后进行的后置处理工作"></a>4. postProcessBeanFactory(beanFactory)：BeanFactory准备完成后进行的后置处理工作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类通过重写这个方法在 BeanFactory 创建并预准备完成以后做进一步的设置</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-invokeBeanFactoryPostProcessors-beanFactory-：执行BeanFactoryPostProcessor"><a href="#5-invokeBeanFactoryPostProcessors-beanFactory-：执行BeanFactoryPostProcessor" class="headerlink" title="5. invokeBeanFactoryPostProcessors(beanFactory)：执行BeanFactoryPostProcessor"></a>5. invokeBeanFactoryPostProcessors(beanFactory)：执行BeanFactoryPostProcessor</h4><p><strong>BeanFactoryPostProcessor</strong>：在 BeanFactory 标准初始化之后执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    核心：invokeBeanFactoryPostProcessors：</span></span><br><span class="line"><span class="comment">    	先执行BeanDefinitionRegistryPostProcessor的方法：</span></span><br><span class="line"><span class="comment">    	1.获取所有的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">    	  postProcessorNames = beanFactory.getBeanNamesForType</span></span><br><span class="line"><span class="comment">    	  	(BeanDefinitionRegistryPostProcessor.class, true, false);</span></span><br><span class="line"><span class="comment">    	2.先看实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">    	  postProcessor.postProcessBeanDefinitionRegistry(registry);</span></span><br><span class="line"><span class="comment">    	3.再执行实现了Ordered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">    	  postProcessor.postProcessBeanDefinitionRegistry(registry);</span></span><br><span class="line"><span class="comment">    	4.最后执行没有实现任何顺序接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    	再执行BeanFactoryPostProcessor的方法</span></span><br><span class="line"><span class="comment">        1.获取所有的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">    	  postProcessorNames = beanFactory.getBeanNamesForType</span></span><br><span class="line"><span class="comment">    	  	(BeanFactoryPostProcessor.class, true, false);</span></span><br><span class="line"><span class="comment">    	2.先看实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">    	  postProcessor.postProcessBeanFactory(registry);</span></span><br><span class="line"><span class="comment">    	3.再执行实现了Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">    	  postProcessor.postProcessBeanFactory(registry);</span></span><br><span class="line"><span class="comment">    	4.最后执行没有实现任何顺序接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors</span><br><span class="line">        (beanFactory, <span class="built_in">this</span>.getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    beanFactory.addBeanPostProcessor</span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader</span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-registerBeanPostProcessors-beanFactory-：注册-Bean-的后置处理器"><a href="#6-registerBeanPostProcessors-beanFactory-：注册-Bean-的后置处理器" class="headerlink" title="6. registerBeanPostProcessors(beanFactory)：注册 Bean 的后置处理器"></a>6. registerBeanPostProcessors(beanFactory)：注册 Bean 的后置处理器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	1.获取所有的 BeanPostProcessor（后置处理器都默认可以有PriorityOrdered、Ordered）</span></span><br><span class="line"><span class="comment">    	2.先注册PriorityOrdered接口的BeanPostProcessor</span></span><br><span class="line"><span class="comment">    	3.再注册实现了Order接口的BeanPostProcessor</span></span><br><span class="line"><span class="comment">    	4.然后注册没有实现任何优先级接口的BeanPostProcessor</span></span><br><span class="line"><span class="comment">    	5.再注册MergedBeanDefinitionPostProcessor</span></span><br><span class="line"><span class="comment">    	6.最终注册一个ApplicationListenerDetector，在Bean创建完成后检查是否是ApplicationListener </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-initMessageSource-：初始化MessageSource组件（国际化、消息绑定、消息解析）"><a href="#7-initMessageSource-：初始化MessageSource组件（国际化、消息绑定、消息解析）" class="headerlink" title="7. initMessageSource()：初始化MessageSource组件（国际化、消息绑定、消息解析）"></a>7. initMessageSource()：初始化MessageSource组件（国际化、消息绑定、消息解析）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取BeanFactory</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.getBeanFactory();</span><br><span class="line">	<span class="comment">//2.看容器中是否有messageSource类型的组件</span></span><br><span class="line">   	<span class="comment">//	MessageSource：取出国际化配置文件中的某个key值、能按照区域信息获取</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(<span class="string">&quot;messageSource&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//有就直接拿过来用，赋值给messageSource属性</span></span><br><span class="line">        <span class="built_in">this</span>.messageSource = </span><br><span class="line">            (MessageSource)beanFactory.getBean(<span class="string">&quot;messageSource&quot;</span>, MessageSource.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没有就创建一个messageSource类型的组件</span></span><br><span class="line">        <span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line">        dms.setParentMessageSource(<span class="built_in">this</span>.getInternalParentMessageSource());</span><br><span class="line">        <span class="built_in">this</span>.messageSource = dms;</span><br><span class="line">    <span class="comment">//3.把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值时，可以自动注入MessageSource    </span></span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;messageSource&quot;</span>, <span class="built_in">this</span>.messageSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-initApplicationEventMulticaster-：初始化事件派发器"><a href="#8-initApplicationEventMulticaster-：初始化事件派发器" class="headerlink" title="8. initApplicationEventMulticaster()：初始化事件派发器"></a>8. initApplicationEventMulticaster()：初始化事件派发器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取BeanFactory</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.getBeanFactory();</span><br><span class="line">    <span class="comment">//2.从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(<span class="string">&quot;applicationEventMulticaster&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventMulticaster = (ApplicationEventMulticaster)beanFactory.getBean(<span class="string">&quot;applicationEventMulticaster&quot;</span>, ApplicationEventMulticaster.class);</span><br><span class="line">    <span class="comment">//3.如果BeanFactory中没有，创建一个SimpleApplicationEventMulticaster    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventMulticaster = </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">    <span class="comment">//4.将ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入  </span></span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;applicationEventMulticaster&quot;</span>, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-onRefresh-：留给子容器"><a href="#9-onRefresh-：留给子容器" class="headerlink" title="9. onRefresh()：留给子容器"></a>9. onRefresh()：留给子容器</h4><p>子类重写该方法，在容器刷新时可以自定义逻辑</p>
<h4 id="10-registerListeners-：将项目中的ApplicationListener注册进容器中"><a href="#10-registerListeners-：将项目中的ApplicationListener注册进容器中" class="headerlink" title="10. registerListeners()：将项目中的ApplicationListener注册进容器中"></a>10. registerListeners()：将项目中的ApplicationListener注册进容器中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//1.从容器中拿到所有的ApplicationListener</span></span><br><span class="line">    String[] listenerBeanNames = </span><br><span class="line">        <span class="built_in">this</span>.getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//2.将每个监听器添加到事件派发器中</span></span><br><span class="line">    <span class="built_in">this</span>.getApplicationEventMulticaster().</span><br><span class="line">        addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-finishBeanFactoryInitialization-beanFactory-：初始化所有剩下的单实例Bean"><a href="#11-finishBeanFactoryInitialization-beanFactory-：初始化所有剩下的单实例Bean" class="headerlink" title="11. finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例Bean"></a>11. finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例Bean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化剩下的单实例bean</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	**beanFactory.preInstantiateSingletons()**：</p>
<ol>
<li><p>获取容器中所有Bean，依次进行初始化和创建对象</p>
</li>
<li><p>获取Bean的定义信息 <code>RootBeanDefinition</code></p>
</li>
<li><p><code>if(Bean不是抽象的、是单实例的、不是懒加载的)</code>：</p>
<ol>
<li><p>判断是否是 FactoryBean &#x2F; 是否是实现 FactoryBean 的 Bean</p>
</li>
<li><p>不是工厂Bean，利用<code>getBean()</code> 创建对象 <strong>（以后再深挖）</strong></p>
<ul>
<li><p><code>getBean()</code>-&gt;<code>doGetBean()</code>-&gt;<code>getSingleton()</code>（缓存中获取单实例Bean）</p>
<p>  ​												-&gt; <code>getSingleton()</code>-&gt;<code>creatBean()</code>-&gt;<code>doCreatBean()</code></p>
<p>  ​												（获取不到就创建Bean）</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="12-finishRefresh-：完成BeanFactory的初始化创建工作"><a href="#12-finishRefresh-：完成BeanFactory的初始化创建工作" class="headerlink" title="12. finishRefresh()：完成BeanFactory的初始化创建工作"></a>12. finishRefresh()：完成BeanFactory的初始化创建工作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.清楚资源缓存</span></span><br><span class="line">    <span class="built_in">this</span>.clearResourceCaches();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    2.初始化和生命周期有关的处理器</span></span><br><span class="line"><span class="comment">    	默认从容器中找 lifecycleProcessor 的组件</span></span><br><span class="line"><span class="comment">    	如果没有就创建一个默认的生命周期组件，加入到容器中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.initLifecycleProcessor();</span><br><span class="line">    <span class="comment">//3.拿到前面的生命周期处理器（BeanFactory），回调onRefresh()方法</span></span><br><span class="line">    <span class="built_in">this</span>.getLifecycleProcessor().onRefresh();</span><br><span class="line">    <span class="comment">//4.发布容器刷新完成事件</span></span><br><span class="line">    <span class="built_in">this</span>.publishEvent((ApplicationEvent)(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>)));</span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-总结"><a href="#13-总结" class="headerlink" title="13. 总结"></a>13. 总结</h4><ol>
<li><p>Spring容器在启动时，先会保存所有注册进来的Bean的定义信息</p>
<ol>
<li>XML注册bean：<code>&lt;bean&gt;&lt;/bean&gt;</code></li>
<li>注解注册bean：<code>@Service</code>,<code>@Controller</code>,<code>@Resporties</code>,<code>@Component</code>,<code>@Bean</code></li>
</ol>
</li>
<li><p>Spring会在<strong>合适的时机</strong>创建这些 bean</p>
<ol>
<li>用到这个 bean 的时候，利用<code>getBean()</code>创建bean，创建好后保存在容器中</li>
<li>统一创建剩下所有 bean <strong>finishBeanFactoryInitialization（）</strong></li>
</ol>
</li>
<li><p><strong>后置处理器</strong>：</p>
<p> 每一个 bean 创建完成后都会使用后置处理器进行处理，来<strong>增强 bean 的功能</strong></p>
</li>
<li><p>事件驱动模型</p>
<p> ApplicationListener：事件监听</p>
<p> ApplicationEventMulticaster：事件派发</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>尚硅谷</tag>
        <tag>源码阅读</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring注解驱动开发】后篇</title>
    <url>/2023/03/01/%E3%80%90Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%91%E5%90%8E%E7%AF%87/</url>
    <content><![CDATA[<h1 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h1><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><p>导入相关依赖</p>
<ul>
<li>数据源</li>
<li>数据库驱动</li>
<li>spring-jdbc模块</li>
</ul>
</li>
<li><p>配置数据源、JdbcTemplate（Spring提供的简化数据库操作的工具）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span>	<span class="comment">//开启基于注解的事务管理功能</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wxs.tx&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//配置数据源</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;abc123aa&quot;</span>);</span><br><span class="line">        dataSource.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">        <span class="comment">//Spring 对 Configuration 类会特殊处理，多次调用给容器中加组件的方法都是从容器中找组件</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource());</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给方法标注上 <code>@Transactional</code> 注解</p>
</li>
<li><p><code>@EnableTransactionManagement</code> 开启基于注解的事务管理功能</p>
</li>
<li><p>配置事务管理器来控制事务</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事务管理器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">()</span> </span><br><span class="line">    <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*添加事务注解</span></span><br><span class="line"><span class="comment">    	如果整个方法正常执行，则方法正常提交</span></span><br><span class="line"><span class="comment">    	如果执行方法期间出现异常，所有的方法都回滚</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO `tbl_user` (username,age) VALUES (?,?)&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        jdbcTemplate.update(sql, username, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">//测试假装方法中出现了错误</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.insert();</span><br><span class="line">        System.out.println(<span class="string">&quot;插入完成!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a>Servlet 3.0</h1><h3 id="基于注解的Servlet（原生的servlet用的比较少）："><a href="#基于注解的Servlet（原生的servlet用的比较少）：" class="headerlink" title="基于注解的Servlet（原生的servlet用的比较少）："></a>基于注解的Servlet（原生的servlet用的比较少）：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拦截 /hello 下的请求，进入doGet()方法执行相应操作</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Shared-libraries-x2F-runtime-pluggability"><a href="#Shared-libraries-x2F-runtime-pluggability" class="headerlink" title="Shared libraries &#x2F; runtime pluggability"></a>Shared libraries &#x2F; runtime pluggability</h3><p>容器在启动应用时，会扫描当前应用每一个jar包里面</p>
<p>META-INF&#x2F;services&#x2F;javax.servlet.ServletContainerInitializer</p>
<p>指定的实现类，启动并运行这个实现类的方法</p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Web容器启动的时候创建对象，调用方法来初始化容器以前的前端控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取根容器的配置类（Spring配置文件） 父容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;RootConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取web容器的配置类（SpringMVC配置文件） 子容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;AppConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取DispatcherServlet的映射信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *      /： 拦截所有请求，包括静态资源，不包括 *.jsp</span></span><br><span class="line"><span class="comment">         *      /*：拦截所有请求包括 *.jsp</span></span><br><span class="line"><span class="comment">         *      jsp页面是 tomcat 的jsp引擎解析的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring 不扫描 Controller 的容器</span></span><br><span class="line"><span class="comment"> * 父容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.wxs&quot;,excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RootConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  SpringMVC 只扫描 Controller</span></span><br><span class="line"><span class="comment"> *  子容器</span></span><br><span class="line"><span class="comment"> *  useDefaultFilters = false：禁用默认的过滤规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.wxs&quot;,includeFilters = &#123;</span></span><br><span class="line"><span class="meta">        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;,useDefaultFilters = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        helloService.sayHello(<span class="string">&quot;wxs&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定制SpringMVC"><a href="#定制SpringMVC" class="headerlink" title="定制SpringMVC"></a>定制SpringMVC</h3><ol>
<li><code>@EnableWebMvc</code>：开启SpringMVC定制配置功能</li>
<li>继承类 <code>WebMvcConfigurer</code></li>
</ol>
<img src="【Spring注解驱动开发】后篇/image-20200420211527677.png" alt="image-20200420211527677"  />]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>尚硅谷</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue快速入门】</title>
    <url>/2023/03/01/%E3%80%90Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>在成为真正的“全栈工程师的”的路上，前端必不可少，在学习完前端三件套（HTML、CSS、JavaScript）、jQuery之后，我们正式步入 前端框架Vue 的学习，Vue是时下流行的前端三大框架（Vue、React、Angular）之一，是前端框架优势的集大成者，这篇笔记作于跟随 bilibili 《【狂神说Java】Vue最新快速上手教程通俗易懂》的学习过程中。</p>
</blockquote>
<h1 id="1-SSM回顾"><a href="#1-SSM回顾" class="headerlink" title="1. SSM回顾"></a>1. SSM回顾</h1><p><img src="/%E3%80%90Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200510173738152.png" alt="image-20200510173738152"></p>
<h1 id="2-Vue简介"><a href="#2-Vue简介" class="headerlink" title="2. Vue简介"></a>2. Vue简介</h1><p><img src="/%E3%80%90Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/vue.png" alt="Angular"></p>
<blockquote>
<p>Vue.js（读音 &#x2F;vjuː&#x2F;, 类似于 view） 是一套构建用户界面的<strong>渐进式框架</strong>（逐步实现新特性）。</p>
<p>Vue <strong>只关注视图层</strong>， 采用<strong>自底向上</strong>增量开发的设计。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
</blockquote>
<h1 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h1><h3 id="1-IDEA安装插件"><a href="#1-IDEA安装插件" class="headerlink" title="1. IDEA安装插件"></a>1. IDEA安装插件</h3><p><img src="/%E3%80%90Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200510183529604.png" alt="image-20200510183529604"></p>
<h3 id="2-导入Vue-js"><a href="#2-导入Vue-js" class="headerlink" title="2. 导入Vue.js"></a>2. 导入Vue.js</h3><p>CDN网址：<a href="https://www.bootcdn.cn/vue/">https://www.bootcdn.cn/vue/</a></p>
<p>源代码：<a href="https://cdn.jsdelivr.net/npm/vue/">cdn.jsdelivr.net&#x2F;npm&#x2F;vue</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 学习过程中使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生产环境中使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.common.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/%E3%80%90Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200510185442139.png" alt="image-20200510185442139"></p>
<h1 id="4-MVVM"><a href="#4-MVVM" class="headerlink" title="4. MVVM"></a>4. MVVM</h1><h1 id="5-Vue基本语法"><a href="#5-Vue基本语法" class="headerlink" title="5. Vue基本语法"></a>5. Vue基本语法</h1><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>No<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">ok</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/%E3%80%90Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200511112428427.png" alt="image-20200511112428427"></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-bind</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!--   index 为数组下标，是自带的值         --&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!--   &lt;li v-for=&quot;(item,index) in items&quot;&gt;--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line">           &#123;&#123;item.message&#125;&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">items</span>: [</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">message</span>: <span class="string">&#x27;wxshhh&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">message</span>: <span class="string">&#x27;前端&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">message</span>: <span class="string">&#x27;vue&#x27;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">            ]</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/%E3%80%90Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200511113035433.png" alt="image-20200511113035433"></p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:v-on</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:</span> <span class="attr">onclick</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&quot;Hello&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">greet</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// `this` 在方法里指向当前 Vue 实例</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;Hello &#x27;</span> + <span class="variable language_">this</span>.<span class="property">message</span> + <span class="string">&#x27;!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// `event` 是原生 DOM 事件</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (event) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">tagName</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>











<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV18E411a7mC">https://www.bilibili.com/video/BV18E411a7mC</a></p>
<p>Vue官网：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></p>
<p>菜鸟教程：<a href="https://www.runoob.com/vue2/vue-tutorial.html">https://www.runoob.com/vue2/vue-tutorial.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>狂神说Java</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【安全框架系列】</title>
    <url>/2023/03/01/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Web开发中，安全是第一位！</p>
<p>在做网站的过程中，安全应该在<strong>设计之初</strong>就进行考虑。</p>
<p>在以往的开发中，我们可以通过配置一些过滤器与拦截器来实现一些简单的安全操作，但是过滤器和拦截器的使用需要编写大量的原生代码，使得项目过于繁琐，产生冗余</p>
<p>接下来我们学习两个常用的安全框架：SpringSecurity、Shiro</p>
<blockquote>
<p>笔记作于跟随 <strong>狂神说Java</strong> b站视频学习过程中</p>
</blockquote>
<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>官网：<a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a></p>
<p>  官方文档：<a href="https://docs.spring.io/spring-security/site/docs/5.3.3.BUILD-SNAPSHOT/reference/html5/">https://docs.spring.io/spring-security/site/docs/5.3.3.BUILD-SNAPSHOT/reference/html5/</a></p>
</li>
<li><p>Spring Security是一个功能强大且高度可定制的<strong>身份验证和访问控制</strong>框架。 它是用于保护基于Spring的应用程序的实际标准。 Spring Security是一个框架，致力于为Java应用程序提供身份验证和授权。 与所有Spring项目一样，Spring Security的真正强大之处在于可以轻松扩展以满足自定义要求（翻译~）</p>
<blockquote>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
</blockquote>
</li>
<li><p>几个重要的类：</p>
<ul>
<li><code>WebSecurityConfigurerAdapter</code>：自定义Security策略</li>
<li><code>AutnenticationManagerBuilder</code>：自定义认证模式</li>
<li><code>@EnableWebSecurity</code>：开启WebSecurity模式</li>
</ul>
</li>
<li><p>SpringSecurity的主要任务：</p>
<ul>
<li>认证（Authentication）</li>
<li>授权（Authorization）</li>
</ul>
</li>
<li><p>本质：</p>
<p>  <strong>采用 AOP</strong> 将安全组件横切进去，不影响业务逻辑！</p>
</li>
</ul>
<h3 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h3><h5 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h5><p><img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518102459647.png" alt="image-20200518102459647"></p>
<h5 id="2-导入依赖"><a href="#2-导入依赖" class="headerlink" title="2. 导入依赖"></a><img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518102542133.png" alt="image-20200518102542133">2. 导入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518101124356.png" alt="image-20200518101124356"></p>
<h5 id="3-编写配置类"><a href="#3-编写配置类" class="headerlink" title="3. 编写配置类"></a>3. 编写配置类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 授权</span></span><br><span class="line"><span class="comment">	* 使用链式编程</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//首页所有人可以访问，功能页只有对应有权限的人可以访问</span></span><br><span class="line">        <span class="comment">//请求授权的规则</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有权限自动跳转到登陆页面</span></span><br><span class="line">        http.formLogin();</span><br><span class="line">               <span class="comment">// .loginPage(&quot;/toLogin&quot;);        设置登陆页面，默认为 &quot;/login&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注销：开启注销功能</span></span><br><span class="line">        http.logout();</span><br><span class="line">               <span class="comment">// .deleteCookies(&quot;remove&quot;)       清空Cookie</span></span><br><span class="line">               <span class="comment">// .invalidateHttpSession(true)	 清空Session</span></span><br><span class="line">               <span class="comment">// .logoutSuccessUrl(&quot;&quot;);	     设置注销后跳转的页面，默认是登陆页面	</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开启 记住我 功能</span></span><br><span class="line">        <span class="comment">//本质：cookie，默认保存两周</span></span><br><span class="line">        http.rememberMe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  认证</span></span><br><span class="line"><span class="comment">     *  密码编码问题：java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id &quot;null&quot;</span></span><br><span class="line"><span class="comment">     *  在 Spring 5.0+ 中加入了很多加密方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常应该去数据库中读</span></span><br><span class="line">        <span class="comment">//auth.jdbcAuthentication(). ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从内存中读取</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                <span class="comment">//必须要添加加密方式</span></span><br><span class="line">                .passwordEncoder(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>())</span><br><span class="line">                .withUser(<span class="string">&quot;wxshhh&quot;</span>)</span><br><span class="line">                .password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;vip1&quot;</span>, <span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                <span class="comment">//通过 and 方法 可添加多个用户</span></span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                .password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;vip1&quot;</span>, <span class="string">&quot;vip2&quot;</span>, <span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;guest&quot;</span>)</span><br><span class="line">                .password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;vip1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4. 运行测试"></a>4. 运行测试</h5><ol>
<li>初次访问各 level页面 时会跳转到登陆页面，需要进行登陆操作</li>
</ol>
<p><img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518113922103.png" alt="image-20200518113922103"></p>
<ol start="2">
<li><p>登陆用户 <strong>“wxshhh”</strong></p>
<ul>
<li>level1的所有页面可以正常访问</li>
</ul>
<p> <img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518104944098.png" alt="image-20200518104944098"></p>
<ul>
<li>level2的所有页面也可以正常访问</li>
</ul>
<p> <img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518105043839.png" alt="image-20200518105043839"></p>
<ul>
<li>level3的页面报错：403</li>
</ul>
<p> <img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518105109990.png" alt="image-20200518105109990"></p>
<p> ​	结果与配置结果一致，配置成功！</p>
</li>
<li><p>注销用户</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置注销页面的请求路径：/logout --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;sign-out icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 注销</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518110231858.png" alt="image-20200518110231858"></p>
<p> 跳转到注销页面：</p>
<p> <img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518110248734.png" alt="image-20200518110248734"></p>
<p> 确认注销之后跳转到登陆页面：</p>
<p> <img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200518110320875.png" alt="image-20200518110320875"></p>
</li>
</ol>
<h3 id="Thymeleaf-与-SpringSecurity-整合"><a href="#Thymeleaf-与-SpringSecurity-整合" class="headerlink" title="Thymeleaf 与 SpringSecurity 整合"></a>Thymeleaf 与 SpringSecurity 整合</h3><ol>
<li><p>导入依赖</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 index.html</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--登录注销--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right menu&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--未登录,只显示登陆按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;!isAuthenticated()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toLogin&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;address card icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 登录</span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--已登录，显示用户名和注销按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;isAuthenticated()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">            用户名：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;sign-out icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 注销</span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据用户角色的不同显示不同的菜单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui three column stackable grid&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;vip1&#x27;)&quot;</span>&gt;</span></span><br><span class="line">		……</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;vip2&#x27;)&quot;</span>&gt;</span></span><br><span class="line">		……</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;vip3&#x27;)&quot;</span>&gt;</span></span><br><span class="line">		……</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> &#x3D;&#x3D;注意！要使用较低版本的SpringBoot&#x3D;&#x3D;</p>
</li>
</ol>
<h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>官网：<a href="http://shiro.apache.org/">http://shiro.apache.org/</a></p>
<p>Apache Shiro™是一个功能强大且易于使用的Java安全框架，它执行身份验证，授权，加密和会话管理。 使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序-从最小的移动应用程序到最大的Web和企业应用程序。</p>
<blockquote>
<p><strong>Apache Shiro™</strong> is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.</p>
</blockquote>
<p>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。</p>
<p>其基本功能如下图所示：</p>
<p><img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200520094749416.png" alt="image-20200520094749416"></p>
<ul>
<li><p><strong>Authentication</strong>：身份认证 &#x2F; 登录，验证用户是不是拥有相应的身份；</p>
</li>
<li><p><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p>
</li>
<li><p><strong>Session Manager</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</p>
</li>
<li><p><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p>
</li>
<li><p><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</p>
</li>
<li><p><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色 &#x2F; 权限不必每次去查，这样可以提高效率；</p>
</li>
<li><p><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p>
</li>
<li><p><strong>Testing</strong>：提供测试支持；</p>
</li>
<li><p><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p>
</li>
<li><p><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</p>
</li>
</ul>
<p>Shiro外部：</p>
<p><img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200520095526775.png" alt="image-20200520095526775"></p>
<ul>
<li><p><strong>Subject</strong>：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p>
</li>
<li><p><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</p>
</li>
<li><p><strong>Realm</strong>：域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 &#x2F; 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p>
</li>
</ul>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><ol>
<li><p>导入依赖</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件 <strong>shiro.ini</strong></p>
 <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Users and their assigned roles</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each line conforms to the format defined in the</span></span><br><span class="line"><span class="comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="comment"># user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; role</span></span><br><span class="line"><span class="attr">root</span> = secret, admin</span><br><span class="line"><span class="comment"># user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; role</span></span><br><span class="line"><span class="attr">guest</span> = guest, guest</span><br><span class="line"><span class="comment"># user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27; (&quot;That&#x27;s the same combination on</span></span><br><span class="line"><span class="comment"># my luggage!!!&quot; ;)), and role &#x27;president&#x27;</span></span><br><span class="line"><span class="attr">presidentskroob</span> = <span class="number">12345</span>, president</span><br><span class="line"><span class="comment"># user &#x27;darkhelmet&#x27; with password &#x27;ludicrousspeed&#x27; and roles &#x27;darklord&#x27; and &#x27;schwartz&#x27;</span></span><br><span class="line"><span class="attr">darkhelmet</span> = ludicrousspeed, darklord, schwartz</span><br><span class="line"><span class="comment"># user &#x27;lonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;</span></span><br><span class="line"><span class="attr">lonestarr</span> = vespa, goodguy, schwartz</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Roles with assigned permissions</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each line conforms to the format defined in the</span></span><br><span class="line"><span class="comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="comment"># &#x27;admin&#x27; role has all permissions, indicated by the wildcard &#x27;*&#x27;</span></span><br><span class="line"><span class="attr">admin</span> = *</span><br><span class="line"><span class="comment"># The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:</span></span><br><span class="line"><span class="attr">schwartz</span> = lightsaber:*</span><br><span class="line"><span class="comment"># The &#x27;goodguy&#x27; role is allowed to &#x27;drive&#x27; (action) the winnebago (type) with</span></span><br><span class="line"><span class="comment"># license plate &#x27;eagle5&#x27; (instance specific id)</span></span><br><span class="line"><span class="attr">goodguy</span> = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure>
</li>
<li><p>HelloWord（部分重要代码）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get the currently executing user:</span></span><br><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> currentUser.getSession();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">currentUser.getPrincipal();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentUser.hasRole(<span class="string">&quot;schwartz&quot;</span>)) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentUser.isPermitted(<span class="string">&quot;lightsaber:wield&quot;</span>)) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">currentUser.logout();</span><br></pre></td></tr></table></figure>

<p> SpringSecurity 中都有，只是名字变了！</p>
</li>
</ol>
<h3 id="集成SpringBoot"><a href="#集成SpringBoot" class="headerlink" title="集成SpringBoot"></a>集成SpringBoot</h3><h5 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h5><p><img src="/%E3%80%90%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E3%80%91/image-20200520160459569.png" alt="image-20200520160459569"></p>
<h5 id="2-导入依赖-1"><a href="#2-导入依赖-1" class="headerlink" title="2. 导入依赖"></a>2. 导入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-shiro --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="3-编写配置类-1"><a href="#3-编写配置类-1" class="headerlink" title="3. 编写配置类"></a>3. 编写配置类</h5><p>从下往上编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wxshhh.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. DefaultWebSecurityManager</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(<span class="meta">@Qualifier(&quot;securityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span> &#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置安全管理器</span></span><br><span class="line">        bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. DefaultWebSecurityManager</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;securityManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getDefaultWebSecurityManager</span><span class="params">(<span class="meta">@Qualifier(&quot;userRealm&quot;)</span> UserRealm userRealm)</span> &#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 创建 Realm 对象</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;userRealm&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserRealm <span class="title function_">userRealm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserRealm</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wxshhh.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的 realm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======执行了授权=======&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======执行了认证=======&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-实现登陆拦截"><a href="#4-实现登陆拦截" class="headerlink" title="4. 实现登陆拦截"></a>4. 实现登陆拦截</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(<span class="meta">@Qualifier(&quot;securityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span> &#123;</span><br><span class="line">    <span class="type">ShiroFilterFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">    <span class="comment">//设置安全管理器</span></span><br><span class="line">    bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        添加内置过滤器：</span></span><br><span class="line"><span class="comment">            anon：无需认证就可以访问</span></span><br><span class="line"><span class="comment">            authc：必须认证了才能访问</span></span><br><span class="line"><span class="comment">            user： 必须拥有 记住我 功能才能用</span></span><br><span class="line"><span class="comment">            perms：拥有对某个资源的权限才能访问</span></span><br><span class="line"><span class="comment">            role：有用某个角色权限才能访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    filterChainDefinitionMap.put(<span class="string">&quot;/user/*&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置登录请求</span></span><br><span class="line">    bean.setLoginUrl(<span class="string">&quot;/toLogin&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    bean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-实现用户认证"><a href="#5-实现用户认证" class="headerlink" title="5. 实现用户认证"></a>5. 实现用户认证</h5><p>IndexController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username,String password,Model model)</span> &#123;</span><br><span class="line">    <span class="comment">//获得当前用户</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">    <span class="comment">//封装用户的登录数据</span></span><br><span class="line">    <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行登录方法</span></span><br><span class="line">        subject.login(token);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;   <span class="comment">//用户名不存在</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;用户名错误！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/login&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;     <span class="comment">//密码不存在</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;密码错误！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserRealm</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//认证</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;=======执行了认证=======&quot;</span>);</span><br><span class="line">    <span class="comment">//伪造数据库</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="type">UsernamePasswordToken</span> <span class="variable">userToken</span> <span class="operator">=</span> (UsernamePasswordToken) authenticationToken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!userToken.getUsername().equals(user.getUsername())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    <span class="comment">//抛出异常 UnKnownAccountException</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//密码认证，shiro来做！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user,user.getPassword(),<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-实现权限控制"><a href="#6-实现权限控制" class="headerlink" title="6. 实现权限控制"></a>6. 实现权限控制</h5><p>ShiroConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">getShiroFilterFactoryBean</span><span class="params">(<span class="meta">@Qualifier(&quot;securityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span> &#123;</span><br><span class="line">    <span class="type">ShiroFilterFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">    <span class="comment">//设置安全管理器</span></span><br><span class="line">    bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        添加内置过滤器：</span></span><br><span class="line"><span class="comment">            anon：无需认证就可以访问</span></span><br><span class="line"><span class="comment">            authc：必须认证了才能访问</span></span><br><span class="line"><span class="comment">            user： 必须拥有 记住我 功能才能用</span></span><br><span class="line"><span class="comment">            perms：拥有对某个资源的权限才能访问</span></span><br><span class="line"><span class="comment">            role：有用某个角色权限才能访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//设置权限</span></span><br><span class="line">    filterChainDefinitionMap.put(<span class="string">&quot;/user/add&quot;</span>, <span class="string">&quot;perms[user:add]&quot;</span>);</span><br><span class="line">    filterChainDefinitionMap.put(<span class="string">&quot;/user/*&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置登录请求</span></span><br><span class="line">    bean.setLoginUrl(<span class="string">&quot;/toLogin&quot;</span>);</span><br><span class="line">    <span class="comment">//设置未授权后跳转页面</span></span><br><span class="line">    bean.setUnauthorizedUrl(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserRealm</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//授权</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;=======执行了授权=======&quot;</span>);</span><br><span class="line">    <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">    info.addStringPermission(<span class="string">&quot;user:add&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拿到当前登录的这个对象</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">    <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> (User) subject.getPrincipal();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//User中有属性 perms ，该结果可从数据库中查出</span></span><br><span class="line">    info.addStringPermission(currentUser.getPerms());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>完结！！！ </p>
<p>狂神，永远滴神！！！</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV1NE411i7S8">https://www.bilibili.com/video/BV1NE411i7S8</a></p>
<p>w3cschool：<a href="https://www.w3cschool.cn/shiro/">https://www.w3cschool.cn/shiro/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>狂神说Java</tag>
        <tag>SpringSecurity</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发</title>
    <url>/2023/03/01/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考视频：<a href="https://www.bilibili.com/video/BV1np4y1C7Yf">https://www.bilibili.com/video/BV1np4y1C7Yf</a></p>
<p>相关资料源码：<a href="https://shimo.im/docs/8xgTjWvDh6P6tkdx/">https://shimo.im/docs/8xgTjWvDh6P6tkdx/</a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h3 id="一、安装-Linux-虚拟机"><a href="#一、安装-Linux-虚拟机" class="headerlink" title="一、安装 Linux 虚拟机"></a>一、安装 Linux 虚拟机</h3><p>这里我使用了自己购买的阿里云服务器上安装的CentOS 7，所以跳过这一步</p>
<p>没有云服务器的使用 VMWare 或者 VirtualBox 都可</p>
<p>相关知识点可以参考下面的连接，就不再赘述</p>
<ul>
<li><p>狂神说Java：<a href="https://www.bilibili.com/video/BV187411y7hF?p=3">https://www.bilibili.com/video/BV187411y7hF?p=3</a></p>
</li>
<li><p>尚硅谷：<a href="https://www.bilibili.com/video/BV1dW411M7xL?from=search&seid=4221493829881452502">https://www.bilibili.com/video/BV1dW411M7xL?from=search&amp;seid=4221493829881452502</a></p>
</li>
</ul>
<h3 id="二、安装-docker"><a href="#二、安装-docker" class="headerlink" title="二、安装 docker"></a>二、安装 docker</h3><p>参考<strong>docker官网</strong>：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.卸载旧版本</span></span><br><span class="line">yum remove docker \</span><br><span class="line">           docker-client \</span><br><span class="line">           docker-client-latest \</span><br><span class="line">           docker-common \</span><br><span class="line">           docker-latest \</span><br><span class="line">           docker-latest-logrotate \</span><br><span class="line">           docker-logrotate \</span><br><span class="line">           docker-engine</span><br><span class="line">                  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.设置镜像仓库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">国外的仓库，下载缓慢，不推荐</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo  </span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">阿里云的仓库，推荐！</span> </span><br><span class="line">yum-config-manager \</span><br><span class="line">	--add-repo \</span><br><span class="line">	http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.5.更新yum软件包索引</span>  </span><br><span class="line">yum makecache fast</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.安装 docker 相关的内容  docker-ce：社区版   docker-ee：企业版</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.查看docker是否安装成功</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7.设置开机自启</span></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>



<h3 id="三、安装mysql、redis"><a href="#三、安装mysql、redis" class="headerlink" title="三、安装mysql、redis"></a>三、安装mysql、redis</h3><h4 id="1-安装配置-mysql"><a href="#1-安装配置-mysql" class="headerlink" title="1. 安装配置 mysql"></a>1. 安装配置 mysql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.下载镜像文件</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.创建实例并启动</span></span><br><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">	-p 3306:3306 --name mysql：将容器的3306端口映射到主机的3306端口</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	-v /mydata/mysql/conf:/etc/mysql：将配置文件挂载到主机</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	-v /mydata/mysql/log:/var/log/mysql：将日志文件挂载到主机</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	-v /mydata/mysql/data:/var/lib/mysql：将数据文件挂载到主机</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	-e MYSQL_ROOT_PASSWORD=root：初始化root用户密码</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以进入 mysql 容器内查看</span></span><br><span class="line">docker exec -it mysql /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.mysql配置（主要是修改字符编码）</span></span><br><span class="line">vim /mydata/mysql/conf/mysql.conf</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">添加以下配置</span></span><br><span class="line">    【client】</span><br><span class="line">    default-character-set=utf8</span><br><span class="line">    【mysql】</span><br><span class="line">    default-character-set=utf8</span><br><span class="line">    【mysqld】</span><br><span class="line">    init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br><span class="line">    init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">    character-set-server=utf8</span><br><span class="line">    collection-server=utf8_unicode_ci</span><br><span class="line">    skip-character-set-client-handshake</span><br><span class="line">    skip-name-resolve</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.设置自启</span></span><br><span class="line">docker update mysql --restart=always</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.重启mysql</span></span><br><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>

<h4 id="2-安装配置redis"><a href="#2-安装配置redis" class="headerlink" title="2. 安装配置redis"></a>2. 安装配置redis</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.安装 redis</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.配置 redis</span></span><br><span class="line">mkdir -p /mydata/redis/conf</span><br><span class="line">touch /mydata/redis/conf/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6379:6379 --name redis  --privileged=true \</span><br><span class="line">-v /mydata/redis/data:/data \</span><br><span class="line">-v/mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连向 redis-cli</span></span><br><span class="line">docker exec -it redis redis-cli</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.redis 启用 aof 的持久化方式</span></span><br><span class="line"></span><br><span class="line">vim /mydata/redis/conf/redis.conf </span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">添加以下配置</span></span><br><span class="line">	appendonly yes</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.设置自启</span></span><br><span class="line">docker update redis --restart=always</span><br></pre></td></tr></table></figure>



<h3 id="四、开发环境统一"><a href="#四、开发环境统一" class="headerlink" title="四、开发环境统一"></a>四、开发环境统一</h3><h4 id="前端：VSCode"><a href="#前端：VSCode" class="headerlink" title="前端：VSCode"></a>前端：VSCode</h4><p>需要插件：</p>
<ul>
<li>Auto Close Tag</li>
<li>Auto Rename Tag</li>
<li>Chinese (Simplified) Language Pack for Visual Studio</li>
<li>ESLint</li>
<li>HTML CSS Support</li>
<li>HTML Snippets</li>
<li>JavaScript (ES6) code snippets</li>
<li>open in browser</li>
<li>Vetur</li>
</ul>
<h4 id="后端：IDEA"><a href="#后端：IDEA" class="headerlink" title="后端：IDEA"></a>后端：IDEA</h4><p>需要插件：</p>
<ul>
<li><p>LomBok</p>
</li>
<li><p>MyBatisX</p>
</li>
<li><p>gitee</p>
</li>
</ul>
<h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><ol>
<li><p>下载git</p>
</li>
<li><p>配置信息</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置作者信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;wxshhh&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user,email <span class="string">&quot;993012459@qq.com&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置 ssh 免密登录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">&quot;993012459@qq.com&quot;</span>		<span class="comment">#三次回车</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub							<span class="comment">#获得密钥</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开码云——》设置——》安全设置——》SSH公钥</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">填入获取到的密钥</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进行测试：填 <span class="built_in">yes</span> 确认</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@gitee.com</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/image-20200526140401407.png" alt="image-20200526140401407"></p>
<ol start="3">
<li>码云中创建仓库</li>
</ol>
<p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/image-20200526140532746.png" alt="image-20200526140532746"></p>
<ol start="4">
<li>IDEA中创建项目：</li>
</ol>
<p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/image-20200526141034206.png" alt="image-20200526141034206"></p>
<p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/image-20200526141208082.png" alt="image-20200526141208082"></p>
<h3 id="五、创建项目微服务"><a href="#五、创建项目微服务" class="headerlink" title="五、创建项目微服务"></a>五、创建项目微服务</h3><ul>
<li>商品服务</li>
<li>仓库服务</li>
<li>订单服务</li>
<li>优惠券服务</li>
<li>用户服务</li>
</ul>
<p>共同点：</p>
<ol>
<li>导入 web、openfeign</li>
<li>每一个服务，com.wxshh.gulimall.xxx</li>
<li>模块名：gulimall-xxx</li>
<li></li>
</ol>
<img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200526141435743.png" alt="image-20200526141435743" style="zoom:67%;" />

<img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200526141435743.png" alt="image-20200526141435743" style="zoom:67%;" />

<img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200526141448810.png" alt="image-20200526141448810" style="zoom:67%;" />



<ol start="5">
<li><p>项目结构</p>
<p> <img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/image-20200527114221039.png" alt="image-20200527114221039"></p>
</li>
</ol>
<h3 id="六、数据库初始化"><a href="#六、数据库初始化" class="headerlink" title="六、数据库初始化"></a>六、数据库初始化</h3><p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/image-20200527120620510.png" alt="image-20200527120620510"></p>
<p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/image-20200527120640829.png" alt="image-20200527120640829"></p>
<h1 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h1><h3 id="一、搭建后台管理系统"><a href="#一、搭建后台管理系统" class="headerlink" title="一、搭建后台管理系统"></a>一、搭建后台管理系统</h3><p>由于自己手写整个项目的前后端费时费力，所以我们使用写好的现成的开源项目来搭建后台管理系统</p>
<p>这里我们选择使用<strong>码云</strong>上的<strong>人人开源</strong>项目</p>
<img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200527121259658.png" alt="image-20200527121259658" style="zoom:67%;" />

<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><ol>
<li>将项目 <strong>renren-fast</strong> 和 <strong>renren-fast-vue</strong> 克隆到本地，删除项目中的 <strong>.git</strong> 文件夹，然后将 <strong>renren-fast</strong> 整个文件夹复制到 <strong>guilimall</strong>项目中</li>
</ol>
<img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200529134847559.png" alt="image-20200529134847559" style="zoom:67%;" />

<ol start="2">
<li>将 <strong>renren-fast</strong> 添加到项目 <strong>pom</strong> 的 <modules> 标签中</li>
</ol>
<img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200529140210916.png" alt="image-20200529140210916" style="zoom:67%;" />

<ol start="3">
<li><p>新建数据库，导入 sql</p>
<p> <img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/image-20200529140558226.png" alt="image-20200529140558226"></p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200529140343348.png" alt="image-20200529140343348" style="zoom:67%;" />

 

<ol start="4">
<li><p>修改配置文件</p>
<p> 进入类目录下的 <strong>application-dev.yml</strong> ，修改数据源的相关配置</p>
</li>
<li><p>启动项目 <strong>renren-fast</strong></p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200530083735885.png" alt="image-20200530083735885" style="zoom:67%;" /></li>
</ol>
</li>
</ol>
<h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><ol>
<li><p>使用 <strong>VSCode</strong> 打开项目 <strong>renren-fast-vue</strong></p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200530084148217.png" alt="image-20200530084148217" style="zoom: 50%;" />
</li>
<li><p>安装 Node.js，安装好的可以跳过这一步 <a href="https://nodejs.org/en/">https://nodejs.org/en/</a> <strong>（不要下载最新版本！！！）</strong></p>
</li>
<li><p>控制台执行语句 <code>cnpm install</code> 下载相关依赖包</p>
</li>
<li><p>控制台执行 <code>cnpm run dev</code> 运行项目</p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200530084556220.png" alt="image-20200530084556220" style="zoom:67%;" />
</li>
<li><p>后台搭建完成！！</p>
</li>
</ol>
<blockquote>
<p>一些需要注意的坑：</p>
<ol>
<li>如果导入 renren-fast 后 springboot 各种爆红，无法运行，建议将项目中的 pom.xml 替换为 《项目资料源码》（见文章前言部分）中 renren-fast 模块的 pox.xml</li>
<li>Node.js 不要下载最新版本！最好使用视频中的版本 10.16.3</li>
<li>使用 Node.js 时，建议使用语句 <code>cnpm</code> 而不是 npm （国内镜像下载起来快）</li>
</ol>
</blockquote>
<h3 id="二、逆向工程搭建与使用"><a href="#二、逆向工程搭建与使用" class="headerlink" title="二、逆向工程搭建与使用"></a>二、逆向工程搭建与使用</h3><h4 id="逆向工程搭建"><a href="#逆向工程搭建" class="headerlink" title="逆向工程搭建"></a>逆向工程搭建</h4><p>使用人人开源提供的代码生成器来为项目每一个微服务提供代码生成！</p>
<p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/image-20200530085652596.png" alt="image-20200530085652596"></p>
<ol>
<li><p>下载项目并<strong>复制粘贴到总项目中</strong></p>
</li>
<li><p>总项目 pom.xml 中添加 <module></p>
<blockquote>
<p>如果爆红，建议直接将项目中的 pom.xml 换成 《项目资料源码》（见文章前言部分） 中的 pom.xml，还是不行就直接将整个 renren-generator 项目替换</p>
</blockquote>
</li>
<li><p>修改 <strong>renren-generarot</strong> 中的数据源配置</p>
</li>
<li><p>修改文件 <strong>generator.properties</strong> 中的包名、模块名、作者名等</p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200530093158746.png" alt="image-20200530093158746" style="zoom:67%;" />
</li>
<li><p>运行 renren-generator 项目，进入 localhost 的 80 端口</p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200530093305005.png" alt="image-20200530093305005" style="zoom:67%;" />
</li>
<li><p>进入 <strong>renren-fast</strong> </p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200530093513064.png" alt="image-20200530093513064" style="zoom:67%;" />

<p> 点击生成代码以后，会跳出下载页面，下载压缩包，将压缩包中的 <strong>main</strong> 文件夹复制粘贴入相应的微服务即可！</p>
<p> <strong>依次生成其他微服务的代码</strong></p>
</li>
</ol>
<h4 id="逆行工程完善"><a href="#逆行工程完善" class="headerlink" title="逆行工程完善"></a>逆行工程完善</h4><ol>
<li><p>创建 <strong>gulimall-common</strong>（普通的maven项目）</p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200530094006415.png" alt="image-20200530094006415" style="zoom:67%;" />
</li>
<li><p>添加 pom 依赖</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wxshhh.gulimall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>每一个微服务公共的依赖、工具类等都放在这<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        mybatis-plus--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpcore<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--    导入mysql驱动    --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加相关工具类</p>
<p> 一般都是直接将 renren-fast 中的类拷贝过来 （具体请参考《资料文档》）</p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200530101059509.png" alt="image-20200530101059509" style="zoom:67%;" /></li>
</ol>
<h3 id="三、配置与测试微服务基本CRUD"><a href="#三、配置与测试微服务基本CRUD" class="headerlink" title="三、配置与测试微服务基本CRUD"></a>三、配置与测试微服务基本CRUD</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#MySQL配置</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://47.103.199.131/gulimall_pms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GulimallProductApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BrandService brandService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BrandEntity</span> <span class="variable">brandEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandEntity</span>();</span><br><span class="line">        brandEntity.setName(<span class="string">&quot;华为&quot;</span>);</span><br><span class="line">        brandService.save(brandEntity);</span><br><span class="line">        System.out.println(<span class="string">&quot;保存成功！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【尚硅谷《谷粒商城》2020学习笔记】一、环境搭建与快速开发/image-20200530103918344.png" alt="image-20200530103918344" style="zoom: 67%;" />



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>尚硅谷</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>【尚硅谷《谷粒商城》2020学习笔记】三、前端基础</title>
    <url>/2023/03/01/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%89%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="前后端技术栈类比"><a href="#前后端技术栈类比" class="headerlink" title="前后端技术栈类比"></a>前后端技术栈类比</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">前端</th>
<th align="center">后端</th>
</tr>
</thead>
<tbody><tr>
<td align="center">编程语言</td>
<td align="center">JavaScript</td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">版本</td>
<td align="center">ES6、7、8</td>
<td align="center">JDK8、9、10、11</td>
</tr>
<tr>
<td align="center">框架</td>
<td align="center">JQuery、Vue、React</td>
<td align="center">Spring、SpringMVC</td>
</tr>
<tr>
<td align="center">工具</td>
<td align="center">WebStorm、VsCode</td>
<td align="center">IDEA、Eclipse</td>
</tr>
<tr>
<td align="center">项目构建</td>
<td align="center">webpack、gulp</td>
<td align="center">maven、gradle</td>
</tr>
<tr>
<td align="center">依赖管理</td>
<td align="center">npm</td>
<td align="center">maven</td>
</tr>
</tbody></table>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>参考文档：<a href="http://caibaojian.com/es6/">http://caibaojian.com/es6/</a></p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<h3 id="ECMAScript和JavaScript的关系"><a href="#ECMAScript和JavaScript的关系" class="headerlink" title="ECMAScript和JavaScript的关系"></a>ECMAScript和JavaScript的关系</h3><p>一个常见的问题是，ECMAScript和JavaScript到底是什么关系？</p>
<p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了<strong>浏览器脚本语言的标准</strong>，并将这种语言称为ECMAScript，这个版本就是1.0版。</p>
<p>该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。</p>
<h3 id="二、let-amp-const"><a href="#二、let-amp-const" class="headerlink" title="二、let &amp; const"></a>二、let &amp; const</h3><h4 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h4><p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//var 申明的变量往往会越域</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//let 申明的变量有严格的作用域</span></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> a = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> b = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);     <span class="comment">// 1</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);     <span class="comment">// b is not defined</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%89%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/image-20200601104027619.png" alt="image-20200601104027619"></p>
<h4 id="2-重复声明"><a href="#2-重复声明" class="headerlink" title="2. 重复声明"></a>2. 重复声明</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//var 可以多次声明</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//let 只能申明一次</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> m = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> m = <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> n = <span class="number">3</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> n = <span class="number">4</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    confirm.<span class="title function_">log</span>(m);     <span class="comment">// 2</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);     <span class="comment">// Identifier &#x27;n&#x27; has already been declared</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-不存在变量提升"><a href="#3-不存在变量提升" class="headerlink" title="3. 不存在变量提升"></a>3. 不存在变量提升</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出undefined</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 报错ReferenceError</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> a = <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> b = <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-const"><a href="#4-const" class="headerlink" title="4. const"></a>4. const</h4><p><code>const</code> 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.1415</span>;</span><br><span class="line"><span class="variable constant_">PI</span> <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>



<h3 id="三、解构-amp-字符串"><a href="#三、解构-amp-字符串" class="headerlink" title="三、解构 &amp; 字符串"></a>三、解构 &amp; 字符串</h3><h4 id="1-解构"><a href="#1-解构" class="headerlink" title="1. 解构"></a>1. 解构</h4><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p><strong>数组解构：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p><strong>对象解构：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;wxs&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;对象属性:新建变量名&#125;，相当于将 person 对象的 name 属性赋值给变量 who</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:who, age&#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(who);	<span class="comment">//&#x27;wxs&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);	<span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h4 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h4><p><strong>字符串拓展：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>模板字符串：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统的输出模板</span></span><br><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).<span class="title function_">append</span>(</span><br><span class="line">  <span class="string">&#x27;There are &lt;b&gt;&#x27;</span> + basket.<span class="property">count</span> + <span class="string">&#x27;&lt;/b&gt; &#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;items in your basket, &#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;em&gt;&#x27;</span> + basket.<span class="property">onSale</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;/em&gt; are on sale!&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板字符串</span></span><br><span class="line"><span class="comment">//字符串用 ``（反引号）包裹</span></span><br><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).<span class="title function_">append</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串中嵌入变量、表达式（甚至是函数也可以嵌入）</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>, </span><br><span class="line">    time = <span class="string">&quot;today&quot;</span>, </span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>

<h3 id="四、函数优化"><a href="#四、函数优化" class="headerlink" title="四、函数优化"></a>四、函数优化</h3><p><strong>1. 函数参数默认值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b = <span class="number">1</span></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">10</span>));       <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 不定参数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(values.<span class="property">length</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fun</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 箭头函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let print = function(obj) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(obj);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">print</span> = obj =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;hello&quot;</span>);             <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let sum = function(a, b) &#123;</span></span><br><span class="line"><span class="comment">//     return a + b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>);                   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数 + 解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;wxs&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">hello</span> = (<span class="params">&#123;name&#125;</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line"><span class="title function_">hello</span>(person);				<span class="comment">// hello wxs</span></span><br></pre></td></tr></table></figure>

<h3 id="五、对象优化"><a href="#五、对象优化" class="headerlink" title="五、对象优化"></a>五、对象优化</h3><p><strong>1. Object 的方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;wxs&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(person); 	<span class="comment">// [&quot;name&quot;,&quot;age&quot;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(person); 	<span class="comment">// [&quot;wxs&quot;,20]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(person); <span class="comment">// [Array(2),Array(2)]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> source1 = &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123;</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);	<span class="comment">//将 target 后面的对象合并到 target 中</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target); <span class="comment">// &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.  声明对象简写</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;wxs&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//let person = &#123;name: name,age: age&#125;;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;name, age&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>3. 对象函数的属性简写</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;wxs&quot;</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="attr">eat</span>: <span class="keyword">function</span> (<span class="params">food</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;吃东西~&quot;</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//箭头函数中不能使用 this！</span></span><br><span class="line">	<span class="attr">eat2</span>: <span class="function"><span class="params">food</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span> + <span class="string">&quot;吃东西~&quot;</span>),</span><br><span class="line">	</span><br><span class="line">	<span class="title function_">eat3</span>(<span class="params">food</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;吃东西~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 对象的拓展运算</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象拓展运算</span></span><br><span class="line"><span class="comment">//1. 深拷贝</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;wxs&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> wxs = &#123;</span><br><span class="line">	...person</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wxs); <span class="comment">// &#123;name: &quot;wxs&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 对象合并</span></span><br><span class="line"><span class="keyword">let</span> name = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;wxs&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> age = &#123;</span><br><span class="line">	<span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	...name,</span><br><span class="line">	...age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、map-amp-reduce"><a href="#六、map-amp-reduce" class="headerlink" title="六、map &amp; reduce"></a>六、map &amp; reduce</h3><h3 id="七、Promise"><a href="#七、Promise" class="headerlink" title="七、Promise"></a>七、Promise</h3><h3 id="八、模块化"><a href="#八、模块化" class="headerlink" title="八、模块化"></a>八、模块化</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>模块化就是把代码进行拆分，方便复用，类似于 Java 中的导包。</p>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h4><p>export</p>
<p>import</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>参考文档：<a href="http://caibaojian.com/vue/guide/">http://caibaojian.com/vue/guide/</a></p>
<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>Vue.js（读音 &#x2F;vjuː&#x2F;, 类似于 <strong>view</strong>） 是一套构建用户界面的 <strong>渐进式框架</strong>。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用<a href="http://caibaojian.com/vue/guide/single-file-components.html">单文件组件</a>和 <a href="https://github.com/vuejs/awesome-vue#libraries--plugins">Vue 生态系统支持的库</a>开发的复杂单页应用。</p>
<p>Vue.js 的目标是通过尽可能简单的 API 实现<strong>响应的数据绑定</strong>和<strong>组合的视图组件</strong>。</p>
<h3 id="二、快速开始"><a href="#二、快速开始" class="headerlink" title="二、快速开始"></a>二、快速开始</h3><ol>
<li><p>在 VsCode 中打开新的文件夹</p>
</li>
<li><p>控制台执行以下命令</p>
<p> <code>cnpm init -y</code></p>
<p> <code>cnpm install vue</code></p>
<p> 至此，vue项目构建完成</p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】三、前端基础/image-20200602092350445.png" alt="image-20200602092350445" style="zoom: 67%;" />
</li>
<li><p>新建测试文件：index.html</p>
</li>
<li><p>引入 Vue</p>
 <script src="./node_modules/vue/dist/vue.js"></script>
</li>
<li><p>编写测试代码</p>
<p> 完整代码如下：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;name&#125;&#125;,帅的一<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&quot;wxs&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 显示效果：</p>
<p> ![image-20200602092626792](【尚硅谷《谷粒商城》2020学习笔记】三、前端基础&#x2F;image-20200602092626792.png</p>
</li>
</ol>
<h3 id="三、常用指令"><a href="#三、常用指令" class="headerlink" title="三、常用指令"></a>三、常用指令</h3><p>官方文档都有，就不一一赘述</p>
<p>（其实就是懒hhh）</p>
<h3 id="四、组件开发"><a href="#四、组件开发" class="headerlink" title="四、组件开发"></a>四、组件开发</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>尚硅谷</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>【尚硅谷《谷粒商城》2020学习笔记】二、分布式组件</title>
    <url>/2023/03/01/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h1><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>Spring Cloud Alibaba 致力于提供分布式应用<strong>服务开发的一站式解决方案</strong>。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p>
<p>依托 Spring Cloud Alibaba，您只需要添加<strong>一些注解和少量配置</strong>，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p>
<p>GitHub地址：<a href="https://github.com/alibaba/spring-cloud-alibaba">https://github.com/alibaba/spring-cloud-alibaba</a></p>
<h3 id="二、主要功能"><a href="#二、主要功能" class="headerlink" title="二、主要功能"></a>二、主要功能</h3><ul>
<li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li>
<li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li><strong>分布式事务</strong>：使用 <code>@GlobalTransactional</code> 注解， 高效并且对业务零侵入地解决分布式事务问题。。</li>
<li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li>
<li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ul>
<h3 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h3><p>**<a href="https://github.com/alibaba/Sentinel">Sentinel</a>**：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p>**<a href="https://github.com/alibaba/Nacos">Nacos</a>**：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>
<p>**<a href="https://rocketmq.apache.org/">RocketMQ</a>**：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p>
<p>**<a href="https://github.com/apache/dubbo">Dubbo</a>**：Apache Dubbo™ 是一款高性能 Java RPC 框架。</p>
<p>**<a href="https://github.com/seata/seata">Seata</a>**：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p>
<p>**<a href="https://www.aliyun.com/product/acm">Alibaba Cloud ACM</a>**：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</p>
<p><strong><a href="https://www.aliyun.com/product/oss">Alibaba Cloud OSS</a></strong>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p>
<p><strong><a href="https://help.aliyun.com/document_detail/43136.html">Alibaba Cloud SchedulerX</a></strong>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</p>
<p><strong><a href="https://www.aliyun.com/product/sms">Alibaba Cloud SMS</a></strong>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</p>
<h3 id="四、Spring-Cloud-Alibaba和Spring-Cloud-的区别和联系"><a href="#四、Spring-Cloud-Alibaba和Spring-Cloud-的区别和联系" class="headerlink" title="四、Spring Cloud Alibaba和Spring Cloud 的区别和联系"></a>四、Spring Cloud Alibaba和Spring Cloud 的区别和联系</h3><p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/image-20200531101103114.png" alt="image-20200531101103114"></p>
<p><img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/image-20200531101045571.png" alt="image-20200531101045571"></p>
<p><strong>SpringCloud Alibaba 的优势：</strong></p>
<p>阿里使用过的组件经历了考验，<strong>性能强悍，设计合理，搭建简单，学习曲线低</strong></p>
<h3 id="五、最终整合方案"><a href="#五、最终整合方案" class="headerlink" title="五、最终整合方案"></a>五、最终整合方案</h3><ul>
<li><p>SpringCloud Alibaba - Nacos：注册中心（服务发现、注册）</p>
</li>
<li><p>SpringCloud Alibaba - Nacos：配置中心（动态配置管理）</p>
</li>
<li><p>SpringCloud - Ribbon：负载均衡</p>
</li>
<li><p>SpringCloud - Feign：声明式 HTTP 客户端（调用远程服务）</p>
</li>
<li><p>SpringCloud Alibaba - Sentinel：服务容错（限流、降级、熔断）</p>
</li>
<li><p>SpringCloud - Gateway：API 网关（webflux 编程模式）</p>
</li>
<li><p>SpringCloud - Sleuth：调用链监控</p>
</li>
<li><p>SpringCloud Alibaba - Seata：分布式事务解决方案</p>
</li>
</ul>
<h3 id="六、版本规范管理"><a href="#六、版本规范管理" class="headerlink" title="六、版本规范管理"></a>六、版本规范管理</h3><p>项目的版本号格式为 x.x.x 的形式，其中 x 的数值类型为数字，从 0 开始取值，且不限于 0~9 这个范围。项目处于孵化器阶段时，第一位版本号固定使用 0，即版本号为 0.x.x 的格式。</p>
<p>由于 Spring Boot 1 和 Spring Boot 2 在 Actuator 模块的接口和注解有很大的变更，且 spring-cloud-commons 从 1.x.x 版本升级到 2.0.0 版本也有较大的变更，因此我们采取跟 SpringBoot 版本号一致的版本:</p>
<ul>
<li>1.5.x 版本适用于 Spring Boot 1.5.x</li>
<li>2.0.x 版本适用于 Spring Boot 2.0.x</li>
<li>2.1.x 版本适用于 Spring Boot 2.1.x</li>
<li>2.2.x 版本适用于 Spring Boot 2.2.x</li>
</ul>
<p>我们的项目使用的是 Spring Boot 2.2.7，故我们选择 Spring Cloud Alibaba 2.2.x版本</p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="SpringCloud-Alibaba-Nacos"><a href="#SpringCloud-Alibaba-Nacos" class="headerlink" title="SpringCloud Alibaba - Nacos"></a>SpringCloud Alibaba - Nacos</h1><h3 id="一、作为注册中心"><a href="#一、作为注册中心" class="headerlink" title="一、作为注册中心"></a>一、作为注册中心</h3><p>参考官方文档地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/readme-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/readme-zh.md</a></p>
<p>这里我们以模块 <strong>GulimallCouponApplication</strong> 为例</p>
<ol>
<li><p>首先，修改 pom.xml 文件，引入 Nacos Discovery Starter。</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在应用的 &#x2F;src&#x2F;main&#x2F;resources&#x2F;application.yml配置文件中配置 Nacos Server 地址及 name</p>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:  <span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">gulimall-coupon</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>@EnableDiscoveryClient</code> 注解开启服务注册与发现功能</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallCouponApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GulimallCouponApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 Nacos Server</p>
<ol>
<li>直接下载：<a href="https://github.com/alibaba/nacos/releases">Nacos Server 下载页</a></li>
<li>相对文件夹 nacos&#x2F;bin，双击打开文件 <code>startup.cmd</code></li>
</ol>
</li>
<li><p>运行 <strong>GulimallCouponApplication</strong> 测试</p>
<p> 进入 <code>127.0.0.1:8848/nacos</code> ，输入账号密码 nacos（账号密码一样）进入 <strong>nacos</strong> 的管理系统</p>
<p> <img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/image-20200531112201805.png" alt="image-20200531112201805"></p>
<p> gulimall-coupon 已经被注册进注册中心，测试成功！</p>
</li>
</ol>
<h3 id="二、作为配置中心"><a href="#二、作为配置中心" class="headerlink" title="二、作为配置中心"></a>二、作为配置中心</h3><p>参考官方文档地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md</a></p>
<ol>
<li><p>首先，修改 pom.xml 文件，引入 Nacos Config Starter。</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果出现 maven 爆红，请尝试添加版本号或者修改版本号</p>
</blockquote>
</li>
<li><p>在应用的 &#x2F;src&#x2F;main&#x2F;resources 下创建 <strong>bootstrap.properties</strong>，在配置文件中配置 Nacos Config 元数据</p>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">gulimall-coupon</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 nacos 配置中心添加<strong>数据集</strong></p>
<p> <img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/image-20200531121805049.png" alt="image-20200531121805049"></p>
<p> <img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/image-20200531121819040.png" alt="image-20200531121819040"></p>
<p> <img src="/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%8A%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E3%80%8B2020%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/image-20200531121735368.png" alt="image-20200531121735368"></p>
<p> <strong>注意 Data Id 命名要规范（应用名.properties）</strong></p>
</li>
<li><p>编写测试类</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RefreshScope</span>：动态刷新并获取配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Value</span>(&quot;$&#123;配置项的名称&#125;&quot;)：获取配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">SampleController</span> &#123;</span><br><span class="line"></span><br><span class="line"> 	<span class="meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span></span><br><span class="line"> 	String userName;</span><br><span class="line"></span><br><span class="line"> 	<span class="meta">@Value(&quot;$&#123;user.age&#125;&quot;)</span></span><br><span class="line"> 	<span class="type">int</span> age;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试完成！</li>
</ol>
<p><strong>一些细节</strong>：</p>
<ol>
<li><p>命名空间：配置隔离</p>
<p> 默认：public（保留空间），默认新增的所有配置都在 public 空间</p>
 <img src="【尚硅谷《谷粒商城》2020学习笔记】二、分布式组件/image-20200531150701476.png" alt="image-20200531150701476" style="zoom:67%;" />

<p> 修改名称空间：</p>
<p> 在  <code>bootstrap.properties</code> 中添加属性 <code>spring.cloud.config.namespace=命名空间ID</code></p>
<p> <strong>可以给不同环境设置不同命名空间，也可以给不同微服务设置不同命名空间</strong></p>
</li>
<li><p>配置集：所有配置的集合</p>
</li>
<li><p>配置集ID：类似于配置文件名</p>
</li>
<li><p>配置分组</p>
<p> 默认所有的配置属于：DEFAULT_GROUP</p>
<p> 修改配置分组：</p>
<p> 在  <code>bootstrap.properties</code> 中添加属性 <code>spring.cloud.config.group=组名</code></p>
</li>
</ol>
<p>我们的微服务配置：<strong>命名空间区分不同微服务，配置分组区分不同开发环境</strong></p>
<h1 id="SpringCloud-OpenFeign"><a href="#SpringCloud-OpenFeign" class="headerlink" title="SpringCloud - OpenFeign"></a>SpringCloud - OpenFeign</h1><p>使用 <strong>feign</strong> 可以实现微服务之间的调用！</p>
<p>我们以 gulimall-member 调用 gulimall-coupon 为例来实现获取会员的优惠价信息功能</p>
<ol>
<li><p>导入依赖</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写测试方法 </p>
<p> <code>com.wxshhh.gulimall.coupon.controller.CouponController</code>：中：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;coupon/coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CouponController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CouponService couponService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/member/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">memberCoupons</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CouponEntity</span> <span class="variable">couponEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CouponEntity</span>();</span><br><span class="line">        couponEntity.setCouponName(<span class="string">&quot;满100减10&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> R.ok().put(<span class="string">&quot;coupons&quot;</span>, Arrays.asList(couponEntity));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个接口，告诉 SpringCloud 这个接口需要调用远程服务</p>
<p> <code>com.wxshhh.gulimall.member.feign.CouponFeignService</code> 中：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  这是一个声明式的远程调用</span></span><br><span class="line"><span class="comment"> *  括号内的参数是要远程调用的微服务名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;gulimall-coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CouponFeignService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接将需要远程调用的方法的头拷贝过来即可</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/coupon/coupon/member/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">memberCoupons</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写测试方法</p>
<p> <code>com.wxshhh.gulimall.member.controller.MemberController</code> 中：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;member/member&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MemberService memberService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CouponFeignService couponFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/coupons&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MemberEntity</span> <span class="variable">memberEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemberEntity</span>();</span><br><span class="line">        memberEntity.setNickname(<span class="string">&quot;wxh&quot;</span>);</span><br><span class="line">        <span class="type">R</span> <span class="variable">memberCoupons</span> <span class="operator">=</span> couponFeignService.memberCoupons();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">coupons</span> <span class="operator">=</span> memberCoupons.get(<span class="string">&quot;coupons&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> R.ok()</span><br><span class="line">                .put(<span class="string">&quot;member&quot;</span>, memberEntity)</span><br><span class="line">                .put(<span class="string">&quot;coupons&quot;</span>, coupons);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启远程调用功能，运行微服务 <strong>gulimall-member</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定远程调用接口的位置</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.wxshhh.gulimall.member.feign&quot;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallMemberApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GulimallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <img src="【尚硅谷《谷粒商城》2020学习笔记】二、分布式组件/image-20200531113732878.png" alt="image-20200531113732878" style="zoom:67%;" />

<p> 测试成功！</p>
</li>
</ol>
<h1 id="SpringCloud-Gateway"><a href="#SpringCloud-Gateway" class="headerlink" title="SpringCloud-Gateway"></a>SpringCloud-Gateway</h1><p>官方文档地址：<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><strong>Route</strong>：网关的基本构建基块。它由 ID、目标 URI、Predicate 集合和 Filter 集合定义。如果聚合 Predicate 为 true，则匹配路由。</li>
<li><strong>Predicate</strong>： 这是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html">Java 8 函数断言</a>。输入类型是<a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html">弹簧框架<code>服务器WebExchange。</code></a>这允许您匹配 HTTP 请求的任何内容，如标头或参数。</li>
<li><strong>Filter</strong>：这些是使用特定工厂构造的<a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/GatewayFilter.html">弹簧框架<code>网关Filter</code></a>的实例。在这里，您可以在发送下游请求之前或之后修改请求和响应。</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><img src="【尚硅谷《谷粒商城》2020学习笔记】二、分布式组件/image-20200601101342702.png" alt="image-20200601101342702" style="zoom:67%;" />

<blockquote>
<p>Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a route, it is sent to the Gateway Web Handler. This handler runs the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line is that filters can run logic both before and after the proxy request is sent. All “pre” filter logic is executed. Then the proxy request is made. After the proxy request is made, the “post” filter logic is run.</p>
</blockquote>
<h3 id="配置样例"><a href="#配置样例" class="headerlink" title="配置样例"></a>配置样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: baidu_route</span><br><span class="line">          uri: https://www.baidu.com</span><br><span class="line">          predicates:</span><br><span class="line">            - Query=url,baidu</span><br><span class="line"></span><br><span class="line">        - id: qq_route</span><br><span class="line">          uri: https://www.qq.com</span><br><span class="line">          predicates:</span><br><span class="line">            - Query=url,qq</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>尚硅谷</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>【初探JVM】</title>
    <url>/2023/03/01/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>JVM是现在面试中的常客，多是些概念性的东西需要把它记住，这个时候可不能拉跨！</p>
<p>先来几道题练练手，心里有个数</p>
<ul>
<li>请你谈谈你对JVM的理解？</li>
<li><strong>Java8</strong>虚拟机和之前的<strong>变化</strong>更新？</li>
<li>什么是<strong>OOM</strong>？什么是栈溢出（<strong>StackOverFlowError</strong>）？怎么分析？</li>
<li>JVM常用的<strong>调优参数</strong>有哪些?</li>
<li>内存<strong>快照</strong>如何抓取、怎么分析<strong>Dump文件</strong>?</li>
<li>谈谈JVM中，<strong>类加载器</strong>的认识？</li>
<li>……</li>
</ul>
<p>懵逼了吧，那就来系统学习一波！</p>
<p>在学习的过程中会遇到很多抽象的概念，需要我们结合图式梳理分析，参考下面的网站：</p>
<ul>
<li><a href="https://www.processon.com/view/5c749debe4b0f9fba6921d15">https://www.processon.com/view/5c749debe4b0f9fba6921d15</a></li>
<li><a href="https://www.processon.com/view/5a7bff4be4b024b99bf5d30f">https://www.processon.com/view/5a7bff4be4b024b99bf5d30f</a></li>
<li><a href="https://www.processon.com/view/5bc708cde4b08faf8c808c91#map">https://www.processon.com/view/5bc708cde4b08faf8c808c91#map</a></li>
</ul>
</blockquote>
<h1 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h1><h1 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h1><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502100551288.png" alt="image-20200502100551288"></p>
<p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502102116094.png" alt="image-20200502102116094"></p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​    加载Class文件</p>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502104222975.png" alt="image-20200502104222975"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>虚拟机自带的加载器</p>
</li>
<li><p>启动（根）加载器（BootStrap）</p>
<p>  它<strong>不是Java类</strong>，因此它不需要被别人加载，它嵌套在Java虚拟机内核里面，也就是JVM启动的时候Bootstrap就已经启动，它<strong>是用C++写的二进制代码</strong>（不是字节码），它<strong>可以去加载别的类</strong>。</p>
</li>
<li><p>扩展类加载器（Extension）</p>
</li>
<li><p>应用程序（系统）加载器（System）</p>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; aClass = person.getClass();</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line">        System.out.println(aClass.getClassLoader());    <span class="comment">//AppClassLoader</span></span><br><span class="line">        System.out.println(aClass.getClassLoader().getParent());    <span class="comment">//ExtClassLoader</span></span><br><span class="line">        System.out.println(aClass.getClassLoader().getParent().getParent());    </span><br><span class="line">        <span class="comment">//根加载器，java程序获取不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502105839415.png" alt="image-20200502105839415"></p>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，<strong>依次递归</strong>，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p>AppClassLoader——&gt;ExtClassLoader——&gt;Bootstrap（最终执行）</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>保证安全性</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果程序会报错：在类 <code>java.lang.String</code> 中找不到 <code>main</code> 方法</p>
<p>分析：程序不会先执行在自己创建的类中的方法，而是<strong>先委托给其父类加载器</strong>，最后在 jdk 自带的 <code>java.lang</code> 中<strong>找到要完成的类加载任务</strong>，会选择该类执行而不是自己创建的类，进而由于找不到 <code>main</code> 方法而报错。</p>
<ul>
<li>类加载器收到类加载请求</li>
<li>将这个请求向上委托给父类加载器完成，一直向上委托直到根类加载器</li>
<li>启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前的类加载器，否则就抛出异常，通知子加载器进行加载</li>
<li>重复上一步</li>
</ul>
<blockquote>
<p>能不能自己写个类叫<code>java.lang.System</code>？</p>
<p><strong>答案：</strong>通常不可以，但可以采取另类方法达到这个需求。<br><strong>解释：</strong>为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，<strong>自己写的System类根本没有机会得到加载。</strong></p>
<p>但是，我们可以<strong>自己定义一个类加载器来达到这个目的</strong>，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。</p>
</blockquote>
<h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h1><blockquote>
<p>     Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>     所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
</blockquote>
<p><a href="https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html">https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html</a></p>
<h1 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简化版</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//在调用该方法后线程启动成功</span></span><br><span class="line">    start0();</span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。</p>
<p>JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。</p>
</blockquote>
<ul>
<li><p>JNI作用：扩展Java的使用，融合不同的编程语言为Java所用</p>
</li>
<li><p>在最终执行的时候，通过 JNI 加载本地方法库中的方法</p>
</li>
</ul>
<h1 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h1><blockquote>
<p>程序计数器是一个记录着当前线程所执行的字节码的行号指示器。</p>
<p>JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程</p>
</blockquote>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区是被所有线程所共享的，所有字段、方法字节码、特殊方法（构造函数、接口代码）等在此定义，<strong>属于共享空间</strong>。</p>
<ul>
<li>静态变量：<code>static</code></li>
<li>常量：<code>final</code></li>
<li>类信息：<code>Class</code></li>
<li>常量池</li>
</ul>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><blockquote>
<p>程序员学习思想：</p>
<p>​    程序 &#x3D; 数据结构 + 算法 √ （持续学习）</p>
<p>​    程序 &#x3D; 框架 + 业务逻辑 ×（很容易被淘汰，吃饭用的）</p>
</blockquote>
<h3 id="一个小问题：为什么-main-方法先执行，最后结束？"><a href="#一个小问题：为什么-main-方法先执行，最后结束？" class="headerlink" title="一个小问题：为什么 main 方法先执行，最后结束？"></a>一个小问题：为什么 <code>main</code> 方法先执行，最后结束？</h3><p>一个图解释清楚：<img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502115532577.png" alt="image-20200502115532577"></p>
<h3 id="再想想递归调用出现栈溢出是怎么肥四？"><a href="#再想想递归调用出现栈溢出是怎么肥四？" class="headerlink" title="再想想递归调用出现栈溢出是怎么肥四？"></a>再想想递归调用出现栈溢出是怎么肥四？</h3><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502115354355.png" alt="image-20200502115354355"></p>
<h3 id="对于栈来说，不存在垃圾回收问题"><a href="#对于栈来说，不存在垃圾回收问题" class="headerlink" title="对于栈来说，不存在垃圾回收问题"></a>对于栈来说，不存在垃圾回收问题</h3><h3 id="栈存放的内容"><a href="#栈存放的内容" class="headerlink" title="栈存放的内容"></a>栈存放的内容</h3><ul>
<li>8大基本类型</li>
<li>对象引用</li>
<li>实例的方法</li>
</ul>
<p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502120644868.png" alt="image-20200502120644868"></p>
<h3 id="类实例化的过程"><a href="#类实例化的过程" class="headerlink" title="类实例化的过程"></a>类实例化的过程</h3><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200502122508381.png" alt="image-20200502122508381"></p>
<h1 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h1><p>了解即可</p>
<ul>
<li>Sun公司 - HotSpot</li>
<li>BEA - JRockit</li>
<li>IBM - J9VM</li>
</ul>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><strong>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</strong></p>
<p>类加载器读取了类文件后，一般会把什么东西放在堆中？</p>
<ul>
<li>类</li>
<li>方法</li>
<li>常量</li>
<li>变量</li>
</ul>
<p>保存引用类型的真实对象</p>
<p>堆内存中还要细分为三个区域：</p>
<ul>
<li>新生区（伊甸园区）</li>
<li>养老区</li>
<li>永久区</li>
</ul>
<img src="【探秘JVM】/image-20200502143710520.png" alt="image-20200502143710520" style="zoom:67%;" />

<p><strong>GC垃圾回收主要是在伊甸园区和养老区！</strong></p>
<p>堆内存满了会爆出 OutOfMemoryError：Java heap space</p>
<p>JDK8以后，永久区——&gt;元空间</p>
<h1 id="新生区、老年区"><a href="#新生区、老年区" class="headerlink" title="新生区、老年区"></a>新生区、老年区</h1><h3 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h3><p>对象诞生、成长甚至死亡的地方</p>
<ul>
<li><p>伊甸园区</p>
<p>  所有对象都是在伊甸园区 <code>new</code> 出来的</p>
</li>
<li><p>幸存区</p>
<ul>
<li>0区</li>
<li>1区</li>
</ul>
</li>
</ul>
<p><strong>经过研究，99%的对象都是临时对象！</strong></p>
<h1 id="永生区（元空间）"><a href="#永生区（元空间）" class="headerlink" title="永生区（元空间）"></a>永生区（元空间）</h1><p>这个区域是常驻的，用来存放 JDK 自身携带的 Class 对象。Interface 元空间，存储的是Java运行时的一些环境或类信息，这个区域不存在 GC。关闭 JVM 时这个区域的内存被释放。</p>
<ul>
<li>JDK1.6 之前：永久带，常量池在方法区中</li>
<li>JDK1.7        ：永久带，但是慢慢退化了（去永久带），常量池在堆中</li>
<li>JDK1.8之后：无永久带，常量池在元空间</li>
</ul>
<h1 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h1><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200503161549133.png" alt="image-20200503161549133"></p>
<p>Dump文件：</p>
<p>使用命令 <code>-XX:HeapDumpOnxxxError</code>、<code>-XX:HeapDumpOnxxxException</code></p>
<p>可以生成关于异常的文件，使用插件 Jprofilter 可以对其进行分析</p>
<p>排除OOM错误故障的方法：</p>
<ul>
<li>能够看到代码第几行出错：内存快照分析工具，MAT（Eclipse）、Jprofiler（IDEA）</li>
<li>Debug</li>
</ul>
<p><strong>MAT、Jprofiler作用</strong></p>
<ul>
<li>分析Dump内存文件，快速定位内存泄露</li>
<li>获得堆中的数据</li>
<li>获得大的对象</li>
<li>……</li>
</ul>
<h1 id="GC：垃圾回收"><a href="#GC：垃圾回收" class="headerlink" title="GC：垃圾回收"></a>GC：垃圾回收</h1><h3 id="一些GC的问题"><a href="#一些GC的问题" class="headerlink" title="一些GC的问题"></a>一些GC的问题</h3><ul>
<li>JVM的内存模型和分区（详细到每个区放什么）</li>
<li>堆里面的分区有哪些？Eden、from、to、老年区，说说他们的特点</li>
<li>GC算法有哪些？怎么用？</li>
<li>轻GC 和 重GC 分别在什么时候发生</li>
</ul>
<h3 id="GC的作用区域"><a href="#GC的作用区域" class="headerlink" title="GC的作用区域"></a>GC的作用区域</h3><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200503194655724.png" alt="image-20200503194655724"></p>
<p>JVM在进行GC时，并不是对新生代、幸存区（from、to）、老年去进行统一回收，<strong>大部分回收的都是新生代</strong>。</p>
<h3 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h3><ul>
<li>轻GC（普通GC）</li>
<li>重GC（全局GC）</li>
</ul>
<h3 id="GC的算法"><a href="#GC的算法" class="headerlink" title="GC的算法"></a>GC的算法</h3><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h4><p>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，<strong>无法解决对象相互循环引用</strong>的问题。</p>
<h4 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h4><img src="【探秘JVM】/image-20200503200832689.png" alt="image-20200503200832689" style="zoom:150%;" />

<p>当一个对象经历了 <strong>15次</strong> GC还没有被清除，就会进入老年代。</p>
<p>（可以使用参数 <code>-XX:MaxTenuringThreshold=?</code>来进行调节）</p>
<ul>
<li>好处：没有内存碎片</li>
<li>坏处：浪费了空间</li>
<li>使用场景：对象存活度较低的区域—新生区。</li>
</ul>
<h4 id="3-标记清除算法"><a href="#3-标记清除算法" class="headerlink" title="3.标记清除算法"></a>3.标记清除算法</h4><p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200503203352254.png" alt="image-20200503203352254"></p>
<ul>
<li>优点：不需要浪费额外的空间</li>
<li>缺点：两次扫描，严重浪费时间，会产生内存碎片</li>
</ul>
<h4 id="4-标记压缩算法"><a href="#4-标记压缩算法" class="headerlink" title="4.标记压缩算法"></a>4.标记压缩算法</h4><p>对标记清除算法的优化</p>
<p><img src="/%E3%80%90%E6%8E%A2%E7%A7%98JVM%E3%80%91/image-20200503203646419.png" alt="image-20200503203646419"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="内存效率"><a href="#内存效率" class="headerlink" title="内存效率"></a>内存效率</h4><p><code>复制算法 &gt; 标记清除算法 &gt;  标记压缩算法</code> </p>
<h4 id="内存整齐度"><a href="#内存整齐度" class="headerlink" title="内存整齐度"></a>内存整齐度</h4><p><code>复制算法 = 标记压缩算法 &gt; 标记清除算法</code></p>
<h4 id="内存利用率"><a href="#内存利用率" class="headerlink" title="内存利用率"></a>内存利用率</h4><p><code>标记压缩算法 = 标记清除算法 &gt; 复制算法</code></p>
<blockquote>
<ul>
<li>思考：难道没有最优的算法嘛？</li>
<li>答案：莫得，只有最合适的</li>
<li>GC：分代收集算法</li>
</ul>
</blockquote>
<p>完结撒花~~~~~~~~~</p>
<p><strong>狂神，永远滴神！！！</strong></p>
<p>完了之后抽空深入了解JVM，看<strong>《深入理解JVM原理》</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV1iJ411d7jS">https://www.bilibili.com/video/BV1iJ411d7jS</a></p>
<p>程序媛想事儿：<a href="https://www.cnblogs.com/lanxuezaipiao/p/4138511.html">https://www.cnblogs.com/lanxuezaipiao/p/4138511.html</a></p>
<p>不止吧：<a href="https://www.cnblogs.com/b3051/p/7484501.html">https://www.cnblogs.com/b3051/p/7484501.html</a></p>
<p>re-phoenix：<a href="https://www.cnblogs.com/manayi/p/9290490.html">https://www.cnblogs.com/manayi/p/9290490.html</a></p>
<p>春_：<a href="https://blog.csdn.net/weixin_43736084/article/details/103937547">https://blog.csdn.net/weixin_43736084/article/details/103937547</a></p>
<p>纯洁的微笑：<a href="https://www.cnblogs.com/ityouknow/p/5614961.html">https://www.cnblogs.com/ityouknow/p/5614961.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>狂神说Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【操作系统】第一章：概述</title>
    <url>/2020/04/16/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>从今天开始一个新的篇章的学习——《计算机操作系统》</p>
<p>为了提前准备将要到来的考研</p>
<p>也为了夯实计算机基础，建立完整的计算机科学体系</p>
<p>内容记录自：b站——操作系统_清华大学（向勇、陈瑜） BV1js411b7vg</p>
<p>​						学堂在线——操作系统（清华大学）</p>
</blockquote>
<h2 id="1-1-课程概述"><a href="#1-1-课程概述" class="headerlink" title="1.1 课程概述"></a>1.1 课程概述</h2><ul>
<li><p>涉及：</p>
<ul>
<li>基本概念及原理</li>
<li>操作系统介绍</li>
<li>中断及系统调用</li>
<li>内存管理</li>
<li>进程和线程</li>
<li>调度</li>
<li>同步</li>
<li>文件系统</li>
<li>I&#x2F;O 子系统</li>
</ul>
</li>
<li><p>操作系统实验：</p>
<ul>
<li><a href="https://www.shiyanlou.com/courses/221">在uCore操作系统上做实验</a></li>
</ul>
</li>
</ul>
<h2 id="1-2-什么是操作系统"><a href="#1-2-什么是操作系统" class="headerlink" title="1.2 什么是操作系统"></a>1.2 什么是操作系统</h2><ul>
<li><p>结构层次：硬件之上，应用程序之下</p>
<ul>
<li><p>用户角度，操作系统是一个<strong>控制软件</strong></p>
</li>
<li><p>资源分配角度，是一个<strong>资源分配器</strong></p>
</li>
</ul>
</li>
<li><p>操作系统的虚拟化：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">底层</th>
<th align="center">上层</th>
</tr>
</thead>
<tbody><tr>
<td align="center">磁盘</td>
<td align="center">文件</td>
</tr>
<tr>
<td align="center">内存</td>
<td align="center">地址空间</td>
</tr>
<tr>
<td align="center">CPU</td>
<td align="center">进程</td>
</tr>
</tbody></table>
<p>主流操作系统的界面属于 Shell，而不是 Kernel，Kernel 是我们的研究重点。</p>
<ul>
<li><p>Kernel —— 操作系统内部组件：</p>
<ul>
<li><strong>CPU调度器</strong></li>
<li><strong>物理内存管理</strong></li>
<li><strong>虚拟内存管理</strong></li>
<li><strong>文件系统管理</strong></li>
<li>中断处理与设备驱动</li>
</ul>
</li>
<li><p>OS Kernel 的特征</p>
<ul>
<li><p>并发</p>
</li>
<li><p>共享（同时存在多个运行的程序，需要 OS 管理和调度）</p>
<ul>
<li>“同时共享”</li>
<li>互斥共享</li>
</ul>
</li>
<li><p>虚拟</p>
<ul>
<li>利用多道程序设计技术，让用户觉得有一个计算机专门为他服务</li>
</ul>
</li>
<li><p>异步</p>
<ul>
<li>程序执行不是一贯到底，而是<strong>走走停停</strong>，推进速度不可预知</li>
<li>运行环境相同，运行结果也相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-为什么学习操作系统"><a href="#1-3-为什么学习操作系统" class="headerlink" title="1.3 为什么学习操作系统"></a>1.3 为什么学习操作系统</h2><ul>
<li><p>操作系统是计算机科学研究的基石之一</p>
</li>
<li><p>操作系统是安全的基础</p>
</li>
<li><p>操作系统的学习具有挑战性</p>
</li>
<li><p>操作系统需要权衡：</p>
<ul>
<li>空间与时间</li>
<li>性能和可预测性</li>
<li>公平和性能</li>
</ul>
</li>
<li><p>操作系统在硬件方面需要：</p>
<ul>
<li>良好的硬件管理</li>
<li>合理的资源分配</li>
</ul>
</li>
</ul>
<h2 id="1-4-为什么学习操作系统"><a href="#1-4-为什么学习操作系统" class="headerlink" title="1.4 为什么学习操作系统"></a>1.4 为什么学习操作系统</h2><h2 id="1-5-操作系统实例"><a href="#1-5-操作系统实例" class="headerlink" title="1.5 操作系统实例"></a>1.5 操作系统实例</h2><ol>
<li><p>UNIX BSD 操作系统</p>
</li>
<li><p>Linux 家族</p>
</li>
<li><p>Windows 家族（ 90年代 ）</p>
<p> 对计算机推广起巨大的作用</p>
</li>
</ol>
<h2 id="1-6-操作系统的历史"><a href="#1-6-操作系统的历史" class="headerlink" title="1.6 操作系统的历史"></a>1.6 操作系统的历史</h2><ol>
<li>早期计算机使用纸带传输和加载数据，早期操作系统只起到了加载作用。</li>
<li>批处理阶段（多道程序设计）：体现操作系统并发的特征，充分利用CPU。</li>
<li>分时计算机系统（时钟定期产生<strong>中断</strong>，将控制权交给操作系统）：为了更好的与用户交互。</li>
<li>个人电脑操作系统：单用户、重点是用户界面和API、利用率不再是关注点、很多服务都不存在了</li>
<li>分布式操作系统：低耦合</li>
</ol>
<p><strong>从一群人围着一个计算机服务 —&gt;  一群计算机围着一个人服务</strong></p>
<h2 id="1-7-操作系统结构"><a href="#1-7-操作系统结构" class="headerlink" title="1.7 操作系统结构"></a>1.7 操作系统结构</h2><ul>
<li><p>面向个人计算计算机、面向服务器的计算机</p>
</li>
<li><p>微内核架构的操作系统设计</p>
<ul>
<li>拓展性较好，模块化</li>
<li>性能存在问题</li>
</ul>
</li>
<li><p>外核设计</p>
</li>
<li><p>虚拟机监控器（VMM）：操作系统之下是虚拟机</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【操作系统】第七章：进程和线程</title>
    <url>/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="7-1-进程的定义"><a href="#7-1-进程的定义" class="headerlink" title="7.1 进程的定义"></a>7.1 进程的定义</h1><img src="【操作系统】第七章：进程和线程/image-20200424205148926.png" alt="image-20200424205148926" style="zoom:67%;" />

<ul>
<li><p><strong>定义：</strong>一个具有一定独立功能的<strong>程序</strong>在一个数据集合上一次<strong>动态的执行过程</strong>。</p>
<p>  进程代表运行的程序的执行过程，需要消耗各种计算机的资源</p>
<p>  通过进程可以更好的表示程序的执行过程</p>
<p>  <strong>进程是程序动态执行的过程</strong></p>
</li>
</ul>
<h1 id="7-2-进程的组成"><a href="#7-2-进程的组成" class="headerlink" title="7.2 进程的组成"></a>7.2 进程的组成</h1><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><ul>
<li><strong>程序的代码</strong></li>
<li><strong>程序处理的数据</strong></li>
<li>程序计数器中的值，指示下一条将运行的指令</li>
<li>一组通用的寄存器的当前值，堆、栈</li>
<li>一组系统资源（如打开的程序）</li>
</ul>
<h3 id="进程与程序的联系（多对多）"><a href="#进程与程序的联系（多对多）" class="headerlink" title="进程与程序的联系（多对多）"></a>进程与程序的联系（多对多）</h3><ul>
<li>程序是产生进程的基础</li>
<li>程序的每次运行构成不同的进程</li>
<li>进程是程序功能的</li>
<li>通过多次执行，<strong>一个程序可对应多个进程</strong>；通过调用关系，<strong>一个进程可以包含多个程序</strong>。</li>
</ul>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><table>
<thead>
<tr>
<th align="center">进程</th>
<th align="center">程序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">动态的</td>
<td align="center">静态的</td>
</tr>
<tr>
<td align="center">暂时的</td>
<td align="center">永久的</td>
</tr>
<tr>
<td align="center">进程组成包含程序、数据、进程控制块</td>
<td align="center">……</td>
</tr>
</tbody></table>
<h1 id="7-3-进程的特点"><a href="#7-3-进程的特点" class="headerlink" title="7.3 进程的特点"></a>7.3 进程的特点</h1><ul>
<li>动态性：可动态的创建、结束进程</li>
<li>并发性：进程可以被独立调度并占用处理及运行</li>
<li>独立性：不同进程的工作不相互影响</li>
<li>制约性：因访问共享数据&#x2F;资源或进程间同步而产生制约</li>
</ul>
<p>&#x3D;&#x3D;程序 &#x3D; 算法 + 数据结构&#x3D;&#x3D;</p>
<p>描述进程的数据结构：<strong>进程控制块（Process Control Block，PCB）</strong></p>
<p>操作系统为每个进程维护了一个PCB，用来保存与该进程有关的各种信息状态</p>
<h1 id="7-4-进程的控制结构"><a href="#7-4-进程的控制结构" class="headerlink" title="7.4 进程的控制结构"></a>7.4 进程的控制结构</h1><p>进程控制块：操作系统管理控制进程运行所用的信息集合</p>
<p>操作系统用PCB来描述进程的基本情况以及运行变化的过程，<strong>PCB是进程存在的唯一标志</strong></p>
<p>进程控制块的使用：</p>
<ul>
<li>进程的创建：生成PCB</li>
<li>进程的终止：回收PCB</li>
<li>进程的组织管理</li>
</ul>
<p>PCB含有下列三大类信息：</p>
<ol>
<li><p>进程标识信息（pid）</p>
</li>
<li><p>处理机状态信息保存区（状态信息）</p>
<ul>
<li>用户可见寄存器、用户程序可以使用的数据、地址等寄存器</li>
<li>控制和状态控制器，如程序计数器（PC）、程序状态字（PSW）</li>
<li>栈指针，过程调用&#x2F;系统调用&#x2F;中断处理和返回时用到</li>
</ul>
</li>
<li><p>进程控制信息（控制信息）</p>
 <img src="【操作系统】第七章：进程和线程/image-20200424212652589.png" alt="image-20200424212652589" style="zoom:67%;" /></li>
</ol>
<img src="【操作系统】第七章：进程和线程/image-20200424213026940.png" alt="image-20200424213026940" style="zoom:67%;" />

<h1 id="7-5-进程的生命周期原理"><a href="#7-5-进程的生命周期原理" class="headerlink" title="7.5 进程的生命周期原理"></a>7.5 进程的生命周期原理</h1><p>进程的生命周期管理：</p>
<ul>
<li>进程创建</li>
<li>进程运行</li>
<li>进程等待</li>
<li>进程唤醒</li>
<li>进程结束</li>
</ul>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><img src="【操作系统】第七章：进程和线程/image-20200424213324923.png" alt="image-20200424213324923" style="zoom:67%;" />

<h3 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h3><img src="【操作系统】第七章：进程和线程/image-20200424213348158.png" alt="image-20200424213348158" style="zoom: 67%;" />

<h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><img src="【操作系统】第七章：进程和线程/image-20200424213450286.png" alt="image-20200424213450286" style="zoom:67%;" />

<h3 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h3><img src="【操作系统】第七章：进程和线程/image-20200424213605087.png" alt="image-20200424213605087" style="zoom:67%;" />

<h3 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h3><img src="【操作系统】第七章：进程和线程/image-20200424213718947.png" alt="image-20200424213718947" style="zoom:67%;" />

<h1 id="7-6-进程状态变化模型"><a href="#7-6-进程状态变化模型" class="headerlink" title="7.6 进程状态变化模型"></a>7.6 进程状态变化模型</h1><img src="【操作系统】第七章：进程和线程/image-20200424213908227.png" alt="image-20200424213908227" style="zoom:67%;" />

<img src="【操作系统】第七章：进程和线程/image-20200424213934958.png" alt="image-20200424213934958" style="zoom:67%;" />

<img src="【操作系统】第七章：进程和线程/image-20200424214214017.png" alt="image-20200424214214017" style="zoom:67%;" />

<h1 id="7-7-进程挂起"><a href="#7-7-进程挂起" class="headerlink" title="7.7 进程挂起"></a>7.7 进程挂起</h1><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20200424214727314.png" alt="image-20200424214727314"></p>
<h1 id="7-8-为什么使用线程"><a href="#7-8-为什么使用线程" class="headerlink" title="7.8 为什么使用线程"></a>7.8 为什么使用线程</h1><p>80年代中期，人们提出了比进程更小的<strong>能独立运行的基本单位</strong>——线程。</p>
<p>为什么要使用线程？</p>
<ul>
<li><p>案例：编写一个MP3播放软件</p>
<p>  核心模块功能：</p>
<ul>
<li>从MP3音频文件当中读取数据</li>
<li>对数据进行解压</li>
<li>把解压后的音频数据播放出来</li>
</ul>
  <img src="【操作系统】第七章：进程和线程/image-20200426101500455.png" alt="image-20200426101500455" style="zoom:67%;" />

  <img src="【操作系统】第七章：进程和线程/image-20200426101537425.png" alt="image-20200426101537425" style="zoom:67%;" />

<p>  如何来解决上述问题呢？</p>
<p>  我们需要一个新的实体来满足以下特性：</p>
<ul>
<li>实体之间可以<strong>并发的执行</strong></li>
<li>实体之间<strong>共享相同的地址</strong></li>
</ul>
<p>  这种实体就是，<strong>线程（Thread）</strong></p>
</li>
</ul>
<h1 id="7-9-什么是线程"><a href="#7-9-什么是线程" class="headerlink" title="7.9 什么是线程"></a>7.9 什么是线程</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>线程是进程当中的一条执行流程。</strong></p>
<p>进程的主要功能是管理资源，线程用来管理进程的执行资源。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p><strong>线程 &#x3D; 进程 - 共享资源</strong></p>
</li>
<li><p>线程的优点：</p>
<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各线程之间可以并发地执行</li>
<li>线程之间可以共享地址空间和文件等资源</li>
</ul>
</li>
<li><p>线程的缺点：</p>
<ul>
<li>安全可靠性没有保障，一个线程崩溃，会导致其所属的进程的所有线程崩溃</li>
</ul>
</li>
</ul>
<h3 id="线程与进程比较"><a href="#线程与进程比较" class="headerlink" title="线程与进程比较"></a>线程与进程比较</h3><table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>资源分配单位</td>
<td>CPU调度单位</td>
</tr>
<tr>
<td>拥有完整的资源平台</td>
<td>独享必不可少的资源，如寄存器、栈</td>
</tr>
<tr>
<td>具有<strong>就绪、阻塞、执行</strong>三种基本状态</td>
<td>具有<strong>就绪、阻塞、执行</strong>三种基本状态</td>
</tr>
</tbody></table>
<p>线程能减少并发执行的时间和空间开销：</p>
<ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同一进程内的线程切换时间比进程短</li>
<li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信</li>
</ul>
<h1 id="7-10-线程的实现"><a href="#7-10-线程的实现" class="headerlink" title="7.10 线程的实现"></a>7.10 线程的实现</h1><h3 id="用户线程：在用户空间实现"><a href="#用户线程：在用户空间实现" class="headerlink" title="用户线程：在用户空间实现"></a>用户线程：在用户空间实现</h3><p>操作系统看不到的线程</p>
<p>由专门的用户线程库来进行管理，包括线程的创建、终止、同步、调度等。</p>
<img src="【操作系统】第七章：进程和线程/image-20200426103953516.png" alt="image-20200426103953516" style="zoom:67%;" />

<ul>
<li>用户线程缺点：<ul>
<li>阻塞性的系统调用（读文件，可能发生阻塞），如果一个线程发起系统调用而阻塞，则整个进程在等待；</li>
<li>当一个线程开始运行后，除非他主动交出CPU的使用权，否则他所在的线程当中的其他线程将无法运行；</li>
<li>由于时间片分配给进程，故与其他进程相比，在多线程执行时，每个线程得到的时间片较少，执行较慢。</li>
</ul>
</li>
</ul>
<h3 id="内核线程：在内核中实现"><a href="#内核线程：在内核中实现" class="headerlink" title="内核线程：在内核中实现"></a>内核线程：在内核中实现</h3><p>操作系统能够看到并进行管理的线程</p>
<p>由操作系统本身进行管理</p>
<img src="【操作系统】第七章：进程和线程/image-20200426104620533.png" alt="image-20200426104620533" style="zoom:67%;" />

<h3 id="轻量级进程：在内核中实现，支持用户线程"><a href="#轻量级进程：在内核中实现，支持用户线程" class="headerlink" title="轻量级进程：在内核中实现，支持用户线程"></a>轻量级进程：在内核中实现，支持用户线程</h3><p>内核支持用户线程。一个进程可有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。</p>
<img src="【操作系统】第七章：进程和线程/image-20200426104921999.png" alt="image-20200426104921999" style="zoom:67%;" />

<h1 id="7-11-上下文切换"><a href="#7-11-上下文切换" class="headerlink" title="7.11 上下文切换"></a>7.11 上下文切换</h1><img src="【操作系统】第七章：进程和线程/image-20200426105252010.png" alt="image-20200426105252010" style="zoom:67%;" />

<p><img src="【操作系统】第七章：进程和线程/image-20200426105318686.png" alt="image-20200426105318686" style="zoom:67%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20200426105516465.png" alt="image-20200426105516465"></p>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/image-20200426105516465.png" alt="image-20200426105516465"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【操作系统】第三章：连续内存分布</title>
    <url>/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<h1 id="3-1-计算机体系结构及内存分层体系"><a href="#3-1-计算机体系结构及内存分层体系" class="headerlink" title="3.1 计算机体系结构及内存分层体系"></a>3.1 计算机体系结构及内存分层体系</h1><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417165432213.png" alt="image-20200417165432213"></p>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><ul>
<li><p>CPU：完成基本的对程序或软件的控制</p>
</li>
<li><p>内存：放置程序代码和他处理的数据</p>
<p>  <img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417170005686.png" alt="image-20200417170005686"></p>
</li>
<li><p>外设</p>
</li>
</ul>
<h3 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417170232005.png" alt="image-20200417170232005"></p>
<h3 id="操作系统管理内存的方法"><a href="#操作系统管理内存的方法" class="headerlink" title="操作系统管理内存的方法"></a>操作系统管理内存的方法</h3><ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存</li>
</ul>
<h1 id="3-2-地址空间和地址生成"><a href="#3-2-地址空间和地址生成" class="headerlink" title="3.2 地址空间和地址生成"></a>3.2 地址空间和地址生成</h1><h3 id="地址空间定义"><a href="#地址空间定义" class="headerlink" title="地址空间定义"></a>地址空间定义</h3><ul>
<li>物理地址空间 — 硬件支持的地址空间（<strong>主存和磁盘</strong>）</li>
<li>逻辑地址空间— 一个运行程序所拥有的内存范围（一维的线性空间）</li>
</ul>
<h3 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h3><ul>
<li>逻辑地址的生成</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417171957066.png" alt="image-20200417171957066"></p>
<ul>
<li><p>物理地址的生成</p>
<p>  <strong>CPU方面</strong></p>
<ol>
<li>计算器<strong>需要</strong>在逻辑地址的<strong>内存内容</strong></li>
<li>内存管理单元<strong>寻找</strong>在逻辑地址和物理地址之间的<strong>映射</strong></li>
<li>控制器从总线<strong>发送</strong>在物理地址的内存内容的<strong>请求</strong></li>
</ol>
<p>  <strong>内存方面</strong></p>
<ol start="4">
<li>内存<strong>发送</strong>物理地址内存的<strong>内容</strong>给CPU</li>
</ol>
<p>  <strong>操作系统方面</strong></p>
<ol start="5">
<li><strong>建立</strong>逻辑地址和物理地址之间的<strong>映射</strong></li>
</ol>
</li>
</ul>
<h3 id="地址安全检查"><a href="#地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查</h3><h1 id="3-3-连续内存分配"><a href="#3-3-连续内存分配" class="headerlink" title="3.3 连续内存分配"></a>3.3 连续内存分配</h1><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p>当我们给正在运行的程序分配空间之后，会出现一些空闲的空间（碎片）不能被利用</p>
<ul>
<li><p>外部碎片</p>
<p>  在分配单元<strong>间</strong>未使用的内存（程序空间之间的碎片）</p>
</li>
<li><p>内部碎片</p>
<p>  在分配单元<strong>中</strong>的未使用内存（在分配给程序的空间内部出现的碎片）</p>
</li>
</ul>
<h3 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h3><ul>
<li>简单的内存管理方法：<ul>
<li>当一个程序准许运行在内存中时，分配一个连续的区间</li>
<li>分配一个连续的内存区间给运行的程序以访问数据</li>
</ul>
</li>
</ul>
<h5 id="第一适配"><a href="#第一适配" class="headerlink" title="第一适配"></a>第一适配</h5><ul>
<li>找到第一个满足需求的空闲块立马返回</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417183628752.png" alt="image-20200417183628752"></p>
<ul>
<li>优点：<ul>
<li>简单</li>
<li>易于产生更大的空闲块，向着地址空间的结尾</li>
</ul>
</li>
<li>缺点<ul>
<li>容易产生外部碎片</li>
<li>不确定性</li>
</ul>
</li>
</ul>
<h5 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h5><ul>
<li>寻找空间中最满足需求的空闲块</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417183554657.png" alt="image-20200417183554657"></p>
<ul>
<li>优点：<ul>
<li>大部分分配是小尺寸时非常有效</li>
<li>比较简单</li>
</ul>
</li>
<li>缺点：<ul>
<li>分配时需要先将空闲块按大小排序进行查找，降低效率</li>
<li>易产生很多没怎么用的微小碎片</li>
</ul>
</li>
</ul>
<h5 id="最差适配"><a href="#最差适配" class="headerlink" title="最差适配"></a>最差适配</h5><ul>
<li>寻找空间中大小最不匹配的空闲块</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417183701187.png" alt="image-20200417183701187"></p>
<ul>
<li>优点：<ul>
<li>分配是中等尺寸时效果最好</li>
</ul>
</li>
<li>缺点：<ul>
<li>效率降低</li>
<li>容易破碎大的空闲块导致大分区无法被分配</li>
</ul>
</li>
</ul>
<h3 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h3><ul>
<li>重置程序以合并孔洞，要求所有程序是 <strong>动态可重置的</strong></li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417184612553.png" alt="image-20200417184612553"></p>
<ul>
<li>何时重置？</li>
<li>开销如何？</li>
</ul>
<h3 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h3><ul>
<li>运行程序需要更多的内存，抢占等待的程序并回收他们的内存</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200417184629751.png" alt="image-20200417184629751"></p>
<ul>
<li>选择哪些程序进行交换？</li>
<li>何时进行？</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【操作系统】第二章：操作系统基础操作</title>
    <url>/2020/04/16/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="2-1-启动、中断、异常和系统调用"><a href="#2-1-启动、中断、异常和系统调用" class="headerlink" title="2.1 启动、中断、异常和系统调用"></a>2.1 启动、中断、异常和系统调用</h2><h4 id="一-启动"><a href="#一-启动" class="headerlink" title="一. 启动"></a>一. 启动</h4><p>DISK：存放 OS</p>
<p>BIOS：基本I&#x2F;O处理系统</p>
<p>Bootloader：加载 OS</p>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/image-20200416092711782.png" alt="image-20200416092711782"></p>
<h4 id="二-中断、异常和系统调用"><a href="#二-中断、异常和系统调用" class="headerlink" title="二. 中断、异常和系统调用"></a>二. 中断、异常和系统调用</h4><ul>
<li><p>定义：</p>
<ul>
<li>系统调用（来源于应用程序）：应用程序主动向操作系统发出服务请求</li>
<li>异常（来源于不良的应用程序）：非法指令或者其他坏的处理状态（如内存出错）</li>
<li>中断（来源于外设）：来自不同的硬件设备的计时器和网络的中断</li>
</ul>
</li>
<li><p>源头：</p>
<ul>
<li>中断：外设</li>
<li>异常：应用程序意想不到的行为</li>
<li>系统调用：应用程序请求操作系统提供服务</li>
</ul>
</li>
<li><p>处理时间：</p>
<ul>
<li>中断：异步</li>
<li>异常：同步</li>
<li>系统调用：异步或同步</li>
</ul>
</li>
<li><p>响应：</p>
<ul>
<li>中断：持续，对用户应用程序是透明的</li>
<li>异常：杀死或者重新执行意想不到的应用程序指令</li>
<li>系统调用：等待和持续</li>
</ul>
</li>
</ul>
<h2 id="2-2-中断、异常和系统调用"><a href="#2-2-中断、异常和系统调用" class="headerlink" title="2.2 中断、异常和系统调用"></a>2.2 中断、异常和系统调用</h2><h4 id="一-中断处理机制"><a href="#一-中断处理机制" class="headerlink" title="一. 中断处理机制"></a>一. 中断处理机制</h4><ul>
<li><p>硬件：设置中断标记（CPU初始化）</p>
<ol>
<li>将内部、外部事件设置中断标记</li>
<li>中断事件的ID</li>
</ol>
</li>
<li><p>软件：</p>
<ul>
<li>保存当前处理状态</li>
<li>中断服务程序处理</li>
<li>清除中断标记</li>
<li>恢复之前保存的处理状态</li>
</ul>
</li>
</ul>
<h4 id="二-异常处理机制"><a href="#二-异常处理机制" class="headerlink" title="二 . 异常处理机制"></a>二 . 异常处理机制</h4><ul>
<li><p>异常：异常编号</p>
<ul>
<li><p>保存现场</p>
</li>
<li><p>异常处理</p>
<ul>
<li>杀死产生异常的程序</li>
<li>重新执行异常指令</li>
</ul>
</li>
<li><p>恢复现场</p>
</li>
</ul>
</li>
</ul>
<h4 id="三-系统调用"><a href="#三-系统调用" class="headerlink" title="三. 系统调用"></a>三. 系统调用</h4><ul>
<li><p>应用程序调用<code>printf()</code>时，会触发系统调用<code>write()</code></p>
</li>
<li><p>操作系统提供很多 API 来进行系统调用</p>
</li>
<li><p>跨越操作系统边界需要支付额外的开销：</p>
<ul>
<li>建立中断&#x2F;异常&#x2F;系统调用号与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈</li>
<li>验证参数</li>
<li>内核态映射到用户态的地址空间</li>
<li>内核态独立地址空间</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【操作系统】第五章：虚拟内存</title>
    <url>/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h1><p>随着技术发展，程序对内存的需求越来越大</p>
<p>我们需要更大的内存更强的机器才能让软件跑起来</p>
<p><strong>程序规模的增长远大于存储器容量的增长速度</strong></p>
<p>需要让更多的程序跑在有限的内存里</p>
<p>理想中的存储器：</p>
<ul>
<li>更大</li>
<li>更快</li>
<li>更便宜</li>
<li>非易失性存储器</li>
</ul>
<img src="【操作系统】第五章：虚拟内存/image-20200419172905391.png" alt="image-20200419172905391" style="zoom: 80%;" />



<h1 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h1><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>在较小可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>把程序按照其自身逻辑结构，划分为若干功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行<ul>
<li>必要部分的代码和数据<strong>常驻内存</strong></li>
<li>可选部分在其他程序模块中实现，平时放在外存，<strong>需要时装入内存</strong></li>
<li>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖，<strong>即他们可以公用一个分区</strong></li>
</ul>
</li>
<li>例子：</li>
</ul>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200419174839065.png" alt="image-20200419174839065"></p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>coder 把一个大程序分为若干小功能模块并确定覆盖关系，费时费力，增加编程复杂度</li>
<li>覆盖模块实际上是<strong>时间换空间</strong></li>
</ul>
<h1 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h1><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>将暂时不能运行的程序送到外存</li>
<li>OS 将一个进程的地址空间保存到外存（<strong>换出</strong>），再将外存中某个进程的地址空间读入到内存（<strong>换入</strong>）。（换入换出大小是整个程序的地址空间）</li>
</ul>
<h3 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h3><ul>
<li><p>何时交换？</p>
<p>  内存不够或有不够的危险时</p>
</li>
<li><p>交换区的大小？</p>
<p>  必须足够大来存放所有用户进程的所有内存映像拷贝</p>
</li>
<li><p>换出再换入后地址需要一样嘛？</p>
<p>  最好采用动态地址映射的方法（建立页表）</p>
</li>
</ul>
<h3 id="交换与覆盖区别"><a href="#交换与覆盖区别" class="headerlink" title="交换与覆盖区别"></a>交换与覆盖区别</h3><p>交换发生在<strong>程序之间</strong>，不需要程序员操作</p>
<p>覆盖发生在<strong>程序之内</strong>，需要程序员！</p>
<h1 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h1><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><ul>
<li>覆盖技术：程序员负担大</li>
<li>交换技术：处理器开销大</li>
<li>充分解决覆盖技术与交换技术存在的问题</li>
</ul>
<h3 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h3><ul>
<li><p>程序的局部性原理：程序在执行过程中的一个较短时期，所执行的指令地址和指令操作数地址分别局限于一定区域</p>
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul>
  <img src="【操作系统】第五章：虚拟内存/image-20200419183544017.png" alt="image-20200419183544017" style="zoom:80%;" />

  <img src="【操作系统】第五章：虚拟内存/image-20200419183746684.png" alt="image-20200419183746684" style="zoom:80%;" /></li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200419184200800.png" alt="image-20200419184200800"></p>
<h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200419184449532.png" alt="image-20200419184449532"></p>
<h3 id="虚拟页式内存管理"><a href="#虚拟页式内存管理" class="headerlink" title="虚拟页式内存管理"></a>虚拟页式内存管理</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200419184621909.png" alt="image-20200419184621909"></p>
<p>hhh，偷懒直接截屏了~~~</p>
<ul>
<li>需要用到的功能：<ul>
<li>请求调页</li>
<li>页面置换</li>
</ul>
</li>
</ul>
<img src="【操作系统】第五章：虚拟内存/image-20200419185124939.png" alt="image-20200419185124939" style="zoom:80%;" />

<img src="【操作系统】第五章：虚拟内存/image-20200419185256585.png" alt="image-20200419185256585" style="zoom:80%;" />

<p><img src="【操作系统】第五章：虚拟内存/image-20200419185600279.png" alt="image-20200419185600279" style="zoom:80%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20200420122547152.png" alt="image-20200420122547152"></p>
<img src="【操作系统】第五章：虚拟内存/image-20200420122547152.png" alt="image-20200420122547152" style="zoom:80%;" />]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【操作系统】第八章：CPU调度</title>
    <url>/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li><p>在进程&#x2F;线程的生命周期中什么时候进行调度？</p>
<p>  在一个状态向另一个状态转换的时候会触发一次调度。</p>
</li>
<li><p>内核运行调度程序的条件</p>
<ul>
<li>一个进程从运行状态切换到等待状态</li>
<li>一个进程被终结了</li>
</ul>
</li>
<li><p>不可抢占</p>
<p>  调度程序必须等待事件结束</p>
<p>  （效率并不是很高）</p>
</li>
<li><p>可以抢占</p>
<p>  调度程序在中断被响应后执行</p>
<p>  当前程序从运行切换到就绪，或者一个进程从等待切换到就绪</p>
<p>  当前运行的进程可以被换出</p>
<p>  （现代操作系统常用的策略，效率较高）</p>
</li>
</ul>
<h1 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h1><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429090909424.png" alt="image-20200429090909424"></p>
<h3 id="程序执行模型"><a href="#程序执行模型" class="headerlink" title="程序执行模型"></a>程序执行模型</h3><ul>
<li><strong>CPU利用率</strong>：CPU处于忙状态所占时间的百分比</li>
<li><strong>吞吐量</strong>：在单位时间内完成的进程数量</li>
<li><strong>周转时间</strong>：一个进程从初始化到结束，包括所有<strong>等待时间</strong>所花的时间</li>
<li><strong>等待时间</strong>：进程在<strong>就绪队列</strong>中的总时间</li>
<li><strong>响应时间</strong>：从一个请求被提交到产生第一次响应所花费的时间</li>
</ul>
<h3 id="比较调度算法的准则"><a href="#比较调度算法的准则" class="headerlink" title="比较调度算法的准则"></a>比较调度算法的准则</h3><ul>
<li>更快的服务<ul>
<li>低延迟：喝水的时候想要打开水龙头就有水</li>
<li>高带宽：给游泳池冲水时希望从水龙头里<strong>同时</strong>流出<strong>大量</strong>的水，并且不介意是否存在延迟</li>
</ul>
</li>
<li>减少响应时间</li>
<li>减少平均响应时间的波动</li>
<li>增加吞吐量<ul>
<li>减少开销（操作系统开销，上下文切换）</li>
<li>系统资源高效利用（CPU、I&#x2F;O设备）</li>
</ul>
</li>
<li>减少等待时间</li>
</ul>
<h3 id="吞吐量-vs-延迟"><a href="#吞吐量-vs-延迟" class="headerlink" title="吞吐量 vs 延迟"></a>吞吐量 vs 延迟</h3><ul>
<li><p>吞吐量时操作系统的计算带宽</p>
</li>
<li><p>响应时间是是操作系统的计算延迟</p>
</li>
</ul>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h3 id="FCFS（先来先服务）"><a href="#FCFS（先来先服务）" class="headerlink" title="FCFS（先来先服务）"></a>FCFS（先来先服务）</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429093124676.png" alt="image-20200429093124676"></p>
<img src="【操作系统】第八章：CPU调度/image-20200429093307340.png" alt="image-20200429093307340" style="zoom:67%;" />

<h3 id="SPN-x2F-SJF-SRT（短进程优先）"><a href="#SPN-x2F-SJF-SRT（短进程优先）" class="headerlink" title="SPN&#x2F;SJF SRT（短进程优先）"></a>SPN&#x2F;SJF SRT（短进程优先）</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429093757961.png" alt="image-20200429093757961"></p>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429094338916.png" alt="image-20200429094338916"></p>
<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429094355350.png" alt="image-20200429094355350"></p>
<h3 id="HRRN（最高响应比优先）"><a href="#HRRN（最高响应比优先）" class="headerlink" title="HRRN（最高响应比优先）"></a>HRRN（最高响应比优先）</h3><img src="【操作系统】第八章：CPU调度/image-20200429094916767.png" alt="image-20200429094916767" style="zoom:67%;" />

<p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9ACPU%E8%B0%83%E5%BA%A6/image-20200429095315462.png" alt="image-20200429095315462">缓解了<strong>长程序</strong>可能产生的<strong>饥饿状态</strong></p>
<h3 id="Round-Robin（轮询）"><a href="#Round-Robin（轮询）" class="headerlink" title="Round Robin（轮询）"></a>Round Robin（轮询）</h3><img src="【操作系统】第八章：CPU调度/image-20200429095325005.png" alt="image-20200429095325005" style="zoom:67%;" />

<img src="【操作系统】第八章：CPU调度/image-20200429095342702.png" alt="image-20200429095342702" style="zoom:67%;" />

<img src="【操作系统】第八章：CPU调度/image-20200429100235462.png" alt="image-20200429100235462" style="zoom:67%;" />

<h3 id="Multilevel-Feedback-Queue（多级反馈队列）"><a href="#Multilevel-Feedback-Queue（多级反馈队列）" class="headerlink" title="Multilevel Feedback Queue（多级反馈队列）"></a>Multilevel Feedback Queue（多级反馈队列）</h3><img src="【操作系统】第八章：CPU调度/image-20200429100455259.png" alt="image-20200429100455259" style="zoom:67%;" />

<img src="【操作系统】第八章：CPU调度/image-20200429100552763.png" alt="image-20200429100552763" style="zoom:67%;" />

<h3 id="Fair-Share-Scheduling（公平共享调度）"><a href="#Fair-Share-Scheduling（公平共享调度）" class="headerlink" title="Fair Share Scheduling（公平共享调度）"></a>Fair Share Scheduling（公平共享调度）</h3><h1 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h1><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><ul>
<li>定义：正确性依赖于其时间和功能两方面的一种操作系统</li>
<li>性能指标：<ul>
<li>时间约束的及时性（deadline）</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>主要特性：时间约束的可预测性</li>
<li>分类：<ul>
<li>强实时系统：规定时间内必须完成</li>
<li>若实时系统：尽量完成</li>
</ul>
</li>
<li><img src="【操作系统】第八章：CPU调度/image-20200429101316653.png" alt="image-20200429101316653" style="zoom:67%;" /></li>
</ul>
<h3 id="可调度性"><a href="#可调度性" class="headerlink" title="可调度性"></a>可调度性</h3><h3 id="单调速率（RM）"><a href="#单调速率（RM）" class="headerlink" title="单调速率（RM）"></a>单调速率（RM）</h3><ul>
<li>最佳静态优先级调度</li>
<li>通过周期安排优先级</li>
<li>周期越短优先级越高</li>
<li>执行周期最短的任务</li>
</ul>
<h3 id="截止日期最早优先（EDF）"><a href="#截止日期最早优先（EDF）" class="headerlink" title="截止日期最早优先（EDF）"></a>截止日期最早优先（EDF）</h3><ul>
<li>最佳的动态优先级调度</li>
<li>Deadline越早优先级越高</li>
<li>执行Deadline最早的任务</li>
</ul>
<h1 id="多处理器调度与优先级反转"><a href="#多处理器调度与优先级反转" class="headerlink" title="多处理器调度与优先级反转"></a>多处理器调度与优先级反转</h1><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><img src="【操作系统】第八章：CPU调度/image-20200429101851018.png" alt="image-20200429101851018" style="zoom:67%;" />

<h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3><ul>
<li>优先级翻转是当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。</li>
</ul>
<img src="【操作系统】第八章：CPU调度/image-20200429102551017.png" alt="image-20200429102551017" style="zoom: 67%;" />

<img src="【操作系统】第八章：CPU调度/image-20200429102551017.png" alt="image-20200429102551017" style="zoom:67%;" />

<ul>
<li><p>解决方法：优先级继承、优先级天花板</p>
<ul>
<li><p>优先级继承：</p>
<p>  优先级继承是当任务A 申请共享资源S 时， 如果S正在被任务C 使用，通过比较任务C 与自身的优先级，如发现任务C 的优先级小于自身的优先级， 则将任务C的优先级提升到自身的优先级， 任务C 释放资源S 后，再恢复任务C 的原优先级。这种方法只在占有资源的低优先级任务阻塞了高优先级任务时才动态的改变任务的优先级，如果过程较复杂， 则需要进行判断。</p>
</li>
<li><p>优先级天花板：</p>
<p>  优先级天花板是当任务<strong>申请某资源</strong>时， 把<strong>该任务的优先级提升到可访问这个资源的所有任务中的最高优先级</strong>， 这个优先级称为该资源的优先级天花板。这种方法简单易行， 不必进行复杂的判断， 不管任务是否阻塞了高优先级任务的运行， 只要任务访问共享资源都会提升任务的优先级。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day1</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>寒假刚刚过去，暑假正式开始！</p>
<p>开始刷 LeetCode 的第一天，计划每天两小时，从简单题开始，到刷完为止（刷不完就一直刷~~~）</p>
<h3 id="1-一维数组的动态和"><a href="#1-一维数组的动态和" class="headerlink" title="1. 一维数组的动态和"></a>1. <a href="https://leetcode-cn.com/problems/running-sum-of-1d-array">一维数组的动态和</a></h3><h3 id="2-拥有最多糖果的孩子"><a href="#2-拥有最多糖果的孩子" class="headerlink" title="2. 拥有最多糖果的孩子"></a>2. <a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies">拥有最多糖果的孩子</a></h3><h3 id="3-重新排列数组"><a href="#3-重新排列数组" class="headerlink" title="3. 重新排列数组"></a>3. <a href="https://leetcode-cn.com/problems/shuffle-the-array">重新排列数组</a></h3><img src="【数据结构与算法】LeetCode：day1/image-20200621151446703.png" alt="image-20200621151446703" style="zoom:67%;" />

<h5 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h5><ol>
<li>引入一个<strong>空数组</strong>用于存放结果，使用<strong>两个指针</strong>分别指向原数组和新数组</li>
<li>指向原数组的指针每次加2，指向新数组的指针每次加1</li>
</ol>
<h5 id="我的代码："><a href="#我的代码：" class="headerlink" title="我的代码："></a>我的代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shuffle(<span class="type">int</span>[] nums, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n; i = i + <span class="number">2</span>, j++)&#123;</span><br><span class="line">            res[i] = nums[j];</span><br><span class="line">            res[i + <span class="number">1</span>] = nums[j + n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day1/image-20200621151957545.png" alt="image-20200621151957545" style="zoom:67%;" />

<p>时间复杂度为 O(n) ，然而只击败26%，有改进空间！</p>
<h5 id="更好的方法："><a href="#更好的方法：" class="headerlink" title="更好的方法："></a>更好的方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shuffle(<span class="type">int</span>[] nums, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            res[i * <span class="number">2</span>] = nums[i];</span><br><span class="line">            res[i * <span class="number">2</span> + <span class="number">1</span>] = nums[i+n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个指针是二倍的关系</strong>，完全可以用一个指针代替两个指针！</p>
<h3 id="4-1比特与2比特字符"><a href="#4-1比特与2比特字符" class="headerlink" title="4. 1比特与2比特字符"></a>4. <a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters">1比特与2比特字符</a></h3><img src="【数据结构与算法】LeetCode：day1/image-20200621162935088.png" alt="image-20200621162935088" style="zoom:67%;" />

<h5 id="我的思路：-1"><a href="#我的思路：-1" class="headerlink" title="我的思路："></a>我的思路：</h5><ol>
<li><p>设置布尔型变量 flag 来标记最后一个字符是否为一个比特，动态的进行判断</p>
</li>
<li><p>若字符数组长度为 1 则直接返回 true</p>
</li>
<li><p>否则进行判断：</p>
<ul>
<li>若上一次判断的结果是 false （两比特） ，则当前字符必定为一比特</li>
<li>若上一次判断结果为true （一比特）：<ul>
<li>若上一个字符为 0 ，则当前字符必定为一比特</li>
<li>若上一个字符为 1 ，则当前字符必定为两比特</li>
</ul>
</li>
</ul>
</li>
<li><p>返回 flag</p>
</li>
</ol>
<h5 id="我的代码：-1"><a href="#我的代码：-1" class="headerlink" title="我的代码："></a>我的代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOneBitCharacter</span><span class="params">(<span class="type">int</span>[] bits)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (bits.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; bits.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bits[i-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果：-1"><a href="#执行结果：-1" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day1/image-20200621163608741.png" alt="image-20200621163608741" style="zoom:67%;" />

<p>显然，在运行时间和内存消耗上都仍有较大改进空间！</p>
<p>康康大佬们是怎么做的</p>
<h5 id="更好的方法：-1"><a href="#更好的方法：-1" class="headerlink" title="更好的方法："></a>更好的方法：</h5><blockquote>
<p>我们可以对  <code>bits</code> 数组从左到右扫描来判断最后一位是否为一比特字符。当扫描到第 i 位时，如果 <code>bits[i] = 1</code>，那么说明这是一个两比特字符，将 i 的值增加 2。如果 <code>bits[i] = 0</code>，那么说明这是一个一比特字符，将 i 的值增加 1。</p>
<p>如果 i 最终落在了 <code>bits.length − 1</code> 的位置，那么说明最后一位一定是一比特字符。</p>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/solution/1bi-te-yu-2bi-te-zi-fu-by-leetcode/">https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/solution/1bi-te-yu-2bi-te-zi-fu-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOneBitCharacter</span><span class="params">(<span class="type">int</span>[] bits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bits.length - <span class="number">1</span>) &#123;</span><br><span class="line">            i += bits[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == bits.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>妙啊！</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day10</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday10/</url>
    <content><![CDATA[<h3 id="1-两个数组的交集-II"><a href="#1-两个数组的交集-II" class="headerlink" title="1. 两个数组的交集 II"></a>1. <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">两个数组的交集 II</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200713200853665.png" alt="image-20200713200853665" style="zoom:67%;" />

<h5 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h5><ol>
<li>使用 <code>HashMap</code> 将 <code>nums1</code> 中的元素加入到 map 中并统计所有数字出现的次数</li>
<li>遍历 <code>nums2</code>，若 <code>nums2</code> 中的元素在 map 中有，则将该元素加入到结果集中并且将 map 中该元素出现的次数减一</li>
<li>返回结果集</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 提高效率，遍历较小的数组，将其元素加入到 map 中</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2,nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums1) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums2) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[index++] = num;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(num, count);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h5><blockquote>
<p>如果两个数组是有序的，则可以便捷地计算两个数组的交集。</p>
<p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</p>
<p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span>[] intersection = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(length1, length2)];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intersection[index] = nums1[index1];</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="2-二叉树的最小深度"><a href="#2-二叉树的最小深度" class="headerlink" title="2. 二叉树的最小深度"></a>2. <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">二叉树的最小深度</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200713203100463.png" alt="image-20200713203100463" style="zoom: 67%;" />

<h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>使用递归，思路与求二叉树最大深度相似。</p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-杨辉三角"><a href="#3-杨辉三角" class="headerlink" title="3.  杨辉三角"></a>3. <a href="https://leetcode-cn.com/problems/pascals-triangle"> 杨辉三角</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200713205033766.png" alt="image-20200713205033766" style="zoom:67%;" />

<h5 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h5><p>每一行都基于前一行构造，顺的写即可</p>
<h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First base case; if user requests zero rows, they get zero rows.</span></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> triangle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Second base case; first row is always [1].</span></span><br><span class="line">        triangle.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        triangle.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rowNum</span> <span class="operator">=</span> <span class="number">1</span>; rowNum &lt; numRows; rowNum++) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; prevRow = triangle.get(rowNum-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The first row element is always 1.</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Each triangle element (other than the first and last of each row)</span></span><br><span class="line">            <span class="comment">// is equal to the sum of the elements above-and-to-the-left and</span></span><br><span class="line">            <span class="comment">// above-and-to-the-right.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; rowNum; j++) &#123;</span><br><span class="line">                row.add(prevRow.get(j-<span class="number">1</span>) + prevRow.get(j));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The last row element is always 1.</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            triangle.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> triangle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/pascals-triangle/solution/yang-hui-san-jiao-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h3 id="4-买卖股票的最佳时机"><a href="#4-买卖股票的最佳时机" class="headerlink" title="4.  买卖股票的最佳时机"></a>4. <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock"> 买卖股票的最佳时机</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200718150149049.png" alt="image-20200718150149049" style="zoom:67%;" />

<h5 id="解题方法一：暴力枚举法"><a href="#解题方法一：暴力枚举法" class="headerlink" title="解题方法一：暴力枚举法"></a>解题方法一：暴力枚举法</h5><p>使用 嵌套循环遍历数组，列出所有可能的收益，从中找到最大的作为结果返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有可能不做交易，因此结果的初始值设置为 0 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                res = Math.max(res, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：liweiwei1419</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="解题方法二：暴力算法的优化"><a href="#解题方法二：暴力算法的优化" class="headerlink" title="解题方法二：暴力算法的优化"></a>解题方法二：暴力算法的优化</h5><p>只需要关心之前看到的最低价格，用一个变量记录下之前的最低价格，这样可以省去内层循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示在当前位置之前的最小值，假设修正法（打擂台法）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 注意：这里从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res = Math.max(res, prices[i] - minVal);</span><br><span class="line">            minVal = Math.min(minVal, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：liweiwei1419</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/bao-li-mei-ju-dong-tai-gui-hua-chai-fen-si-xiang-b/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="5-环形链表"><a href="#5-环形链表" class="headerlink" title="5.  环形链表"></a>5. <a href="https://leetcode-cn.com/problems/linked-list-cycle"> 环形链表</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200718152847322.png" alt="image-20200718152847322" style="zoom:67%;" />

<h5 id="解体方法一：哈希表"><a href="#解体方法一：哈希表" class="headerlink" title="解体方法一：哈希表"></a>解体方法一：哈希表</h5><p>我们使用 <code>HashSet</code> 来存储每个访问过的节点的引用，如果该节点出现在 <code>HashSet</code> 中，则说明链表为环形链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="解题方法二：快慢指针"><a href="#解题方法二：快慢指针" class="headerlink" title="解题方法二：快慢指针"></a>解题方法二：快慢指针</h5><p>想象两个人跑圈子，如果一个人较快一个人较慢，则这两个人迟早会相遇</p>
<p>我们用快慢指针来代表这两个人，快指针每次后移两步，慢指针每次后移一步，如果两个指针相遇，则说明链表为环形链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="6-最小栈"><a href="#6-最小栈" class="headerlink" title="6.  最小栈"></a>6. <a href="https://leetcode-cn.com/problems/min-stack"> 最小栈</a></h3><img src="【数据结构与算法】LeetCode：day10/image-20200718162438484.png" alt="image-20200718162438484" style="zoom:67%;" />

<h5 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h5><p>更改底层数据结构，设计一个 <strong>MinStackNode</strong> 类，类中每个节点用来存放值和当前栈中的最小值。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    LinkedList&lt;MinStackNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * initialize your data structure here.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">preMin</span> <span class="operator">=</span> stack.getLast().min;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(x, preMin);</span><br><span class="line">            stack.add(<span class="keyword">new</span> <span class="title class_">MinStackNode</span>(x, min));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.add(<span class="keyword">new</span> <span class="title class_">MinStackNode</span>(x, x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.getLast().value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.getLast().min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStackNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStackNode</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> min)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.min = min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h5><p>设计一个辅助栈，用来保存最小值，如果 <code>pop()</code> 的值刚好是最小值，那么同时将辅助栈的栈顶也 <code>pop()</code> 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 先将 x 压入数据栈</span></span><br><span class="line">        dataStack.push(x);</span><br><span class="line">        <span class="comment">// 如果 x 是当前的最小值，则也需要将 x 压入辅助栈</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || x &lt;= minStack.peek()) &#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先删除数据栈的栈顶元素 x</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dataStack.pop();</span><br><span class="line">        <span class="comment">// 若 x 是当前的最小值，则也需要删除辅助栈的栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (x == minStack.peek()) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：sweetiee</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/min-stack/solution/3-chong-fang-fa-shi-xian-bi-xu-miao-dong-by-sweeti/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day11</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday11/</url>
    <content><![CDATA[<h3 id="1-相交链表"><a href="#1-相交链表" class="headerlink" title="1. 相交链表"></a>1. <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">相交链表</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200720175326197.png" alt="image-20200720175326197" style="zoom:67%;" />

<h5 id="思路一：暴力求解"><a href="#思路一：暴力求解" class="headerlink" title="思路一：暴力求解"></a>思路一：暴力求解</h5><p>对 <code>headA</code> 中的每一个节点，遍历 <code>headB</code> 中的每一个节点判断是否与其相等。</p>
<ul>
<li><p>时间复杂度：<code>O (mn)</code></p>
</li>
<li><p>空间复杂度：<code>O (1)</code></p>
</li>
</ul>
<h5 id="思路二：借助哈希表"><a href="#思路二：借助哈希表" class="headerlink" title="思路二：借助哈希表"></a>思路二：借助哈希表</h5><p>将 <code>headA</code> 中的节点存入一个 <code>HashSet</code> 中，如果 <code>headB</code> 中有节点在 <code>HashSet</code> 中，则说明该节点为交叉点</p>
<ul>
<li><p>时间复杂度：<code>O (m + n)</code></p>
</li>
<li><p>空间复杂度：<code>O (m) </code></p>
</li>
</ul>
<h5 id="思路三：浪漫双指针法"><a href="#思路三：浪漫双指针法" class="headerlink" title="思路三：浪漫双指针法"></a>思路三：浪漫双指针法</h5><p>创建两个指针分别指向 <code>headA</code> 、 <code>headB</code>，两个指针分别向前走，若相同则返回当前节点，若为空则指向另一条链表的头</p>
<blockquote>
<p>初看很难理解，但是细想就会发现很简单很巧妙 A和B两个链表长度可能不同，但是 A+B 和 B+A 的长度是相同的，所以遍历 A+B 和遍历 B+A 一定是同时结束。 如果A, B相交的话A和B有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点 如果A,B不相交的话两个指针就会同时到达 A+B（B+A）的尾节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)</span></span><br><span class="line"><span class="comment">        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="comment">// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头</span></span><br><span class="line">     	<span class="comment">// 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null</span></span><br><span class="line">        <span class="keyword">while</span>(pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：<code>O (m + n)</code></p>
</li>
<li><p>空间复杂度：<code>O (1) </code></p>
</li>
</ul>
<p>至于，为什么说他浪漫……</p>
<img src="【数据结构与算法】LeetCodee：day11/image-20200720180421830.png" alt="image-20200720180421830" style="zoom:67%;" />

<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCodee%EF%BC%9Aday11/image-20200720180447776.png" alt="image-20200720180447776"></p>
<h3 id="2-Excel表列名称"><a href="#2-Excel表列名称" class="headerlink" title="2.  Excel表列名称"></a>2. <a href="https://leetcode-cn.com/problems/excel-sheet-column-title"> Excel表列名称</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200720182149737.png" alt="image-20200720182149737" style="zoom:67%;" />

<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>Excel 表中相对应列的名称遵循 <strong>逢26进一</strong>  的原则，所以这题本质上考的是进制的转化！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            sb.append((<span class="type">char</span>)(n % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-Excel表列序号"><a href="#3-Excel表列序号" class="headerlink" title="3.  Excel表列序号"></a>3. <a href="https://leetcode-cn.com/problems/excel-sheet-column-number"> Excel表列序号</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200723170226918.png" alt="image-20200723170226918" style="zoom:67%;" />

<h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><p>与上题一致，主要考察进制的转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sum = sum * <span class="number">26</span> + (<span class="type">int</span>)(s.charAt(i) - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-多数元素"><a href="#4-多数元素" class="headerlink" title="4.  多数元素"></a>4. <a href="https://leetcode-cn.com/problems/majority-element/"> 多数元素</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200723160835580.png" alt="image-20200723160835580" style="zoom:67%;" />

<h5 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h5><p>使用 <code>HashMap</code> 存储每个数字出现的次数，当某个数字出现的次数大于 <code>n/2</code> 时，返回该数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(num) &gt; len / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCodee：day11/image-20200723161041959.png" alt="image-20200723161041959" style="zoom:67%;" />



<h5 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h5><p>对数组进行排序，排序后的数组的第 <code>n/2</code> 个元素一定是众数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>算法题应该考验<strong>算法设计能力</strong>，而不是调用现成 api 的能力，故这种方法<strong>不推荐使用</strong>！</p>
<h5 id="最优的思路：Boyer-Moore-投票算法"><a href="#最优的思路：Boyer-Moore-投票算法" class="headerlink" title="最优的思路：Boyer-Moore 投票算法"></a>最优的思路：Boyer-Moore 投票算法</h5><p>如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 <code>0</code>，从结果本身我们可以看出众数比其他数多。</p>
<p>从第一个数开始count&#x3D;1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maj</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == maj) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    maj = nums[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCodee：day11/image-20200723163229747.png" alt="image-20200723163229747" style="zoom:67%;" />



<h3 id="5-阶乘后的零"><a href="#5-阶乘后的零" class="headerlink" title="5. 阶乘后的零"></a>5. <a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes">阶乘后的零</a></h3><img src="【数据结构与算法】LeetCodee：day11/image-20200723170428188.png" alt="image-20200723170428188" style="zoom:67%;" />

<h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><p>按一般思路：先求出 n 的阶乘，如何再计算阶乘结果中末尾 0 的个数。然而这样做不能满足时间复杂度的要求</p>
<blockquote>
<p>不可能去直接计算阶乘的结果看看有多少个0.</p>
<p>可以直接发现，尾数要为0，看看阶承中的数有多少个相乘后可以为10.</p>
<p>比如 5！：可以2*5.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10！：可以2*5，1*10，其中10又可以拆分为2*5.</span><br></pre></td></tr></table></figure>

<p>说4*5也可以，不过我们要的是最小的因数.</p>
<p>那么就转为寻找一个阶乘有多少个2和多少个5</p>
<p>拿20！来分析：[1<em>10, 2</em>5, 4<em>15, 5</em>6] 即：[1<em>2</em>5, 2<em>5, 2</em>2<em>5</em>3, 5<em>2</em>3]</p>
<p>再来个30！：[1<em>10, 2</em>5, 4<em>15, 5</em>6, 随便一个数<em>20, 25</em>8, 30<em>随便一个数]，即：[1</em>2<em>5, 2</em>5, 2<em>2</em>5<em>3, <em>2</em>2</em>5, 5<em>5</em>2<em>2</em>2, 2<em>5</em>3]</p>
<p>可以看出2总是比5多，那看看多少个5是不是就是多少个0</p>
<p>20!的结果为2432902008176640000，有4个0刚好跟有4个5相同</p>
<p>30！265252859812191058636308480000000有7个0,刚好也有7个5，所以可以证明</p>
<p>只需要看给定的数中有多少个5或者5的倍数就行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n / <span class="number">5</span> + trailingZeroes(n / <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day13</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday13/</url>
    <content><![CDATA[<h3 id="1-颠倒二进制位"><a href="#1-颠倒二进制位" class="headerlink" title="1. 颠倒二进制位"></a>1. <a href="https://leetcode-cn.com/problems/reverse-bits/">颠倒二进制位</a></h3><img src="【数据结构与算法】LeetCode：day13/image-20200725101830752.png" alt="image-20200725101830752" style="zoom:67%;" />

<h5 id="解法一：调用-api"><a href="#解法一：调用-api" class="headerlink" title="解法一：调用 api"></a>解法一：调用 api</h5><p>使用 Integer 现成的 api 翻转二进制位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.reverse(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐这种做法，但是我们可以深究一步，看看 <code>Integer.reverse()</code> 方法究竟是怎样实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Figure 7-1</span></span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">    ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来花里胡哨，经过简单了解，该方法是使用了分治思想，反转左右16位，然后反转每个16位中的左右8位，依次类推，最后反转2位，反转后合并即可，同时可以利用位运算在原地反转。</p>
<p>暂时不做深究……</p>
<ul>
<li>时间复杂度：O (1)</li>
<li>空间复杂度：O (1)</li>
</ul>
<h5 id="解法二：取模求和"><a href="#解法二：取模求和" class="headerlink" title="解法二：取模求和"></a>解法二：取模求和</h5><blockquote>
<p>与反转十进制整数使用取模除十累加的方法类似，</p>
<p>十进制：<code>ans = ans * 10 + n % 10;</code> </p>
<p>​				<code>n = n / 10;</code><br>二进制：<code>ans = ans * 2 + n % 2;</code> </p>
<p>​				<code>n = n / 2;</code><br>但是，仅仅使用这种写法，会有一些问题，比如都<strong>要考虑是否整型溢出</strong>，Java的整数溢出后的二进制数会表示成负数（补码形式），Java中负数除以2会向零取整</p>
<p>然后还要考虑前导零，因为十进制是不考虑前面是否还有零的，比如100反转后就是1，不用写成001，而二进制要考虑前导零的问题。</p>
<p>所以综上所述，<strong>要使用位运算来避免溢出问题</strong>，同时循环32次。</p>
<p>因为一共只有32位，所以时间复杂度和空间复杂度都是O(1)。</p>
<p>作者：lartecy<br>链接：<a href="https://leetcode-cn.com/problems/reverse-bits/solution/zhi-qi-ran-zhi-qi-suo-yi-ran-wei-yun-suan-jie-fa-x/">https://leetcode-cn.com/problems/reverse-bits/solution/zhi-qi-ran-zhi-qi-suo-yi-ran-wei-yun-suan-jie-fa-x/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<img src="【数据结构与算法】LeetCode：day13/image-20200725105110797.png" alt="image-20200725105110797" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// res &lt;&lt; 1：左移一位，相当于十进制中的 *10</span></span><br><span class="line">            <span class="comment">// n &amp; 1：取最后一位，相当于十进制中的 %10</span></span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) | (n &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// n 右移一位，相当于十进制中 /10</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O (1)</li>
<li>空间复杂度：O (1)</li>
</ul>
<h3 id="2-位1的个数"><a href="#2-位1的个数" class="headerlink" title="2. 位1的个数"></a>2. <a href="https://leetcode-cn.com/problems/number-of-1-bits/">位1的个数</a></h3><img src="【数据结构与算法】LeetCode：day13/image-20200725112200386.png" alt="image-20200725112200386" style="zoom:67%;" />

<h5 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h5><p>受 <a href="https://leetcode-cn.com/problems/reverse-bits">颠倒二进制位</a>  启发，使用 <code>n &amp; 1</code> 取出最后一位，若为1则 <code>count++</code>，然后将n右移，如此循环32次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) count++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="其他思路：位操作的小技巧"><a href="#其他思路：位操作的小技巧" class="headerlink" title="其他思路：位操作的小技巧"></a>其他思路：位操作的小技巧</h5><blockquote>
<p>我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 0 的时候偶，我们就知道它没有 1 的位了，此时返回答案。</p>
<p>这里关键的想法是对于任意数字 n ，将 n 和 n−1 做与运算，会把最后一个 1 的位变成 0 。为什么？考虑 n 和 n−1 的二进制表示。</p>
<p>在二进制表示中，数字 n 中最低位的 1 总是对应 n−1 中的 0 。因此，<strong>将 n 和 n−1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变</strong>。</p>
<p>使用这个小技巧，代码变得非常简单。</p>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode/">https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<img src="https://pic.leetcode-cn.com/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png" alt="image.png" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="3-打家劫舍"><a href="#3-打家劫舍" class="headerlink" title="3. 打家劫舍"></a>3. <a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h3><img src="【数据结构与算法】LeetCode：day13/image-20200725160055131.png" alt="image-20200725160055131" style="zoom:67%;" />

<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><blockquote>
<p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p>
<p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k (k&gt;2) 间房屋，有两个选项：</p>
<p>偷窃第 k 间房屋，那么就不能偷窃第 <code>k−1</code> 间房屋，偷窃总金额为前 <code>k−2</code> 间房屋的最高总金额与第 kk 间房屋的金额之和。</p>
<p>不偷窃第 k 间房屋，偷窃总金额为前 <code>k−1</code> 间房屋的最高总金额。</p>
<p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。</p>
<p>用 <code>dp[i]</code> 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p>
<p><code>dp[i]=max(dp[i−2]+nums[i],dp[i−1])</code></p>
<p>边界条件为：</p>
<p><code>dp[0] = nums[0]</code>  只有一间房屋，则偷窃该房屋 </p>
<p><code>dp[1] = max(nums[0], nums[1])</code> 只有两间房屋，选择其中金额较高的房屋进行偷窃</p>
<p>只有一间房屋，则偷窃该房屋<br>只有两间房屋，选择其中金额较高的房屋进行偷窃</p>
<p>最终的答案即为 <code>dp[n−1]</code>，其中 <code>n</code> 是数组的长度。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/">https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<img src="https://assets.leetcode-cn.com/solution-static/198/1.PNG" alt="img" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/">https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> second;</span><br><span class="line">            second = Math.max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day12</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday12/</url>
    <content><![CDATA[<h3 id="1-组合两个表"><a href="#1-组合两个表" class="headerlink" title="1. 组合两个表"></a>1. <a href="https://leetcode-cn.com/problems/combine-two-tables">组合两个表</a></h3><img src="【数据结构与算法】LeetCode：day12/image-20200724091409976.png" alt="image-20200724091409976" style="zoom:67%;" />

<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><blockquote>
<p>因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。</p>
<p>考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。</p>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/combine-two-tables/solution/zu-he-liang-ge-biao-by-leetcode/">https://leetcode-cn.com/problems/combine-two-tables/solution/zu-he-liang-ge-biao-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select p.FirstName, p.LastName, a.City, a. State</span><br><span class="line">from Person p</span><br><span class="line">left join Address a</span><br><span class="line">on p.PersonId = a.PersonId;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day12/image-20200724091642420.png" alt="image-20200724091642420" style="zoom:67%;" />





<h3 id="2-第二高的薪水"><a href="#2-第二高的薪水" class="headerlink" title="2. 第二高的薪水"></a>2. <a href="https://leetcode-cn.com/problems/second-highest-salary/">第二高的薪水</a></h3><img src="【数据结构与算法】LeetCode：day12/image-20200724092500972.png" alt="image-20200724092500972" style="zoom:67%;" />

<h5 id="解题方法一：使用子查询和-LIMIT-子句"><a href="#解题方法一：使用子查询和-LIMIT-子句" class="headerlink" title="解题方法一：使用子查询和 LIMIT 子句"></a>解题方法一：使用子查询和 LIMIT 子句</h5><blockquote>
<p>将不同的薪资按降序排序，然后使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"><code>LIMIT</code></a> 子句获得第二高的薪资。</p>
<p>然而，如果没有这样的第二最高工资，这个解决方案将被判断为 “错误答案”，因为本表可能只有一项记录。为了克服这个问题，我们可以将其作为临时表。</p>
<p>如果查询结果为 null，原本将返回空数据，建立临时表后变为：<code>select null</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    (SELECT DISTINCT</span><br><span class="line">            Salary</span><br><span class="line">        FROM</span><br><span class="line">            Employee</span><br><span class="line">        ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1) </span><br><span class="line">AS SecondHighestSalary</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">#作者：LeetCode</span><br><span class="line">#链接：https://leetcode-cn.com/problems/second-highest-salary/solution/di-er-gao-de-xin-shui-by-leetcode/</span><br><span class="line">#来源：力扣（LeetCode）</span><br><span class="line">#著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>解题方法二：使用 <code>IFNULL</code> 和 <code>LIMIT</code> 子句</p>
<blockquote>
<p>解决 “NULL” 问题的另一种方法是使用 “IFNULL” 函数，如下所示。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    IFNULL(</span><br><span class="line">      (SELECT DISTINCT Salary</span><br><span class="line">       FROM Employee</span><br><span class="line">       ORDER BY Salary DESC</span><br><span class="line">        LIMIT 1 OFFSET 1),</span><br><span class="line">    NULL) </span><br><span class="line">AS SecondHighestSalary</span><br><span class="line"></span><br><span class="line">#作者：LeetCode</span><br><span class="line">#链接：https://leetcode-cn.com/problems/second-highest-salary/solution/di-er-gao-de-xin-shui-by-leetcode/</span><br><span class="line">#来源：力扣（LeetCode）</span><br><span class="line">#著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h3 id="3-两数之和-II-输入有序数组"><a href="#3-两数之和-II-输入有序数组" class="headerlink" title="3. 两数之和 II - 输入有序数组"></a>3. <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></h3><img src="【数据结构与算法】LeetCode：day12/image-20200724101739403.png" alt="image-20200724101739403" style="zoom:67%;" />

<h5 id="解法一：二分查找"><a href="#解法一：二分查找" class="headerlink" title="解法一：二分查找"></a>解法一：二分查找</h5><p>在本题中，我们可以先固定一个值 <code>num</code>，然后再使用二分查找找 <code>target - num</code></p>
<p>充分利用了题目中所给的<strong>数组是有序数组</strong>的条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 固定一个值 num</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> numbers[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 二分查找 target - num</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (numbers[mid] == target - num) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i + <span class="number">1</span>, mid + <span class="number">1</span>&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; target - num) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O (n logn) </li>
<li>空间复杂度：O (1)</li>
</ul>
<h5 id="解法二：Map"><a href="#解法二：Map" class="headerlink" title="解法二：Map"></a>解法二：Map</h5><p>我们可以把数组的元素存储到Map中，然后再查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] num, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(num.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(target - num[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - num[i]) + <span class="number">1</span>, i + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(num[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：sdwwld</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/javashuang-zhi-zhen-qiu-jie-by-sdwwld/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O (n) </li>
<li>空间复杂度：O (n)</li>
</ul>
<h5 id="解法三：双指针法（最优解）"><a href="#解法三：双指针法（最优解）" class="headerlink" title="解法三：双指针法（最优解）"></a>解法三：双指针法（最优解）</h5><p>使用两个指针分别指向数组的头尾，将指针指向的值的和 <code>sum</code> 与 <code>target</code> 作比较：</p>
<ul>
<li><code>sum &lt; target</code> ：<code>left++</code></li>
<li><code>sum = target：</code>：<code>return new int[]&#123;left + 1. right + 1&#125;</code></li>
<li><code>sum &gt; target</code>： <code>right++</code></li>
</ul>
<p>充分利用了题目中所给的<strong>数组是有序数组</strong>的条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[i] + numbers[j];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：CyC2018</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/shuang-zhi-zhen-on-shi-jian-fu-za-du-by-cyc2018/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O (n) </li>
<li>空间复杂度：O (1)</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day14</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday14/</url>
    <content><![CDATA[<h1 id="1-判断子序列"><a href="#1-判断子序列" class="headerlink" title="1. 判断子序列"></a>1. <a href="https://leetcode-cn.com/problems/is-subsequence/">判断子序列</a></h1><img src="【数据结构与算法】LeetCode：day14/image-20200727092718611.png" alt="image-20200727092718611" style="zoom:80%;" />

<h3 id="我的思路：双指针"><a href="#我的思路：双指针" class="headerlink" title="我的思路：双指针"></a>我的思路：双指针</h3><p>建立两个指针 i，j，分别指向 s 和 t</p>
<ul>
<li>当 <code>s.charAt(i) == t.charAt(j)</code> 时，两个指针均向后移动一位</li>
<li>否则，只将 j 后移一位</li>
</ul>
<p>循环结束后，如果 i 等于 s 的长度，说明指针遍历过整个字符串 s，均找到 t 中与之相等的字母，故返回 <code>true</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == s.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day14/image-20200727093155189.png" alt="image-20200727093155189" style="zoom:80%;" />

<h3 id="更快的方法"><a href="#更快的方法" class="headerlink" title="更快的方法"></a>更快的方法</h3><p>遍历 s 中的字符，用 <code>t.indexOf()</code> 方法查询字符串 t 中是否含有该字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="comment">// 第一个参数：要查找的字符</span></span><br><span class="line">            <span class="comment">// 第二个参数：查找的起始位置</span></span><br><span class="line">            index = t.indexOf(c, index+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// indexOf() 如果没找到，则返回 -1</span></span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-快乐数"><a href="#2-快乐数" class="headerlink" title="2. 快乐数"></a>2. <a href="https://leetcode-cn.com/problems/happy-number/">快乐数</a></h1><img src="【数据结构与算法】LeetCode：day14/image-20200727100806469.png" alt="image-20200727100806469" style="zoom:80%;" />

<h3 id="我的思路：递归（失败）"><a href="#我的思路：递归（失败）" class="headerlink" title="我的思路：递归（失败）"></a>我的思路：递归（失败）</h3><p>求出 n 的下一个数 next ，带入函数 <code>isHappy(next)</code></p>
<p>存在问题：无法确定返回 <code>false</code> 的条件，如果结果是 <code>true</code> 则可直接返回，是 <code>false</code> 将出现 <code>StackOverflowError</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            res += (temp * temp);</span><br><span class="line">            n /= <span class="number">10</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> isHappy(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day14/image-20200727101111995.png" alt="image-20200727101111995" style="zoom: 80%;" />



<h3 id="官方思路一：HashSet检测循环"><a href="#官方思路一：HashSet检测循环" class="headerlink" title="官方思路一：HashSet检测循环"></a>官方思路一：HashSet检测循环</h3><p>直接贴代码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照规则求出 n 的下一个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 如果 set 中包含 n ，则说明进入了循环</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !seen.contains(n)) &#123;</span><br><span class="line">            seen.add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="官方思路二：快慢指针检测循环"><a href="#官方思路二：快慢指针检测循环" class="headerlink" title="官方思路二：快慢指针检测循环"></a>官方思路二：快慢指针检测循环</h3><p>直接贴代码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照规则求出 n 的下一个数</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowRunner</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fastRunner</span> <span class="operator">=</span> getNext(n);</span><br><span class="line">        <span class="comment">// 慢指针移动一次，快指针移动两次</span></span><br><span class="line">        <span class="comment">// 当快指针和慢指针相同时，说明进入了循环</span></span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="3-移除链表元素"><a href="#3-移除链表元素" class="headerlink" title="3. 移除链表元素"></a>3. <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">移除链表元素</a></h1><img src="【数据结构与算法】LeetCode：day14/image-20200727103654392.png" alt="image-20200727103654392" style="zoom:80%;" />

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置一个哨兵节点，哨兵节点的 <code>next</code> 指向头节点</p>
<p>设置一个 <code>pre</code> 节点，记录当前节点 <code>cur</code> 的上一个节点</p>
<ul>
<li>当 <code>cur.val == val</code>：<code>pre.next = cur.next</code></li>
<li>否则：<code>pre = cur</code></li>
</ul>
<p><code>cur</code> 指向下一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        sentinel.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> sentinel, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == val) pre.next = cur.next;</span><br><span class="line">            <span class="keyword">else</span> pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-计数质数"><a href="#4-计数质数" class="headerlink" title="4. 计数质数"></a>4. <a href="https://leetcode-cn.com/problems/count-primes/">计数质数</a></h1><img src="【数据结构与算法】LeetCode：day14/image-20200727105615429.png" alt="image-20200727105615429" style="zoom: 80%;" />

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>如求10之内的质数，首先列出2~N-1的所有数，如果当前数为质数，则其倍数就是质数，如</p>
<p>第一个质数为2，在2上画圈，其倍数4&#x2F;6&#x2F;8不是质数，划掉4&#x2F;6&#x2F;8，继续遍历<br>下一个质数为3，在3上画圈，其倍数6&#x2F;9不是质数，划掉6&#x2F;9，继续遍历<br>下一个质数为5，在5上画圈，没有倍数，继续遍历<br>下一个质数为7，在7上画圈，没有倍数，继续遍历。<br>最后再次遍历整个数组，画圈的数字就是质数，即2,3,5,7</p>
<p>转换为代码就是如果需要求&lt;n的所有质数个数，则创建一个长度为n的整数数组，所有元素值变为1，1表示对应的索引值为质数，0表示对应的索引值为非质数。从2开始遍历，如果当前数字值为1，则获取其所有倍数，将元素值变为0（标记为非质数）。遍历完成后再次遍历数组，从2开始，记录元素为1的个数，即为对应的质数个数。</p>
<p>作者：mmmmmJCY<br>链接：<a href="https://leetcode-cn.com/problems/count-primes/solution/e-la-duo-sai-shai-fa-qiu-zhi-shu-java-by-zxy0917/">https://leetcode-cn.com/problems/count-primes/solution/e-la-duo-sai-shai-fa-qiu-zhi-shu-java-by-zxy0917/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//如果当前数为质数</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//将对应数的倍数变为0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; i * j &lt; n; j++) &#123;</span><br><span class="line">                nums[i * j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组，统计值为1的元素个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：mmmmmJCY</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/count-primes/solution/e-la-duo-sai-shai-fa-qiu-zhi-shu-java-by-zxy0917/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day15</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday15/</url>
    <content><![CDATA[<h1 id="1-同构字符串"><a href="#1-同构字符串" class="headerlink" title="1. 同构字符串"></a>1. <a href="https://leetcode-cn.com/problems/isomorphic-strings/">同构字符串</a></h1><img src="【数据结构与算法】LeetCode：day15/image-20200730113921873.png" alt="image-20200730113921873" style="zoom:80%;" />

<h3 id="思路一：调用-api"><a href="#思路一：调用-api" class="headerlink" title="思路一：调用 api"></a>思路一：调用 api</h3><p>遍历字符串 s 和字符串 t 中的每一个元素，如果每个元素第一次出现的位置都相同，则两个字符串为同构字符串（不推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.indexOf(s.charAt(i)) != t.indexOf(t.charAt(i))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路二：HashMap-建立映射关系"><a href="#思路二：HashMap-建立映射关系" class="headerlink" title="思路二：HashMap 建立映射关系"></a>思路二：HashMap 建立映射关系</h3><p>两个字符串同构的含义就是字符串 <code>s</code> 可以唯一的映射到 <code>t</code> ，同时 <code>t</code> 也可以唯一的映射到 <code>s</code> </p>
<p>使用 HashMap，存入两个字符串中相映射的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">egg 和 add 同构，就意味着下边的映射成立</span><br><span class="line">e -&gt; a</span><br><span class="line">g -&gt; d</span><br><span class="line">也就是将 egg 的 e 换成 a, g 换成 d, 就变成了 add</span><br><span class="line"></span><br><span class="line">同时倒过来也成立</span><br><span class="line">a -&gt; e</span><br><span class="line">d -&gt; g</span><br><span class="line">也就是将 add 的 a 换成 e, d 换成 g, 就变成了 egg</span><br><span class="line"></span><br><span class="line">foo 和 bar 不同构，原因就是映射不唯一</span><br><span class="line">o -&gt; a</span><br><span class="line">o -&gt; r</span><br><span class="line">其中 o 映射到了两个字母</span><br><span class="line"></span><br><span class="line">作者：windliang</span><br><span class="line">链接：https://leetcode-cn.com/problems/isomorphic-strings/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-42/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要同时验证 s-&gt;t、t-&gt;s</span></span><br><span class="line">        <span class="keyword">return</span> isIsomorphicHelper(s, t) &amp;&amp; isIsomorphicHelper(t, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphicHelper</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                map.put(s.charAt(i), t.charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(s.charAt(i)) != t.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2. 反转链表"></a>2. <a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></h1><img src="【数据结构与算法】LeetCode：day15/image-20200730134355893.png" alt="image-20200730134355893" style="zoom:80%;" />

<h3 id="法一：迭代法"><a href="#法一：迭代法" class="headerlink" title="法一：迭代法"></a>法一：迭代法</h3><p>设置一个指针 cur 指向当前节点，设置一个指针 pre 指向当前节点的前一个节点</p>
<p>遍历链表：</p>
<ul>
<li>用临时变量 next 保存当前节点的下一个节点</li>
<li>当前节点下一个节点 &#x3D; pre</li>
<li>cur 变成 pre</li>
<li>next 变成 cur</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O*(*n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="法二：递归法"><a href="#法二：递归法" class="headerlink" title="法二：递归法"></a>法二：递归法</h3><p>稍微有点复杂，可以参考以下回答</p>
<img src="【数据结构与算法】LeetCode：day15/image-20200730135834374.png" alt="image-20200730135834374" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="3-存在重复元素-II"><a href="#3-存在重复元素-II" class="headerlink" title="3. 存在重复元素 II"></a>3. <a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">存在重复元素 II</a></h1><img src="【数据结构与算法】LeetCode：day15/image-20200903164806929.png" alt="image-20200903164806929" style="zoom:80%;" />

<h3 id="思路：滑动窗口"><a href="#思路：滑动窗口" class="headerlink" title="思路：滑动窗口"></a>思路：滑动窗口</h3><blockquote>
<p>用散列表来维护这个 k 大小的<strong>滑动窗口</strong>。</p>
<p>在之前的方法中，我们知道了对数时间复杂度的 搜索 操作是不够的。在这个方法里面，我们需要一个支持在常量时间内完成 <strong>搜索</strong>，<strong>删除</strong>，<strong>插入</strong> 操作的数据结构，那就是散列表。这个算法的实现跟方法二几乎是一样的。</p>
<p>遍历数组，对于每个元素做以下操作：<br>在散列表中搜索当前元素，如果找到了就返回 <code>true</code>。<br>在散列表中插入当前元素。<br>如果当前散列表的大小超过了 kk， 删除散列表中最旧的元素。<br>返回 false。</p>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode/">https://leetcode-cn.com/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-用队列实现栈"><a href="#4-用队列实现栈" class="headerlink" title="4. 用队列实现栈"></a>4. <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">用队列实现栈</a></h1><img src="【数据结构与算法】LeetCode：day15/image-20200730151552931.png" alt="image-20200730151552931" style="zoom: 80%;" />

<h3 id="思路：使用双队列"><a href="#思路：使用双队列" class="headerlink" title="思路：使用双队列"></a>思路：使用双队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q1;		<span class="comment">// 输入队列</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; q2;		<span class="comment">// 输出队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        q1.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!q2.isEmpty()) &#123;</span><br><span class="line">            q1.offer(q2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Queue</span> <span class="variable">temp</span> <span class="operator">=</span> q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q2.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【操作系统】第四章：非连续式内存分布</title>
    <url>/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<p> <strong>非连续内存分配优点</strong></p>
<ul>
<li>一个程序的物理地址是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码与数据</li>
<li>支持动态加载和动态链接</li>
</ul>
<p><strong>潜在问题</strong></p>
<ul>
<li>如何建立虚拟地址与物理地址之间的转换<ul>
<li>软件方案</li>
<li>硬件方案<ul>
<li>分段</li>
<li>分页</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><h3 id="程序的分段地址空间"><a href="#程序的分段地址空间" class="headerlink" title="程序的分段地址空间"></a>程序的分段地址空间</h3><ul>
<li>将逻辑地址空间分成各个块</li>
</ul>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418141948265.png" alt="image-20200418141948265" style="zoom:50%;" />

<ul>
<li>如下图，需要一种运行机制，来使<strong>逻辑地址空间</strong>与<strong>物理地址空间</strong>之间有对应的<strong>关联</strong></li>
</ul>
<p><img src="【操作系统】第四章：非连续式内存分布/image-20200418142034374.png" alt="image-20200418142034374" style="zoom:50%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200418142254435.png" alt="image-20200418142254435"></p>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418142312648.png" alt="image-20200418142312648" style="zoom:50%;" />



<h3 id="分段寻址方案"><a href="#分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h3><ul>
<li><p>两种实现方案：</p>
<ul>
<li><p>段寄存器 + 地址寄存器：将段号和段内偏移分开放置</p>
</li>
<li><p>单地址实现方案：将段号和段内偏移放在一起</p>
</li>
</ul>
</li>
</ul>
<p><img src="【操作系统】第四章：非连续式内存分布/image-20200418142553901.png" alt="image-20200418142553901" style="zoom:50%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200418143008669.png" alt="image-20200418143008669"></p>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418143028307.png" alt="image-20200418143028307" style="zoom:50%;" />



<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><ul>
<li>现在CPU主要使用分页方式</li>
</ul>
<h3 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h3><ul>
<li><p>与分段方式相似，同样拥有页号和偏移</p>
</li>
<li><p>不同之处在于分段中<strong>段的大小可变</strong>，而分页中<strong>页的大小固定的</strong></p>
</li>
<li><p>帧（frame）和页（page）：</p>
<ul>
<li><p>划分<strong>物理内存</strong>至固定大小的<strong>帧</strong>：大小是2的幂次方</p>
  <img src="【操作系统】第四章：非连续式内存分布/image-20200418144103065.png" alt="image-20200418144103065" style="zoom:50%;" />

  <img src="【操作系统】第四章：非连续式内存分布/image-20200418144606645.png" alt="image-20200418144606645" style="zoom:50%;" />
</li>
<li><p>划分<strong>逻辑地址空间</strong>至相同大小的<strong>页</strong>：大小也是2的幂次方</p>
  <img src="【操作系统】第四章：非连续式内存分布/image-20200418145629651.png" alt="image-20200418145629651" style="zoom:50%;" />

  <img src="【操作系统】第四章：非连续式内存分布/image-20200418145930471.png" alt="image-20200418145930471" style="zoom:50%;" />

  

<p>  依据逻辑地址的页号到页表中查询出物理地址的帧号</p>
</li>
</ul>
</li>
<li><p>建立方案转化逻辑地址为物理地址（pages to frames）</p>
</li>
</ul>
<h3 id="页的寻址方案"><a href="#页的寻址方案" class="headerlink" title="页的寻址方案"></a>页的寻址方案</h3><img src="【操作系统】第四章：非连续式内存分布/image-20200418150212728.png" alt="image-20200418150212728" style="zoom:50%;" />

<h1 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>页表其实就是一个<strong>大数组</strong>，索引代表的是 page_number，索引对应的值存的是 frame_number</p>
  <img src="【操作系统】第四章：非连续式内存分布/image-20200418150738864.png" alt="image-20200418150738864" style="zoom:50%;" /></li>
</ul>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418151533051.png" alt="image-20200418151533051" style="zoom: 80%;" />

<ul>
<li>存在问题：访问一个内存单元需要两次访问内存，存在性能问题<ul>
<li>一次获取页表项</li>
<li>一次用于访问数据</li>
</ul>
</li>
</ul>
<h3 id="TLB（Translation-Look-aside-Buffer）"><a href="#TLB（Translation-Look-aside-Buffer）" class="headerlink" title="TLB（Translation Look-aside Buffer）"></a>TLB（Translation Look-aside Buffer）</h3><ul>
<li>缓存近期访问的页帧转换表项<ul>
<li>TLB使用关联内存（速度快容量小）实现，具备快速访问性能</li>
<li>如果查到，则物理帧号可以被快速获取</li>
<li>如果查不到，就在页表中进行查找然后将内容更新到TLB</li>
</ul>
</li>
</ul>
<h3 id="二级、多级页表（时间换空间）"><a href="#二级、多级页表（时间换空间）" class="headerlink" title="二级、多级页表（时间换空间）"></a>二级、多级页表（时间换空间）</h3><ul>
<li>会增加时间开销</li>
<li>省下空间（一级页表中的保留位为0，二级页表就不需要留位置了）</li>
</ul>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418153639436.png" alt="image-20200418153639436" style="zoom: 67%;" />

<img src="【操作系统】第四章：非连续式内存分布/image-20200418153843016.png" alt="image-20200418153843016" style="zoom:67%;" />

<h3 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h3><ul>
<li>大地址空间问题：<ul>
<li>有大地址空间，向前映射页表变得繁琐（5级页表）</li>
<li>不是让页表与逻辑地址空间的大小相对应，而是让页表与物理地址空间的大小相对于（虚拟地址空间增长速度快于物理地址空间）</li>
</ul>
</li>
</ul>
<p><img src="【操作系统】第四章：非连续式内存分布/image-20200418155010474.png" alt="image-20200418155010474" style="zoom: 67%;" /><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/image-20200418155148496.png" alt="image-20200418155148496"></p>
<img src="【操作系统】第四章：非连续式内存分布/image-20200418155557962.png" alt="image-20200418155557962" style="zoom:67%;" />]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day17</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday17/</url>
    <content><![CDATA[<h1 id="1-回文链表"><a href="#1-回文链表" class="headerlink" title="1. 回文链表"></a>1. <a href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表</a></h1><img src="【数据结构与算法】LeetCode：day17/image-20200801140012736.png" alt="image-20200801140012736" style="zoom:80%;" />

<h3 id="思路一：使用数组"><a href="#思路一：使用数组" class="headerlink" title="思路一：使用数组"></a>思路一：使用数组</h3><p>由于链表只能单向访问，故我们可以将链表中的值先保存到 <code>List</code> 中，再使用双指针分别指向 <code>List</code> 的头尾来依次判断对应元素是否相等</p>
<p>（也可以将所有的节点值入栈中，再比较各节点元素和栈顶元素是否相等）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 存入List</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 使用双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 由于 List 中存的是 Integer 对象，故使用 .equals 判断</span></span><br><span class="line">            <span class="keyword">if</span> (!list.get(i).equals(list.get(j))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="思路二：快慢指针-翻转"><a href="#思路二：快慢指针-翻转" class="headerlink" title="思路二：快慢指针 + 翻转"></a>思路二：快慢指针 + 翻转</h3><p>先通过快慢指针找到链表中点，再将中点后面的链表倒转，最后进行比较判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head, pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 通过快慢指针找到链表中点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 翻转后半个链表</span></span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较判断</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != pre.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day17/image-20200801142525492.png" alt="image-20200801142525492" style="zoom:80%;" />



<h1 id="2-二叉搜索树的最近公共祖先"><a href="#2-二叉搜索树的最近公共祖先" class="headerlink" title="2. 二叉搜索树的最近公共祖先"></a>2. <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></h1><img src="【数据结构与算法】LeetCode：day17/image-20200801145403785.png" alt="image-20200801145403785" style="zoom:67%;" />

<h3 id="思路一：递归"><a href="#思路一：递归" class="headerlink" title="思路一：递归"></a>思路一：递归</h3><p>因为题目中给的是 BST，故两个子节点的值一定在他们公共祖先的值左右</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果子节点的值均比根节点值小</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">// 如果子节点的值均比根节点值大</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 如果子节点在根节点两侧</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路二：迭代"><a href="#思路二：迭代" class="headerlink" title="思路二：迭代"></a>思路二：迭代</h3><p>与递归思路相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Value of p</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pVal</span> <span class="operator">=</span> p.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Value of q;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">qVal</span> <span class="operator">=</span> q.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start from the root node of the tree</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Traverse the tree</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Value of ancestor/parent node.</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">parentVal</span> <span class="operator">=</span> node.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pVal &gt; parentVal &amp;&amp; qVal &gt; parentVal) &#123;</span><br><span class="line">                <span class="comment">// If both p and q are greater than parent</span></span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pVal &lt; parentVal &amp;&amp; qVal &lt; parentVal) &#123;</span><br><span class="line">                <span class="comment">// If both p and q are lesser than parent</span></span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We have found the split point, i.e. the LCA node.</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian--2/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="3-删除链表中的节点"><a href="#3-删除链表中的节点" class="headerlink" title="3. 删除链表中的节点"></a>3. <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">删除链表中的节点</a></h1><img src="【数据结构与算法】LeetCode：day17/image-20200801150351668.png" alt="image-20200801150351668" style="zoom:67%;" />

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>函数中只给了一个参数（要删除的节点），要充分利用所给的条件</p>
<ul>
<li>将要删除节点的值变为下一个节点的值</li>
<li>将要删除节点的下一个节点变为下下个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-二叉树的所有路径"><a href="#4-二叉树的所有路径" class="headerlink" title="4. 二叉树的所有路径"></a>4. <a href="https://leetcode-cn.com/problems/binary-tree-paths/">二叉树的所有路径</a></h1><img src="【数据结构与算法】LeetCode：day17/image-20200803084348259.png" alt="image-20200803084348259" style="zoom: 80%;" />

<h3 id="思路一：递归-1"><a href="#思路一：递归-1" class="headerlink" title="思路一：递归"></a>思路一：递归</h3><p>一开始想到使用递归，但是递归时无法使用 List 保存<strong>已有的路径和全部路径</strong></p>
<p>参考官方解答后发现可以<strong>构造一个新的函数</strong>，将已有路径和全部路径都作为参数传入，这样就能完美解决这一问题！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 一条支路的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paths 全部支路的总和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constructPaths</span><span class="params">(TreeNode root, String path, LinkedList&lt;String&gt; paths)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            path += Integer.toString(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) paths.add(path);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                constructPaths(root.left, path, paths);</span><br><span class="line">                constructPaths(root.right, path, paths);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        constructPaths(root, <span class="string">&quot;&quot;</span>, paths);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day17/image-20200803085808662.png" alt="image-20200803085808662" style="zoom:80%;" />



<h3 id="思路二：迭代-1"><a href="#思路二：迭代-1" class="headerlink" title="思路二：迭代"></a>思路二：迭代</h3><blockquote>
<p>上面的算法也可以使用迭代（宽度优先搜索）的方法实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是一个叶子节点，则将它对应的路径加入到答案中。如果它不是一个叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时，迭代结束。</p>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode/">https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; node_stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        LinkedList&lt;String&gt; path_stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        node_stack.add(root);</span><br><span class="line">        path_stack.add(Integer.toString(root.val));</span><br><span class="line">        TreeNode node;</span><br><span class="line">        String path;</span><br><span class="line">        <span class="keyword">while</span> (!node_stack.isEmpty()) &#123;</span><br><span class="line">            node = node_stack.pollLast();</span><br><span class="line">            path = path_stack.pollLast();</span><br><span class="line">            <span class="keyword">if</span> ((node.left == <span class="literal">null</span>) &amp;&amp; (node.right == <span class="literal">null</span>))</span><br><span class="line">                paths.add(path);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                node_stack.add(node.left);</span><br><span class="line">                path_stack.add(path + <span class="string">&quot;-&gt;&quot;</span> + Integer.toString(node.left.val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                node_stack.add(node.right);</span><br><span class="line">                path_stack.add(path + <span class="string">&quot;-&gt;&quot;</span> + Integer.toString(node.right.val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="5-丑数"><a href="#5-丑数" class="headerlink" title="5. 丑数"></a>5. <a href="https://leetcode-cn.com/problems/ugly-number/">丑数</a></h3><img src="【数据结构与算法】LeetCode：day17/image-20200803090835004.png" alt="image-20200803090835004" style="zoom:80%;" />

<h3 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h3><ul>
<li>先排除 <code>num</code> 为 0 或 <code>num</code> 小于 0 的情况</li>
<li>如果 <code>num</code> 能被 2 、3、5 整除，判断整除后的结果是否为丑数即可</li>
<li><code>num</code> 等于 1 时返回 <code>true</code>，其余结果返回 <code>false</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> isUgly(num / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span>) <span class="keyword">return</span> isUgly(num / <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">5</span> == <span class="number">0</span>) <span class="keyword">return</span> isUgly(num / <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-缺失数字"><a href="#5-缺失数字" class="headerlink" title="5. 缺失数字"></a>5. <a href="https://leetcode-cn.com/problems/missing-number/">缺失数字</a></h1><img src="【数据结构与算法】LeetCode：day17/image-20200803145103333.png" alt="image-20200803145103333" style="zoom:80%;" />

<h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p>将数组排序后进行遍历，如果数组中元素与其下标不同，则为确实元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day17/image-20200803150619515.png" alt="image-20200803150619515" style="zoom:80%;" />



<h3 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h3><p>将数组中的值存入 <strong>hash表</strong> 中，遍历 1 到 <code>nums.length</code>，返回哈希表中不包含的数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) set.add(nums[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day17/image-20200803151135762.png" alt="image-20200803151135762" style="zoom: 80%;" />



<h3 id="方法三：位运算"><a href="#方法三：位运算" class="headerlink" title="方法三：位运算"></a>方法三：位运算</h3><img src="【数据结构与算法】LeetCode：day17/image-20200803151613269.png" alt="image-20200803151613269" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;     </span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法四：数学方法"><a href="#方法四：数学方法" class="headerlink" title="方法四：数学方法"></a>方法四：数学方法</h3><p>求 1 到 <code>nums.length</code> 的和，减去数组中所有元素的和，结果就是缺少的数字（有整型溢出风险）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数列求和公式： Sn = n(a1 + an) / 2</span></span><br><span class="line">        <span class="keyword">return</span> nums.length * (nums.length + <span class="number">1</span>) / <span class="number">2</span> - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day16</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday16/</url>
    <content><![CDATA[<h1 id="1-翻转二叉树"><a href="#1-翻转二叉树" class="headerlink" title="1. 翻转二叉树"></a>1. <a href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></h1><img src="【数据结构与算法】LeetCode：day16/image-20200731134158978.png" alt="image-20200731134158978" style="zoom:80%;" />

<h3 id="法一：递归"><a href="#法一：递归" class="headerlink" title="法一：递归"></a>法一：递归</h3><ul>
<li>左子树 &#x3D; 翻转后的左子树</li>
<li>右子树 &#x3D; 翻转后的右子树</li>
<li>左子树和右子树交换位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="法二：迭代"><a href="#法二：迭代" class="headerlink" title="法二：迭代"></a>法二：迭代</h3><blockquote>
<p>这个方法的思路就是，我们需要交换树中所有节点的左孩子和右孩子。因此可以创一个队列来存储所有左孩子和右孩子还没有被交换过的节点。开始的时候，只有根节点在这个队列里面。只要这个队列不空，就一直从队列中出队节点，然后互换这个节点的左右孩子节点，接着再把孩子节点入队到队列，对于其中的空节点不需要加入队列。最终队列一定会空，这时候所有节点的孩子节点都被互换过了，直接返回最初的根节点就可以了。</p>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode/">https://leetcode-cn.com/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> current.left;</span><br><span class="line">        current.left = current.right;</span><br><span class="line">        current.right = temp;</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span>) queue.add(current.left);</span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="literal">null</span>) queue.add(current.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-2的幂"><a href="#2-2的幂" class="headerlink" title="2. 2的幂"></a>2. <a href="https://leetcode-cn.com/problems/power-of-two/">2的幂</a></h1><img src="【数据结构与算法】LeetCode：day16/image-20200731142948588.png" alt="image-20200731142948588" style="zoom:80%;" />

<h3 id="思路一：递归"><a href="#思路一：递归" class="headerlink" title="思路一：递归"></a>思路一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPowerOfTwo(n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路二：-amp-运算"><a href="#思路二：-amp-运算" class="headerlink" title="思路二：&amp; 运算"></a>思路二：&amp; 运算</h3> <img src="【数据结构与算法】LeetCode：day16/image-20200731142137371.png" alt="image-20200731142137371" style="zoom:80%;" />

<blockquote>
<p>作者：jyd<br>链接：<a href="https://leetcode-cn.com/problems/power-of-two/solution/power-of-two-er-jin-zhi-ji-jian-by-jyd/">https://leetcode-cn.com/problems/power-of-two/solution/power-of-two-er-jin-zhi-ji-jian-by-jyd/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路三：位移运算"><a href="#思路三：位移运算" class="headerlink" title="思路三：位移运算"></a>思路三：位移运算</h3><p>把二进制数进行左右移位。左移1位，扩大2倍；右移1位，缩小2倍。</p>
<p><code>1 &lt;&lt; 30</code> 得到最大的2的整数次幂，对 n 取模如果等于0，说明 n 只有因子2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-用栈实现队列"><a href="#3-用栈实现队列" class="headerlink" title="3. 用栈实现队列"></a>3. <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">用栈实现队列</a></h1><h3 id="思路：使用两个栈"><a href="#思路：使用两个栈" class="headerlink" title="思路：使用两个栈"></a>思路：使用两个栈</h3><p>与昨天使用队列实现栈的思路大体相同，设置两个栈，分别为<strong>输入栈</strong>和<strong>输出栈</strong>，<strong>输出时只需要将输入栈的内容弹出保存到输出栈，再将输出栈输出即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; stack1;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day18</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday18/</url>
    <content><![CDATA[<h1 id="1-单词规律"><a href="#1-单词规律" class="headerlink" title="1. 单词规律"></a>1. <a href="https://leetcode-cn.com/problems/word-pattern/">单词规律</a></h1><img src="【数据结构与算法】LeetCode：day18/image-20200804152330222.png" alt="image-20200804152330222" style="zoom:80%;" />

<h3 id="思路：HashMap"><a href="#思路：HashMap" class="headerlink" title="思路：HashMap"></a>思路：HashMap</h3><p>将 <code>pattern</code> 中的字母和 <code>str</code> 中的单词使用 <code>HashMap</code> 进行一一映射</p>
<p><strong>注意：需要对 pattern 和 str 进行双向映射（也可以判断 map 中是否已经包含了 value）</strong></p>
<p>如果只是完成了 pattern -&gt; str 的映射，则下例仍会判断错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pattern = <span class="string">&quot;abba&quot;</span></span><br><span class="line">str = <span class="string">&quot;dog dog dog dog&quot;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPattern</span><span class="params">(String pattern, String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wordPatternHelper1(pattern, str) &amp;&amp; wordPatternHelper2(pattern, str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// str -&gt; pattern</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPatternHelper1</span><span class="params">(String pattern, String str)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        String[] strs = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (strs.length != pattern.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(strs[i])) &#123;</span><br><span class="line">                map.put(strs[i],pattern.charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!map.get(strs[i]).equals(pattern.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pattern -&gt; str</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordPatternHelper2</span><span class="params">(String pattern, String str)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        String[] strs = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (strs.length != pattern.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(pattern.charAt(i))) &#123;</span><br><span class="line">                map.put(pattern.charAt(i),strs[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!map.get(pattern.charAt(i)).equals(strs[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day18/image-20200804154005893.png" alt="image-20200804154005893" style="zoom:80%;" />



<h1 id="2-Nim-游戏"><a href="#2-Nim-游戏" class="headerlink" title="2. Nim 游戏"></a>2. <a href="https://leetcode-cn.com/problems/nim-game">Nim 游戏</a></h1><img src="【数据结构与算法】LeetCode：day18/image-20200804155513535.png" alt="image-20200804155513535" style="zoom:80%;" />

<h3 id="我的思路：递归"><a href="#我的思路：递归" class="headerlink" title="我的思路：递归"></a>我的思路：递归</h3><ul>
<li>当 <code>n &lt; 3</code> 时，我必赢</li>
<li>当 <code>n &gt; 3</code> 时，<code>canWinNim(n - 1)</code> 、<code>canWinNim(n - 2)</code> 、<code>canWinNim(n - 3)</code> 分别返回我拿一块、拿两块、拿三块后对方是否会获胜</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> !(canWinNim(n - <span class="number">1</span>) &amp;&amp; canWinNim(n - <span class="number">2</span>) &amp;&amp; canWinNim(n - <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路没问题，但是在执行过程中，当 n &gt; 43 时，会出现超时的问题！</p>
<img src="【数据结构与算法】LeetCode：day18/image-20200804160422554.png" alt="image-20200804160422554" style="zoom:80%;" />

<h3 id="大佬思路"><a href="#大佬思路" class="headerlink" title="大佬思路"></a>大佬思路</h3><img src="【数据结构与算法】LeetCode：day18/image-20200804160630312.png" alt="image-20200804160630312" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">4</span> != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-区域和检索-数组不可变"><a href="#3-区域和检索-数组不可变" class="headerlink" title="3. 区域和检索 - 数组不可变"></a>3. <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">区域和检索 - 数组不可变</a></h1><img src="【数据结构与算法】LeetCode：day18/image-20200805082908152.png" alt="image-20200805082908152" style="zoom:80%;" />

<h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>直接暴力遍历数组的子区间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt;=j; k++) &#123;</span><br><span class="line">            sum += nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这样做有可能会产生超时错误，且题目中强调了 “会多次调用 <code>sumRange</code> ” 方法，故我们应该考虑更高率的求和方法</p>
<img src="【数据结构与算法】LeetCode：day18/image-20200805083137393.png" alt="image-20200805083137393" style="zoom:80%;" />



<h3 id="更好的思路"><a href="#更好的思路" class="headerlink" title="更好的思路"></a>更好的思路</h3><p>可以改用 <strong>sum数组</strong> 来保存前 n 位的数组中元素的和，这样调用 <code>sumRange</code> 方法时可以直接返回 <code>sum[j + 1] - sum[i]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day18/image-20200805085001507.png" alt="image-20200805085001507" style="zoom:80%;" />



<h1 id="4-3的幂"><a href="#4-3的幂" class="headerlink" title="4. 3的幂"></a>4. <a href="https://leetcode-cn.com/problems/power-of-three/">3的幂</a></h1><img src="【数据结构与算法】LeetCode：day18/image-20200805085734775.png" alt="image-20200805085734775" style="zoom:80%;" />

<h3 id="思路一：递归-x2F-迭代"><a href="#思路一：递归-x2F-迭代" class="headerlink" title="思路一：递归&#x2F;迭代"></a>思路一：递归&#x2F;迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isPowerOfThree(n / <span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day18/image-20200805090238615.png" alt="image-20200805090238615" style="zoom: 80%;" />



<h3 id="思路二：取余"><a href="#思路二：取余" class="headerlink" title="思路二：取余"></a>思路二：取余</h3><p>在整型范围内，3 的最大幂次方是 1162261467，若 n 能被它整除，则说明 n 是 3 的幂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="5-反转字符串中的元音字母"><a href="#5-反转字符串中的元音字母" class="headerlink" title="5. 反转字符串中的元音字母"></a>5. <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">反转字符串中的元音字母</a></h1><img src="【数据结构与算法】LeetCode：day18/image-20200805095023811.png" alt="image-20200805095023811" style="zoom:80%;" />

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>本题为基础双指针法交换前后元音元素；</p>
<p>一般遇见字符串问题，能转成字符数组就尽量转(方便)；</p>
<p>转换成数组后，分别定义前后两个索引指针用 while 依次遍历数组；</p>
<p>定义 isVowel() 方法将非元音元素返回给判断处，然后移动指针直到符合元音的位置，然后 tmp 进行交换即可；</p>
<p>最后扫描完数组后，一定要在返回的时候再转成字符串 String 输出。</p>
<p>作者：Jasion_han<br>链接：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/solution/20200320345easy-by-jasion_han-r/">https://leetcode-cn.com/problems/reverse-vowels-of-a-string/solution/20200320345easy-by-jasion_han-r/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseVowels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">vowels</span> <span class="operator">=</span> <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将字符串转化成char类型数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 双指针相向而行找元音字符</span></span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; !vowels.contains(chars[start] + <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; !vowels.contains(chars[end] + <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(chars, start, end);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[start];</span><br><span class="line">        chars[start] = chars[end];</span><br><span class="line">        chars[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：Jasion_han</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string/solution/20200320345easy-by-jasion_han-r/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day2</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday2/</url>
    <content><![CDATA[<h3 id="1-顺时针打印矩阵"><a href="#1-顺时针打印矩阵" class="headerlink" title="1. 顺时针打印矩阵"></a>1. <a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">顺时针打印矩阵</a></h3><img src="【数据结构与算法】LeetCode：day2/image-20200622155851958.png" alt="image-20200622155851958" style="zoom:67%;" />

<p>本题稍有难度，算是简单题中的难题，思考、实现过程花费将近两个小时，最后还是参考了官方答案，头大~</p>
<h5 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h5><p>设置循环，从外层依次向内遍历</p>
<p>设置两个变量：height、width分别表示向上（下）、向左（右）遍历的次数</p>
<p>每一次循环：</p>
<ul>
<li><p>向右遍历	</p>
<p>  <code>height--</code></p>
</li>
<li><p>向下遍历 </p>
<p>  <code>width--</code></p>
</li>
<li><p>向左遍历</p>
<p>  <code>height--</code></p>
</li>
<li><p>向上遍历</p>
<p>  <code>width--</code></p>
</li>
</ul>
<p>然而始终没有想明白外层循环结束的时机….</p>
<h5 id="更好的方法："><a href="#更好的方法：" class="headerlink" title="更好的方法："></a>更好的方法：</h5><img src="【数据结构与算法】LeetCode：day2/image-20200622160616550.png" alt="image-20200622160616550" style="zoom:67%;" />

<p>引入四个变量（top、left、bottom、right）来标识边界更加直观！</p>
<p>每次循环结束，整个边界向内收缩一圈：</p>
<ul>
<li><code>left++;</code></li>
<li><code>right--;</code></li>
<li><code>top++;</code></li>
<li><code>bottom--;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] order = <span class="keyword">new</span> <span class="title class_">int</span>[rows * columns];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = columns - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> left; column &lt;= right; column++) &#123;</span><br><span class="line">                order[index++] = matrix[top][column];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> top + <span class="number">1</span>; row &lt;= bottom; row++) &#123;</span><br><span class="line">                order[index++] = matrix[row][right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> right - <span class="number">1</span>; column &gt; left; column--) &#123;</span><br><span class="line">                    order[index++] = matrix[bottom][column];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order[index++] = matrix[row][left];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day3</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday3/</url>
    <content><![CDATA[<h3 id="1-数组异或操作"><a href="#1-数组异或操作" class="headerlink" title="1.  数组异或操作"></a>1. <a href="https://leetcode-cn.com/problems/xor-operation-in-an-array"> 数组异或操作</a></h3><img src="【数据结构与算法】LeetCode：day3/image-20200623173137501.png" alt="image-20200623173137501" style="zoom:67%;" />

<h3 id="2-左旋转字符串"><a href="#2-左旋转字符串" class="headerlink" title="2. 左旋转字符串"></a>2. <a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">左旋转字符串</a></h3><img src="【数据结构与算法】LeetCode：day3/image-20200623172910698.png" alt="image-20200623172910698" style="zoom:67%;" />

<h3 id="3-删除中间节点"><a href="#3-删除中间节点" class="headerlink" title="3. 删除中间节点"></a>3. <a href="https://leetcode-cn.com/problems/delete-middle-node-lcci">删除中间节点</a></h3><img src="【数据结构与算法】LeetCode：day3/image-20200623175320130.png" alt="image-20200623175320130" style="zoom:67%;" />

<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>题目中链表只给了要删除的节点，我们通过已知节点可以删除他的下一个节点，但是无法删除他本身</p>
<p>我们可以将他下一个节点的值赋给当前节点，那么该节点就变得和下一个节点一样了，此时我们只需删除下一个节点即可。</p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-二进制求和"><a href="#4-二进制求和" class="headerlink" title="4. 二进制求和"></a>4. <a href="https://leetcode-cn.com/problems/add-binary">二进制求和</a></h3><img src="【数据结构与算法】LeetCode：day3/image-20200624175005659.png" alt="image-20200624175005659" style="zoom:67%;" />

<h5 id="不全对的一个想法："><a href="#不全对的一个想法：" class="headerlink" title="不全对的一个想法："></a>不全对的一个想法：</h5><p>通过Java自带的函数，将给出的两个字符串转化为十进制数相加，相加后的结果再转回二进制数的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> Integer.toBinaryString(Integer.parseInt(a,<span class="number">2</span>) + Integer.parseInt(b,<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而在 Java 中：</p>
<ul>
<li>如果字符串超过 3333 位，不能转化为 Integer</li>
<li>如果字符串超过 6565 位，不能转化为 Long</li>
<li>如果字符串超过 500000001500000001 位，不能转化为 BigInteger</li>
</ul>
<p>因此，为了适用于长度较大的字符串计算，我们应该使用更加健壮的算法。</p>
<h5 id="更健壮的算法："><a href="#更健壮的算法：" class="headerlink" title="更健壮的算法："></a>更健壮的算法：</h5><blockquote>
<p>我们可以借鉴「列竖式」的方法，末尾对齐，逐位相加。在十进制的计算中「逢十进一」，二进制中我们需要「逢二进一」。</p>
<p>具体的，我们可以取 <code>n=max&#123;∣a∣,∣b∣&#125;</code>，循环 nn 次，从最低位开始遍历。我们使用一个变量 <code>carry</code> 表示上一个位置的进位，初始值为 0。记当前位置对其的两个位为 a_i  和 b_i  ，则每一位的答案为 (carry + a_i + b_i) mod 2，下一位的进位为 (carry + a_i + b_i) &#x2F; 2。重复上述步骤，直到数字 a 和 b 的每一位计算完毕。最后如果 <code>carry</code> 的最高位不为 0，则将最高位添加到计算结果的末尾。</p>
<p>注意，为了让各个位置对齐，你可以先反转这个代表二进制数字的字符串，然后低下标对应低位，高下标对应高位。当然你也可以直接把 a 和 b 中短的那一个补 0 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转。这里的代码给出第一种的实现。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/">https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Math.max(a.length(),b.length()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            carry += i &lt; a.length() ? (a.charAt(a.length() - <span class="number">1</span> -i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.length() ? (b.charAt(b.length() - <span class="number">1</span> -i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.append((<span class="type">char</span>)(carry % <span class="number">2</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day4</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday4/</url>
    <content><![CDATA[<h3 id="1-各位相加"><a href="#1-各位相加" class="headerlink" title="1. 各位相加"></a>1. <a href="https://leetcode-cn.com/problems/add-digits">各位相加</a></h3><img src="【数据结构与算法】LeetCode：day4/image-20200626151342622.png" alt="image-20200626151342622" style="zoom:67%;" />

<h5 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h5><ol>
<li>如果 <code>num &lt; 10</code> 则直接返回 <code>num</code></li>
<li>如果 <code>num &gt; 10</code> ，则将 <code>num</code> 各位相加得到 <code>res</code><ol>
<li><code>res &lt; 10</code> 直接返回</li>
<li><code>res &gt;= 10</code> 带入函数进行递归</li>
</ol>
</li>
</ol>
<h5 id="我的代码："><a href="#我的代码：" class="headerlink" title="我的代码："></a>我的代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            res += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += num;</span><br><span class="line">        <span class="keyword">while</span> (res &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            res = addDigits(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day4/image-20200626151926316.png" alt="image-20200626151926316" style="zoom:67%;" />

<p>感觉方法有点笨，肯定有更好的方法！</p>
<h5 id="更好的方法："><a href="#更好的方法：" class="headerlink" title="更好的方法："></a>更好的方法：</h5><blockquote>
<p>看了下 Discuss ，原来要求的数叫做<strong>数字根</strong>，看下 维基百科 的定义。</p>
<p>在数学中，数根(又称位数根或数字根Digital root)是自然数的一种性质，换句话说，每个自然数都有一个数根。</p>
<p><strong>数根是将一正整数的各个位数相加（即横向相加），若加完后的值大于10的话，则继续将各位数进行横向相加直到其值小于十为止，或是，将一数字重复做数字和，直到其值小于十为止，则所得的值为该数的数根。</strong></p>
<p>例如54817的数根为7，因为5+4+8+1+7&#x3D;25，25大于10则再加一次，2+5&#x3D;7，7小于十，则7为54817的数根。</p>
<p>然后是它的用途。</p>
<p>数根可以计算模运算的同余，对于非常大的数字的情况下可以节省很多时间。</p>
<p>数字根可作为一种检验计算正确性的方法。例如，两数字的和的数根等于两数字分别的数根的和。</p>
<p>另外，数根也可以用来判断数字的整除性，如果数根能被3或9整除，则原来的数也能被3或9整除。</p>
<p>接下来讨论我们怎么求出树根。</p>
<p>我们把 1 到 30 的树根列出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原数: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30</span><br><span class="line">数根: 1 2 3 4 5 6 7 8 9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3 </span><br></pre></td></tr></table></figure>

<p>可以发现数根 9 个为一组， 1 - 9 循环出现。我们需要做就是把原数映射到树根就可以，循环出现的话，想到的就是取余了。</p>
<p>结合上边的规律，对于给定的 n 有三种情况。</p>
<p>n 是 0 ，数根就是 0。</p>
<p>n 不是 9 的倍数，数根就是 n 对 9 取余，即 n mod 9。</p>
<p>n 是 9 的倍数，数根就是 9。</p>
<p>我们可以把两种情况统一起来，我们将给定的数字减 1，相当于原数整体向左偏移了 1，然后再将得到的数字对 9 取余，最后将得到的结果加 1 即可。</p>
<p>原数是 n，树根就可以表示成 (n-1) mod 9 + 1，可以结合下边的过程理解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原数: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30</span><br><span class="line">偏移: 0 1 2 3 4 5 6 7 8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 </span><br><span class="line">取余: 0 1 2 3 4 5 6 7 8  0  1  2  3  4  5  6  7  8  0  1  2  3  4  5  6  7  8  0  1  2  </span><br><span class="line">数根: 1 2 3 4 5 6 7 8 9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3 </span><br></pre></td></tr></table></figure>


<p>所以代码的话其实一句就够了。</p>
<p>作者：windliang<br>链接：<a href="https://leetcode-cn.com/problems/add-digits/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-7/">https://leetcode-cn.com/problems/add-digits/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-7/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-字符串相加"><a href="#2-字符串相加" class="headerlink" title="2.  字符串相加"></a>2. <a href="https://leetcode-cn.com/problems/add-strings"> 字符串相加</a></h3><img src="【数据结构与算法】LeetCode：day4/image-20200626161815160.png" alt="image-20200626161815160" style="zoom:67%;" />

<h5 id="我的思路：-1"><a href="#我的思路：-1" class="headerlink" title="我的思路："></a>我的思路：</h5><p>受到昨天 <strong>二进制求和</strong> 的启发，二进制求和与十进制求和本质是一样的，故可搬用二进制求和的那一套！</p>
<h5 id="我的代码：-1"><a href="#我的代码：-1" class="headerlink" title="我的代码："></a>我的代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> num1.length() &gt; num2.length() ? num1.length() : num2.length();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            carry += num1.length() &gt; i ? (num1.charAt(num1.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += num2.length() &gt; i ? (num2.charAt(num2.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            sb.append(carry % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) sb.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// 记得最后将字符串反转</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString().isEmpty() ? <span class="string">&quot;0&quot;</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果：-1"><a href="#执行结果：-1" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day4/image-20200626162136148.png" alt="image-20200626162136148" style="zoom:67%;" />

<p>其他人的解答都大抵与之相似！</p>
<h3 id="3-不用加号的加法"><a href="#3-不用加号的加法" class="headerlink" title="3. 不用加号的加法"></a>3. <a href="https://leetcode-cn.com/problems/add-without-plus-lcci">不用加号的加法</a></h3><img src="【数据结构与算法】LeetCode：day4/image-20200626174749025.png" alt="image-20200626174749025" style="zoom:67%;" />

<h5 id="解体思路："><a href="#解体思路：" class="headerlink" title="解体思路："></a>解体思路：</h5><blockquote>
<ol>
<li>二进制位<strong>异或运算</strong>相当于<strong>对应位相加</strong>，不考虑进位<br> 比如： 1 ^ 1 &#x3D; 0 —&gt; 1 + 1 &#x3D; 0 (当前位值为0，进一位)<br> 1 ^ 0 &#x3D; 1 —&gt; 1 + 0 &#x3D; 1 (当前位值为1)<br> 0 ^ 0 &#x3D; 0 —&gt; 0 + 0 &#x3D; 0 (当前位值为0)</li>
<li>二进制位<strong>与运算</strong>相当于<strong>对应位相加之后的进位</strong><br> 比如： 1 &amp; 1 &#x3D; 1 —&gt; 1 + 1 &#x3D; 0 (当前位的值进一位)<br> 1 &amp; 0 &#x3D; 0 —&gt; 1 + 0 &#x3D; 1 (当前位的值不进位)<br> 0 &amp; 0 &#x3D; 0 —&gt; 0 + 0 &#x3D; 0 (当前位的值不进位)</li>
<li><strong>两个数相加：对应二进制位相加的结果 + 进位的结果</strong><br> 比如：3 + 2 –&gt; 0011 + 0010<br> 0011 ^ 0010 &#x3D; 0001<br> 0011 &amp; 0010 &#x3D; 0010 需要进位变成 0100 也就是&lt;&lt;1<br> 当进位之后的结果为0时，相加结束。</li>
</ol>
<p>作者：ba-xiang<br>链接：<a href="https://leetcode-cn.com/problems/add-without-plus-lcci/solution/go-wei-yun-suan-by-ba-xiang/">https://leetcode-cn.com/problems/add-without-plus-lcci/solution/go-wei-yun-suan-by-ba-xiang/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><ol>
<li>递归</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a ^ b;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> add(sum,carry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>循环</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (a ^ b);</span><br><span class="line">            <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-数组形式的整数加法"><a href="#4-数组形式的整数加法" class="headerlink" title="4. 数组形式的整数加法"></a>4. <a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer">数组形式的整数加法</a></h3><img src="【数据结构与算法】LeetCode：day4/image-20200626184807332.png" alt="image-20200626184807332" style="zoom:67%;" />

<h5 id="我的思路：-2"><a href="#我的思路：-2" class="headerlink" title="我的思路："></a>我的思路：</h5><p>大体思路与前面做过的 <strong>二进制加法</strong> 、 <strong>字符串相加</strong> 一致，稍作改动</p>
<p>返回值是 <code>List&lt;Integer&gt;</code> ，所以我们可以直接用 <code>LinkedList</code> 存储新的数组！</p>
<h5 id="我的代码：-2"><a href="#我的代码：-2" class="headerlink" title="我的代码："></a>我的代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">addToArrayForm</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> A.length &gt; String.valueOf(K).length() ? A.length : String.valueOf(K).length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            carry += i &lt; A.length ? A[A.length - i -<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            carry += K % <span class="number">10</span>;</span><br><span class="line">            list.addFirst(carry % <span class="number">10</span>);</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) list.addFirst(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果：-2"><a href="#执行结果：-2" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day4/image-20200626185134870.png" alt="image-20200626185134870" style="zoom:67%;" />

<h5 id="官方解法："><a href="#官方解法：" class="headerlink" title="官方解法："></a>官方解法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">addToArrayForm</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> K;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N;</span><br><span class="line">        <span class="comment">// 退出循环条件为：数组越界、整数除尽</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> || cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">                cur += A[i];</span><br><span class="line">            ans.add(cur % <span class="number">10</span>);</span><br><span class="line">            cur /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.reverse(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/shu-zu-xing-shi-de-zheng-shu-jia-fa-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day5</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday5/</url>
    <content><![CDATA[<h3 id="1-回文数"><a href="#1-回文数" class="headerlink" title="1. 回文数"></a>1. <a href="https://leetcode-cn.com/problems/palindrome-number">回文数</a></h3><img src="【数据结构与算法】LeetCode：day5/image-20200628161222446.png" alt="image-20200628161222446" style="zoom:67%;" />

<h5 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h5><p>直接将整数转化为字符串，使用字符串相关的函数将字符串反转后与原串作比较</p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(x)).toString()</span><br><span class="line">        		.equals(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(x)).reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day5/image-20200628163110346.png" alt="image-20200628163110346" style="zoom:67%;" />

<p>可以看出执行效率较差、占用空间也较多！</p>
<h5 id="更好的方法："><a href="#更好的方法：" class="headerlink" title="更好的方法："></a>更好的方法：</h5><blockquote>
<p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p>
<p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 \text{int.MAX}int.MAX，我们将遇到整数溢出问题。</p>
<p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p>
<p>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday5/9_fig1.png" alt="fig1"></p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">revertedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-罗马数字转整数"><a href="#2-罗马数字转整数" class="headerlink" title="2. 罗马数字转整数"></a>2. <a href="https://leetcode-cn.com/problems/roman-to-integer">罗马数字转整数</a></h3><img src="【数据结构与算法】LeetCode：day5/image-20200628171957342.png" alt="image-20200628171957342" style="zoom:67%;" />

<h5 id="我的思路：-1"><a href="#我的思路：-1" class="headerlink" title="我的思路："></a>我的思路：</h5><p>使用 HashMap 将罗马数字与对应的值作为键值对存储，然后分类讨论各种情况！</p>
<h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;I&#x27;</span>) &#123;			<span class="comment">// I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span></span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">                    res += map.get(<span class="string">&#x27;V&#x27;</span>) - map.get(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    res += map.get(<span class="string">&#x27;X&#x27;</span>) - map.get(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += map.get(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">                res += map.get(<span class="string">&#x27;V&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;X&#x27;</span>) &#123;	<span class="comment">// X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span></span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                    res += map.get(<span class="string">&#x27;L&#x27;</span>) - map.get(<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                    res += map.get(<span class="string">&#x27;C&#x27;</span>) - map.get(<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += map.get(<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                res += map.get(<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;C&#x27;</span>) &#123;	<span class="comment">// C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span></span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                    res += map.get(<span class="string">&#x27;D&#x27;</span>) - map.get(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                    res += map.get(<span class="string">&#x27;M&#x27;</span>) - map.get(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += map.get(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                res += map.get(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += map.get(<span class="string">&#x27;M&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果：-1"><a href="#执行结果：-1" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day5/image-20200628172259917.png" alt="image-20200628172259917" style="zoom:67%;" />

<p>代码较为繁琐且执行效率并不高！</p>
<h5 id="更好的方法：-1"><a href="#更好的方法：-1" class="headerlink" title="更好的方法："></a>更好的方法：</h5><blockquote>
<p><strong>把一个小值放在大值的左边，就是做减法，否则为加法</strong>。</p>
<p>![Screen Shot 2020-02-17 at 21.14.47.png](【数据结构与算法】LeetCode：day5&#x2F;9d092fd44be4a809487a326dd6e9adcdddb1b27b6f5ec02ce60651745ff43528-Screen Shot 2020-02-17 at 21.14.47.png)</p>
<p>在代码实现上，可以往后看多一位，对比当前位与后一位的大小关系，从而确定当前位是加还是减法。当没有下一位时，做加法即可。</p>
<p>也可保留当前位的值，当遍历到下一位的时，对比保留值与遍历位的大小关系，再确定保留值为加还是减。最后一位做加法即可。</p>
<p>作者：donespeak<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/">https://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preNum</span> <span class="operator">=</span> getValue(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> getValue(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(preNum &lt; num) &#123;</span><br><span class="line">                sum -= preNum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += preNum;</span><br><span class="line">            &#125;</span><br><span class="line">            preNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += preNum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 switch 替换 HashMap，极大提升了效率（小数据量时）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：donespeak</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. <a href="https://leetcode-cn.com/problems/longest-common-prefix">最长公共前缀</a></h3><img src="【数据结构与算法】LeetCode：day5/image-20200628180537264.png" alt="image-20200628180537264" style="zoom:67%;" />

<h5 id="我的思路：-2"><a href="#我的思路：-2" class="headerlink" title="我的思路："></a>我的思路：</h5><p>暴力匹配法，直接嵌套循环从前往后判断各字符串中的第n个字母是否相同，相同则加入到 StringBuilder 中</p>
<h5 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].length() &lt; length) &#123;</span><br><span class="line">                length = strs[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[j].charAt(i) != strs[j - <span class="number">1</span>].charAt(i))&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                sb.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果：-2"><a href="#执行结果：-2" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day5/image-20200628180810612.png" alt="image-20200628180810612" style="zoom:67%;" />

<p>还阔以，官方方法比较丰富，不过时间复杂度大抵相同都是 <code>O(log(mn))</code></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day6</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday6/</url>
    <content><![CDATA[<h3 id="1-有效的括号"><a href="#1-有效的括号" class="headerlink" title="1.  有效的括号"></a>1. <a href="https://leetcode-cn.com/problems/valid-parentheses"> 有效的括号</a></h3><img src="【数据结构与算法】LeetCode：day6/image-20200629174328167.png" alt="image-20200629174328167" style="zoom:67%;" />

<h5 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h5><p>知道要用到<strong>栈</strong>，但是实际操作的时候出现了问题！</p>
<h5 id="好的思路："><a href="#好的思路：" class="headerlink" title="好的思路："></a>好的思路：</h5><ol>
<li><p>建立一个堆栈</p>
</li>
<li><p>当遇到 <code>(</code>、<code>[</code>、<code>&#123;</code> 的时候，将与之对应的括号放入堆栈</p>
<p> 当遇到 <code>)</code>、<code>]</code>、<code>&#125;</code> 时，说明栈顶一 定是与之相对应的括号，如果堆栈为空或者栈顶不是与之相对应的括号，则括号无效</p>
</li>
<li><p>最后如果堆栈为空则说明括号有效！</p>
</li>
</ol>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || (c != stack.pop())) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-合并两个有序链表"><a href="#2-合并两个有序链表" class="headerlink" title="2. 合并两个有序链表"></a>2. <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">合并两个有序链表</a></h3><img src="【数据结构与算法】LeetCode：day6/image-20200630164948870.png" alt="image-20200630164948870" style="zoom:67%;" />

<h5 id="我的思路：-1"><a href="#我的思路：-1" class="headerlink" title="我的思路："></a>我的思路：</h5><ol>
<li>设置一个头节点保存链表的头部，用于最后返回结果</li>
<li>依次遍历两条链表，谁的值小谁就依次跟在头节点的后面</li>
<li>一直遍历直到两条链表遍历完毕（<code>l1 == null &amp;&amp; l2 == null</code>）</li>
</ol>
<h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 两条链表都未遍历完毕</span></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                    node.next = <span class="type">l1</span></span><br><span class="line">                    <span class="variable">l1</span> <span class="operator">=</span> l1.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = l2;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;	<span class="comment">// l2 遍历完毕</span></span><br><span class="line">                    node.next = l1;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;					<span class="comment">// l1 遍历完毕</span></span><br><span class="line">                    node.next = l2;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="更好的想法1："><a href="#更好的想法1：" class="headerlink" title="更好的想法1："></a>更好的想法1：</h5><p>大体与我的思路相同，区别在于当两条链中一条为空时，直接将 <code>node.next</code> 设为不空的那条链（减少不必要的循环）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prehead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> prehead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="更好的想法2："><a href="#更好的想法2：" class="headerlink" title="更好的想法2："></a>更好的想法2：</h5><img src="【数据结构与算法】LeetCode：day6/image-20200630172234489.png" alt="image-20200630172234489" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="3-移除元素"><a href="#3-移除元素" class="headerlink" title="3.  移除元素"></a>3. <a href="https://leetcode-cn.com/problems/remove-element"> 移除元素</a></h3><img src="【数据结构与算法】LeetCode：day6/image-20200712175712277.png" alt="image-20200712175712277" style="zoom:67%;" />

<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote>
<p>当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。只要 <code>nums[j]  != val</code>，我们就复制 <code>nums[j]</code> 到 <code>nums[i]</code> 并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。</p>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/remove-element/solution/yi-chu-yuan-su-by-leetcode/">https://leetcode-cn.com/problems/remove-element/solution/yi-chu-yuan-su-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/remove-element/solution/yi-chu-yuan-su-by-leetcode/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="4-删除排序数组中的重复项"><a href="#4-删除排序数组中的重复项" class="headerlink" title="4.  删除排序数组中的重复项"></a>4.  <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/">删除排序数组中的重复项</a></h3><img src="【数据结构与算法】LeetCode：day6/image-20200630180751937.png" alt="image-20200630180751937" style="zoom:67%;" />

<h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><p>与上题一致</p>
<h5 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回数组的长度： i = 1，length = 2</span></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-实现-strStr"><a href="#5-实现-strStr" class="headerlink" title="5.  实现 strStr()"></a>5. <a href="https://leetcode-cn.com/problems/implement-strstr"> 实现 strStr()</a></h3><img src="【数据结构与算法】LeetCode：day6/image-20200630184748964.png" alt="image-20200630184748964" style="zoom:67%;" />

<h5 id="我的思路：-2"><a href="#我的思路：-2" class="headerlink" title="我的思路："></a>我的思路：</h5><p>遍历字符串 <code>haystack</code>，当 <code>haystack </code> 中有元素与 <code>needle</code> 中第一个元素相同时，截取 <code>haystack</code> 中该元素后的字串判断是否与 <code>needle</code> 相同。</p>
<h5 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(needle)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (haystack.length() &lt; needle.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + needle.length() &gt; haystack.length()) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">                <span class="keyword">if</span> (haystack.substring(i,i + needle.length()).equals(needle)) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day7</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday7/</url>
    <content><![CDATA[<h3 id="1-搜索插入位置"><a href="#1-搜索插入位置" class="headerlink" title="1.  搜索插入位置"></a>1. <a href="https://leetcode-cn.com/problems/search-insert-position"> 搜索插入位置</a></h3><img src="【数据结构与算法】LeetCode：day7/image-20200701162747314.png" alt="image-20200701162747314" style="zoom:67%;" />

<h5 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h5><p>使用二分查找</p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums.length==) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right -left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day7/image-20200701162902446.png" alt="image-20200701162902446" style="zoom:67%;" />

<h5 id="其他解法："><a href="#其他解法：" class="headerlink" title="其他解法："></a>其他解法：</h5><p>从左向右遍历数组，当遇到比 target 相同或比 target 大的数时，返回该数的索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-最大子序和"><a href="#2-最大子序和" class="headerlink" title="2. 最大子序和"></a>2. <a href="https://leetcode-cn.com/problems/maximum-subarray">最大子序和</a></h3><img src="【数据结构与算法】LeetCode：day7/image-20200701172238221.png" alt="image-20200701172238221" style="zoom:67%;" />

<h5 id="我的思路：-1"><a href="#我的思路：-1" class="headerlink" title="我的思路："></a>我的思路：</h5><p>设置 sum 记录各数字的和，如果 <code>sum &lt; 0</code> ，与后面数相加只会使和更小，故作清零处理，然后继续与后面相加。</p>
<p>用 res 存储在相加过程中出现的最大的 sum 值，返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            res = Math.max(res, sum);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-最后一个单词的长度"><a href="#3-最后一个单词的长度" class="headerlink" title="3. 最后一个单词的长度"></a>3. <a href="https://leetcode-cn.com/problems/length-of-last-word">最后一个单词的长度</a></h3><img src="【数据结构与算法】LeetCode：day7/image-20200701175045407.png" alt="image-20200701175045407" style="zoom:67%;" />

<h5 id="我的思路：-2"><a href="#我的思路：-2" class="headerlink" title="我的思路："></a>我的思路：</h5><p>遍历字符串中的字符，每次遇到空格记录之前遍历过的长度。</p>
<p>无法处理尾部空格等问题，没有实现。</p>
<h5 id="更好的思路："><a href="#更好的思路：" class="headerlink" title="更好的思路："></a>更好的思路：</h5><p>从末尾向前遍历，遇到非空字符 <code>length++</code> ，遇到空格且 <code>length</code> 不为 0，返回 <code>length</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                length++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day8</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday8/</url>
    <content><![CDATA[<h3 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1.  爬楼梯"></a>1. <a href="https://leetcode-cn.com/problems/climbing-stairs"> 爬楼梯</a></h3><img src="【数据结构与算法】LeetCode：day8/image-20200702164140831.png" alt="image-20200702164140831" style="zoom:67%;" />

<h5 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h5><p>写出前五项观察结果：</p>
<p>1：1</p>
<p>2：2</p>
<p>3：3</p>
<p>4：5</p>
<p>5：8</p>
<p>……</p>
<p>可知结果为斐波那契数列，直接用递归的方法求解斐波那契数列第 n 项</p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day8/image-20200702164353193.png" alt="image-20200702164353193" style="zoom:67%;" />

<p>由于递归及其耗费时间，时间复杂度为 O(2^n)，导致求解超时</p>
<h5 id="更好的解法："><a href="#更好的解法：" class="headerlink" title="更好的解法："></a>更好的解法：</h5><p><img src="https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif" alt="fig1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="【数据结构与算法】LeetCode：day8/image-20200702164659173.png" alt="image-20200702164659173" style="zoom:67%;" />



<h3 id="2-删除排序链表中的重复元素"><a href="#2-删除排序链表中的重复元素" class="headerlink" title="2.  删除排序链表中的重复元素"></a>2. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list"> 删除排序链表中的重复元素</a></h3><img src="【数据结构与算法】LeetCode：day8/image-20200702170926322.png" alt="image-20200702170926322" style="zoom:67%;" />

<h5 id="我的思路：-1"><a href="#我的思路：-1" class="headerlink" title="我的思路："></a>我的思路：</h5><p>循环遍历链表：</p>
<ul>
<li>当 node 的值与 node.next 值相同时，node.next 后移</li>
<li>否则 node 后移</li>
</ul>
<h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.val == node.next.val) &#123;</span><br><span class="line">                node.next = node.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-合并两个有序数组"><a href="#3-合并两个有序数组" class="headerlink" title="3. 合并两个有序数组"></a>3. <a href="https://leetcode-cn.com/problems/merge-sorted-array">合并两个有序数组</a></h3><img src="【数据结构与算法】LeetCode：day8/image-20200702202006718.png" alt="image-20200702202006718" style="zoom:67%;" />

<h5 id="解体思路："><a href="#解体思路：" class="headerlink" title="解体思路："></a>解体思路：</h5><p>考虑从右往左递归，这样不需要额外的数组占用额外的空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m-- + n-- - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-相同的树"><a href="#4-相同的树" class="headerlink" title="4.  相同的树"></a>4. <a href="https://leetcode-cn.com/problems/same-tree"> 相同的树</a></h3><img src="【数据结构与算法】LeetCode：day8/image-20200703162444481.png" alt="image-20200703162444481" style="zoom:67%;" />

<h5 id="我的思路：-2"><a href="#我的思路：-2" class="headerlink" title="我的思路："></a>我的思路：</h5><p>使用中序遍历的方法遍历两个二叉树，将结果保存在 List 中，最终比较两个 List 是否相同</p>
<p>问题在于我在中序遍历的时候使用递归，每次递归都要创建一个全新的 List ，故无法完整保存二叉树的全部节点信息</p>
<h5 id="更好的思路："><a href="#更好的思路：" class="headerlink" title="更好的思路："></a>更好的思路：</h5><p>递归遍历二叉树……</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val == q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【操作系统】第六章：页面置换算法</title>
    <url>/2023/03/01/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>功能目标</strong></p>
<ul>
<li><p>功能：当缺页中断发生，需要调入新的页面而内存已满时，选择当中哪个物理页面被置换。</p>
</li>
<li><p>目标：<strong>尽可能减少页面的换进换出次数。</strong></p>
</li>
<li><p>页面锁定：将相关的页（必须常驻操作系统的关键部分）放在内存里面，确保操作系统随时能够正常工作</p>
</li>
</ul>
<h1 id="6-1-最优页面置换算法"><a href="#6-1-最优页面置换算法" class="headerlink" title="6.1 最优页面置换算法"></a>6.1 最优页面置换算法</h1><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>（如果能预知将来）根据将来什么时候访问，将<strong>距离再次使用间隔时间最长的页</strong>作为被置换的页面（不太实际，无法预知未来）</p>
<p>可用作其他算法的性能评价依据。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><img src="【操作系统】第六章：页面置换算法/image-20200421160738838.png" alt="image-20200421160738838" style="zoom:80%;" />

<h1 id="6-2-先进先出算法（FIFO）"><a href="#6-2-先进先出算法（FIFO）" class="headerlink" title="6.2 先进先出算法（FIFO）"></a>6.2 先进先出算法（FIFO）</h1><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>选择在内存中驻留时间最长的页面并淘汰之。</p>
<p>系统维护着一个<strong>链表</strong>，记录了所有位于内存中的逻辑页面，链表首页驻留时间最长，尾部最短，发生缺页中断时，链表首页先淘汰，在链表尾部加入新的页面。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>性能较差</strong>，调出的页面有可能是经常要访问的页面，并且有可能出现 <strong>Belady现象</strong>（后面讲），<strong>很少单独使用</strong>。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><img src="【操作系统】第六章：页面置换算法/image-20200421161641490.png" alt="image-20200421161641490" style="zoom:80%;" />

<h1 id="6-3-最近最久未使用（LRU）"><a href="#6-3-最近最久未使用（LRU）" class="headerlink" title="6.3 最近最久未使用（LRU）"></a>6.3 最近最久未使用（LRU）</h1><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><p>当一个缺页中断发生时，<strong>选择最久未使用</strong>的那个页面并淘汰之。</p>
<p><strong>根据过去推测将来。</strong>（过去使用的较少，推测将来使用的也会很少）</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p><strong>LRU算法需要记录各个页面使用的先后顺序，开销比较大</strong></p>
<p>两种可能的实现方式：</p>
<ol>
<li><p><strong>链表</strong></p>
<p> 系统维护一个页面链表，<strong>最近刚刚使用的页面作为首节点，最久未使用的页面作为尾节点</strong></p>
</li>
<li><p><strong>堆栈</strong></p>
<p> 设置一个活动页面栈，当访问某页时，将此页号压入栈顶，然后考察站内是否有与此页面相同的页号，有则抽出。需要淘汰一个页面时，总是选择栈底的页面。</p>
</li>
</ol>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/image-20200421162315694.png" alt="image-20200421162315694"></p>
<h1 id="6-4-时钟页面置换算法"><a href="#6-4-时钟页面置换算法" class="headerlink" title="6.4 时钟页面置换算法"></a>6.4 时钟页面置换算法</h1><p>Clock 页面置换算法，LRU 近似，对 FIFO 的一种改进</p>
<h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li><p>需用用到页表中的<strong>访问位</strong>，页面被装入内存时，访问位初始化为0，页面被读写，访问位被置为1</p>
</li>
<li><p>将页面制成<strong>环形链表</strong>，指针指向最先进来的页</p>
</li>
<li><p>发生缺页中断时，指针开始移动</p>
<p>  ​		若所指页面访问位为0，立即被淘汰</p>
<p>  ​		若所指页面访问位为1，把该位置为0，指针继续移动</p>
</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>访问位只占一个字节，只有两种可能，结果不是很准确！</p>
<p>准确率跟 LRU 差不多</p>
<img src="【操作系统】第六章：页面置换算法/image-20200421164403875.png" alt="image-20200421164403875" style="zoom:80%;" />



<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p><img src="/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/image-20200421165406064.png" alt="image-20200421165406064"></p>
<h1 id="6-5-二次机会法"><a href="#6-5-二次机会法" class="headerlink" title="6.5 二次机会法"></a>6.5 二次机会法</h1><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>同时使用 <strong>脏位（dirty bit）和访问位（used bit）</strong> 来指导位置交换。</p>
<p>脏位：用来标识是否进行过<strong>写操作</strong></p>
<p>​			如果执行过写操作，则脏位置为1，淘汰该页时需要将其写入物理硬盘以更新信息</p>
<p>​			如果没有执行过写操作，则脏位置为0，淘汰该页时直接将其释放即可，不需要再写入硬盘</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><img src="【操作系统】第六章：页面置换算法/image-20200421170625437.png" alt="image-20200421170625437" style="zoom:80%;" />

<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><img src="【操作系统】第六章：页面置换算法/image-20200421171058688.png" alt="image-20200421171058688" style="zoom:80%;" />



<h1 id="6-6-最不常用法"><a href="#6-6-最不常用法" class="headerlink" title="6.6 最不常用法"></a>6.6 最不常用法</h1><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h3><p>当一个缺页中断发生时，选择访问次数最少的那个页面，淘汰之</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>对每个页面设置一个计数器，页面被访问时计数器加一。发生缺页中断时，选择计数器最小的淘汰。</p>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>引入计数器占用物理内存，开销较大。</p>
<p>检索计数器觉得淘汰谁时同样存在开销。</p>
<h1 id="6-7-Belady现象、LRU、FIFO、Clock"><a href="#6-7-Belady现象、LRU、FIFO、Clock" class="headerlink" title="6.7 Belady现象、LRU、FIFO、Clock"></a>6.7 Belady现象、LRU、FIFO、Clock</h1><p>Belady现象：在采用FIFO算法时，有时候会出现分配的<strong>物理页面数增加</strong>，<strong>缺页率反而提高</strong>的异常现象</p>
<p>产生原因：FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的，因此，被它置换出去的页面并不一定是进程不会访问的。</p>
<h3 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h3><ul>
<li>三个物理页帧：</li>
</ul>
<p><img src="【操作系统】第六章：页面置换算法/image-20200423180050021.png" alt="image-20200423180050021" style="zoom:67%;" />- </p>
<ul>
<li>四个物理页帧：</li>
</ul>
<img src="【操作系统】第六章：页面置换算法/image-20200423180202056.png" style="zoom:67%;" />

<h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><img src="【操作系统】第六章：页面置换算法/image-20200423180342776.png" alt="image-20200423180342776" style="zoom:67%;" />



<h1 id="6-8-局部页面替换算法的问题、工作集模型"><a href="#6-8-局部页面替换算法的问题、工作集模型" class="headerlink" title="6.8 局部页面替换算法的问题、工作集模型"></a>6.8 局部页面替换算法的问题、工作集模型</h1><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><img src="【操作系统】第六章：页面置换算法/image-20200423182114630.png" alt="image-20200423182114630" style="zoom:67%;" />



<img src="【操作系统】第六章：页面置换算法/image-20200423190957657.png" alt="image-20200423190957657" style="zoom:67%;" />

<img src="【操作系统】第六章：页面置换算法/image-20200423191500252.png" alt="image-20200423191500252" style="zoom:67%;" />

<img src="【操作系统】第六章：页面置换算法/image-20200423191724551.png" alt="image-20200423191724551" style="zoom:67%;" />

<h1 id="6-9-两个全局置换算法"><a href="#6-9-两个全局置换算法" class="headerlink" title="6.9 两个全局置换算法"></a>6.9 两个全局置换算法</h1><h3 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h3><ul>
<li><p>基本思想：</p>
<p>  需要替换页面时，替换那些不在工作集窗口内的页</p>
<p>  工作集会随程序执行挪动，如果某个页不在工作集窗口之内，它会被丢掉</p>
</li>
</ul>
<img src="【操作系统】第六章：页面置换算法/image-20200423192758848.png" alt="image-20200423192758848" style="zoom:67%;" />

<ul>
<li>在整个系统层面，会确保整个系统的缺页次数较低</li>
</ul>
<h3 id="缺页率页面置换算法"><a href="#缺页率页面置换算法" class="headerlink" title="缺页率页面置换算法"></a>缺页率页面置换算法</h3><img src="【操作系统】第六章：页面置换算法/image-20200423193027256.png" alt="image-20200423193027256" style="zoom:67%;" />

<ul>
<li><p>缺页率：</p>
<p>  缺页次数 &#x2F; 内存访问次数</p>
<ul>
<li>影响因素：<ul>
<li>页面置换算法</li>
<li>分配给进程的物理页大小</li>
<li>页面本身大小</li>
<li>程序的编写</li>
</ul>
</li>
<li>方法：<ul>
<li>缺页率高——–增加工作集</li>
<li>缺页率低——–减少工作集</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="【操作系统】第六章：页面置换算法/image-20200423193934644.png" alt="image-20200423193934644" style="zoom:67%;" />

<p><strong>总结：</strong>对操作系统而言，如果要<strong>应对多个正在运行的程序</strong>，采取<strong>全局页替换算法</strong>效果要好于局部页替换算法</p>
<h1 id="6-10-抖动问题"><a href="#6-10-抖动问题" class="headerlink" title="6.10 抖动问题"></a>6.10 抖动问题</h1><img src="【操作系统】第六章：页面置换算法/image-20200423194424780.png" alt="image-20200423194424780" style="zoom:67%;" />

<img src="【操作系统】第六章：页面置换算法/image-20200423194520833.png" alt="image-20200423194520833" style="zoom:67%;" />]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：day9</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9Aday9/</url>
    <content><![CDATA[<h3 id="1-路径总和"><a href="#1-路径总和" class="headerlink" title="1.  路径总和"></a>1. <a href="https://leetcode-cn.com/problems/path-sum"> 路径总和</a></h3><img src="【数据结构与算法】LeetCode：day9/image-20200707162521503.png" alt="image-20200707162521503" style="zoom:67%;" />

<h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>向下进行递归求解：满足<code>hasPathSum(TreeNode root, int sum)</code> </p>
<p>​								  等价于满足 <code>hasPathSum(root.right, sum -val)</code> 或 <code>hasPathSum(root.left, sum -val)</code></p>
<p>寻找退出条件：当最后一次递归时 <code>sum - root.val == 0</code></p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> sum - root.val == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-对称二叉树"><a href="#2-对称二叉树" class="headerlink" title="2.  对称二叉树"></a>2. <a href="https://leetcode-cn.com/problems/symmetric-tree"> 对称二叉树</a></h3><img src="【数据结构与算法】LeetCode：day9/image-20200707174517416.png" alt="image-20200707174517416" style="zoom:67%;" />

<h5 id="递归解法："><a href="#递归解法：" class="headerlink" title="递归解法："></a>递归解法：</h5><blockquote>
<p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p>
<img src="【数据结构与算法】LeetCode：day9/101_fig1.PNG" alt="fig1" style="zoom: 25%;" />

<p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>
<p>如果同时满足下面的条件，两个树互为镜像：</p>
<ul>
<li>它们的两个根结点具有相同的值</li>
<li>每个树的右子树都与另一个树的左子树镜像对称</li>
</ul>
<img src="【数据结构与算法】LeetCode：day9/101_fig2.PNG" alt="fig2" style="zoom:25%;" />

<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="迭代解法："><a href="#迭代解法：" class="headerlink" title="迭代解法："></a>迭代解法：</h5><blockquote>
<p>「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode u, TreeNode v)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(u);</span><br><span class="line">        q.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            u = q.poll();</span><br><span class="line">            v = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="literal">null</span> &amp;&amp; v == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((u == <span class="literal">null</span> || v == <span class="literal">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.offer(u.left);</span><br><span class="line">            q.offer(v.right);</span><br><span class="line"></span><br><span class="line">            q.offer(u.right);</span><br><span class="line">            q.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="3-二叉树的最大深度"><a href="#3-二叉树的最大深度" class="headerlink" title="3.  二叉树的最大深度"></a>3. <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree"> 二叉树的最大深度</a></h3><img src="【数据结构与算法】LeetCode：day9/image-20200707181543035.png" alt="image-20200707181543035" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-二叉树的层次遍历-II"><a href="#4-二叉树的层次遍历-II" class="headerlink" title="4.  二叉树的层次遍历 II"></a>4. <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii"> 二叉树的层次遍历 II</a></h3><img src="【数据结构与算法】LeetCode：day9/image-20200709173333742.png" alt="image-20200709173333742" style="zoom:67%;" />

<h5 id="解体思路："><a href="#解体思路：" class="headerlink" title="解体思路："></a>解体思路：</h5><ol>
<li><p>设置一个 Queue 用来存放每一层的节点</p>
</li>
<li><p>当 Queue 不为空的时候，遍历 Queue</p>
<ul>
<li><p>设置一个 List 存放一层节点的整数值</p>
</li>
<li><p>依次取出 Queue 中的每一个节点，将该放入到 List 中</p>
</li>
<li><p>将每个节点的左右子树（不为空时）放入 Queue 中</p>
</li>
<li><p>将 List 加到队列头部</p>
</li>
</ul>
</li>
</ol>
<h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; oneLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                oneLevel.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.addFirst(oneLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h5><img src="【数据结构与算法】LeetCode：day9/image-20200709174332294.png" alt="image-20200709174332294" style="zoom:67%;" />





<h3 id="5-将有序数组转换为二叉搜索树"><a href="#5-将有序数组转换为二叉搜索树" class="headerlink" title="5. 将有序数组转换为二叉搜索树"></a>5. <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">将有序数组转换为二叉搜索树</a></h3><img src="【数据结构与算法】LeetCode：day9/image-20200711200625580.png" alt="image-20200711200625580" style="zoom:50%;" />

<h5 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h5><p>将有序数组转化为二叉搜索树，由 BST 的性质可知转化后所得的 <strong>BST 的根节点为有序数组最中间的数</strong>，<strong>根节点的左子节点为有序数组前半段最中间的数，根节点的右子节点为有序数组后半段的中间数</strong>，依次类推……</p>
<h5 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> add(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = add(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = add(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：二分查找</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="正常实现"><a href="#正常实现" class="headerlink" title="正常实现"></a>正常实现</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input : [1,2,3,4,5]</span><br><span class="line">key : 3</span><br><span class="line">return the index : 2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; key) &#123;</span><br><span class="line">            h = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong></p>
<p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p>
<p><strong>m 计算</strong></p>
<p>有两种计算中值 m 的方式：</p>
<ul>
<li>m &#x3D; (l + h) &#x2F; 2</li>
<li>m &#x3D; l + (h - l) &#x2F; 2</li>
</ul>
<p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p>
<p><strong>未成功查找的返回值</strong></p>
<p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p>
<ul>
<li>-1：以一个错误码表示没有查找到 key</li>
<li>l：将 key 插入到 nums 中的正确位置</li>
</ul>
<p><strong>变种</strong></p>
<p>二分查找可以有很多变种，实现变种要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &gt;= key) &#123;</span><br><span class="line">            h = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该实现和正常实现有以下不同：</p>
<ul>
<li>h 的赋值表达式为 h &#x3D; m</li>
<li>循环条件为 l &lt; h</li>
<li>最后返回 l 而不是 -1</li>
</ul>
<p>在 nums[m] &gt;&#x3D; key 的情况下，可以推导出最左 key 位于 [l, m] 区间中，这是一个闭区间。h 的赋值表达式为 h &#x3D; m，因为 m 位置也可能是解。</p>
<p>在 h 的赋值表达式为 h &#x3D; m 的情况下，如果循环条件为 l &lt;&#x3D; h，那么会出现循环无法退出的情况，因此循环条件只能是 l &lt; h。以下演示了循环条件为 l &lt;&#x3D; h 时循环无法退出的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = &#123;0, 1, 2&#125;, key = 1</span><br><span class="line">l   m   h</span><br><span class="line">0   1   2  nums[m] &gt;= key</span><br><span class="line">0   0   1  nums[m] &lt; key</span><br><span class="line">1   1   1  nums[m] &gt;= key</span><br><span class="line">1   1   1  nums[m] &gt;= key</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当循环体退出时，不表示没有查找到 key，因此最后返回的结果不应该为 -1。为了验证有没有查找到，需要在调用端判断一下返回位置上的值和 key 是否相等。</p>
<p><strong>以上内容均取自：[CS-Notes](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode</a> 题解 - 二分查找.md)</strong></p>
<h1 id="1-X的平方根"><a href="#1-X的平方根" class="headerlink" title="1.X的平方根"></a>1.<a href="https://leetcode.com/problems/sqrtx/description/">X的平方根</a></h1><img src="【数据结构与算法】LeetCode：二分查找/image-20200727090857991.png" alt="image-20200727090857991" style="zoom: 80%;" />

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有常识可知 x 的平方根一定在 (0，x] 之间，如果暴腻一点我们可以遍历 (0,x]，分别平方寻找等于或者最近接x的那个值，但是这样做显然会消耗极大的时间 O(n)，所以我们可以采用二分查找来进行优化！</p>
<blockquote>
<p>二分查找的下界为 00，上界可以粗略地设定为 xx。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 xx 的大小关系，并通过比较的结果调整上下界的范围。</p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/">https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sqrt</span> <span class="operator">=</span> x / mid;</span><br><span class="line">            <span class="keyword">if</span>(sqrt == mid)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqrt &gt; mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul>
<li>时间复杂度：<em>O</em>(log<em>n</em>)，即为二分查找需要的次数。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<h1 id="2-寻找比目标字母大的最小字母"><a href="#2-寻找比目标字母大的最小字母" class="headerlink" title="2. 寻找比目标字母大的最小字母"></a>2. <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">寻找比目标字母大的最小字母</a></h1><p> <img src="【数据结构与算法】LeetCode：二分查找/image-20200727090940739.png" alt="image-20200727090940739" style="zoom: 67%;" /><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20200727091009493.png" alt="image-20200727091009493"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>方法一：采用直接遍历的方法，从左到右遍历数组，若找到一个比 target 大的字母，直接返回该字母，若没有找到，返回数组中的第一个字母。</p>
</li>
<li><p>方法二：采用二分查找的方法</p>
</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> letters.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (letters[mid] &lt;= target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left &lt; len ? letters[left] : letters[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>方法一：</p>
<ul>
<li>时间复杂度：<em>O</em>(<em>N</em>)</li>
<li>空间复杂度：<em>O</em>(1)</li>
</ul>
</li>
<li><p>方法二：</p>
<ul>
<li><p>时间复杂度：O(logN)</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
</li>
</ul>
<h1 id="3-有序数组中的单一元素"><a href="#3-有序数组中的单一元素" class="headerlink" title="3. 有序数组中的单一元素"></a>3. 有序数组中的单一元素</h1><p><img src="【数据结构与算法】LeetCode：二分查找/image-20200727090940739.png" alt="image-20200727090940739" style="zoom: 80%;" /><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20200727091009493.png" alt="image-20200727091009493"></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>不难发现，数组中含有的元素总是奇数个，以为数组是由多个出现两次的元素和一个只出现一次的元素组成的。</p>
<p>在我们要寻找的元素之前，数组元素均成对存在；加上在该元素之后，数组成对存在的情况被改变。</p>
<img src="【数据结构与算法】LeetCode：二分查找/image-20200727091031997.png" alt="image-20200727091031997" style="zoom:67%;" />

<p>我们对最中间的偶数索引 <code>index</code> 进行二分查找，若 <code>index</code> 处元素 与 <code>index + 1</code> 处相同，则要查找的元素在 <code>index</code> 右侧，反之则在 <code>index</code> 左侧。</p>
<img src="【数据结构与算法】LeetCode：二分查找/image-20200727091045155.png" alt="image-20200727091045155" style="zoom: 67%;" />

<p>依此类推继续进行二分查找，直到最后搜索区域只剩一个元素，该元素即为要查找的值。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNonDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//找到中值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//取偶数中值</span></span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                mid--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向右边查找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;	<span class="comment">//向左边查找</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. <a href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本</a></h1><img src="【数据结构与算法】LeetCode：二分查找/image-20200727091112216.png" alt="image-20200727091112216" style="zoom:80%;" />

<h3 id="思路一：暴力搜索"><a href="#思路一：暴力搜索" class="headerlink" title="思路一：暴力搜索"></a>思路一：暴力搜索</h3><p>直接遍历查找，时间复杂度为 O(n) ，调用 api 次数过多，超出题目时间限制</p>
<h3 id="思路二：二分查找"><a href="#思路二：二分查找" class="headerlink" title="思路二：二分查找"></a>思路二：二分查找</h3><p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 <code>h = m</code>；否则第一个错误的版本在 [m + 1, h] 之间，令 <code>l = m + 1</code>。</p>
<p>因为 h 的赋值表达式为 <code>h = m</code>，因此循环条件为 <code>l &lt; h</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="5-寻找旋转排序数组中的最小值"><a href="#5-寻找旋转排序数组中的最小值" class="headerlink" title="5. 寻找旋转排序数组中的最小值"></a>5. <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></h1><img src="【数据结构与算法】LeetCode：二分查找/image-20200727091159793.png" alt="image-20200727091159793" style="zoom:80%;" />

<h3 id="思路一：排序后返回数组的第一个数"><a href="#思路一：排序后返回数组的第一个数" class="headerlink" title="思路一：排序后返回数组的第一个数"></a>思路一：排序后返回数组的第一个数</h3><p>将数组重新排成有序数组，那么数组的第一个值就是数组中的最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐这种做法，使用排序增加了时间复杂度。</p>
<h3 id="思路二：二分查找-1"><a href="#思路二：二分查找-1" class="headerlink" title="思路二：二分查找"></a>思路二：二分查找</h3><p>排序查找也就图一乐，真查找还得看二分~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这里有个编程技巧 </span></span><br><span class="line">        <span class="comment">//因为l&lt;r 所以最后一轮肯定是(r,r+1)</span></span><br><span class="line">        <span class="comment">//那么mid 肯定是取值l 当判断条件是mid与l比时 会出现与自身比 造成出现等于情况 不好判断</span></span><br><span class="line">        <span class="comment">//所以判断条件时mid 与 r比 这样肯定是不同的两个数比</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[r]) &#123;  <span class="comment">// mid可能为最小值</span></span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有重复值</span></span><br><span class="line">            l = mid+<span class="number">1</span>;      <span class="comment">// mid肯定不是最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="6-在排序数组中查找元素的第一个和最后一个位置"><a href="#6-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="6. 在排序数组中查找元素的第一个和最后一个位置"></a>6. <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h1><img src="【数据结构与算法】LeetCode：二分查找/image-20200727091213270.png" alt="image-20200727091213270" style="zoom:80%;" />

<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>可以通过二分查找寻找第一次出现的位置，最后出现的位置其实就是 target + 1 的值第一次出现的位置往前移一位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> findFirst(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> findFirst(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (first == nums.length || nums[first] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;first, Math.max(first, last)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findFirst</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：剑指Offer30天计划</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E5%89%91%E6%8C%87Offer30%E5%A4%A9%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="第-1-天-栈与队列"><a href="#第-1-天-栈与队列" class="headerlink" title="第 1 天 栈与队列"></a>第 1 天 栈与队列</h2><h3 id="1-剑指-Offer-09-用两个栈实现队列"><a href="#1-剑指-Offer-09-用两个栈实现队列" class="headerlink" title="1. 剑指 Offer 09. 用两个栈实现队列"></a>1. <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220111204109161.png" alt="image-20220111204109161" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<ul>
<li><p>设置栈 1、2，</p>
</li>
<li><p>添加元素时直接在栈 1 中压入元素即可</p>
</li>
<li><p>删除元素时：如果栈 2 不为空则直接将 2 中元素弹出，如果 2 为空，则将 1 中元素全部弹出并依次压住 2 中，再将 2 的栈顶元素弹出（如果栈 2 仍然为空，则说明栈 1 也为空，返回 -1）</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;  </span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; stack1;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化两个栈</span></span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 栈2空则将1中元素全部压入2中</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) </span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) stack2.push(stack1.pop());</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-30-包含min函数的栈"><a href="#2-剑指-Offer-30-包含min函数的栈" class="headerlink" title="2. 剑指 Offer 30. 包含min函数的栈"></a>2. <a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220111204931055.png" alt="image-20220111204931055" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<ul>
<li><code>push()</code> 中只需要每次把当前最小值与新的值 x 作比较并更新最小值就能解决</li>
<li><code>pop()</code> 时如果当前值是最小值，就得用前一个最小值代替当前最小值，但是再次 <code>pop()</code> 又得有前前个最小值，故考虑使用一个栈 <code>min</code> 来保存最小值序列。在这个栈中，每次使用 <code>push()</code> 需要更新最小值时就把新的最小值压入栈中，这样，栈 <code>min</code> 的栈顶元素就是当前栈 <code>stack</code> 的最小值</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    </span><br><span class="line">    LinkedList&lt;Integer&gt; stack;</span><br><span class="line">    LinkedList&lt;Integer&gt; min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        min = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (min.isEmpty() || min.peek() &gt;= x) </span><br><span class="line">            min.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.pop().equals(min.peek())) </span><br><span class="line">            min.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="第-2-天-链表"><a href="#第-2-天-链表" class="headerlink" title="第 2 天 链表"></a>第 2 天 链表</h2><h3 id="1-剑指-Offer-06-从尾到头打印链表"><a href="#1-剑指-Offer-06-从尾到头打印链表" class="headerlink" title="1. 剑指 Offer 06. 从尾到头打印链表"></a>1. <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220113084415906.png" alt="image-20220113084415906" style="zoom:80%;" />

<p><strong>思路一：</strong></p>
<p>使用辅助栈存储链表信息，建立数组保存从站内依次弹出的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        我的-辅助栈</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>遍历链表得到链表的长度，然后顺序遍历链表，在数组中逆序添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = cur.val;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-24-反转链表"><a href="#2-剑指-Offer-24-反转链表" class="headerlink" title="2. 剑指 Offer 24. 反转链表"></a>2. <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220113084933609.png" alt="image-20220113084933609" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>设置变量 <code>pre</code> 保存前一个结点</p>
<img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220113090030130.png" alt="image-20220113090030130" style="zoom:80%;" />

<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-剑指-Offer-35-复杂链表的复制"><a href="#3-剑指-Offer-35-复杂链表的复制" class="headerlink" title="3. 剑指 Offer 35. 复杂链表的复制"></a>3. <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220113092423407.png" alt="image-20220113092423407" style="zoom:80%;" />

<p>（通过建立新的 Node 结点来复制原来的链表，而不是将原来结点的引用当作是新结点）</p>
<p><strong>思路一（哈希表）：</strong></p>
<ul>
<li><p>建立一个包含 &lt;原结点，新节点&gt; 的<strong>哈希表</strong></p>
</li>
<li><p>根据原节点的前后关系建立新节点的前后关系</p>
</li>
<li><p>根据原节点的 random 指针建立新节点的 random 指针</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希表法</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next) </span><br><span class="line">            map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));				<span class="comment">// 建立哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);			<span class="comment">// 建立 next 指针</span></span><br><span class="line">            map.get(cur).random = map.get(cur.random);		<span class="comment">// 建立 random 指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二（原地修改）：</strong></p>
<ul>
<li>初始链表：<code>1—&gt;2-&gt;3</code></li>
<li>将新结点拷贝到原结点之后：<code>1-&gt;1&#39;-&gt;2-&gt;2&#39;-&gt;3-&gt;3&#39;</code></li>
<li>分离结点：<ul>
<li><code>1-&gt;2-&gt;3</code></li>
<li><code>1&#39;-&gt;2&#39;-&gt;3&#39;</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">// 原地修改法</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 原结点后拷贝新结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">            newNode.next = node.next;</span><br><span class="line">            node.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建立新结点的 random 指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> node.next;</span><br><span class="line">            newNode.random = (node.random != <span class="literal">null</span>) ? node.random.next : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分离链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head, temp = <span class="literal">null</span>; node != <span class="literal">null</span> &amp;&amp; node.next != <span class="literal">null</span>;) &#123;</span><br><span class="line">            temp = node.next;</span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            node = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第-3-天-字符串"><a href="#第-3-天-字符串" class="headerlink" title="第 3 天 字符串"></a>第 3 天 字符串</h2><h3 id="1-剑指-Offer-05-替换空格"><a href="#1-剑指-Offer-05-替换空格" class="headerlink" title="1. 剑指 Offer 05. 替换空格"></a>1. <a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h3><p>简单，略</p>
<h3 id="2-剑指-Offer-58-II-左旋转字符串"><a href="#2-剑指-Offer-58-II-左旋转字符串" class="headerlink" title="2. 剑指 Offer 58 - II. 左旋转字符串"></a>2. <a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h3><p>简单，略</p>
<h2 id="第-4-天-查找算法（简单）"><a href="#第-4-天-查找算法（简单）" class="headerlink" title="第 4 天 查找算法（简单）"></a>第 4 天 查找算法（简单）</h2><h3 id="1-剑指-Offer-03-数组中重复的数字"><a href="#1-剑指-Offer-03-数组中重复的数字" class="headerlink" title="1. 剑指 Offer 03. 数组中重复的数字"></a>1. <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220114153806259.png" alt="image-20220114153806259" style="zoom:80%;" />

<p><strong>思路一（辅助数组）：</strong></p>
<ul>
<li>数组中的数的范围是 0 ~ n - 1，故可以使用一个辅助数组 <code>arr</code>（初始化元素为 0）来判断一个数是否出现过</li>
<li>遍历数组：<ul>
<li>若 <code>arr[num]</code> 值为 0 ，说明该数之前未出现过，则将 <code>arr[num]</code> 的值改为 1</li>
<li>若 <code>arr[num]</code> 值为 1 ，说明该数之前出现过，返回 <code>arr[num]</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) </span><br><span class="line">            arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[nums[i]] == <span class="number">1</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">            arr[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法采用的是空间换时间的策略，时间复杂度可以达到 <code>O(n)</code>，空间复杂度为 <code>O(n)</code></p>
<p>同样的可以使用一个集合来保存 arr 中的元素</p>
</blockquote>
<p><strong>思路二（原地置换法）：</strong></p>
<img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220114154750819.png" alt="image-20220114154750819" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) </span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[nums[i]];</span><br><span class="line">                nums[nums[i]] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方法不需要使用额外的辅助空间，是算法的进一步优化，大大降低了空间复杂度</p>
<p>时间复杂度可以达到 <code>O(n)</code>，空间复杂度为 <code>O(1)</code></p>
</blockquote>
<h3 id="2-剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#2-剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="2. 剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>2. <a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220114214036414.png" alt="image-20220114214036414" style="zoom:80%;" />

<p><strong>思路一（顺序遍历）：</strong></p>
<p>顺序遍历数组，到目标值后开始计数，到下一个数时停止计数，结束遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length &amp;&amp; nums[i] &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;	</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二（二分查找定界）：</strong></p>
<p>顺序遍历没用充分利用到升序数组的特性，可以考虑采用二分查找提升效率</p>
<p>目标值是连续出现的，可以使用二分查找确定出目标值的上下边界，做差就能得到目标值的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target) - helper(nums, target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> tar)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// &lt;= 是往右靠，能找到上边界</span></span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt;= tar) </span><br><span class="line">                i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般给的题目千万不要掉以轻心，习惯了直接遍历，面试的时候也可能就被直接遍历过去了</p>
<p>升序（降序）数组多往二分查找的方向上想一想</p>
<p>顺序遍历时间复杂度：<code>O(n)</code></p>
<p>优化后二分查找时间复杂度：<code>O(logn)</code></p>
</blockquote>
<h3 id="3-剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#3-剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="3. 剑指 Offer 53 - II. 0～n-1中缺失的数字"></a>3. <a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220114215219618.png" alt="image-20220114215219618" style="zoom:80%;" />

<p><strong>思路一（顺序遍历）：</strong></p>
<p>顺序遍历数组，遍历过程中判断当前值与其下标是否相等，不等则返回当前下标</p>
<p>需要注意几种特殊情况：</p>
<ul>
<li><p>[0]：缺失 1</p>
</li>
<li><p>[1]：缺失 0</p>
</li>
<li><p>[0, 1, 2]：缺失 n</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>  (nums.length == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == nums[nums.length - <span class="number">1</span>] + <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二（二分查找）：</strong></p>
<p>数组为升序数组，同样可以考虑使用二分查找进行优化</p>
<p>二分查找时：</p>
<ul>
<li>若 <code>nums[mid] == mid</code> ：说明 <code>mid</code> 之前没有缺失 数字</li>
<li>否则，说明 <code>mid</code> 之前就有缺失，令 <code>r = mid - 1</code></li>
</ul>
<p>循环结束，<code>l</code>就是缺失数字的下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) </span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-5-天-查找算法（中等）"><a href="#第-5-天-查找算法（中等）" class="headerlink" title="第 5 天 查找算法（中等）"></a>第 5 天 查找算法（中等）</h2><h3 id="1-剑指-Offer-04-二维数组中的查找"><a href="#1-剑指-Offer-04-二维数组中的查找" class="headerlink" title="1. 剑指 Offer 04. 二维数组中的查找"></a>1. <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220116172315234.png" alt="image-20220116172315234" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>站在矩阵右上角看，可以将矩阵当作是一个 BST 来处理，右上角元素为根节点，往左走数值减小，往下走，数值增大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>, row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target)</span><br><span class="line">                row++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                col--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种题明显可以用暴力搜索解决，时间复杂度：<code>O(n^2)</code>，但是用暴力法就大概率被 pass 了</p>
<p>从右上角开始走，利用这个顺序关系可以在<code>O(m+n)</code>的复杂度下解决这个题</p>
</blockquote>
<h3 id="2-剑指-Offer-11-旋转数组的最小数字"><a href="#2-剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="2. 剑指 Offer 11. 旋转数组的最小数字"></a>2. <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220116173233104.png" alt="image-20220116173233104" style="zoom:80%;" />

<p><strong>思路</strong></p>
<p>可以顺序遍历，但是就慢了</p>
<p>数组是由升序数组旋转而成，同样可以考虑使用二分查找</p>
<ul>
<li>当中间值小于最右侧的值时：说明右侧元素全部有序</li>
<li>当中间值大于最右侧的值时：说明左侧元素全部有序</li>
<li>当中间值等于最右侧的值时：说明最小值就在中间值与最右侧之间，不断逼近即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="comment">// 二分法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[pivot] &lt; numbers[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[pivot] &gt; numbers[high]) &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-剑指-Offer-50-第一个只出现一次的字符"><a href="#3-剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="3. 剑指 Offer 50. 第一个只出现一次的字符"></a>3. <a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220116174210635.png" alt="image-20220116174210635" style="zoom:80%;" />

<p><strong>思路一（辅助数组）：</strong></p>
<p>使用一个大小为 26 的数组记录下每个字母出现的次数，再遍历一遍数组就能得到只出现一次的字符</p>
<p>但是！这样虽然能通过，可求出的只是<strong>按字母表顺序排列</strong>的第一个出现一次的字符，并不是数组中第一个只出现一次的字符，还是存在漏洞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 辅助数组（过了但是不太符合题意）</span></span><br><span class="line">        <span class="type">int</span>[] alph = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            alph[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (alph[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二（链式哈希表）：</strong></p>
<p>借助链式哈希表（LinkedHashMap&lt;字符，是否是第一次出现&gt;）来寻找第一个只出现一次的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 链式哈希表</span></span><br><span class="line">        Map&lt;Character, Boolean&gt; dic = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> <span class="variable">strArr</span> <span class="operator">=</span> s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (c : strArr) </span><br><span class="line">            <span class="comment">// true：未重复出现过 false：重复出现过</span></span><br><span class="line">            dic.put(c, !dic.containsKey(c));</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())</span><br><span class="line">            <span class="keyword">if</span> (d.getValue())</span><br><span class="line">                <span class="keyword">return</span> d.getKey();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-6-天-搜索与回溯算法（树的层序遍历）"><a href="#第-6-天-搜索与回溯算法（树的层序遍历）" class="headerlink" title="第 6 天 搜索与回溯算法（树的层序遍历）"></a>第 6 天 搜索与回溯算法（树的层序遍历）</h2><h3 id="1-剑指-Offer-32-I-从上到下打印二叉树"><a href="#1-剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="1. 剑指 Offer 32 - I. 从上到下打印二叉树"></a>1. <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220116175733987.png" alt="image-20220116175733987" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>考察常规的层序遍历，借助队列就能实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ans.size(); i++) </span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#2-剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="2. 剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>2. <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220116180048049.png" alt="image-20220116180048049" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>层序遍历的过程中，每次循环时队列中的元素个数即为当前层的元素个数</p>
<p>只要在循环中再嵌套一层循环<code>for (int i = queue.size(); i &gt; 0; i--)</code>，不断将结点值加入 List 中就能实现分层打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#3-剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="3. 剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>3. <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220116180619130.png" alt="image-20220116180619130" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>分层层序遍历（如上题）的过程中，增加对当前所处层的判断即可</p>
<ul>
<li>当前层为偶数层：顺序打印</li>
<li>当前层为奇数层：逆序打印</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 顺序打印</span></span><br><span class="line">                <span class="keyword">if</span> (res.size() % <span class="number">2</span> == <span class="number">0</span>) temp.addLast(node.val);</span><br><span class="line">                <span class="comment">// 逆序打印</span></span><br><span class="line">                <span class="keyword">else</span> temp.addFirst(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-7-天-搜索与回溯（树的递归）"><a href="#第-7-天-搜索与回溯（树的递归）" class="headerlink" title="第 7 天 搜索与回溯（树的递归）"></a>第 7 天 搜索与回溯（树的递归）</h2><h3 id="1-剑指-Offer-26-树的子结构"><a href="#1-剑指-Offer-26-树的子结构" class="headerlink" title="1. 剑指 Offer 26. 树的子结构"></a>1. <a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220117112251661.png" alt="image-20220117112251661" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>判断 B 是否为 A 的子树，需要使用先序遍历对 A 的每一个结点进行遍历，来寻找一棵与 B 结构相同的子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主函数确定根的起点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="comment">// 排除特例</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 先序遍历</span></span><br><span class="line">        <span class="keyword">return</span> recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断两棵树的结构是否相同</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="comment">// B 先全部遍历完，说明结构相同</span></span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// A 先全部遍历完或者 A 与 B 的值不同，说明结构不同</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断子树是否相同</span></span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-27-二叉树的镜像"><a href="#2-剑指-Offer-27-二叉树的镜像" class="headerlink" title="2. 剑指 Offer 27. 二叉树的镜像"></a>2. <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220117113732487.png" alt="image-20220117113732487" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>通过递归交换左右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = mirrorTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-剑指-Offer-28-对称的二叉树"><a href="#3-剑指-Offer-28-对称的二叉树" class="headerlink" title="3. 剑指 Offer 28. 对称的二叉树"></a>3. <a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220117114350325.png" alt="image-20220117114350325" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>对称二叉树结点的左子树的左子树与右子树的右子树相同，左子树的右子树与右子树的左子树相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span> || recur(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(left.left, right.right) &amp;&amp; recur(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-8-天-动态规划-简单"><a href="#第-8-天-动态规划-简单" class="headerlink" title="第 8 天 动态规划(简单)"></a>第 8 天 动态规划(简单)</h2><h3 id="1-剑指-Offer-10-I-斐波那契数列"><a href="#1-剑指-Offer-10-I-斐波那契数列" class="headerlink" title="1. 剑指 Offer 10- I. 斐波那契数列"></a>1. <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220118092721772.png" alt="image-20220118092721772" style="zoom:80%;" />

<p><strong>思路一（递归法）：</strong></p>
<p>存在大量重复计算，时间复杂度高</p>
<p><strong>思路二（动态规划—辅助数组）：</strong></p>
<p>使用长度为 n 的辅助数组来保存斐波那契数列，减少递归算法中重复的计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">            dp[i] %= <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
</blockquote>
<p><strong>思路三（动态规划—辅助变量）：</strong></p>
<p>每一项都只与前两项有关，故在迭代时可以将辅助数组替换为两个辅助变量，大大减小时间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<h3 id="2-剑指-Offer-10-II-青蛙跳台阶问题🚩"><a href="#2-剑指-Offer-10-II-青蛙跳台阶问题🚩" class="headerlink" title="2. 剑指 Offer 10- II. 青蛙跳台阶问题🚩"></a>2. <a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a>🚩</h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220118103137414.png" alt="image-20220118103137414" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>青蛙每次只能只能跳一级或两级台阶，那么第 n 级台阶的跳法，应该是：<br>$$<br>f(n)&#x3D;f(n-1)+f(n-2)<br>$$</p>
<ul>
<li>让青蛙跳到倒数第二级台阶后，再跳一级</li>
<li>让青蛙跳到倒数第一级台阶后，再跳两级</li>
</ul>
<p>初始状态：$f(0)&#x3D;1,f(1)&#x3D;1$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-剑指-Offer-63-股票的最大利润"><a href="#3-剑指-Offer-63-股票的最大利润" class="headerlink" title="3. 剑指 Offer 63. 股票的最大利润"></a>3. <a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220118111401353.png" alt="image-20220118111401353" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>在遍历数组的过程中，维护一个最小值 <code>min</code>，最小值初试为<code>prices[0]</code></p>
<ul>
<li><p>如果<code>prices[i]</code>大于<code>min</code>，则更新利润<code>res</code></p>
</li>
<li><p>否则说明当前的<code>prices[i]</code>比<code>min</code>还小，则更新<code>min</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt;= <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt;= min)</span><br><span class="line">                min = prices[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res = Math.max(res, prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-9-天-动态规划（中等）"><a href="#第-9-天-动态规划（中等）" class="headerlink" title="第 9 天 动态规划（中等）"></a>第 9 天 动态规划（中等）</h2><h3 id="1-剑指-Offer-42-连续子数组的最大和"><a href="#1-剑指-Offer-42-连续子数组的最大和" class="headerlink" title="1. 剑指 Offer 42. 连续子数组的最大和"></a>1. <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220121102228988.png" alt="image-20220121102228988" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>定义状态数组 $dp[i]$ 来表示数组中从某个位置到 $i$ 的数最大和</p>
<p>初始状态 $dp[0] &#x3D; nums[0]$</p>
<p>状态转移方程：$dp[i]&#x3D;max(dp(i-1)+nums[i],nums[i])$ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>] + nums[i],nums[i]);</span><br><span class="line">            res = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：<code>O(n)</code></p>
<p>空间复杂度：<code>O(n)</code></p>
</blockquote>
<p>进一步的，我们可以原地修改数组 <code>nums</code>以减小空间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] += Math.max(nums[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            res = Math.max(nums[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：<code>O(n)</code></p>
<p>空间复杂度：<code>O(1)</code></p>
</blockquote>
<h3 id="2-剑指-Offer-47-礼物的最大价值"><a href="#2-剑指-Offer-47-礼物的最大价值" class="headerlink" title="2. 剑指 Offer 47. 礼物的最大价值"></a>2. <a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220121122458233.png" alt="image-20220121122458233" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>定义状态数组 $dp[i][j]$，表示从原点到位置 (i，j) 处可最多拿到价值多少的礼物</p>
<p>因为只能向右或向下移动，故数组上边界状态转移方程： $dp[0][j]&#x3D;dp[0][j-1]+grid[0][j]$</p>
<p>同理，左边界状态转移方程：$dp[i][0]&#x3D;dp[i-1][0]+grid[i][0]$</p>
<p>其他位置的状态转移方程：$dp[i][j]&#x3D;grid[i][j]+max(dp[i][j-1]，dp[i-1][j])$</p>
<p>同样如上题，我们可以通过原地修改来减小空间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) <span class="comment">// 初始化第一行</span></span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) <span class="comment">// 初始化第一列</span></span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">                grid[i][j] += Math.max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>





<h2 id="第-11-天-双指针"><a href="#第-11-天-双指针" class="headerlink" title="第 11 天 双指针"></a>第 11 天 双指针</h2><h3 id="1-剑指-Offer-18-删除链表的节点"><a href="#1-剑指-Offer-18-删除链表的节点" class="headerlink" title="1. 剑指 Offer 18. 删除链表的节点"></a>1. <a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220122103421773.png" alt="image-20220122103421773" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>删除链表某节点既是找到删除节点的前置结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.val != val) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-剑指-Offer-22-链表中倒数第k个节点"><a href="#2-剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="2.剑指 Offer 22. 链表中倒数第k个节点"></a>2.<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220122104259177.png" alt="image-20220122104259177" style="zoom:80%;" />

<p><strong>思路（快慢指针）：</strong></p>
<p>设置两个指针，让慢指针原地不动，快指针先走 k 个，此时快慢指针相距 k</p>
<p>让快慢指针同时开始移动，每次都移动一个单位，当快指针走完时，相距 k 个单位的慢指针刚好指向倒数第 k 个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head, cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-12-天-双指针"><a href="#第-12-天-双指针" class="headerlink" title="第 12 天 双指针"></a>第 12 天 双指针</h2><h3 id="1-剑指-Offer-25-合并两个排序的链表"><a href="#1-剑指-Offer-25-合并两个排序的链表" class="headerlink" title="1. 剑指 Offer 25. 合并两个排序的链表"></a>1. <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220122104853679.png" alt="image-20220122104853679" style="zoom:80%;" />

<p><strong>思路一（循环）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), cur = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 != <span class="literal">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二（递归）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-52-两个链表的第一个公共节点"><a href="#2-剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="2. 剑指 Offer 52. 两个链表的第一个公共节点"></a>2. <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220122115239964.png" alt="image-20220122115239964" style="zoom:80%;" />

<p><strong>思路一（哈希集合）：</strong></p>
<p>设置一个集合，遍历链表1，将链表1 中的元素加入集合中，然后遍历链表 2 ，判断结点是否在集合中，若在，既为公共结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            visited.add(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = headB;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(temp)) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/liang-ge-lian-biao-de-di-yi-ge-gong-gong-pzbs/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：<code>O(m + n)</code></p>
<p>空间复杂度：<code>O(n)</code></p>
</blockquote>
<p><strong>思路二（双指针）：</strong></p>
<p>设公共部分长度为 $len$，则有 $skipA + len + skipB &#x3D; skipB + len + skipA$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n2</span> <span class="operator">=</span> headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n1 != n2)&#123;</span><br><span class="line">            n1 = n1 == <span class="literal">null</span> ? headB : n1.next;</span><br><span class="line">            n2 = n2 == <span class="literal">null</span> ? headA : n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序员的浪漫：“两个结点不断的去对方的轨迹中寻找对方的身影，只要二人有交集，就终会相遇 💖”</p>
<p>时间复杂度：<code>O(m + n)</code></p>
<p>空间复杂度：<code>O(1)</code></p>
</blockquote>
<h2 id="第-13-天-双指针"><a href="#第-13-天-双指针" class="headerlink" title="第 13 天 双指针"></a>第 13 天 双指针</h2><h3 id="1-剑指-Offer-21-调整数组顺序使奇数位于"><a href="#1-剑指-Offer-21-调整数组顺序使奇数位于" class="headerlink" title="1. 剑指 Offer 21. 调整数组顺序使奇数位于"></a>1. <a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220124101340680.png" alt="image-20220124101340680" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>设置头尾双指针，头指针++直到遇到偶数，尾指针–直到遇到奇数，交换头尾指针指向的值，重复上述操作</p>
<p>思路有点像快排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; l &lt; nums.length &amp;&amp; r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] % <span class="number">2</span> != <span class="number">0</span>) l++;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] % <span class="number">2</span> == <span class="number">0</span>) r--;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) swap(nums, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] swap(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        nums[r] = tmp;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-57-和为s的两个数字"><a href="#2-剑指-Offer-57-和为s的两个数字" class="headerlink" title="2. 剑指 Offer 57. 和为s的两个数字"></a>2. <a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220124102246165.png" alt="image-20220124102246165" style="zoom:80%;" />

<p><strong>思路一（二分法）：</strong></p>
<p>顺序遍历数组，若第 $i$ 个元素为 a，则使用二分查找查找 $target-a$ 即可</p>
<blockquote>
<p>时间复杂度：$O(nlogn)$</p>
<p>空间复杂度：$O(1)$</p>
</blockquote>
<p><strong>思路二（双指针）👍：</strong></p>
<p>所给数组是递增数组，可以采用头尾指针 $l、r$</p>
<ul>
<li>若 $nums[l]+nums[r]&lt;target$，则 $l++$</li>
<li>若 $nums[l]+nums[r]&gt;target$，则 $r–$</li>
<li>若 $nums[l]+nums[r]&#x3D;target$，则说明找到</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (val == target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[l], nums[r]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; target) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-剑指-Offer-58-I-翻转单词顺序"><a href="#3-剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="3. 剑指 Offer 58 - I. 翻转单词顺序"></a>3. <a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220124112050270.png" alt="image-20220124112050270" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>设置双指针 $i、j$ 记录单词边界，删除字符串两端空格，逆序遍历字符串</p>
<p>每确定一个单词的边界，则将其添加到单词列表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i; <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/mian-shi-ti-58-i-fan-zhuan-dan-ci-shun-xu-shuang-z/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="第-14-天-搜索与回溯算法"><a href="#第-14-天-搜索与回溯算法" class="headerlink" title="第 14 天 搜索与回溯算法"></a>第 14 天 搜索与回溯算法</h2><h3 id="1-剑指-Offer-12-矩阵中的路径🚩"><a href="#1-剑指-Offer-12-矩阵中的路径🚩" class="headerlink" title="1. 剑指 Offer 12. 矩阵中的路径🚩"></a>1. <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a>🚩</h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220125114434495.png" alt="image-20220125114434495" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<ul>
<li>dfs + 回溯；</li>
<li>使用二维布尔数组记录之前的位置是否已经被访问过，如果已经被访问过的话，则在 dfs 的过程中，直接 <code>return false</code> 即可。也就是说，此路已经不通了；</li>
<li>如果当前遍历到的字符不等于 <code>board[i][j]</code> 位置上的字符，那么说明此路也是不通的，因此返回 <code>false</code>；</li>
<li>至于递归结束的条件：如果指针 <code>k</code> 能够来到 <code>word</code> 的最后一个字符，那么说明能够在矩阵 <code>board</code> 中找到一条路径，此时返回 <code>true</code>；</li>
<li>在遍历到当前 <code>board[i][j]</code> 的时候，首先应将该位置的 <code>visited[i][j]</code> 设置为 <code>true</code>，表明访问过；</li>
<li>然后，递归地去 <code>board[i][j]</code> 的上下左右四个方向去找，剩下的路径；</li>
<li>在 dfs 的过程当中，如果某条路已经不通了，那么那么需要回溯，也就是将 <code>visited[i][j]</code> 位置的布尔值重新赋值为 <code>fasle</code>；</li>
<li>最后，返回 <code>ans</code> 即可。</li>
</ul>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/u/sircarol/">CarolL3</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="literal">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, words, visited, i, j, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span>[] words, <span class="type">boolean</span>[][] visited, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length</span><br><span class="line">                || words[k] != board[i][j] || visited[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == words.length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        ans = dfs(board, words, visited, i + <span class="number">1</span>, j, k + <span class="number">1</span>)</span><br><span class="line">            || dfs(board, words, visited, i - <span class="number">1</span>, j, k + <span class="number">1</span>)</span><br><span class="line">            || dfs(board, words, visited, i, j + <span class="number">1</span>, k + <span class="number">1</span>)</span><br><span class="line">            || dfs(board, words, visited, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-13-机器人的运动范围"><a href="#2-剑指-Offer-13-机器人的运动范围" class="headerlink" title="2. 剑指 Offer 13. 机器人的运动范围"></a>2. <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220125120710231.png" alt="image-20220125120710231" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>同上题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">boolean</span> visited[][])</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || (i/<span class="number">10</span> + i%<span class="number">10</span> + j/<span class="number">10</span> + j%<span class="number">10</span>) &gt; k || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(i + <span class="number">1</span>, j, m, n, k, visited) + dfs(i - <span class="number">1</span>, j, m, n, k, visited) + </span><br><span class="line">               dfs(i, j + <span class="number">1</span>, m, n, k, visited) + dfs(i, j - <span class="number">1</span>, m, n, k, visited) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-15-天-搜索与回溯算法"><a href="#第-15-天-搜索与回溯算法" class="headerlink" title="第 15 天 搜索与回溯算法"></a>第 15 天 搜索与回溯算法</h2><h3 id="1-剑指-Offer-34-二叉树中和为某一值的路径"><a href="#1-剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="1. 剑指 Offer 34. 二叉树中和为某一值的路径"></a>1. <a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220127101314125.png" alt="image-20220127101314125" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>典型的二叉树方案搜索问题，使用回溯法解决（先序遍历 + 路径记录）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        recur(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(TreeNode root, <span class="type">int</span> tar)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        tar -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; tar == <span class="number">0</span>) </span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(path));</span><br><span class="line">        recur(root.left, tar);</span><br><span class="line">        recur(root.right, tar);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-36-二叉搜索树与双向链表"><a href="#2-剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="2. 剑指 Offer 36. 二叉搜索树与双向链表"></a>2. <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220127102020967.png" alt="image-20220127102020967" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>将二叉搜索树排成有序序列 &#x3D;&#x3D;&gt; 中序遍历</p>
<p>遍历时，判断当前结点是否是首个结点，如果是首个结点还要做特殊处理（左子节点是头节点而不是上一个结点）</p>
<p>遍历结束，连接链表头尾形成双向循环链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Node head, pre;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>) pre.right = cur;</span><br><span class="line">        <span class="keyword">else</span> head = cur;</span><br><span class="line">        cur.left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        dfs(cur.right); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-剑指-Offer-54-二叉搜索树的第k大节点"><a href="#3-剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="3. 剑指 Offer 54. 二叉搜索树的第k大节点"></a>3. <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220127102505427.png" alt="image-20220127102505427" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>由于是二叉搜索树，故可以采用中序遍历，将遍历结果依次保存到一个列表中，从而得到一个升序列表，升序列表中倒数第 k 个元素就是第 k 大的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inOrder(root, list);</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) </span><br><span class="line">            inOrder(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) </span><br><span class="line">            inOrder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
</blockquote>
<p><strong>进一步优化：</strong></p>
<p>其实遍历到第 k 大元素的时候，就可以停止遍历了</p>
<p>遍历过程采用 <code>右-根-左</code> 的中序遍历，那么遍历过程得到的其实是一个降序序列</p>
<p>设置一个变量 <code>count</code> 记录当前元素是第几大，当 <code>count == k</code> 时，返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量    </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) </span><br><span class="line">        inOrder(root.left, list);</span><br><span class="line">    <span class="keyword">if</span> (++count == k) &#123;</span><br><span class="line">        ans = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) </span><br><span class="line">        inOrder(root.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-16-天-排序"><a href="#第-16-天-排序" class="headerlink" title="第 16 天 排序"></a>第 16 天 排序</h2><h3 id="1-剑指-Offer-45-把数组排成最小的数"><a href="#1-剑指-Offer-45-把数组排成最小的数" class="headerlink" title="1. 剑指 Offer 45. 把数组排成最小的数"></a>1. <a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220127192621470.png" alt="image-20220127192621470" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>需要将字符按特定规则排序，排序后进行组合，就能得到最小的数</p>
<p>排序的规则：</p>
<ul>
<li><p>若拼接字符串 $ x + y &gt; y + x$ ，则 $ x$ “大于” $y$</p>
</li>
<li><p>反之，若 $x + y &lt; y + x$，则 $x$ “小于” $y$</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            list.add(String.valueOf(num));</span><br><span class="line">        &#125;</span><br><span class="line">        list.sort((o1, o2) -&gt; (o1 + o2).compareTo(o2 + o1));</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot;&quot;</span>, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-61-扑克牌中的顺子"><a href="#2-剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="2. 剑指 Offer 61. 扑克牌中的顺子"></a>2. <a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220127195110316.png" alt="image-20220127195110316" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<blockquote>
<p>根据题意，此 5 张牌是顺子的 充分条件 如下：</p>
<ol>
<li>除大小王外，所有牌 无重复 ；</li>
<li>设此 5 张牌中最大的牌为 $max $，最小的牌为 $min $（大小王除外），则需满足：$max - min &lt; 5$</li>
</ol>
<p>因而，可将问题转化为：此 5 张牌是否满足以上两个条件？</p>
<p>作者：jyd<br>链接：<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solution/mian-shi-ti-61-bu-ke-pai-zhong-de-shun-zi-ji-he-se/">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solution/mian-shi-ti-61-bu-ke-pai-zhong-de-shun-zi-ji-he-se/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">14</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            min = Math.min(min, num);</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (max - min) &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-17-天-排序"><a href="#第-17-天-排序" class="headerlink" title="第 17 天 排序"></a>第 17 天 排序</h2><h3 id="1-剑指-Offer-40-最小的k个数"><a href="#1-剑指-Offer-40-最小的k个数" class="headerlink" title="1.  剑指 Offer 40. 最小的k个数"></a>1.  <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220128100129828.png" alt="image-20220128100129828" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>将数组进行排序，排序后取数组前 k 个元素既为结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// Arrays.sort(arr);</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partation(arr, low, high);</span><br><span class="line">            quickSort(arr, low, pivot - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pivot + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">partation</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; pivot &lt;= arr[high]) high--;</span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; pivot &gt;= arr[low]) low++;</span><br><span class="line">            arr[high] = arr[low]; </span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-18-天-搜索与回溯算法"><a href="#第-18-天-搜索与回溯算法" class="headerlink" title="第 18 天 搜索与回溯算法"></a>第 18 天 搜索与回溯算法</h2><h3 id="1-剑指-Offer-55-I-二叉树的深度"><a href="#1-剑指-Offer-55-I-二叉树的深度" class="headerlink" title="1. 剑指 Offer 55 - I. 二叉树的深度"></a>1. <a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220129110624830.png" alt="image-20220129110624830" style="zoom:80%;" />

<p><strong>思路一（dfs）：</strong></p>
<p>直接看代码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二（bfs）：</strong></p>
<p>设置变量 <code>depth</code> 记录树深，层序遍历，每遍历一层，<code>depth++</code>，就类似于按层打印二叉树的思想</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-55-II-平衡二叉树"><a href="#2-剑指-Offer-55-II-平衡二叉树" class="headerlink" title="2. 剑指 Offer 55 - II. 平衡二叉树"></a>2. <a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220129115034921.png" alt="image-20220129115034921" style="zoom:80%;" />

<p><strong>思路一：</strong></p>
<p>分别求出每个结点作为树的根节点时树的深度，再对每个结点递归的进行判断是否为平衡二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(getDepth(root.left) - getDepth(root.right)) &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : <span class="number">1</span> + Math.max(getDepth(root.left), getDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法虽然容易想到，但是在计算深度时会产生大量重复计算，时间效率较低</p>
<p>时间复杂度：$O(nlogn)$</p>
<p>空间复杂度：$O(n)$</p>
</blockquote>
<p><strong>思路二：</strong></p>
<p>对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> recur(root.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> recur(root.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/solution/mian-shi-ti-55-ii-ping-heng-er-cha-shu-cong-di-zhi/">面试题55 - II. 平衡二叉树（从底至顶、从顶至底，清晰图解）</a></p>
<p>时间复杂度：$O(n)$</p>
<p>空间复杂度：$O(n)$</p>
</blockquote>
<h2 id="第-19-天-搜索与回溯算法"><a href="#第-19-天-搜索与回溯算法" class="headerlink" title="第 19 天 搜索与回溯算法"></a>第 19 天 搜索与回溯算法</h2><h3 id="1-剑指-Offer-64-求1-2-…-n"><a href="#1-剑指-Offer-64-求1-2-…-n" class="headerlink" title="1. 剑指 Offer 64. 求1+2+…+n"></a>1. <a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220130113136083.png" alt="image-20220130113136083" style="zoom:80%;" />

<p><strong>思路一（调包）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.range(<span class="number">1</span>, n + <span class="number">1</span>).sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路二（巧用 &amp;&amp;）：</strong></p>
<p>在式子 <code>A &amp;&amp; B</code> 中，如果 A 为 <code>false</code>，则整个表达式已经是 <code>false</code> 了，就不用执行 B 的内容了</p>
<p>由此，我们可以用 B 来递归计算 n 项和，A 作为终止条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> n &gt; <span class="number">1</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#2-剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="2. 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>2. <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220130114815529.png" alt="image-20220130114815529" style="zoom:80%;" />



<p><strong>思路：</strong></p>
<p>题中所给树是一颗二叉搜索树，不难推出，两个结点 p、q 的最近公共祖先的值必定夹在 p、q 的值之间</p>
<p>递归搜索即可，递归终止条件：$root.val &gt; p.val\ and\ root.val &lt; q.val$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#3-剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="3. 剑指 Offer 68 - II. 二叉树的最近公共祖先"></a>3. <a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h3><img src="【数据结构与算法】LeetCode：剑指Offer30天计划/image-20220130115409513.png" alt="image-20220130115409513" style="zoom:80%;" />

<p><strong>思路：</strong></p>
<p>考虑通过递归对二叉树进行先序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p, q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</p>
<blockquote>
<p>作者：jyd<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 若当前节点为空或当前结点为 p、q 中的一个，则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 递归搜索当前结点的左右子树，看 p、q 结点是否在当前结点的左右子树中</span></span><br><span class="line">        <span class="comment">// 最先遇到哪个就返回哪个</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 递归得到的左(右)子节点为空，说明当前节点的左(右)子节点的子节点中不含 p、q</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：搜索与回溯算法</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="1-矩阵中的路径"><a href="#1-矩阵中的路径" class="headerlink" title="1. 矩阵中的路径"></a>1. <a href="https://leetcode-cn.com/problems/word-search/">矩阵中的路径</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201113082513982.png" alt="image-20201113082513982" style="zoom:80%;" />

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本问题是典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p>
<ul>
<li><p><strong>深度优先搜索</strong>： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p>
</li>
<li><p><strong>剪枝</strong>： 在搜索中，遇到 <strong>这条路不可能和目标字符串匹配成功</strong> 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 <strong>可行性剪枝</strong> 。</p>
</li>
</ul>
<p><strong>DFS 解析：</strong> f</p>
<ul>
<li><p>递归参数： 当前元素在矩阵 <code>board</code> 中的行列索引 <code>i</code> 和 <code>j</code> ，当前目标字符在 <code>word</code> 中的索引 <code>k</code> 。</p>
</li>
<li><p>终止条件：</p>
<ol>
<li><p>返回 <code>false</code> ： (1) 行或列索引越界 </p>
<p> ​						  (2) 当前矩阵元素与目标字符不同 </p>
<p> ​						  (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） </p>
</li>
<li><p>返回 <code>true</code> ： <code>k = len(word) - 1</code> ，即字符串 <code>word</code> 已全部匹配。</p>
</li>
</ol>
</li>
<li><p>递推工作：</p>
<ol>
<li>标记当前矩阵元素： 将 board<code>[i][j]</code> 修改为 空字符 ‘\0’ ，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li>搜索下一单元格： 朝当前元素的 <strong>上、下、左、右</strong> 四个方向开启下层递归，使用 <code>或</code> 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 <code>res</code> 。</li>
<li>还原当前矩阵元素： 将 <code>board[i][j]</code> 元素还原至初始值，即 <code>word[k]</code> 。</li>
</ol>
</li>
<li><p>返回值： 返回布尔量 res ，代表是否搜索到目标字符串。</p>
<blockquote>
<p>使用空字符（Python: ‘’ , Java&#x2F;C++: ‘\0’ ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>作者：Krahets<br>链接：<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/58d5vh/">https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/58d5vh/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(board, words, i, j, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span>[] words, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// i 或 j 越界，或者字符不匹配，则直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != words[k])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == words.length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board, words, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, words, i - <span class="number">1</span>, j, k + <span class="number">1</span>)</span><br><span class="line">            || dfs(board, words, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, words, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">    board[i][j] = words[k];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-机器人的运动范围"><a href="#2-机器人的运动范围" class="headerlink" title="2. 机器人的运动范围"></a>2. <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">机器人的运动范围</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201121093611682.png" alt="image-20201121093611682" style="zoom:80%;" />

<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>数位之和计算</p>
<p>  数位之和计算通法：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sums</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在本题中，机器人每次移动一格，x 的增量为 1，故：</p>
<p>  数位之和计算可简化为：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(x + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? s_x + <span class="number">1</span> : s_x - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>易知，机器人可 <strong>仅通过向右和向下移动，访问所有可达解</strong> 。</p>
</li>
<li><p>综上，可使用深度优先遍历：</p>
<ul>
<li>终止条件：<ol>
<li>遍历数组下标越界</li>
<li>数组下标之和大于 k</li>
<li>该位置已被访问过</li>
</ol>
</li>
<li>将当前位置设置为已访问</li>
<li>返回 <code>1 + dfs(向下) + dfs(向右)</code></li>
</ul>
</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>可以使用<strong>本题简化后的数位之和运算方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> visited[][];</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> si, <span class="type">int</span> sj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m || j &gt;= n || si + sj &gt; k || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + </span><br><span class="line">                dfs(i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj) +</span><br><span class="line">                dfs(i, j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可使用<strong>最基本的数位之和运算方法</strong>进行解答，代码更易懂，但效率相对会低一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> visited[][];</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m || j &gt;= n || sums(i, j) &gt; k || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j) + dfs(i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sums</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += y % <span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-树的子结构"><a href="#3-树的子结构" class="headerlink" title="3. 树的子结构"></a>3. <a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201121102743432.png" alt="image-20201121102743432" style="zoom:80%;" />

<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考：<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5dsbng/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
<ul>
<li><p>判断 B 树是否为 A 树的子树，需要依次判断 B 树是否为 A 树某个节点的子树，该过程可分为两步：</p>
<ol>
<li><p>遍历 A 树的每个节点 node_i                 （对应函数 <code>isSubStructure(A, B)</code>）</p>
</li>
<li><p>判断 B 树是否为节点 node_i 的子树    （对应函数 <code>recur(A, B)</code>）</p>
</li>
</ol>
</li>
<li><p><code>recur(A , B)</code></p>
<ul>
<li>终止条件：<ol>
<li>B 树到底，说明 B 树是该节点的子树，返回 <code>true</code></li>
<li>A 树(该节点)到底，说明该节点不包含 B 树，返回 <code>false</code></li>
<li>A 树(该节点)与 B 树的值不相等，返回 <code>false</code></li>
</ol>
</li>
<li>返回值：<ol>
<li>判断当前节点的左子树是否与 B 树的左子树相等</li>
<li>判断当前节点的右子树是否与 B 树的右子树相等</li>
</ol>
</li>
</ul>
</li>
<li><p><code>isSubStructure(A, B)</code></p>
<ul>
<li>排除特殊情况：A 树 或者 B 树为空</li>
<li>B 树是 A 树根节点的子树 <code>recur(A, B)</code></li>
<li>B 树是 A 树 左子节点的子树 <code>isSubStructure(A.left, B)</code></li>
<li>B 树是 A 树 右子节点的子树 <code>isSubStructure(A.right, B)</code></li>
</ul>
</li>
</ul>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span> <span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-二叉树的镜像-🔥"><a href="#4-二叉树的镜像-🔥" class="headerlink" title="4. 二叉树的镜像 🔥"></a>4. <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像 🔥</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201121104553494.png" alt="image-20201121104553494" style="zoom:80%;" />

<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考：<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/59slxe/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
<p>递归遍历整个二叉树，交换每个节点的左右子节点，即可得到镜像的二叉树</p>
<ul>
<li><p>终止条件：当节点为空时，返回 null</p>
</li>
<li><p>递推工作：交换左右子节点（类似于交换两个值）</p>
<ol>
<li><p><code>TreeNode temp = root.left;</code></p>
</li>
<li><p><code>root.left = mirrorTree(root.right);</code></p>
</li>
<li><p><code>root.right = mirrorTree(temp);</code></p>
</li>
</ol>
</li>
<li><p>返回结果： <code>root</code></p>
</li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = mirrorTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-对称的二叉树"><a href="#5-对称的二叉树" class="headerlink" title="5. 对称的二叉树"></a>5. <a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201121113002400.png" alt="image-20201121113002400" style="zoom:80%;" />

<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考：<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5d1zmj/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
<ul>
<li><p>对于对称的二叉树，一定有：</p>
<ul>
<li><code>L.val = R.val</code></li>
<li><code>L.left.val = R.right.val</code></li>
<li><code>L.left.val = R.right.val</code></li>
</ul>
</li>
<li><p><strong><code>recur(left, right)</code></strong></p>
<ul>
<li><p>终止条件：</p>
<ol>
<li>当 <code>L</code> 和 <code>R</code> 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true</li>
<li>当 <code>L</code> 或 <code>R</code> 中只有一个越过叶节点： 此树不对称，因此返回 <code>false</code></li>
<li>当节点 <code>L</code> 值 !&#x3D; 节点 <code>R</code> 值： 此树不对称，因此返回 <code>false</code></li>
</ol>
</li>
<li><p>返回值：</p>
<p>  两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</p>
</li>
</ul>
</li>
</ul>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span> || recur(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(left.left, right.right) &amp;&amp; recur(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="6-从上到下打印二叉树-🔥"><a href="#6-从上到下打印二叉树-🔥" class="headerlink" title="6. 从上到下打印二叉树 🔥"></a>6. <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树 🔥</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201123170957052.png" alt="image-20201123170957052" style="zoom: 80%;" />

<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考：<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/9ab39g/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
<p>从上至下打印二叉树一般使用 <strong>BFS（广度优先搜索）</strong>。</p>
<p>BFS 通常借助 <strong>队列</strong> 的先入先出的特性来实现。</p>
<ul>
<li>特殊处理：<code>root == null</code></li>
<li>初始化：<code>List</code>、<code>Queue</code></li>
<li><strong>BFS循环</strong><ul>
<li>队首元素出队</li>
<li>将队首元素的值添加到 <code>List</code> 中</li>
<li>添加<strong>不为空的子节点</strong>至队列中</li>
</ul>
</li>
<li>将 <code>List</code> 转为 整性数组 并返回</li>
</ul>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// 1. 特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 2. 初始化</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">// 3. BFS循环</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 将 List 转化为 数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ans.size(); i++) </span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-从上到下打印二叉树-II"><a href="#7-从上到下打印二叉树-II" class="headerlink" title="7. 从上到下打印二叉树 II"></a>7. <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof">从上到下打印二叉树 II</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201123173037014.png" alt="image-20201123173037014" style="zoom:80%;" />

<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>大致思路同 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树</a></p>
<p>变化在于在 BFS循环 中，<strong>队列 Queue 的长度即为每一层的节点数</strong>！</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 队列 queue 的长度即为每一层的节点数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="8-二叉树中和为某一值的路径"><a href="#8-二叉树中和为某一值的路径" class="headerlink" title="8. 二叉树中和为某一值的路径"></a>8. <a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201123175344652.png" alt="image-20201123175344652" style="zoom:80%;" />

<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考：<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5dc8rr/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
<p>二叉树方案搜索问题，使用<strong>回溯法</strong>解决，包含 <strong>先序遍历 + 路径记录</strong></p>
<ul>
<li><p>先序遍历： 按照 “根、左、右” 的顺序，遍历树的所有节点。</p>
</li>
<li><p>路径记录： 在先序遍历中，记录从根节点到当前节点的路径。当路径满足</p>
<p>   ① 根节点到叶节点形成的路径 </p>
<p>   ② 各节点值的和等于目标值 sum </p>
<p>  时，将此路径加入结果列表。</p>
</li>
</ul>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        recur(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// root：当前节点 	tar：当前目标值</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(TreeNode root, <span class="type">int</span> tar)</span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 路径更新</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">// 目标值更新</span></span><br><span class="line">        tar -= root.val;</span><br><span class="line">        <span class="comment">// 路径记录，将满足条件的路径添加到结果中</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; tar == <span class="number">0</span>) </span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(path));</span><br><span class="line">        <span class="comment">// 不满足条件，继续递归</span></span><br><span class="line">        recur(root.left, tar);</span><br><span class="line">        recur(root.right, tar);</span><br><span class="line">        <span class="comment">// 路径恢复：向上回溯前需要将当前节点从路径中删除</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="9-二叉搜索树与双向链表"><a href="#9-二叉搜索树与双向链表" class="headerlink" title="9. 二叉搜索树与双向链表"></a>9. <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201127102646145.png" alt="image-20201127102646145" style="zoom:80%;" />

<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考：<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5dj09d/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
<p>题目要求将<strong>二叉搜索树</strong>转化为<strong>排序</strong>的<strong>双向循环链表</strong></p>
<p>按顺序遍历二叉搜索树需要用到中序遍历！</p>
<p>这里我们需要用到两个函数 <code>treeToDoublyList(Node root)</code> 、 <code>dfs(Node cur)</code></p>
<ul>
<li><p><code>dfs(Node cur)</code></p>
<p>  用来中序遍历 BST，在遍历过程中生成双向链表</p>
<ul>
<li><p>特殊情况：当前节点为空，直接返回</p>
</li>
<li><p>生成双向链表：</p>
<p>  如果上一个节点为空，则说明没有头节点，将当前节点置为头节点</p>
<p>  <code>pre.right = cur</code></p>
<p>  <code>cur.left = pre</code></p>
<p>  <code>pre</code> 节点后移一位，指向当前节点</p>
</li>
</ul>
</li>
<li><p><code>treeToDoublyList(Node root)</code>：</p>
<p>  该函数用来生成完整的双向循环链表</p>
<ul>
<li>特殊情况：当前节点为空，直接返回</li>
<li>生成双向链表：<code>dfs(root)</code></li>
<li>生成循环链表：头尾相连</li>
<li>返回头节点 <code>head</code></li>
</ul>
</li>
</ul>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Node head, pre;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>) pre.right = cur</span><br><span class="line">        <span class="keyword">else</span> head = cur;</span><br><span class="line">        cur.left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        dfs(cur.right); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="10-序列化二叉树"><a href="#10-序列化二叉树" class="headerlink" title="10. 序列化二叉树"></a>10. <a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">序列化二叉树</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201127105322127.png" alt="image-20201127105322127" style="zoom:80%;" />

<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考：<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/997ebc/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
<p><strong>序列化</strong> 使用<strong>层序遍历</strong>实现。<strong>反序列化</strong> 通过各层节点之间的关系建立序列中的索引，进而实现。</p>
<ul>
<li><p>序列化</p>
<ul>
<li><p>特数情况： <code>root</code> 为空，直接返回 <code>[]</code></p>
</li>
<li><p>建立 <code>StringBulider</code>（存储序列化后的二叉树）、<code>Queue</code> （进行层序遍历）</p>
<p>  <code>node</code> 不为空：将  <code>node </code>的值加入结果</p>
<p>  <code>node</code> 为空：将 <code>null</code> 加入结果 </p>
</li>
<li><p>需要注意的小细节：</p>
<ol>
<li>结果的首尾需要加上 <code>[]</code></li>
<li>序列化后得每个字符之间通过 <code>,</code> 隔开，故需要每次加入值时加入 <code>,</code> 同时最后删除多余的 <code>,</code></li>
</ol>
</li>
</ul>
</li>
<li><p>反序列化</p>
<p>  基本操作同上，但需要设置一个索引 <code>i</code> 来记录得到的字符串数组的下标，每当有不为 <code>i++</code> ，判断 <code>vals[i]</code> 是否为 <code>null</code>，不为<code>null</code> 则用它的值建立树，并与二叉树相连</p>
<ul>
<li>需要注意的小细节：<ol>
<li>处理字符串数组可使用 <code>data.substring(1, data.length() - 1).split(&quot;,&quot;)</code></li>
<li>使用字符串数组中的值初始化树节点时注意将值转为整型</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        String[] vals = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<h3 id="绝活"><a href="#绝活" class="headerlink" title="绝活"></a>绝活</h3><p>看到0ms的大神🤷‍♀️</p>
<ul>
<li><p>设置全局变量保存 <code>root</code></p>
</li>
<li><p>结果的输出与第一个函数输出<strong>无关</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root =root;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="11-二叉树的深度-🔥"><a href="#11-二叉树的深度-🔥" class="headerlink" title="11. 二叉树的深度 🔥"></a>11. <a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">二叉树的深度 🔥</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201127151908392.png" alt="image-20201127151908392" style="zoom:80%;" />

<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>基础题，一般情况可用递归两行代码搞定！</p>
<ul>
<li>思路一：<strong>递归遍历</strong>二叉树，返回 <code>1 + 深度较大的子树的层数</code></li>
<li>思路二：<strong>层序遍历</strong>二叉树，设置变量记录遍历最大层数</li>
</ul>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 初始化一个空列表 tmp ，用于临时存储下一层节点；</span></span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(TreeNode node : queue) &#123;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) tmp.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) tmp.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            queue = tmp;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="12-求1-2-…-n"><a href="#12-求1-2-…-n" class="headerlink" title="12. 求1+2+…+n"></a>12. <a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201127153506025.png" alt="image-20201127153506025" style="zoom:80%;" />

<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本题禁止使用乘除法，不然可以用公式：</li>
</ul>
<p>$$<br>sum &#x3D; n * (n - 1) &#x2F; 2<br>$$</p>
<ul>
<li><p>也禁止用条件判断、循环语句，不然可以直接循环或者递归求和：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// if 语句不让用</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    n += sum(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以我们考虑使用<strong>布尔运算</strong>的<strong>短路效应</strong>来替代 <code>if</code> 语句：</p>
<p>  <code>boolean x = (n &gt; 1) &amp;&amp; ...</code></p>
<ul>
<li>当 <code>n &gt; 1</code> 时，会执行后面的判断语句</li>
<li>当 <code>n &lt;= 1</code> 时，会直接得出结果 <code>false</code> 从而不执行后面的语句</li>
</ul>
</li>
</ul>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> n &gt; <span class="number">1</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绝活-1"><a href="#绝活-1" class="headerlink" title="绝活"></a>绝活</h3><p>使用 C++ 构造二维数组，直接求 二维数组的大小的一半，就是结果</p>
<p>从而间接实现<br>$$<br>sum &#x3D; \frac{n * (n - 1)}  {2}<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++ 一步到位</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNums</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> arr[n][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(arr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="13-二叉搜索树的最近公共祖先-🔥"><a href="#13-二叉搜索树的最近公共祖先-🔥" class="headerlink" title="13. 二叉搜索树的最近公共祖先 🔥"></a>13. <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉搜索树的最近公共祖先 🔥</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201127175822734.png" alt="image-20201127175822734" style="zoom:80%;" />

<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考：<a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5793vc/">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p>
<p>由二叉搜索树的性质可知两个子树的公共祖先的值一定在两个子树的值之间</p>
<img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201127180601259.png" alt="image-20201127180601259" style="zoom: 50%;" />

<p>故可分三种情况进行递归：</p>
<ol>
<li><p>子树的值都比当前节点小：</p>
<p> 公共祖先在当前节点的左侧，向左进行递归</p>
</li>
<li><p>子树的值都比当前节点大：</p>
<p> 公共祖先在当前节点的右侧，向右进行递归</p>
</li>
<li><p>子树的值在当前节点之间：</p>
<p> 返回当前节点</p>
</li>
</ol>
<h3 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="14-二叉树的最近公共祖先"><a href="#14-二叉树的最近公共祖先" class="headerlink" title="14. 二叉树的最近公共祖先"></a>14. <a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先</a></h1><img src="【数据结构与算法】LeetCode：搜索与回溯算法/image-20201127181040078.png" alt="image-20201127181040078" style="zoom:80%;" />

<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><p>大体思路同 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先</a></p>
<h3 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的最近公共祖先</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * 三种情况：</span></span><br><span class="line"><span class="comment">     * 1、p q 一个在左子树 一个在右子树 那么当前节点即是最近公共祖先</span></span><br><span class="line"><span class="comment">     * 2、p q 都在左子树 </span></span><br><span class="line"><span class="comment">     * 3、p q 都在右子树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p q 一个在左，一个在右</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p q 都在左子树</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p q 都在右子树</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】LeetCode：每日一题</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h1 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h1><h2 id="3-连续数组🎈"><a href="#3-连续数组🎈" class="headerlink" title="3 连续数组🎈"></a>3 <a href="https://leetcode-cn.com/problems/contiguous-array/">连续数组</a>🎈</h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210603212532955.png" alt="image-20210603212532955" style="zoom:80%;" />

<h3 id="大佬思路"><a href="#大佬思路" class="headerlink" title="大佬思路"></a>大佬思路</h3><p>算法步骤：</p>
<p>创建一个哈希表，用 <code>key</code> 来储存 <code>cur</code> 值, <code>value</code> 来储存当前 <code>index</code>。</p>
<p>假设我们碰到 0 就将 <code>cur</code> 减一, 碰到 1 则 加一。<br>如果我们能在哈希表中找到当前的 <code>cur</code> 值, 则取出对应的 <code>pos</code>, 在看当前的 <code>index - pos</code> 是否比 <code>ans</code> 大, 取其中的最优解。</p>
<p><strong>核心：由于以上碰1加一，碰0减一的操作，当0与1数量一致时(连续数组), 其连续数组的和为零。因此我们知道数组前面的 <code>cur</code> 值是什么，在到达该连续数组尾部时就不会变。因此我们只需要检查哈希表中是否存在其相同的 <code>cur</code> 值即可！(多读几遍)</strong></p>
<blockquote>
<p>作者：Xiaohu9527<br>链接：<a href="https://leetcode-cn.com/problems/contiguous-array/solution/dong-tu-yan-shi-qian-zhui-he-si-xiang-by-z2no/">https://leetcode-cn.com/problems/contiguous-array/solution/dong-tu-yan-shi-qian-zhui-he-si-xiang-by-z2no/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<img src="【数据结构与算法】LeetCode：每日一题/image-20210603214006741.png" alt="image-20210603214006741" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        map.put(counter, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(counter)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">prevIndex</span> <span class="operator">=</span> map.get(counter);</span><br><span class="line">                maxLength = Math.max(maxLength, i - prevIndex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(counter, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/contiguous-array/solution/lian-xu-shu-zu-by-leetcode-solution-mvnm/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h1 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h1><h2 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1. 无重复字符的最长子串"></a>1. <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210504171538656.png" alt="image-20210504171538656" style="zoom:80%;" />

<h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>偷懒直接看了评论…</p>
<h3 id="大佬的思路"><a href="#大佬的思路" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p><strong>滑动窗口！！！</strong></p>
<p>滑动窗口具体内容就不多说了，直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 滑动窗口</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(r))) &#123;</span><br><span class="line">                l = Math.max(l, map.get(s.charAt(r)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(r), r);</span><br><span class="line">            max = Math.max(max, r - l + <span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-子数组异或查询"><a href="#2-子数组异或查询" class="headerlink" title="2. 子数组异或查询"></a>2. <a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">子数组异或查询</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210512172613337.png" alt="image-20210512172613337" style="zoom:80%;" />

<h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>直接两层循环搞定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] xorQueries(<span class="type">int</span>[] arr, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; queries.length; k++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queries[k][<span class="number">0</span>]; i &lt;= queries[k][<span class="number">1</span>]; i++) &#123;</span><br><span class="line">                tmp ^= arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res[k] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大佬的思路-1"><a href="#大佬的思路-1" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>题太简单，都差不多</p>
<h2 id="3-二叉树的堂兄弟节点"><a href="#3-二叉树的堂兄弟节点" class="headerlink" title="3. 二叉树的堂兄弟节点"></a>3. <a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">二叉树的堂兄弟节点</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210517213529650.png" alt="image-20210517213529650" style="zoom:80%;" />

<h3 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h3><p>层序遍历二叉树，如果某一层的节点满足条件且不是相同父节点，则输出 true</p>
<p>有想法但是没有实现</p>
<h3 id="大佬的思路-2"><a href="#大佬的思路-2" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>参考：<a href="https://leetcode-cn.com/u/allenz-me/">FāKăL1</a></p>
<p>深度遍历，记录 x、y 两节点的深度与父节点，最后做判断即可</p>
<p>代码简单易懂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存 x、y 的深度与父节点</span></span><br><span class="line">    <span class="type">int</span> xpar, xdep, ypar, ydep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        dfs(root.left, <span class="number">1</span>, x, y, root.val);</span><br><span class="line">        dfs(root.right, <span class="number">1</span>, x, y, root.val);</span><br><span class="line">        <span class="keyword">return</span> (xpar != ypar) &amp;&amp; (xdep == ydep);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> dep, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> par)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.val == x) &#123;</span><br><span class="line">            xpar = par;</span><br><span class="line">            xdep = dep;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val == y) &#123;</span><br><span class="line">            ypar = par;</span><br><span class="line">            ydep = dep;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(node.left, dep+<span class="number">1</span>, x, y, node.val);</span><br><span class="line">            dfs(node.right, dep+<span class="number">1</span>, x, y, node.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-前K个高频单词"><a href="#4-前K个高频单词" class="headerlink" title="4. 前K个高频单词"></a>4. <a href="https://leetcode-cn.com/problems/top-k-frequent-words/">前K个高频单词</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210520193745365.png" alt="image-20210520193745365" style="zoom:80%;" />

<h3 id="我的思路-3"><a href="#我的思路-3" class="headerlink" title="我的思路"></a>我的思路</h3><p>遍历 <code>words</code> 数组，将每个 <code>word</code> 及其出现的频率加入到一个 <code>map</code> 中，最后对 <code>map</code> 进行排序，输出前 <code>k</code> 个到 List 中进行返回。</p>
<p>思路没问题，但是在对 map 排序的时候出现了问题：需要同时对 <code>key</code> 和 <code>value</code> 进行排序</p>
<h3 id="大佬的思路-3"><a href="#大佬的思路-3" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><ul>
<li><code>map.entrySet</code> :</li>
</ul>
 <img src="【数据结构与算法】LeetCode：每日一题/image-20210520194554863.png" alt="image-20210520194554863" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            cnt.put(word, cnt.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; rec = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// Entry 可以建立起 key 与 value 一一对应的关系</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            rec.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(rec, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">                <span class="comment">// 两单词出现频率相同：按字母顺序排</span></span><br><span class="line">                <span class="comment">// 两单词出现频率不同：按单词频率排</span></span><br><span class="line">                <span class="keyword">return</span> cnt.get(word1) == cnt.get(word2) ? </span><br><span class="line">                    word1.compareTo(word2) : cnt.get(word2) - cnt.get(word1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rec.subList(<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/top-k-frequent-words/solution/qian-kge-gao-pin-dan-ci-by-leetcode-solu-3qk0/">https://leetcode-cn.com/problems/top-k-frequent-words/solution/qian-kge-gao-pin-dan-ci-by-leetcode-solu-3qk0/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h1 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h1><h2 id="1-递增顺序搜索树"><a href="#1-递增顺序搜索树" class="headerlink" title="1 递增顺序搜索树"></a>1 <a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">递增顺序搜索树</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210425210936999.png" alt="image-20210425210936999" style="zoom:80%;" />

<h3 id="我的思路-4"><a href="#我的思路-4" class="headerlink" title="我的思路"></a>我的思路</h3><p>先用一个数组保存树的中序序列，再通过中序序列根据题目要求构建新的树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">increasingBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inOrder(root, vals);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value: vals) &#123;</span><br><span class="line">            cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; vals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, vals);</span><br><span class="line">        vals.add(root.val);</span><br><span class="line">        inOrder(root.right, vals);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大佬的思路-4"><a href="#大佬的思路-4" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>在中序遍历的过程中，修改树的左右子节点，使左子树为空，右子树为中序中序遍历的下一个节点</p>
<img src="【数据结构与算法】LeetCode：每日一题/image-20210425211503346.png" alt="image-20210425211503346" style="zoom:80%;" />

<img src="【数据结构与算法】LeetCode：每日一题/image-20210425211522483.png" alt="image-20210425211522483" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode resNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">increasingBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>);</span><br><span class="line">        resNode = dummyNode;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> dummyNode.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历的过程中修改节点指向</span></span><br><span class="line">        resNode.right = node;</span><br><span class="line">        node.left = <span class="literal">null</span>;</span><br><span class="line">        resNode = node;</span><br><span class="line"></span><br><span class="line">        inorder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/increasing-order-search-tree/solution/di-zeng-shun-xu-cha-zhao-shu-by-leetcode-dfrr/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="2-在-D-天内送达包裹的能力"><a href="#2-在-D-天内送达包裹的能力" class="headerlink" title="2. 在 D 天内送达包裹的能力"></a>2. <a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210427200151926.png" alt="image-20210427200151926" style="zoom:80%;" />

<h3 id="我的思路-5"><a href="#我的思路-5" class="headerlink" title="我的思路"></a>我的思路</h3><p>没有一点点挣扎</p>
<h3 id="大佬的思路-5"><a href="#大佬的思路-5" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>采用二分查找</p>
<p>根据题意，结果一定落在 <code>[max(weights), sum(weights)]</code> 这个区间上</p>
<ul>
<li><p>左端点：船的运载能力不能小于单个包裹的重量</p>
</li>
<li><p>右端点：一艘船一次性直接把所有货物拉走</p>
</li>
</ul>
<p>在左右端点之间进行二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> D)</span> &#123;</span><br><span class="line">        <span class="comment">// 确定二分查找左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// need 为需要运送的天数</span></span><br><span class="line">            <span class="comment">// cur 为当前这一天已经运送的包裹重量之和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">need</span> <span class="operator">=</span> <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> weight : weights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur + weight &gt; mid) &#123;</span><br><span class="line">                    ++need;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weight;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need &lt;= D) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/solution/zai-d-tian-nei-song-da-bao-guo-de-neng-l-ntml/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="3-二叉搜索树的范围和"><a href="#3-二叉搜索树的范围和" class="headerlink" title="3. 二叉搜索树的范围和"></a>3. <a href="https://leetcode-cn.com/problems/range-sum-of-bst/">二叉搜索树的范围和</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210427191433608.png" alt="image-20210427191433608" style="zoom:80%;" />

<h3 id="我的思路-6"><a href="#我的思路-6" class="headerlink" title="我的思路"></a>我的思路</h3><p>困难题唯唯诺诺，简单题重拳出击</p>
<p>遍历二叉树，遍历过程中判断每个节点的值是否在 <code>low</code> 与 <code>high</code> 之间，满足条件就把 <code>sum</code> 加上该值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        inOrder(root, low, high);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, low, high);</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt;= low &amp;&amp; root.val &lt;= high) sum += root.val;</span><br><span class="line">        inOrder(root.right, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是考虑到题目中所给出的树是<strong>二叉搜索树</strong>，这一条件并没有被我用上，所以肯定可以通过这一条件对算法进行改进</p>
<h3 id="大佬的思路-6"><a href="#大佬的思路-6" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>直接进行递归，不借用辅助中序遍历的函数</p>
<p>有用到二叉搜索树的性质</p>
<p>效率更高且代码更加优雅</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt;= low &amp;&amp; root.val &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val + </span><br><span class="line">                   rangeSumBST(root.left, low, high) + </span><br><span class="line">                   rangeSumBST(root.right, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.right, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-两数相加"><a href="#4-两数相加" class="headerlink" title="4. 两数相加"></a>4. <a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210429203603745.png" alt="image-20210429203603745" style="zoom:80%;" />

<h3 id="我的思路-7"><a href="#我的思路-7" class="headerlink" title="我的思路"></a>我的思路</h3><ol>
<li><p>同时遍历两个链表，将对应位相加得 <code>val</code>，<code>val % 10</code> 存入新链表对应节点中，<code>val / 10</code> 作为进位与下一位相加</p>
<p> 思路没问题，但是最后的一位如果出现进位的的问题一直没能解决</p>
</li>
<li><p>先遍历链表得到两个整数，将两个整数相加后再转换为链表</p>
<p> 被测试用例教做人</p>
 <img src="【数据结构与算法】LeetCode：每日一题/image-20210429204608148.png" alt="image-20210429204608148" style="zoom:80%;" /></li>
</ol>
<h3 id="大佬的思路-7"><a href="#大佬的思路-7" class="headerlink" title="大佬的思路"></a>大佬的思路</h3><p>思路大致与我的思路一相同，但是在循环条件中加了一条判断进位是否为0的条件，完美解决了我的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>; </span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2 + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">sumNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            cur.next = sumNode;</span><br><span class="line">            cur = sumNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h1><h2 id="1-公平的糖果棒交换"><a href="#1-公平的糖果棒交换" class="headerlink" title="1 公平的糖果棒交换"></a>1 <a href="https://leetcode-cn.com/problems/fair-candy-swap">公平的糖果棒交换</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210201222030150.png" alt="image-20210201222030150" style="zoom:80%;" />

<h3 id="自己家的解法"><a href="#自己家的解法" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><p>求出两个数组中个数的总和 <code>sum</code>，取其一半就是交换后<strong>各自数组</strong>中数的总和 <code>val</code></p>
<p>原数组中数的总和 <code>sumA</code>、<code>sumB</code>与 <code>val</code>只差就是需要交换的数量，分别找出每个数组中的这个差值的位置</p>
<p>接下来就遇到问题卡住辽</p>
<h3 id="别人家的解法"><a href="#别人家的解法" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><ul>
<li>哈希表</li>
</ul>
<img src="【数据结构与算法】LeetCode：每日一题/image-20210201224115760.png" alt="image-20210201224115760" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] fairCandySwap(<span class="type">int</span>[] A, <span class="type">int</span>[] B) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumA</span> <span class="operator">=</span> Arrays.stream(A).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumB</span> <span class="operator">=</span> Arrays.stream(B).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> (sumA - sumB) / <span class="number">2</span>;</span><br><span class="line">        Set&lt;Integer&gt; rec = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: A) &#123;</span><br><span class="line">            rec.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y: B) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> y + delta;</span><br><span class="line">            <span class="keyword">if</span>(rec.contains(x)) &#123;</span><br><span class="line">                ans[<span class="number">0</span>] = x;</span><br><span class="line">                ans[<span class="number">1</span>] = y;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-替换后的最长重复字符"><a href="#2-替换后的最长重复字符" class="headerlink" title="2 替换后的最长重复字符"></a>2 <a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement">替换后的最长重复字符</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210203191952563.png" alt="image-20210203191952563" style="zoom:80%;" />

<h3 id="自己家的解法-1"><a href="#自己家的解法-1" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><p>None</p>
<h3 id="别人家的解法-1"><a href="#别人家的解法-1" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><ul>
<li>本题是比较典型的滑动窗口问题</li>
<li>这类问题一般通过一个滑动窗口就能在 <em>O(N)</em> 的时间复杂度下求解</li>
</ul>
<p>本题可以先退化成考虑 <em>K&#x3D;0</em> 的情况，此时题目就变成了求解字符串中最长连续子串长度问题了。<br>  我们先可以通过这个特例先了解一下滑动窗口的求解过程</p>
<img src="【数据结构与算法】LeetCode：每日一题/578fc15b7b426eb61dcf1fd73bb87f1511d8733c474797dbb9188b706a219cc5.jpg" alt="滑动窗口求解最长连续子串长度" style="zoom:80%;" />

<p>上图的求解过程展示中，窗口从左至右不断扩张&#x2F;滑动，当窗口触达字符串末尾字符时，运算结束，窗口的宽度为最终结果。初始窗口的宽度为 1，我们不断的通过向当前窗口覆盖的子串后面追加一个字符看是否能满足我们的要求，如果满足窗口扩张，如果不满足，窗口向右滑动。</p>
<p>当 K&gt;0K&gt;0 时，子串的条件变成了允许我们变换子串中的 KK 个字符使其变成一个连续子串</p>
<p>那么这个题的关键点就是我们如何判断一个字符串改变 KK 个字符，能够变成一个连续串</p>
<p>如果当前字符串中的出现次数最多的字母个数 +K+K 大于串长度，那么这个串就是满足条件的</p>
<p>我们维护一个数组 int[26] 来存储当前窗口中各个字母的出现次数，leftleft 表示窗口的左边界，rightright 表示窗口右边界</p>
<p>窗口扩张：<code>left</code> 不变，<code>right++</code><br>窗口滑动：<code>left++</code>，<code>right++</code><br><code>historyCharMax</code> 保存滑动窗口内相同字母出现次数的 历史 最大值，通过判断窗口宽度                               <code>(right - left + 1)</code> 是否大于 <code>historyCharMax + k</code> 来决定窗口是否做滑动，否则窗口就扩张。</p>
<blockquote>
<p>作者：migoo<br>链接：<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/tong-guo-ci-ti-liao-jie-yi-xia-shi-yao-shi-hua-don/">https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/tong-guo-ci-ti-liao-jie-yi-xia-shi-yao-shi-hua-don/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characterReplacement</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 建立字符表，记录每个字符出现的次数</span></span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 记录字符串中出现次数最多的字母出现的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">historyCharMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 双指针，记录滑动窗口的左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 将新加入的字符加入字符表中</span></span><br><span class="line">            num[s.charAt(right) - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            <span class="comment">// 看新加入的字符是否会影响出现最多的字符</span></span><br><span class="line">            maxn = Math.max(maxn, num[s.charAt(right) - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">            <span class="comment">// 如果 滑动窗口宽度 大于 窗口内出现次数最多的字符与k之和，则窗口左边界移动</span></span><br><span class="line">            <span class="comment">// 既将其他字符中的k个字符全部进行替换以后窗口大小最长字串长度并不会增加</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; historyCharMax + k) &#123;</span><br><span class="line">                num[s.charAt(left) - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回滑动窗口的大小</span></span><br><span class="line">        <span class="keyword">return</span> right - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-滑动窗口中位数"><a href="#3-滑动窗口中位数" class="headerlink" title="3 滑动窗口中位数"></a>3 <a href="https://leetcode-cn.com/problems/sliding-window-median/">滑动窗口中位数</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210203233343603.png" alt="image-20210203233343603" style="zoom:80%;" />

<h3 id="自己家的解法-2"><a href="#自己家的解法-2" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><p>最朴素的暴力求法，不出所料了的超时了…</p>
<h3 id="别人家的解法-2"><a href="#别人家的解法-2" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><p>直接挂链接吧：<a href="https://leetcode-cn.com/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/">https://leetcode-cn.com/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] medianSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">DualHeap</span> <span class="variable">dh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DualHeap</span>(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            dh.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span>[] ans = <span class="keyword">new</span> <span class="title class_">double</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = dh.getMedian();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            dh.insert(nums[i]);</span><br><span class="line">            dh.erase(nums[i - k]);</span><br><span class="line">            ans[i - k + <span class="number">1</span>] = dh.getMedian();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DualHeap</span> &#123;</span><br><span class="line">    <span class="comment">// 大根堆，维护较小的一半元素</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line">    <span class="comment">// 小根堆，维护较大的一半元素</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line">    <span class="comment">// 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; delayed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="comment">// small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> smallSize, largeSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DualHeap</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.small = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer num1, Integer num2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> num2.compareTo(num1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.large = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer num1, Integer num2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> num1.compareTo(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.delayed = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.smallSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.largeSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (k &amp; <span class="number">1</span>) == <span class="number">1</span> ? small.peek() : ((<span class="type">double</span>) small.peek() + large.peek()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (small.isEmpty() || num &lt;= small.peek()) &#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">            ++smallSize;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">            ++largeSize;</span><br><span class="line">        &#125;</span><br><span class="line">        makeBalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        delayed.put(num, delayed.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= small.peek()) &#123;</span><br><span class="line">            --smallSize;</span><br><span class="line">            <span class="keyword">if</span> (num == small.peek()) &#123;</span><br><span class="line">                prune(small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --largeSize;</span><br><span class="line">            <span class="keyword">if</span> (num == large.peek()) &#123;</span><br><span class="line">                prune(large);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        makeBalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断地弹出 heap 的堆顶元素，并且更新哈希表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prune</span><span class="params">(PriorityQueue&lt;Integer&gt; heap)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> heap.peek();</span><br><span class="line">            <span class="keyword">if</span> (delayed.containsKey(num)) &#123;</span><br><span class="line">                delayed.put(num, delayed.get(num) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (delayed.get(num) == <span class="number">0</span>) &#123;</span><br><span class="line">                    delayed.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (smallSize &gt; largeSize + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// small 比 large 元素多 2 个</span></span><br><span class="line">            large.offer(small.poll());</span><br><span class="line">            --smallSize;</span><br><span class="line">            ++largeSize;</span><br><span class="line">            <span class="comment">// small 堆顶元素被移除，需要进行 prune</span></span><br><span class="line">            prune(small);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (smallSize &lt; largeSize) &#123;</span><br><span class="line">            <span class="comment">// large 比 small 元素多 1 个</span></span><br><span class="line">            small.offer(large.poll());</span><br><span class="line">            ++smallSize;</span><br><span class="line">            --largeSize;</span><br><span class="line">            <span class="comment">// large 堆顶元素被移除，需要进行 prune</span></span><br><span class="line">            prune(large);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/">https://leetcode-cn.com/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="4-子数组最大平均数-I"><a href="#4-子数组最大平均数-I" class="headerlink" title="4 子数组最大平均数 I"></a>4 <a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">子数组最大平均数 I</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210204202536643.png" alt="image-20210204202536643" style="zoom:80%;" />

<h3 id="自己家解法"><a href="#自己家解法" class="headerlink" title="自己家解法"></a>自己家解法</h3><p>楞头暴力求也没多想…</p>
<h3 id="别人家解法"><a href="#别人家解法" class="headerlink" title="别人家解法"></a>别人家解法</h3><ul>
<li>先求出前 <code>k</code> 个数的和 <code>sum</code></li>
<li>接下来开始滑动窗口，每次滑动后 <code>sum</code> 的值变为 <code>sum</code> 加上新进入窗口的值，再减去从窗口中滑出的值</li>
<li>使用变量 <code>maxSum</code> 记录每次滑动后 <code>sum</code> 的最大值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum = sum + nums[i] - nums[i - k];</span><br><span class="line">            maxSum = Math.max(sum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * maxSum / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tips：</strong></p>
<ul>
<li><code>double</code> 类型的变量进行运算会较慢，所以可以先求 <code>int</code>类型的和，最后求平均时再转为 <code>double</code></li>
</ul>
<h2 id="13-找到所有数组中消失的数字"><a href="#13-找到所有数组中消失的数字" class="headerlink" title="13 找到所有数组中消失的数字"></a>13 <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">找到所有数组中消失的数字</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210213213522841.png" alt="image-20210213213522841" style="zoom:80%;" />

<h3 id="自己家的解法-3"><a href="#自己家的解法-3" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><ul>
<li><p>一个思路</p>
<p>  既然要求没有出现的数字，那就把出现过的数字加入到一个 <code>Set</code> 中，从 1 到 n 开始遍历，不在 <code>Set</code> 中的数就是在数组中没有出现过的数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(i)) list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>另一个思路</p>
<p>  从1 - n求和得到 <code>sum1</code>，再将数组中的数求和得到 <code>sum2</code></p>
<p>   <code>sum1 - sum2</code> 就等于 <strong>没有出现的数减去重复出现的数</strong></p>
<p>  具体就不知道怎么实现了…</p>
</li>
</ul>
<h3 id="别人家的解法-3"><a href="#别人家的解法-3" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><ol>
<li>将数组元素对应为索引的位置 <strong>加n</strong> （<strong>置为负数</strong>）</li>
<li>遍历变化后得数组，若数组元素 小于n值（为负值），说明数组下标不存在，既为消失的数字</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            nums[(num - <span class="number">1</span>) % n] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= n) res.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-数组拆分-I"><a href="#16-数组拆分-I" class="headerlink" title="16 数组拆分 I"></a>16 <a href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210216231135883.png" alt="image-20210216231135883" style="zoom:80%;" />

<h3 id="自己家的解法-4"><a href="#自己家的解法-4" class="headerlink" title="自己家的解法"></a>自己家的解法</h3><p>将所给数组排序，<strong>奇数位置的数之和</strong>就是题目中要求的<strong>最大总和</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arrayPairSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="别人家的解法-4"><a href="#别人家的解法-4" class="headerlink" title="别人家的解法"></a>别人家的解法</h3><p>跟我的想法差不多嘛</p>
 <img src="【数据结构与算法】LeetCode：每日一题/image-20210216231352461.png" alt="image-20210216231352461" style="zoom:67%;" />

<h2 id="19-最大连续1的个数-III"><a href="#19-最大连续1的个数-III" class="headerlink" title="19 最大连续1的个数 III"></a>19 <a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">最大连续1的个数 III</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210219230908647.png" alt="image-20210219230908647" style="zoom:80%;" />

<h3 id="别人家思路"><a href="#别人家思路" class="headerlink" title="别人家思路"></a>别人家思路</h3><p>问题可以转化为 <strong>找出一个最长字串，其中最多允许有 k 个 0</strong> </p>
<p>最大连续子区间问题，可以使用 <strong>滑动窗口</strong> 解决</p>
<ul>
<li><p>两个指针分别指向窗口的两端：<code>left</code>、<code>right</code></p>
</li>
<li><p><code>right</code> 主动右移，若窗口内 0 的个数大于 k，考虑左移 <code>left</code></p>
</li>
<li><p>一直左移 <code>left</code>，直到窗口内 0 的个数小于 k</p>
</li>
<li><p>统计每次移动后窗口的长度</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 考虑到之后考研算法题大多需要用c或c++实现，故之后的代码都选择用c++实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, zeros = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; A.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[right] == <span class="number">0</span>) zeros++;</span><br><span class="line">            <span class="keyword">while</span> (zeros &gt; K) &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[left++] == <span class="number">0</span>) --zeros;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="20-比特位计数"><a href="#20-比特位计数" class="headerlink" title="20 比特位计数"></a>20 <a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a></h2><img src="【数据结构与算法】LeetCode：每日一题/image-20210303212948035.png" alt="image-20210303212948035" style="zoom:80%;" />

<h3 id="自己家解法-1"><a href="#自己家解法-1" class="headerlink" title="自己家解法"></a>自己家解法</h3><p>没思路直接看了官方解</p>
<h3 id="别人家解法-1"><a href="#别人家解法-1" class="headerlink" title="别人家解法"></a>别人家解法</h3><blockquote>
<p>以下思路及代码均取自<a href="https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/">LeetCode官方解</a></p>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/">https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<ul>
<li><p>暴力法</p>
<p>  从 0 到 num 计算每个数二进制的 【一比特数】</p>
<p>  对于任意整数 <code>x</code>，<code>x = x &amp; (x - 1)</code> 可以将二进制下 <code>x</code> 的<strong>最后一位 1 置为 0</strong>，重复操作，操作次数既为 x 的【一比特数】</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countOnes</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x &amp;= (x - <span class="number">1</span>);</span><br><span class="line">            ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(num + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            bits[i] = <span class="built_in">countOnes</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>动态规划——最高有效位</p>
<p>   <img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91LeetCode%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20210303214100186.png" alt="image-20210303214100186"></p>
<p>  我们规定 2 的整数次方为<strong>最高有效位</strong>，最高有效位之间的数与上一最高有效位之间的数存在一定关系，具体看原回答</p>
<p>  其实就是偷懒</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] <span class="built_in">countBits</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="type">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                highBit = i;</span><br><span class="line">            &#125;</span><br><span class="line">            bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态规划——最低有效位<ul>
<li>如果 <code>x</code> 是偶数， 那 <code>countBits(x) == countBits(x / 2)</code></li>
<li>如果 <code>x</code> 是奇数，那<code>countBits(x) == countBits(x - 1) + 1</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] <span class="built_in">countBits</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="type">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】图</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图的基本介绍"><a href="#图的基本介绍" class="headerlink" title="图的基本介绍"></a>图的基本介绍</h1><h3 id="为什么要有图"><a href="#为什么要有图" class="headerlink" title="为什么要有图"></a>为什么要有图</h3><p>我们之前学习的所有数据结构（线性表、树……）不能表示多对多的关系，这时候就需要引入图了！</p>
<h3 id="图的定义及一些概念"><a href="#图的定义及一些概念" class="headerlink" title="图的定义及一些概念"></a>图的定义及一些概念</h3><ul>
<li><p>图是一种数据结构，其中节点可以有零个或多个相邻元素。两个节点之间的连接称为边，节点也可以成为顶点。</p>
<p>  <img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE/image-20200429162328950.png" alt="image-20200429162328950"></p>
</li>
<li><p>图的一些概念</p>
<ul>
<li><p>顶点</p>
</li>
<li><p>边</p>
</li>
<li><p>路径</p>
</li>
<li><p>无向图<img src="【数据结构与算法】图/image-20200429162438755.png" alt="image-20200429162438755" style="zoom:67%;" /></p>
</li>
<li><p>有向图 <img src="【数据结构与算法】图/image-20200429162509013.png" alt="image-20200429162509013" style="zoom:67%;" /></p>
</li>
<li><p>带权图 <img src="【数据结构与算法】图/image-20200429162551460.png" alt="image-20200429162551460" style="zoom:67%;" /></p>
</li>
</ul>
</li>
</ul>
<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="comment">//存储图对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="comment">//边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;</span><br><span class="line">    <span class="comment">//定义一个数组，记录某个节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无向图！！！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 第一个节点下标（序号）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个节点下标（序号）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 权值，0为不直接相连，1为直接相连</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回顶点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回边的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据节点下标（序号）得到对应节点的值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1、v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出图的矩阵形式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h3 id="深度优先算法（DFS）"><a href="#深度优先算法（DFS）" class="headerlink" title="深度优先算法（DFS）"></a>深度优先算法（DFS）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 当前节点的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 得到第一个邻接节点的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据前一个邻接节点的下标获取下一个邻接节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v1 当前节点下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v2 当前节点邻节点下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v2 + <span class="number">1</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[v1][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * private：私有方法，只供内部函数调用</span></span><br><span class="line"><span class="comment"> * 深度优先算法</span></span><br><span class="line"><span class="comment"> * （相当于是对一个节点进行的dfs）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isVisited</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 第一次就是0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">//输出访问的节点</span></span><br><span class="line">    System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//将访问过的节点的访问标识设置为true，表示已被访问</span></span><br><span class="line">    isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//查找i的第一个邻节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getFirstNeighbor(i);</span><br><span class="line">    <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">            dfs(isVisited, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果w已经被访问过</span></span><br><span class="line">        w = getNextNeighbor(i, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载dfs(boolean[] isVisited, int i)</span></span><br><span class="line"><span class="comment"> * 遍历每一个节点，对每一个节点进行dfs</span></span><br><span class="line"><span class="comment"> * （相当于是对整个图进行的dfs）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">            dfs(isVisited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先算法（BFS）"><a href="#广度优先算法（BFS）" class="headerlink" title="广度优先算法（BFS）"></a>广度优先算法（BFS）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对一个节点进行广度优先遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> u;  <span class="comment">//表示队列头节点对应的下标</span></span><br><span class="line">    <span class="type">int</span> w;  <span class="comment">//邻接节点的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列，记录节点访问的顺序</span></span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    System.out.println(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//将节点加入队列</span></span><br><span class="line">    queue.addLast(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//取出队列的头节点下标</span></span><br><span class="line">        u = (Integer) queue.removeFirst();</span><br><span class="line">        <span class="comment">//得到第一个邻节点的下标</span></span><br><span class="line">        w = getFirstNeighbor(u);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//是否访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                System.out.println(getValueByIndex(w) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                <span class="comment">//标记已经访问</span></span><br><span class="line">                isVisited[w] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//入队列</span></span><br><span class="line">                queue.addLast(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//体现广度优先！</span></span><br><span class="line">            w = getNextNeighbor(u, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对整个图进行广度优先算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">            bfs(isVisited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】常用十大算法：KMP算法</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>字符串匹配问题：</p>
<p>有一个字符串 <code>BBC ABCDAB ABABCDABD </code>，另一个字符串为 <code>ABCDABD </code></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523160517802.png" alt="image-20200523160517802"></p>
<p>现在要判断 str1 中是否含有 str2，如果有就返回 str1 中首个匹配字母的索引，如果没有，则返回 1</p>
<h1 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历两个字符串：</p>
<ol>
<li>若 <code>str1[i] == str2[j]</code>，则 <code>i++</code>、<code>j++</code>，继续匹配下一个字符</li>
<li>若 <code>str1[i] != str2[j]</code>，则 <code>i = i - j + 1</code>、<code>j = 0</code>，继续进行匹配</li>
<li>如此循环直至 <code>i &gt; str1.length &amp;&amp; j &gt; str2.length</code></li>
</ol>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><ul>
<li>红色代表匹配失败</li>
<li>绿色代表匹配成功</li>
<li>。。。表示以此类推</li>
</ul>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523160906606.png" alt="image-20200523160906606"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523160743609.png" alt="image-20200523160743609"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523161010707.png" alt="image-20200523161010707"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523161110178.png" alt="image-20200523161110178"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523161226656.png" alt="image-20200523161226656"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523161010707.png" alt="image-20200523161010707"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523161353704.png" alt="image-20200523161353704"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523161443152.png" alt="image-20200523161443152"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523161010707.png" alt="image-20200523161010707"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523161725460.png" alt="image-20200523161725460"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">violenceMatch</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">//索引指向s1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">//索引指向s2</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1.length &amp;&amp; j &lt; s2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) &#123;   <span class="comment">//若匹配上了则继续后移看是否匹配</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                <span class="comment">//若没有匹配上就回溯，再继续后移</span></span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == s2.length) &#123; </span><br><span class="line">            <span class="keyword">return</span> i - j;           <span class="comment">//返回匹配上的第一个字符的索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用暴力匹配法匹配字符串，每次匹配失败都需要回溯到开始位置的后一位，其间花费了大量的时间，仔细思考，其实这些开销是不必要的。</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523162040054.png" alt="image-20200523162040054"></p>
<p>看图，字符串一直从 A 匹配到 D ，D 处不匹配，但是前面的 ABCDAB 都已经一一匹配了，故此时将 str2 后移一位结果可想而知也不会匹配</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523162402920.png" alt="image-20200523162402920"></p>
<p>如图，中间后移的五步结果不算都可以知道是不匹配的，那我们干嘛还要去浪费时间一次一次移动呢？</p>
<p>直接从移动到 str1 中的下一个 A 不香嘛！</p>
<p>那我们可以可以设计某种算法来进行优化呢？</p>
<p>我觉得不行</p>
<p>但是有三位聪明的大师做到了！</p>
<p>这种算法被命名为 <strong>KMP算法</strong> ，也就是今天的主角了！</p>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>KMP是三位大牛：<strong>D.E.Knuth</strong>、<strong>J.H.Morris</strong> 和 <strong>V.R.Pratt</strong> 同时发现的。其中第一位就是《计算机程序设计艺术》的作者！</p>
</li>
<li><p>KMP算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字，如果它在一个主串中出现，就返回它的具体位置，否则返回-1（常用手段）。</p>
</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>KMP算法如何实现呢，这里我们需要先引入一些概念</li>
</ul>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523163401092.png" alt="image-20200523163401092"></p>
<ul>
<li><p>举例：“ABCDABD”</p>
<ul>
<li>”A”的前缀和后缀都为空集，共有元素的长度为 <strong>0</strong></li>
<li>”AB”的前缀为[A]，后缀为[B]， 共有元素的长度为 <strong>0</strong></li>
<li>“ABC”的前缀为[A, AB],后缀为[BC, C]，共有元素的长度 <strong>0</strong></li>
<li>”ABCD” 的前缀为[A, AB, ABC],后缀为[BCD, CD, D]，共有元素的长度为 <strong>0</strong></li>
<li>”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA,A]，共有元素为”A”，长度为 <strong>1</strong></li>
<li>”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA],后缀为[BCDAB, CDAB, DAB, AB, B],共有元素为”AB”,<br>  长度为 <strong>2</strong></li>
<li>”ABCDABD”的前缀为[A, AB, ABC,ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD,<br>  D]，共有元素的长度为 <strong>0</strong></li>
</ul>
<p>  通过上述分析，我们可以得到一张<strong>部分匹配表</strong></p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">D</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>  这张部分匹配表就是 KMP算法的核心，接下来我们就要用它了！</p>
</li>
</ul>
<p>接着暴力匹配算法走：</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523162040054.png" alt="image-20200523162040054"></p>
<p>当 D 与 “ ” 不匹配时，前面六个字符 “ABCDAB” 是匹配的，查 <strong>部分匹配表</strong> 可知最后一个匹配的字母 B 对应的部分匹配值为 2 </p>
<p>由公式：<br>$$<br>移动位数 &#x3D; 已知匹配字符数 - 对应匹配值<br>$$<br>可得 <strong>移动位数 &#x3D; 6 - 2 &#x3D; 4</strong></p>
<p>故将搜索词向后移动 4 位</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523165755165.png" alt="image-20200523165755165"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523170017335.png" alt="image-20200523170017335"></p>
<p>C 的部分匹配值为 0，</p>
<p>由公式得 <strong>位移位数 &#x3D; 2 - 0 &#x3D; 2</strong></p>
<p>故将搜索词后移两位</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523170148706.png" alt="image-20200523170148706"></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9AKMP%E7%AE%97%E6%B3%95/image-20200523161010707.png" alt="image-20200523161010707"></p>
<p>以此类推，可<strong>高效</strong>得到答案！</p>
<p>至此，KMP算法 思路分析全部结束。</p>
<p>至于原理，emmm，比较玄学的东西还没有学习，可以参考 <a href="https://zhuanlan.zhihu.com/p/83334559">https://zhuanlan.zhihu.com/p/83334559</a></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//部分匹配表</span></span><br><span class="line">    <span class="type">int</span>[] next = kmpNext(str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个 next 数组来保存部分匹配值</span></span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[dest.length()];</span><br><span class="line">    <span class="comment">//字符串长度为 1 时，部分匹配值为 0</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>mvn install:install-file -DgroupId&#x3D;com.google.code.kaptcha -DartifactId&#x3D;kaptcha -Dversion&#x3D;2.3 -Dfile&#x3D;E:\CS\Java\Project\ruoyi\kaptcha-2.3.2.jar -Dpackaging&#x3D;jar -DgeneratePom&#x3D;true</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>尚硅谷：<a href="https://www.bilibili.com/video/BV1E4411H73v?p=161">https://www.bilibili.com/video/BV1E4411H73v?p=161</a></p>
<p>labuladong：<a href="https://zhuanlan.zhihu.com/p/83334559">https://zhuanlan.zhihu.com/p/83334559</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>尚硅谷</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】常用十大算法：二分查找</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>二分查找</strong>也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找<strong>要求线性表必须采用顺序存储结构</strong>，而且表中元素按关键字有序排列。</p>
<p>顾名思义，二分查找就是从中间开始查找，如果中间的值比目标值大，则结果要么在左边，要么不存在，反之则结果要么在右边，要么不存在，以此类推进行下一步查找……</p>
<p>二分查找的运行时间为对数时间：<br>$$<br>O(log_2n)<br>$$<br>假设从 [0,99] 中查找目标位置最多只需要查找 7 次（2^6 &lt; 100 &lt; 2^7）</p>
<h1 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重载二分查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    需要查找的目标数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 需要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回查找的值在数组中的索引，如果不存在，则返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   需要查找的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  查找的左端点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 查找的右端点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回查找的值在数组中的索引，如果不存在，则返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; value || arr[arr.length - <span class="number">1</span>] &lt; value || right - left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; value) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    需要查找的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 需要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回查找的值在数组中的索引，如果不存在，则返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;         <span class="comment">//找到直接返回</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;    <span class="comment">//还要继续从左边查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;     <span class="comment">//还要继续从右边查找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未找到结果，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>mid 的计算：</strong></p>
<ul>
<li><code>mid = (left + right) / 2</code></li>
<li><code>mid = left + (right - left) / 2</code></li>
</ul>
<p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，<strong>最好使用第二种计算法方法</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>尚硅谷</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】常用十大算法：分治算法</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>当我们求解某些问题时，由于这些问题要处理的数据相当多，或求解过程相当复杂，使得直接求解法在时间上相当长，或者根本无法直接求出。对于这类问题，我们往往先把它分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。如果这些子问题还较大，难以解决，可以再把它们分成几个更小的子问题，以此类推，直至可以直接求出解为止。这就是<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5">分治策略</a>的基本思想。</p>
</blockquote>
<p>比如说，把大象装到冰箱里我们就可以分三步完成：打开冰箱门、把大象推进器、关闭冰箱门（狗头）</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/image-20200518153350036.png" alt="image-20200518153350036"></p>
<h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><ul>
<li>二分搜索</li>
<li>大整数乘法</li>
<li>棋牌覆盖</li>
<li>归并排序</li>
<li>快速排序</li>
<li>线性时间选择</li>
<li>最接近点对问题</li>
<li>循坏赛日程表</li>
<li><strong>汉诺塔</strong></li>
</ul>
<h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><ol>
<li><strong>分解</strong>：将原问题分解成一系列子问题。</li>
<li><strong>解决</strong>：递归地求解各个子问题，若子问题足够小，则直接求解。</li>
<li><strong>合并</strong>：将子问题的结果合并成原问题。</li>
</ol>
<h1 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>法国数学家<a href="https://baike.baidu.com/item/%E7%88%B1%E5%BE%B7%E5%8D%8E%C2%B7%E5%8D%A2%E5%8D%A1%E6%96%AF">爱德华·卢卡斯</a>曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神<a href="https://baike.baidu.com/item/%E6%A2%B5%E5%A4%A9">梵天</a>在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而<a href="https://baike.baidu.com/item/%E6%A2%B5%E5%A1%94">梵塔</a>、庙宇和众生也都将同归于尽。移动图片</p>
<p>不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有n片，移动次数是f(n).显然f(1)&#x3D;1,f(2)&#x3D;3,f(3)&#x3D;7，且f(k+1)&#x3D;2*f(k)+1。此后不难证明f(n)&#x3D;2^n-1。n&#x3D;64时，</p>
<p>假如每秒钟一次，共需多长时间呢？一个平年365天有31536000 秒，闰年366天有31622400秒，平均每年31557600秒，计算一下：</p>
<p>18446744073709511615秒</p>
<p>这表明移完这些金片需要5845.42亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.42亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p>
</blockquote>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9A%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/image-20200518154741914.png" alt="image-20200518154741914"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>如果只有一个盘：</p>
<p> A &#x3D;&gt; C</p>
</li>
<li><p>如果 盘数 ≥ 2：</p>
<p> 我们可以将最下面的盘看成一个盘（下盘），将剩下的盘看成另一个盘</p>
<p> 分三步（上盘）：</p>
<ol>
<li><p><strong>上盘 A &#x3D;&gt; B</strong></p>
</li>
<li><p>下盘并不是很稳</p>
<p> &amp;<em>……&amp;<em>……&amp;</em></em>*%&amp;……%&amp;，串场了</p>
<p> <strong>下盘 A &#x3D;&gt; C</strong></p>
</li>
<li><p><strong>上盘 B &#x3D;&gt; C</strong></p>
</li>
</ol>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 汉诺塔的移动方法</span></span><br><span class="line"><span class="comment"> * 使用分治算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hannoiTower</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> a, <span class="type">char</span> b,<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第1个盘从 &quot;</span> + a + <span class="string">&quot; --&gt; &quot;</span> + c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//第一步</span></span><br><span class="line">        hannoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">        <span class="comment">//第二步</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + num + <span class="string">&quot;个盘从 &quot;</span> + a + <span class="string">&quot; --&gt; &quot;</span> + c);</span><br><span class="line">        <span class="comment">//第三部</span></span><br><span class="line">        hannoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>尚硅谷</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】常用十大算法：动态规划</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><ul>
<li>动态规划算法通常用于<strong>求解具有某种最优性质</strong>的问题。在这类问题中，可能会<strong>有许多可行解</strong>。每一个解都对应于一个值，我们希望找到具有<strong>最优值</strong>的解。 </li>
<li>动态规划算法<strong>与分治法类似</strong>，其<strong>基本思想</strong>也是<strong>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</strong>。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</li>
<li>我们可以<strong>用一个表来记录所有已解的子问题的答案</strong>。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</li>
</ul>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>动态规划一般可分为<strong>线性动规</strong>，<strong>区域动规</strong>，<strong>树形动规</strong>，<strong>背包动规</strong>四类。 </p>
<ul>
<li><p>线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等； </p>
</li>
<li><p>区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等； </p>
</li>
<li><p>树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等； </p>
</li>
<li><p>背包问题：<strong>01背包问题</strong>，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶等。</p>
</li>
</ul>
<p>应用实例：</p>
<p>​	最短路径问题 ，项目管理，网络流优化……</p>
<h1 id="实践：背包问题"><a href="#实践：背包问题" class="headerlink" title="实践：背包问题"></a>实践：背包问题</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有一个背包，容量为 4 磅，现有如下物品：</p>
<table>
<thead>
<tr>
<th align="center">物品</th>
<th align="center">重量</th>
<th align="center">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center">吉他（G）</td>
<td align="center">1</td>
<td align="center">1500</td>
</tr>
<tr>
<td align="center">音响（S）</td>
<td align="center">4</td>
<td align="center">3000</td>
</tr>
<tr>
<td align="center">电脑（L）</td>
<td align="center">3</td>
<td align="center">2000</td>
</tr>
</tbody></table>
<ol>
<li>要求装入背包的总价值最大，且重量不超出背包容量</li>
<li>装入物品不能重复（01背包）</li>
</ol>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ul>
<li><p>如基本介绍所说，我们不妨先列表寻找规律</p>
<table>
<thead>
<tr>
<th align="center">物品</th>
<th align="center">0磅</th>
<th align="center">1磅</th>
<th align="center">2磅</th>
<th align="center">3磅</th>
<th align="center">4磅</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">吉他（G）</td>
<td align="center">0</td>
<td align="center">1500（G）</td>
<td align="center">1500（G）</td>
<td align="center">1500（G）</td>
<td align="center">1500（G）</td>
</tr>
<tr>
<td align="center">音箱（S）</td>
<td align="center">0</td>
<td align="center">1500（G）</td>
<td align="center">1500（G）</td>
<td align="center">1500（G）</td>
<td align="center">3000（S）</td>
</tr>
<tr>
<td align="center">电脑（L）</td>
<td align="center">0</td>
<td align="center">1500（G）</td>
<td align="center">1500（G）</td>
<td align="center">2000（L）</td>
<td align="center">2000（L）+ 1500（G）</td>
</tr>
</tbody></table>
</li>
<li><p>设 <code>weight[i]</code>、<code>value[i]</code> 分别表示第 i 个物品的重量和价值，<code>total[i][j]</code>表示前 i 个物品中能够装入容量为 j 的背包中的物品的的最大价值</p>
</li>
<li><p>每遍历一个物品，我们可以根据  <code>weight[i]</code>、<code>value[i]</code> 计算是否需要把他放入背包中（能够放入的前提下放入会使背包中物品的总价值增加就放入）</p>
</li>
<li><p>由图表易知：</p>
<ul>
<li><p>当 <code>weight[i] &gt; j</code>（当装入物品质量大于背包容量时，直接使用上一单元格的策略）</p>
<p>  <code>total[i][j] = total[i - 1][j]</code></p>
</li>
<li><p>当<code>weight[i] &lt;= j</code>（当装入物品质量小于背包容量时，表示可以装进去）</p>
<p>  <code>total[i][j] = Max&#123; total[i - 1][j] , value[i] + total[i - 1][j - weight[i]]&#125;</code></p>
<p>  <code>total[i - 1][j]</code>：上一单元格装入的最大值</p>
<p>  <code>value[i] + total[i - 1][j - weight[i]]</code>：装入前 i -1 商品到剩余空间 <code>j - weight[i]</code>的最大值</p>
</li>
</ul>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>其实整个代码实现过程就是依据上面分析的思路来还原整个图表！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapSackProblem</span>   &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] value = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;       <span class="comment">//各物品的价格</span></span><br><span class="line">        <span class="type">int</span>[] weight = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;               <span class="comment">//各物品的重量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">catacity</span> <span class="operator">=</span> <span class="number">4</span>;                       <span class="comment">//背包的容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> value.length;                 <span class="comment">//物品的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//total[i][j] 表示再前 i 个物品中能够装入容量为j的背包中的最大价值</span></span><br><span class="line">        <span class="type">int</span>[][] total = <span class="keyword">new</span> <span class="title class_">int</span>[num + <span class="number">1</span>][catacity + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//记录放入商品的情况</span></span><br><span class="line">        <span class="type">int</span>[][] path = <span class="keyword">new</span> <span class="title class_">int</span>[num + <span class="number">1</span>][catacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; total.length; i++) &#123;    <span class="comment">//i从1开始，不处理第一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; total[<span class="number">0</span>].length; j++) &#123;     <span class="comment">//j从1开始，不处理第一列</span></span><br><span class="line">                <span class="comment">//i 从 1 开始，所以第i个物品的重量应该表示为 weight[i - 1]</span></span><br><span class="line">                <span class="keyword">if</span> (weight[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                    total[i][j] = total[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (total[i - <span class="number">1</span>][j] &lt; value[i - <span class="number">1</span>] + total[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        total[i][j] = value[i - <span class="number">1</span>] + total[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">//物品放入到背包中的同时需要用path记录</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        total[i][j] = total[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历输出二维数组，即前面分析后得到的表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; total.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; total[i].length; j++) &#123;</span><br><span class="line">                System.out.print(total[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出放入背包中物品的序号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> path.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> path[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个商品放入背包中！&quot;</span>);</span><br><span class="line">                j -= weight[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出结果：</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200521122437944.png" alt="image-20200521122437944"></p>
<p>​        </p>
<p>​        </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>尚硅谷</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】树：二叉排序树</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉排序树介绍"><a href="#二叉排序树介绍" class="headerlink" title="二叉排序树介绍"></a>二叉排序树介绍</h1><p><strong>二叉排序树（Binary Sort&#x2F;Search Tree）</strong>：对于二叉排序树的任意一个<strong>非叶子节点</strong>，<strong>左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</strong></p>
<p>&#x3D;&#x3D;如果值相同，该节点可以放在左子节点或右子节点&#x3D;&#x3D;</p>
<p><strong>示例：</strong></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20200421175929851.png" alt="image-20200421175929851"></p>
<p><strong>复杂度：</strong></p>
<p>不论哪一种操作，<strong>所花的时间都和树的高度成正比</strong>。因此，如果共有n个元素，那么平均每次操作需要**O(logn)**的时间。</p>
<h1 id="二叉排序树的实现"><a href="#二叉排序树的实现" class="headerlink" title="二叉排序树的实现"></a>二叉排序树的实现</h1><h3 id="1-二叉排序树的创建"><a href="#1-二叉排序树的创建" class="headerlink" title="1. 二叉排序树的创建"></a>1. 二叉排序树的创建</h3><ul>
<li><p>构建(就是普通的二叉树)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value;          <span class="comment">//节点属性值</span></span><br><span class="line">    TreeNode left;      <span class="comment">//左子节点</span></span><br><span class="line">    TreeNode right;     <span class="comment">//右子节点</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入</p>
<p>  思路：1. 比较插入节点的值与当前节点的值来决定插入位置是左子节点还是右子节点</p>
<p>  ​			2. 插入的左子节点为空，则将插入节点设置为左子节点；不为空，则进行递归</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TreeNode：</span></span><br><span class="line"><span class="comment">//添加节点操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(TreeNode treeNode)</span> &#123;</span><br><span class="line">    <span class="comment">//先判断加入的节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当加入节点的值小于当前节点的值时，考虑左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (treeNode.value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = treeNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.add(treeNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//当加入节点的值大于当前节点的值时，考虑右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right = treeNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.add(treeNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BinarySearchTree：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(TreeNode treeNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root.add(treeNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-二叉排序树的删除"><a href="#2-二叉排序树的删除" class="headerlink" title="2. 二叉排序树的删除"></a>2. 二叉排序树的删除</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><ol>
<li><p>删除<strong>叶子节点</strong>：</p>
<ol>
<li><p>找到要删除的节点 targetNode</p>
</li>
<li><p>找到要删除的节点的父节点 parentNode</p>
</li>
<li><p>确定 targetNode 是 parentNode 的左子节点还是右子节点</p>
</li>
<li><p>（如果是左子节点）<code>parentNode.left = null</code></p>
<p> （如果是右子节点）<code>parentNode.right = null</code></p>
</li>
</ol>
</li>
<li><p>删除<strong>只有一颗子树</strong>的节点</p>
<ol>
<li><p>找到要删除的节点 targetNode </p>
</li>
<li><p>找到要删除的节点的父节点 parentNode</p>
</li>
<li><p>确定 targetNode 是 parentNode 的左子节点还是右子节点</p>
<ul>
<li><p>是左子节点且有左子节点：<img src="【数据结构与算法】树：二叉排序树/image-20200421183949555.png" alt="image-20200421183949555" style="zoom: 67%;" /></p>
  <img src="【数据结构与算法】树：二叉排序树/image-20200421184844266.png" alt="image-20200421184844266" style="zoom: 67%;" />

  <img src="【数据结构与算法】树：二叉排序树/image-20200421184309611.png" alt="image-20200421184309611" style="zoom:67%;" />
</li>
<li><p>是左子节点且有右子节点：<img src="【数据结构与算法】树：二叉排序树/image-20200421184513886.png" alt="image-20200421184513886" style="zoom:67%;" /></p>
  <img src="【数据结构与算法】树：二叉排序树/image-20200421184728009.png" alt="image-20200421184728009" style="zoom:67%;" />

  <img src="【数据结构与算法】树：二叉排序树/image-20200421184943481.png" alt="image-20200421184943481" style="zoom:67%;" />
</li>
<li><p>是右子节点且有左子节点：<img src="【数据结构与算法】树：二叉排序树/image-20200421185045085.png" alt="image-20200421185045085" style="zoom:67%;" /></p>
  <img src="【数据结构与算法】树：二叉排序树/image-20200421185206368.png" alt="image-20200421185206368" style="zoom:67%;" />

  <img src="【数据结构与算法】树：二叉排序树/image-20200421185218029.png" alt="image-20200421185218029" style="zoom:67%;" />
</li>
<li><p>是右子节点且有右子节点：<img src="【数据结构与算法】树：二叉排序树/image-20200421185305923.png" alt="image-20200421185305923" style="zoom:67%;" /></p>
  <img src="【数据结构与算法】树：二叉排序树/image-20200421185411090.png" alt="image-20200421185411090" style="zoom:67%;" />

  <img src="【数据结构与算法】树：二叉排序树/image-20200421185423027.png" alt="image-20200421185423027" style="zoom:67%;" /></li>
</ul>
</li>
</ol>
</li>
<li><p>删除有两颗子树的节点：</p>
<ol>
<li><p>找到要删除的节点 targetNode</p>
 <img src="【数据结构与算法】树：二叉排序树/image-20200423094725078.png" alt="image-20200423094725078" style="zoom:67%;" />
</li>
<li><p>找到 targetNode 的父节点 parentNode</p>
</li>
<li><p>找到 targetNode 节点 左子节点，向右递归找到最大的节点 tempNode（没有右子节点就是targetNode的左子节点本身）</p>
 <img src="【数据结构与算法】树：二叉排序树/image-20200423094856992.png" alt="image-20200423094856992" style="zoom:67%;" />

<p> <strong>或者</strong></p>
<p> 找到 targetNode节点 右子节点，向左递归找到最小的节点 tempNode（没有左子节点就是targetNode的右子节点本身）</p>
</li>
<li><p>targetNode.value &#x3D; tempNode.value</p>
 <img src="【数据结构与算法】树：二叉排序树/image-20200423095146383.png" alt="image-20200423095146383" style="zoom:67%;" />
</li>
<li><p>删除tempNode节点</p>
 <img src="【数据结构与算法】树：二叉排序树/image-20200423095200674.png" alt="image-20200423095200674" style="zoom:67%;" /></li>
</ol>
</li>
</ol>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TreeNode：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找值为 value 的节点</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.value == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.value &gt; value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left.value == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right.value == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找置为value的节点的父节点</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前节点就是要删除的节点的父节点，则返回当前节点</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value) || (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">//否则则进行递归查找父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value &gt; value &amp;&amp; <span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt;= value &amp;&amp; <span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BinarySearchTree：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.root.search(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.root.searchParent(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除左子树的最大节点 tempNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> treeNode 要删除的节点targetNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回targetNode左子树向右递归得到的最大节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delLeftTreeMax</span><span class="params">(TreeNode treeNode)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> treeNode;</span><br><span class="line">    <span class="comment">//向右循环寻早最大子树</span></span><br><span class="line">    <span class="keyword">while</span> (tempNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        tempNode = tempNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">    delete(tempNode.value);</span><br><span class="line">    <span class="keyword">return</span> tempNode.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">    <span class="comment">//如果没有找到要删除的节点就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (targetNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是根节点就直接删除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.root.left == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">    <span class="comment">//1.删除叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode == parent.left) &#123;</span><br><span class="line">            parent.left = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="literal">null</span> &amp;&amp; targetNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//2. 删除有两颗子树的节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> delLeftTreeMax(targetNode.left);</span><br><span class="line">        targetNode.value = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//3. 删除只有一个子树的节点</span></span><br><span class="line">        <span class="keyword">if</span> (targetNode == parent.left) &#123;        <span class="comment">//如果是targetNode是左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                parent.left = targetNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = targetNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;        <span class="comment">//如果是targetNode是右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                parent.right = targetNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = targetNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】树：多路查找树</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%EF%BC%9A%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树与多叉树"><a href="#二叉树与多叉树" class="headerlink" title="二叉树与多叉树"></a>二叉树与多叉树</h1><h3 id="二叉树存在的问题"><a href="#二叉树存在的问题" class="headerlink" title="二叉树存在的问题"></a>二叉树存在的问题</h3><p>二叉树提供了高效的插入删除查找等操作，但是也存在一定的问题：</p>
<ul>
<li><p>当数据量较小时，普通二叉树不存在什么问题</p>
</li>
<li><p>当数据量特别大时，会导致<strong>二叉树的深度过深</strong>，使用搜索算法自上向下搜索时经过的节点就会相当多。这些节点存储在外存储器时，每访问一个节点就相当于进行了一次 I&#x2F;O，随着树深度的增加，开销会越来越大，进而降低操作速度！</p>
</li>
</ul>
<h3 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h3><p>如果每个节点可以有更多的数据项和更多的节点，就是<strong>多叉树</strong>。</p>
<p>多叉树<strong>通过重新组织节点，降低树的高度</strong>，<strong>并且减少 I&#x2F;O 读写次数</strong>来提升效率。</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%EF%BC%9A%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/image-20200427205618162.png" alt="image-20200427205618162"></p>
<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>2-3树是最简单的b树结构，具有以下特点：</p>
<ol>
<li>2-3树的所有<strong>叶子节点在同一层</strong></li>
<li>二节点（有两个子节点的节点）要么没有子节点，要么有两个子节点</li>
<li>三节点（有三个子节点的节点）要么没有子节点，要么有三个子节点</li>
<li><strong>2-3树是由二节点和三节点构成的树</strong></li>
</ol>
<h1 id="B树、B-树、B-树"><a href="#B树、B-树、B-树" class="headerlink" title="B树、B+树、B*树"></a>B树、B+树、B*树</h1><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树（Balanced Tree），前面介绍的2-3树，还有2-3-4树都是b树</p>
<p><strong>MySQL中的索引就是基于B树或B+树的</strong></p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%EF%BC%9A%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/image-20200427213158970.png" alt="image-20200427213158970"></p>
<ol>
<li><p>B树的阶：节点最多的节点的子节点个数（2-3树的阶是3）</p>
</li>
<li><p>B树的搜索：</p>
<p> 从根节点开始，对<strong>节点内</strong>的关键字的有序序列进行<strong>二分查找</strong>，找到则结束，否则进入查询关键字所属范围的子节点</p>
</li>
<li><p><strong>叶子节点和非叶子节点都可以存放数据（区别于B+树）</strong></p>
</li>
<li><p>搜索有可能在非叶子节点结束（区别与B+树）</p>
</li>
<li><p><strong>搜索性能等价于在关键字全集内做一次二分查找</strong></p>
</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B树的变体，也是一种多路搜索树。</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%EF%BC%9A%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/image-20200427213704102.png" alt="image-20200427213704102"></p>
<ol>
<li><p>B+树的搜索：</p>
<p> 只有到达叶子节点才会找到或结束，性能也等价于在关键字全集做一次二分查找</p>
</li>
<li><p><strong>所有关键字都存储在叶子节点的链表中，且链表中的关键字也是有序的</strong></p>
</li>
<li><p><strong>非叶子节点相当于叶子节点的索引，叶子节点相当于存储数据的数据层</strong></p>
</li>
<li><p>更适合<strong>文件索引系统</strong></p>
</li>
</ol>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>B*树是B+树的变体，在B+树的非根和非叶子节点增加指向兄弟的指针</p>
<p><img src="/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%EF%BC%9A%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/image-20200427215305770.png" alt="image-20200427215305770"></p>
<p>B*定义了非叶子节点关键字个数至少为（2&#x2F;3）x M，块的最低使用率为 2&#x2F;3，而B+树块的最低使用率为 1&#x2F;2</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】树：平衡二叉树</title>
    <url>/2023/03/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="为什么需要平衡二叉树？"><a href="#为什么需要平衡二叉树？" class="headerlink" title="为什么需要平衡二叉树？"></a>为什么需要平衡二叉树？</h1><blockquote>
<p>首先我们思考一个问题，为什么要学习平衡二叉树（AVL），是二叉排序树（BST）不香嘛？</p>
<p>哎，确实，确实不香。</p>
</blockquote>
<p>二叉排序树存在一个致命缺点，如下图所示这种情况：</p>
<img src="【数据结构与算法】树：平衡二叉树/image-20200425084803240.png" alt="image-20200425084803240" style="zoom:67%;" />

<blockquote>
<p>emmmm，这确实也是一个二叉排序树，但是乍一看，害，这不整一条链表过来装树嘛！</p>
<p>在这种情况下，<strong>二叉排序树退化成一条链表</strong></p>
<p>链表的特点是什么？（给你三秒种反应）</p>
<p>3</p>
<p>2</p>
<p>1</p>
<p>对了！<strong>增删快、查找慢</strong>，这与我们建立二叉排序树的初衷相悖</p>
<p>为此，我们引入了今天的主角，<strong>平衡二叉树（Self-balancing binary search tree）！</strong></p>
</blockquote>
<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><ul>
<li>平衡二叉树也叫平衡二叉搜索树，又被称为AVL树，可以保证查询效率较高</li>
<li>具有以下特点：<ul>
<li>是一颗空树或左右两个子树的高度差的绝对值不超过1</li>
<li>左右两个子树都是一颗平衡二叉树</li>
</ul>
</li>
</ul>
<p>平衡二叉树的实现方法：<strong>红黑树</strong>（HashMap、TreeMap底层都有用到）、AVL、替罪羊树、Treap、伸展树</p>
<h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>每当 平衡二叉树满足：<br>$$<br>|rightHeight() - leftHeight()| &gt; 1<br>$$<br>时，不再是一颗平衡二叉树，需要进行<strong>旋转操作</strong>使其恢复平衡。</p>
<h3 id="左旋-降低右子树的高度-："><a href="#左旋-降低右子树的高度-：" class="headerlink" title="左旋(降低右子树的高度)："></a>左旋(降低右子树的高度)：</h3><p>给定数列 {4，3，6，5，7，8}，创建出对应的二叉平衡树<img src="【数据结构与算法】树：平衡二叉树/image-20200425093659703.png" alt="image-20200425093659703" style="zoom:67%;" /></p>
<p>注意到当插入 8 时，不满足平衡二叉树的条件，此时需要对二叉树进行<strong>左旋</strong>，才能使其恢复平衡</p>
<img src="【数据结构与算法】树：平衡二叉树/image-20200425093714198.png" alt="image-20200425093714198" style="zoom:67%;" />

<p>具体流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前节点：0004</span></span><br><span class="line"><span class="comment">//1. 以根节点的值为值创建新节点</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>)；</span><br><span class="line"><span class="comment">//2. 将新节点的左子树设置为当前节点的左子树</span></span><br><span class="line">newNode.left = <span class="built_in">this</span>.left;</span><br><span class="line"><span class="comment">//3. 把新结点的右子树设为当前节点的右子树的左子树</span></span><br><span class="line">newNode.right = <span class="built_in">this</span>.right.left;</span><br><span class="line"><span class="comment">//4. 把当前节点的值换为右子节点的值</span></span><br><span class="line"><span class="built_in">this</span>.value = right.value;</span><br><span class="line"><span class="comment">//5. 把当前节点的右子树设置成右子树的右子树</span></span><br><span class="line"><span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line"><span class="comment">//6. 当前节点的左子树设置为新节点</span></span><br><span class="line"><span class="built_in">this</span>.left = newNode;</span><br></pre></td></tr></table></figure>

<h3 id="右旋-降低左子树的高度-："><a href="#右旋-降低左子树的高度-：" class="headerlink" title="右旋(降低左子树的高度)："></a>右旋(降低左子树的高度)：</h3><p>给定数列 {10，12，8，9，7，6} 创建对应平衡二叉树<img src="【数据结构与算法】树：平衡二叉树/image-20200425095021888.png" alt="image-20200425095021888" style="zoom:67%;" /></p>
<p>当插入节点 6 时，不满足平衡二叉树的条件，此时需要对二叉树进行<strong>右旋</strong>，才能使其恢复平衡</p>
<img src="【数据结构与算法】树：平衡二叉树/image-20200425095126703.png" alt="image-20200425095126703" style="zoom:67%;" />

<p>具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前节点：0008</span></span><br><span class="line"><span class="comment">//1. 创建一个以根节点为值的新节点</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">10</span>)；</span><br><span class="line"><span class="comment">//2. 将新节点的右子树设置为当前节点的右子树</span></span><br><span class="line">newNode.right = <span class="built_in">this</span>.right;</span><br><span class="line"><span class="comment">//3. 新节点的左子树设置为当前节点左子树的右子树</span></span><br><span class="line">newNode.left = <span class="built_in">this</span>.left.right;</span><br><span class="line"><span class="comment">//4. 将当前节点的值换为左子节点的值</span></span><br><span class="line"><span class="built_in">this</span>.value = right.value;</span><br><span class="line"><span class="comment">//5. 将当前节点的左子树设置为左子树的左子树</span></span><br><span class="line"><span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;</span><br><span class="line"><span class="comment">//6. 将当前节点的右子树设置为新节点</span></span><br><span class="line"><span class="built_in">this</span>.right = newNode;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下左旋和右旋的实现：</strong></p>
<ol>
<li>创建新节点</li>
<li>设置新节点的左右子树</li>
<li>设置当前节点的左右子树</li>
</ol>
<h3 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h3><p>前面的两个实例都可以通过一次旋转将非平衡二叉树转化为平衡二叉树，但是在一些情况下，单旋转不能完成平衡二叉树的转换，比如数列 {10，11，7，6，8，9}、{2，1，6，5，7，3}</p>
<p>问题分析：</p>
<ol>
<li>当符合右旋条件时</li>
<li>如果当前节点的左子树的右子树高于当前节点的右子树</li>
<li>应当先对当前节点的左子树进行左旋</li>
<li>再对当前节点进行右旋</li>
</ol>
<img src="【数据结构与算法】树：平衡二叉树/image-20200425102817626.png" alt="image-20200425102817626" style="zoom:67%;" />

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Node：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.left.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.right.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用递归的方法返回当前节点的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(), right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋：参考“具体流程”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="built_in">this</span>.value);</span><br><span class="line">    newNode.left = <span class="built_in">this</span>.left;</span><br><span class="line">    newNode.right = <span class="built_in">this</span>.right.left;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.right.value;</span><br><span class="line">    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">    <span class="built_in">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋：参考“具体流程”</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="built_in">this</span>.value);</span><br><span class="line">    newNode.right = <span class="built_in">this</span>.right;</span><br><span class="line">    newNode.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.right.value;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;</span><br><span class="line">    <span class="built_in">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//先判断加入的节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当加入节点的值小于当前节点的值时，考虑左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//当加入节点的值大于当前节点的值时，考虑右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要进行左旋</span></span><br><span class="line">    <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否需要双旋转</span></span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; right.leftHeight() - right.rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            right.rightRotate();</span><br><span class="line">            leftRotate();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要右旋</span></span><br><span class="line">    <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否需要双旋转</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; left.rightHeight() - left.leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            left.leftRotate();</span><br><span class="line">            rightRotate();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightRotate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>尚硅谷：<a href="https://www.bilibili.com/video/BV1E4411H73v">https://www.bilibili.com/video/BV1E4411H73v</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【服务器购买及部署】初识服务器</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/</url>
    <content><![CDATA[<blockquote>
<p>第一次相遇</p>
<p>……</p>
<p>很高兴认识你！</p>
</blockquote>
<h1 id="服务器必知"><a href="#服务器必知" class="headerlink" title="服务器必知"></a>服务器必知</h1><p><strong>整个服务器就相当于是一个远程的Linux电脑</strong></p>
<h3 id="为什么要有一个自己的服务器"><a href="#为什么要有一个自己的服务器" class="headerlink" title="为什么要有一个自己的服务器"></a>为什么要有一个自己的服务器</h3><ul>
<li><p>作为敲代码为生的程序员，写博客是日常，可以记录不断增长的技术栈和学习开发过程中遇到的各种问题，这时候就需要将自己的博客网站部署到服务器上</p>
</li>
<li><p>发布自己的项目</p>
</li>
<li><p>熟练Linux操作（联系Linux命令行操作的好方法）</p>
</li>
<li><p>将自己的远程仓库、远程数据库、远程tomcat等等搭载在服务器上</p>
</li>
<li><p>……</p>
</li>
</ul>
<h3 id="如何购买服务器"><a href="#如何购买服务器" class="headerlink" title="如何购买服务器"></a>如何购买服务器</h3><p><strong>阿里云</strong>了解一下：<a href="https://cn.aliyun.com/">https://cn.aliyun.com/</a></p>
<p><img src="/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/image-20200430082526275.png" alt="image-20200430082526275"></p>
<p><strong>云服务器一般都很贵，动辄上千上万一年</strong></p>
<blockquote>
<p>啊？家里有矿啊</p>
<p>那没事了</p>
</blockquote>
<p><img src="/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/image-20200430083102896.png" alt="image-20200430083102896"></p>
<p>还可以考虑一下两种购买方式：</p>
<ul>
<li><p>学生机</p>
<p>  要求：是在校学生&#x2F;年龄在24岁以下，没错就是我了hhh</p>
<p>  1.在阿里云首页<strong>直接搜索学生机</strong></p>
<p>  ​	<img src="【服务器购买及部署】看我部署，你也可以！/image-20200430083344969.png" alt="image-20200430083344969" style="zoom:67%;" /></p>
<p>  ​	</p>
<p>  2.一年也就114，也就是差不多一年黄钻或者QQ会员的价钱！相对来说便宜了好多！（做QQ的贵族不如做程序员中的贵族）</p>
<p>  ​	<img src="【服务器购买及部署】看我部署，你也可以！/image-20200430083635162.png" alt="image-20200430083635162" style="zoom:67%;" /></p>
<p>  两种套餐对比：</p>
<blockquote>
<h3 id="公网宽带对比"><a href="#公网宽带对比" class="headerlink" title="公网宽带对比"></a>公网宽带对比</h3><p>宽带方面轻量应用服务器5M峰值宽带，而ECS云服务器只有1M；但是轻量应用服务器是限制流量的，每月1000G流量包，但是对于一般用户而言1000G&#x2F;月的流量足够用了。如果流量每月不超1000G，5M宽带的轻量应用服务器更香。</p>
<h3 id="云盘对比"><a href="#云盘对比" class="headerlink" title="云盘对比"></a>云盘对比</h3><p>轻量应用服务器配备的是40G的SSD云盘，而ECS云服务器配备的是40G的高效云盘，云盘性能方面SS云盘完胜高效云盘，所以云盘方面轻量应用服务器又赢了一局。</p>
<h3 id="集群对比"><a href="#集群对比" class="headerlink" title="集群对比"></a>集群对比</h3><p>轻量应用服务器只能做单机应用，而ECS云服务器可以做集群使用。</p>
<h3 id="操作系统及应用性"><a href="#操作系统及应用性" class="headerlink" title="操作系统及应用性"></a>操作系统及应用性</h3><p>轻量应用服务器支持应用镜像和系统镜像，系统镜像支持较少，轻量应用服务器对于技术门槛要求较低，适用于个人用户使用。ECS云服务器支持的系统镜像会丰富一些，需要用户有一些技术基础。</p>
<p>综上，如果您购买学生云服务器是用来搭建单机应用，如网站，并且流量每月不超过1000G，那么轻量应用服务器是最佳的选择。如果需要搭集群，那么只能选ECS云服务器。</p>
<p>作者：哪个快<br>链接：<a href="https://www.zhihu.com/question/267913124/answer/1179610483">https://www.zhihu.com/question/267913124/answer/1179610483</a><br>来源：知乎</p>
</blockquote>
</li>
<li><p>限时优惠</p>
<p>  阿里云会经常做一些限时折扣之类的活动：<a href="https://www.aliyun.com/minisite/goods?userCode=0phtycgr">https://www.aliyun.com/minisite/goods?userCode=0phtycgr</a></p>
  <img src="【服务器购买及部署】看我部署，你也可以！/image-20200430084433153.png" alt="image-20200430084433153" style="zoom: 33%;" />

<p>  以后可能会用到，暂时用不到，就先不管啦！</p>
</li>
</ul>
<p>综上，我进行了如是选择：</p>
<img src="【服务器购买及部署】看我部署，你也可以！/image-20200430085842175.png" alt="image-20200430085842175" style="zoom:67%;" />



<h1 id="管理服务器"><a href="#管理服务器" class="headerlink" title="管理服务器"></a>管理服务器</h1><h3 id="一些准备"><a href="#一些准备" class="headerlink" title="一些准备"></a>一些准备</h3><ol>
<li><h5 id="获取服务器公网IP地址、修改实例名称和密码（第一次修改需要重启）"><a href="#获取服务器公网IP地址、修改实例名称和密码（第一次修改需要重启）" class="headerlink" title="获取服务器公网IP地址、修改实例名称和密码（第一次修改需要重启）"></a>获取服务器公网IP地址、修改实例名称和密码（第一次修改需要重启）</h5></li>
<li><h5 id="进入服务器"><a href="#进入服务器" class="headerlink" title="进入服务器"></a>进入服务器</h5><p> <img src="/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/image-20200430104905430.png" alt="image-20200430104905430"></p>
<p> <img src="/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/image-20200430100403535.png" alt="image-20200430100403535"></p>
</li>
<li><h5 id="创建安全组，开启端口映射"><a href="#创建安全组，开启端口映射" class="headerlink" title="创建安全组，开启端口映射"></a>创建安全组，开启端口映射</h5></li>
</ol>
<p><img src="/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/image-20200430104750892.png" alt="image-20200430104750892"></p>
<p>​	常见端口，比如说：</p>
<p>​		3306：MySQL</p>
<p>​		8080：Tomcat</p>
<p>​		……</p>
<blockquote>
<p>注意：<br>如需完整使用宝塔的所有功能 你还需要放行如下端口<br>20 、21、 39000-40000端口（linux 系统 ），3000-4000（windows系统）<br>22 (SSH)<br>80、443（网站及SSL）<br>3306 （数据库远程连接）<br>888 （phpmyadmin）</p>
</blockquote>
<ol start="4">
<li><h5 id="XShell连接"><a href="#XShell连接" class="headerlink" title="XShell连接"></a>XShell连接</h5></li>
</ol>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>我们有两种方法：</p>
<ul>
<li><p>傻瓜式（宝塔面板，可视化，不推荐）：<a href="https://www.bt.cn/download/linux.html">https://www.bt.cn/download/linux.html</a></p>
<p>  <img src="/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/image-20200430100703608.png" alt="image-20200430100703608"></p>
<p>  宝塔安装：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://125.88.182.172:5880/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure>

<p>  <img src="/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/image-20200430102558800.png" alt="image-20200430102558800"></p>
</li>
</ul>
<p>​		根据链接进入网页，输入用户名和密码……</p>
<p>​		安装软件：		<img src="【服务器购买及部署】看我部署，你也可以！/image-20200430105800735.png" alt="image-20200430105800735" style="zoom:67%;" /></p>
<p>​		一键部署：<img src="/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/image-20200430110045806.png" alt="image-20200430110045806"></p>
<p>​		控制端口：</p>
<p><img src="/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E9%83%A8%E7%BD%B2%E3%80%91%E7%9C%8B%E6%88%91%E9%83%A8%E7%BD%B2%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%EF%BC%81/image-20200430110346262.png" alt="image-20200430110346262"></p>
<ul>
<li><p>命令式（原生）</p>
<p>  使用Linux命令行进行操作</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV177411K7bH?from=search&seid=9611310942469724449">https://www.bilibili.com/video/BV177411K7bH?from=search&amp;seid=9611310942469724449</a></p>
<p>哪个快：<a href="https://www.zhihu.com/question/267913124/answer/1179610483">https://www.zhihu.com/question/267913124/answer/1179610483</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】异常检测文献阅读：关键算法篇</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91NLP%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95%E7%AF%87/</url>
    <content><![CDATA[<h1 id="1-k-NN"><a href="#1-k-NN" class="headerlink" title="1 k-NN"></a>1 k-NN</h1><h1 id="2-LOF（Local-Outlier-Factor）"><a href="#2-LOF（Local-Outlier-Factor）" class="headerlink" title="2 LOF（Local Outlier Factor）"></a>2 LOF（Local Outlier Factor）</h1><h3 id="2-1-Article"><a href="#2-1-Article" class="headerlink" title="2.1 Article"></a>2.1 Article</h3><table>
<thead>
<tr>
<th>Abbreviation</th>
<th>Paper Title</th>
<th>Venue</th>
<th>Year</th>
<th>Author</th>
<th>Materials</th>
</tr>
</thead>
<tbody><tr>
<td>LOF</td>
<td>LOF: identifying density-based local outliers</td>
<td>ACM SIGMOD Record</td>
<td>2000</td>
<td>Markus M. Breunig、Hans-Peter Kriegel、Raymond T. Ng、Jörg Sander</td>
<td><a href="http://www.dbs.ifi.lmu.de/Publikationen/Papers/LOF.pdf">PDF</a></td>
</tr>
</tbody></table>
<h3 id="2-2-Aim"><a href="#2-2-Aim" class="headerlink" title="2.2 Aim"></a>2.2 Aim</h3><p>In this paper, we contend that for many scenarios, it is more meaningful to assign to each object a degree of being an outlier. This degree is called the local outlier factor (LOF) of an object.</p>
<h3 id="2-3-Key-Notes"><a href="#2-3-Key-Notes" class="headerlink" title="2.3 Key Notes"></a>2.3 Key Notes</h3><ul>
<li><p><strong>Definition 1</strong>:  (Hawkins-Outlier)</p>
<p>  An outlier is an observation that deviates so much from other observations as to arouse suspicion that it was generated by a different mechanism.</p>
  <img src="【机器学习】NLP文献阅读：关键算法篇/image-20210122112045179.png" alt="image-20210122112045179" style="zoom:80%;" />
</li>
<li><p><strong>Definition 2:</strong> (DB(<em>pct</em>, <em>dmin</em>)-Outlier)</p>
<p>  An object <em>p</em> in a dataset <em>D</em> is a <em>DB</em>(<em>pct, dmin</em>)-outlier if at least percentage <em>pct</em> of the objects in <em>D</em> lies greater than distance <em>dmin</em> from <em>p</em>, i.e., the cardinality of the set {<em>q</em> ∈ <em>D</em> | <em>d</em>(<em>p</em>, <em>q</em>) ≤ <em>dmin</em>} is less than or equal to (100 − <em>pct</em>)% of the size of <em>D</em>.</p>
</li>
<li><p><strong>Definition 3:</strong> (<em>k</em>-distance of an object <em>p</em>， <strong>点 p 距离第k个邻居的距离</strong>)</p>
<p>  For any positive integer <em>k</em>, the <em>k</em>-distance of object <em>p</em>, denoted as<em>k-distance</em>(<em>p</em>), is defined as the distance <em>d</em>(<em>p</em>,<em>o</em>) between <em>p</em> and an object <em>o</em> ∈ <em>D</em>.</p>
</li>
<li><p><strong>Definition 4:</strong> (<em>k</em>-distance neighborhood of an object <em>p</em>， <strong>点 p 的 k 个邻居</strong>)</p>
<p>  Given the <em>k</em>-distance of <em>p</em>, the <em>k-distance neighborhood of p</em> contains every object whose distance from <em>p</em> is not greater than the <em>k</em>-distance.</p>
</li>
<li><p><strong>Definition 5:</strong> (reachability distance of an object <em>p</em> w.r.t. object <em>o</em>)</p>
  <img src="【机器学习】NLP文献阅读：关键算法篇/image-20210122112137206.png" alt="image-20210122112137206" style="zoom:80%;" />

<p>  <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91NLP%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95%E7%AF%87/image-20210122111700368.png" alt="image-20210122111700368"></p>
</li>
<li><p><strong>Definition 6:</strong> (local reachability density of an object <em>p</em>)</p>
<p>  局部可达密度：p 的第 k 邻域内到点 p 的平均可达距离的倒数</p>
  <img src="【机器学习】NLP文献阅读：关键算法篇/image-20210122111922611.png" alt="image-20210122111922611" style="zoom:80%;" />
</li>
<li><p><strong>Definition 7:</strong> ((local) outlier factor of an object <em>p</em>， 局部异常因子)</p>
  <img src="【机器学习】NLP文献阅读：关键算法篇/image-20210122112837320.png" alt="image-20210122112837320" style="zoom:80%;" />

<p>  点 p 的领域点的局部可达密度与点 p 的局部可达密度的平均比值</p>
<ul>
<li>LOF(p) ≈ 1：p 与其邻域点的的密度差不多，他们很有可能在同一类中</li>
<li>LOF(p) &gt;  1：p 点密度越小于其邻域点的密度，p 点是异常点的可能性越大</li>
<li>LOF(p) &lt;  1：p 点密度越大于其邻域点的密度，p 点为密集点</li>
</ul>
</li>
<li><p><strong>Determining a Range of</strong> <strong>MinPts</strong> <strong>Values</strong></p>
<ul>
<li>The first guideline we provide for picking MinPtsLB is that <strong>it should be at least 10</strong> to remove unwanted statistical fluctuations.</li>
<li>The guideline we provide for picking <em>MinPtsUB</em> is the maximum number of “close by” objects that can potentially be local outliers.</li>
</ul>
</li>
<li><p>In this paper, we show that for many situations, it is meaningful to <strong>consider being an outlier not as a binary property, but as the degree to which the object is isolated from its surrounding neighborhood</strong>.</p>
</li>
</ul>
<h3 id="2-4-Background"><a href="#2-4-Background" class="headerlink" title="2.4 Background"></a>2.4 Background</h3><p>For many KDD applications, such as detecting criminal activities in E-commerce, finding the rare instances or the outliers, can be more interesting than finding the common patterns. <strong>Existing work in outlier detection regards being an outlier as a binary property.</strong> </p>
<h3 id="2-5-Key-result"><a href="#2-5-Key-result" class="headerlink" title="2.5 Key result"></a>2.5 Key result</h3><p>Use LOF to judge the outlier-ness of a data in datasets</p>
<h3 id="2-6-Comment"><a href="#2-6-Comment" class="headerlink" title="2.6 Comment"></a>2.6 Comment</h3><h1 id="3-iForest（Isolation-Forest）"><a href="#3-iForest（Isolation-Forest）" class="headerlink" title="3 iForest（Isolation Forest）"></a>3 iForest（Isolation Forest）</h1><h3 id="3-1-Article"><a href="#3-1-Article" class="headerlink" title="3.1 Article"></a>3.1 Article</h3><table>
<thead>
<tr>
<th>Abbreviation</th>
<th>Paper Title</th>
<th>Venue</th>
<th>Year</th>
<th>Author</th>
<th>Materials</th>
</tr>
</thead>
<tbody><tr>
<td>IForest</td>
<td>Isolation forest</td>
<td>ICDM</td>
<td>2008</td>
<td>Fei Tony Liu、Kai Ming Ting、<strong>Zhi-Hua Zhou</strong></td>
<td>[<a href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf">PDF]</a></td>
</tr>
</tbody></table>
<h3 id="3-2-Aims"><a href="#3-2-Aims" class="headerlink" title="3.2 Aims"></a>3.2 Aims</h3><p>This paper proposes a fundamentally different <strong>model-based method</strong> that explicitly isolates anomalies instead of profiles normal points.</p>
<h3 id="3-3-Key-Notes"><a href="#3-3-Key-Notes" class="headerlink" title="3.3 Key Notes"></a>3.3 Key Notes</h3><h4 id="3-3-1-rationale"><a href="#3-3-1-rationale" class="headerlink" title="3.3.1 rationale"></a>3.3.1 rationale</h4><p><strong>Anomalies are more susceptible to isolation and hence have short path lengths.</strong></p>
<img src="【机器学习】NLP文献阅读：关键算法篇/image-20210125144546066.png" alt="image-20210125144546066" style="zoom:80%;" />

<img src="【机器学习】NLP文献阅读：关键算法篇/image-20210125144558961.png" alt="image-20210125144558961" style="zoom:80%;" />

<h4 id="3-3-2-Defifinition-Isolation-Tree"><a href="#3-3-2-Defifinition-Isolation-Tree" class="headerlink" title="3.3.2 Defifinition : Isolation Tree."></a>3.3.2 Defifinition : <strong>Isolation Tree.</strong></h4><p>Let <em>T</em> be a node of an isolation tree. <em>T</em> is either <strong>an external-node with no child, or an internal-node with one test and exactly two daughter nodes</strong> (<em>T_l</em>,<em>T_r</em>). A test consists of <strong>an attribute <em>q</em> and a split value <em>p</em></strong> such that the test <em>q &lt; p</em> divides data points into <em>T_l</em> and <em>T_r</em>.</p>
<ul>
<li><p>随机选择一个属性 Attr</p>
</li>
<li><p>随机选择该属性的一个值 Value</p>
</li>
<li><p>根据Attr对每条记录进行分类，把Attr小于Value的记录放在左子节点，把大于等于Value的记录放在右子节点</p>
</li>
<li><p>然后递归的构造左子节点和右子节点，直到 </p>
<p>  1）传入的数据集只有一条记录或者多条一样的记录 </p>
<p>  2）树的高度达到了限定高度</p>
</li>
</ul>
 <img src="【机器学习】NLP文献阅读：关键算法篇/image-20210125162852242.png" alt="image-20210125162852242" style="zoom: 80%;" />

<h4 id="3-3-3-Defifinition-Path-Length-h-x"><a href="#3-3-3-Defifinition-Path-Length-h-x" class="headerlink" title="3.3.3 Defifinition : Path Length h(x)."></a>3.3.3 Defifinition : <strong>Path Length</strong> <em>h</em>(<em>x</em>).</h4><p>measured by the number of edges <em>x</em> traverses an iTree from the root node until the traversal is terminated at an external node.</p>
<p>叶子节点到根节点的路径长度</p>
 <img src="【机器学习】NLP文献阅读：关键算法篇/image-20210125162941406.png" alt="image-20210125162941406" style="zoom:80%;" />

<h4 id="3-3-4-Anomaly-score"><a href="#3-3-4-Anomaly-score" class="headerlink" title="3.3.4 Anomaly score"></a>3.3.4 Anomaly score</h4><p>The maximum possible height of iTree grows in the order of <em>n</em>, the average height grows in the order of log <em>n</em> </p>
<p>Normalization of <em>h</em>(<em>x</em>) by any of the above terms is either not bounded or cannot be directly compared.    </p>
<p>对于一个包含n条记录的数据集，其构造的树的高度最小值为 log(n)，最大值为 n-1， 直接归一化存在问题，故采用复杂一点的公式进行归一化：</p>
<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91NLP%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95%E7%AF%87/image-20210125160305788.png" alt="image-20210125160305788"></p>
<p><em>s(x,n)</em> 就是记录 x 在由 n 个样本的训练数据构成的 iTree 的异常指数</p>
<ul>
<li>if instances return <em>s</em> <strong>very close to 1</strong>, then they are <strong>definitely anomalies</strong></li>
<li>if instances have <em>s</em> <strong>much smaller than 0.5</strong>, then they are <strong>quite safe to be regarded as normal instances</strong></li>
<li>if all the instances return <strong><em>s</em> <em>≈</em> 0*.*5</strong>, then the entire sample <strong>does not really have any distinct anomaly</strong></li>
</ul>
<h4 id="3-3-5-IForest"><a href="#3-3-5-IForest" class="headerlink" title="3.3.5 IForest"></a>3.3.5 IForest</h4><p>随机采样一部分数据去构建每一颗 ITree，并且保证 ITree 之间的差异性</p>
 <img src="【机器学习】NLP文献阅读：关键算法篇/image-20210125163017284.png" alt="image-20210125163017284" style="zoom:80%;" />

<h5 id="reason-of-sampling"><a href="#reason-of-sampling" class="headerlink" title="reason of sampling"></a><strong>reason of sampling</strong></h5><p><strong>Large sampling size reduces iForest’s ability to isolate anomalies</strong> as normal instances can interfere with the isolation process and therefore reduces its ability to clearly isolate anomalies.</p>
<img src="【机器学习】NLP文献阅读：关键算法篇/image-20210125162551162.png" alt="image-20210125162551162" style="zoom:80%;" />

<h5 id="bulid-stage"><a href="#bulid-stage" class="headerlink" title="bulid stage"></a><strong>bulid stage</strong></h5><ul>
<li>The first (training) stage <strong>builds isolation trees</strong> using subsamples of the training set. </li>
<li>The second (testing) stage passes the test instances through isolation trees to <strong>obtain an anomaly score for each instance</strong></li>
</ul>
<p><strong>height limit</strong>：</p>
<p>The rationale of growing trees up to the average tree height is that <strong>we are only interested in data points that have shorter-than -verage path lengths</strong>, as <strong>those points are more likely to be anomalies</strong>.</p>
<h3 id="3-4-Background"><a href="#3-4-Background" class="headerlink" title="3.4 Background"></a>3.4 Background</h3><ul>
<li><p>The concept of isolation has not been explored in the current literature and the use of isolation is shown to be highly effective in detecting anomalies with extremely high effificiency.</p>
</li>
<li><p>Most existing model-based approaches to anomaly detection construct a profile of normal instances, then identify instances that do not conform to the normal profifile as anomalies. Notable examples such as statistical methods, classifification-based methods , and clustering-based methods  all use this general approach. Two major drawbacks of this approach are: </p>
<p>  (i) the anomaly detector is optimized to profifile normal instances, but not optimized to detect anomalies—as a consequence, the results of anomaly detection might not be as good as expected, causing too many false alarms (having normal instances identifified as anomalies) or too few anomalies being detected; </p>
<p>  (ii) many existing methods are constrained to low dimensional data and small data size because of their high computational complexity.</p>
</li>
</ul>
<h3 id="3-5-Key-result"><a href="#3-5-Key-result" class="headerlink" title="3.5 Key result"></a>3.5 Key result</h3><ul>
<li><p>iForest performs <strong>signifificantly better than a near-linear time complexity distance-based method</strong>, ORCA, LOF and RF in terms of AUC and execution time, especially in large data sets. In addition, iForest converges quickly with a small ensemble size, which enables it to detect anomalies with high efficiency.</p>
</li>
<li><p>For high dimensional problems that contain a large number of irrelevant attributes, iForest can achieve high detection performance quickly <strong>with an additional attribute selector</strong></p>
</li>
<li><p>Isolation Forest is <strong>an accurate and effificient anomaly detector</strong> especially for <strong>large databases.</strong></p>
</li>
</ul>
<h3 id="3-6-Comment"><a href="#3-6-Comment" class="headerlink" title="3.6 Comment"></a>3.6 Comment</h3>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>OD</tag>
        <tag>机器学习</tag>
        <tag>NLP</tag>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】异常检测文献阅读：概览和综述篇</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91NLP%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E6%A6%82%E8%A7%88%E5%92%8C%E7%BB%BC%E8%BF%B0%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>在科研训练老师的推荐下，选择走上这条未知的道路——NLP，更具体一点又或者是文档中的异常检测(Outlier Detection)。</p>
<p>前几天看到阿里达摩院的青橙奖颁布全程记录的视频，心中似乎、可能、大概对科研有了那么一丢丢兴趣。也看到一个关于本科生、研究生、博士生学习区别的视频，视频中假设人类全部已知的知识在一个有固定半径的圆内，本科生便是对圆内一个方向进行探索，研究生可以接触到这个方向的边界，博士生则是努力把这个方向的圆往外括出一个小凸点。</p>
<p>若不必苦于为生计东奔西走，用十年、用一生去解决一个问题，去探索一片未知领域，去拓宽人类的知识边界，又何尝不是一件值得去做的事情呢？</p>
<p>感谢老师能够提供相关的指导，为我用心整理了出一些需要研读的文献。这个系列文章就是为了记录 OD文献 阅读过程中的所学、所思、所想……</p>
</blockquote>
<h1 id="1-A-Survey-of-Outlier-Detection-Methodologies"><a href="#1-A-Survey-of-Outlier-Detection-Methodologies" class="headerlink" title="1. A Survey of Outlier Detection Methodologies."></a>1. A Survey of Outlier Detection Methodologies.</h1><h3 id="1-1-Article"><a href="#1-1-Article" class="headerlink" title="1.1 Article"></a>1.1 Article</h3><table>
<thead>
<tr>
<th>Paper Title</th>
<th>Venue</th>
<th>Year</th>
<th>Author</th>
<th>Materials</th>
</tr>
</thead>
<tbody><tr>
<td>A survey of outlier detection methodologies</td>
<td>ARTIF INTELL REV</td>
<td>2004</td>
<td>Victoria J. Hodge 、Jim Austin</td>
<td>[<a href="https://www-users.cs.york.ac.uk/vicky/myPapers/Hodge+Austin_OutlierDetection_AIRE381.pdf">PDF]</a></td>
</tr>
</tbody></table>
<h3 id="1-2-Aim"><a href="#1-2-Aim" class="headerlink" title="1.2 Aim"></a>1.2 Aim</h3><ul>
<li>In this paper, we introduce <strong>a survey of contemporary techniques for outlier detection</strong>.</li>
<li>We identify their respective <strong>motivations</strong> and <strong>distinguish their advantages and disadvantages</strong> in a comparative review.</li>
</ul>
<h3 id="1-3-Conclusion"><a href="#1-3-Conclusion" class="headerlink" title="1.3 Conclusion"></a>1.3 Conclusion</h3><ul>
<li><p>defination of OD:</p>
<ul>
<li>An outlying observation, or outlier, is one that appears to deviate markedly from other members of the sample in which it occurs.</li>
<li>An observation (or subset of observations) which appears to be inconsistent with the remainder of that set of data.</li>
</ul>
</li>
<li><p><strong>three fundamental approaches</strong> to the problem of outlier detection:</p>
<ol>
<li><p>Determine the outliers with no prior knowledge of the data.（<strong>unsupervised clustering</strong>）</p>
<p> 事先并不知道数据集中异常与正常的数据分别是哪些，需要通过一些列算法找出异常与正常数据的边界值（accommodation）或不断剔除数据集最偏离其他数据的数据（diagnosis），进而区别异常数据与正常数据。</p>
</li>
<li><p>Model both normality and abnormality. （<strong>supervised classifification</strong>）</p>
<p> 事先已经将数据中的异常值与正常值分好，当有新数据加入时更接近正常值新数据就会被归类为正常值，反之则会被归类为异常值。</p>
<p> 但是新数据已知正常值和异常值都存在较大差异（比如一些之前从未出现过的错误），那么分类就会出现问题。</p>
</li>
<li><p>Model only normality or in a very few cases model abnormality.（<strong>semi-supervised recognition or detection</strong>）</p>
<p> 在已知所有正常值而不知道异常值、异常情况数据比较珍贵的情况下，判断新数据是异常还是正常。（这与现实中许多实际情况相符合）</p>
<p> 目标是定义出一些正常数据的边界。</p>
</li>
</ol>
</li>
</ul>
<h3 id="1-4-Background"><a href="#1-4-Background" class="headerlink" title="1.4 Background"></a>1.4 Background</h3><h3 id="1-5-Key-result"><a href="#1-5-Key-result" class="headerlink" title="1.5 Key result"></a>1.5 Key result</h3><h3 id="1-6-Methods"><a href="#1-6-Methods" class="headerlink" title="1.6 Methods"></a>1.6 Methods</h3><h1 id="2-Anomalous-Instance-Detection-in-Deep-Learning-A-Survey"><a href="#2-Anomalous-Instance-Detection-in-Deep-Learning-A-Survey" class="headerlink" title="2. Anomalous Instance Detection in Deep Learning: A Survey"></a>2. Anomalous Instance Detection in Deep Learning: A Survey</h1><h3 id="1-1-Article-1"><a href="#1-1-Article-1" class="headerlink" title="1.1 Article"></a>1.1 Article</h3><table>
<thead>
<tr>
<th>Paper Title</th>
<th>Venue</th>
<th>Year</th>
<th>Author</th>
<th>Materials</th>
</tr>
</thead>
<tbody><tr>
<td>Anomalous Instance Detection in Deep Learning: A Survey</td>
<td>Preprint</td>
<td>2020</td>
<td>Saikiran Bulusu、Bhavya Kailkhura、Bo Li、Pramod K. Varshney、Dawn Song</td>
<td>[<a href="https://arxiv.org/pdf/2003.06979.pdf">PDF]</a></td>
</tr>
</tbody></table>
<h3 id="1-2-Aim-1"><a href="#1-2-Aim-1" class="headerlink" title="1.2 Aim"></a>1.2 Aim</h3><ul>
<li>This survey tries to provide a structured and comprehensive overview of the research on<br>   anomaly detection for DL based applications.</li>
<li>Our goal in this survey is to provide an easier yet better understanding of the techniques belonging to different categories in which research has been done on this topic.</li>
</ul>
<h3 id="1-3-Content"><a href="#1-3-Content" class="headerlink" title="1.3 Content"></a>1.3 Content</h3><h3 id="1-4-Background-1"><a href="#1-4-Background-1" class="headerlink" title="1.4 Background"></a>1.4 Background</h3><h3 id="1-5-Key-result-1"><a href="#1-5-Key-result-1" class="headerlink" title="1.5 Key result"></a>1.5 Key result</h3><h3 id="1-6-Methods-1"><a href="#1-6-Methods-1" class="headerlink" title="1.6 Methods"></a>1.6 Methods</h3>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>OD</tag>
        <tag>机器学习</tag>
        <tag>NLP</tag>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】Python数据分析常用库</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%BA%93/</url>
    <content><![CDATA[<blockquote>
<p>刚结束了4四天的死亡美赛，在建模过程和之前机器学习进行数据分析过程中用到了大量 Python 数据分析常用库</p>
<p>一次次在搜索引擎上查各个库的用法是真滴麻烦</p>
<p>本篇博客用以记录 Python 数据分析中常用库的常用用法，日常用到时查阅方便</p>
</blockquote>
<h1 id="1-Numpy"><a href="#1-Numpy" class="headerlink" title="1. Numpy"></a>1. Numpy</h1><ul>
<li><p>Python没有提供数组功能，Numpy可以提供数组支持以及相应的高效处理函数，是Python数据分析的基础，也是SciPy、Pandas等数据处理和科学计算库最基本的函数功能库，且其数据类型对Python数据分析十分有用。</p>
</li>
<li><p>Numpy提供了<strong>两种基本的对象</strong>：<strong>ndarray和ufunc</strong>。<strong>ndarray是存储单一数据类型的多维数组，而ufunc是能够对数组进行处理的函数</strong>。Numpy的功能：</p>
<ul>
<li>N维数组，一种快速、高效使用内存的多维数组，他提供矢量化数学运算。</li>
<li>可以不需要使用循环，就能对整个数组内的数据进行标准数学运算。</li>
<li>非常便于传送数据到用低级语言编写(C\C++)的外部库,也便于外部库以Numpy数组形式返回数据。</li>
</ul>
</li>
<li><p>Numpy不提供高级数据分析功能，但可以更加深刻的理解Numpy数组和面向数组的计算。</p>
</li>
<li><p>官方文档：<a href="https://numpy.org/doc/stable/">https://numpy.org/doc/stable/</a>    （加载起来小慢）             </p>
<p>  中文文档：<a href="https://www.numpy.org.cn/">https://www.numpy.org.cn/</a></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>



<h3 id="1-1-创建-ndarray"><a href="#1-1-创建-ndarray" class="headerlink" title="1.1 创建 ndarray"></a>1.1 创建 ndarray</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">np.arange(n)</td>
<td align="center">类似range函数，放回ndarray类型，元素从0到n-1</td>
</tr>
<tr>
<td align="center">np.ones(shape)</td>
<td align="center">根据shape生成一个全1数组，shape是元组类型</td>
</tr>
<tr>
<td align="center">np.zeros(shape)</td>
<td align="center">根据shape生成一个全0数组</td>
</tr>
<tr>
<td align="center">np.full(shape,val)</td>
<td align="center">根据shape生成一个数组，每个元素值都为val</td>
</tr>
<tr>
<td align="center">np.eye(n)</td>
<td align="center">创建一个正方的n*n单位矩阵，对角线全为1其余为0</td>
</tr>
<tr>
<td align="center">np.linspace(b,e,n)</td>
<td align="center">根据起始值等间距的填充数据，形成数组</td>
</tr>
</tbody></table>
<h3 id="1-2-数组的变换"><a href="#1-2-数组的变换" class="headerlink" title="1.2 数组的变换"></a>1.2 数组的变换</h3><table>
<thead>
<tr>
<th>.reshape(shape)</th>
<th>不改变数组元素，返回一个shape形状的数组，但原数组不变</th>
</tr>
</thead>
<tbody><tr>
<td>.resize(shape)</td>
<td>与.reshape()功能一致，但修改原数组</td>
</tr>
<tr>
<td>.swapaxes(ax1,ax2)</td>
<td>将数组n个维度中两个进行交换</td>
</tr>
<tr>
<td>.flatten()</td>
<td>对数组进行降维,返回折叠后的一维数组，原数组不变</td>
</tr>
</tbody></table>
<h3 id="1-3-数组的运算"><a href="#1-3-数组的运算" class="headerlink" title="1.3  数组的运算"></a>1.3  数组的运算</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">np.abs(x) , np. fabs(x)</td>
<td align="center">计算数组各数的绝对值</td>
</tr>
<tr>
<td align="center">np.sqrt(x)</td>
<td align="center">计算数组各元素的平方</td>
</tr>
<tr>
<td align="center">np.square()</td>
<td align="center">计算数组各元素的平方</td>
</tr>
<tr>
<td align="center">np.log(x), np.log10(x), np.log2(x)</td>
<td align="center">计算各元素的自然对数，10底对数和2底对数</td>
</tr>
<tr>
<td align="center">np.ceil(x),np.floor(x)</td>
<td align="center">前者向上取整，后者向下取整</td>
</tr>
<tr>
<td align="center">np.rint(x)</td>
<td align="center">四舍五入</td>
</tr>
<tr>
<td align="center">np.modf(x)</td>
<td align="center">将各元素的小数和整数部分以两个独立的数组形式返回</td>
</tr>
<tr>
<td align="center">np.cos(x), np.cosh(x), np.sin(x), np.sinh(x), np.tan(x), np.tanh(x)</td>
<td align="center">计算各元素的普通型和双曲型三角函数</td>
</tr>
<tr>
<td align="center">np.exp(x)</td>
<td align="center">各元素指数值</td>
</tr>
<tr>
<td align="center">np.sign(x)</td>
<td align="center">计算各元素的符号值,1(+),0(0),-1(-)</td>
</tr>
</tbody></table>
<h3 id="1-4-统计函数"><a href="#1-4-统计函数" class="headerlink" title="1.4 统计函数"></a>1.4 统计函数</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sum(a,axis&#x3D;None)</td>
<td align="center">根据给定轴 axis 计算数组 a 相关元素之和，axis 为整数或元组</td>
</tr>
<tr>
<td align="center">mean(a,axis&#x3D;None)</td>
<td align="center">计算期望</td>
</tr>
<tr>
<td align="center">average(a,axis&#x3D;None,weights&#x3D;None)</td>
<td align="center">计算加权平均值</td>
</tr>
<tr>
<td align="center">std(a,axis&#x3D;None)</td>
<td align="center">计算标准差</td>
</tr>
<tr>
<td align="center">var(a,axis&#x3D;None</td>
<td align="center">计算方差</td>
</tr>
<tr>
<td align="center">min(a), max(a)</td>
<td align="center">计算a中的最小值，最大值</td>
</tr>
<tr>
<td align="center">ptp(a)</td>
<td align="center">计算最大值与最小值的差</td>
</tr>
<tr>
<td align="center">median(a)</td>
<td align="center">计算中位数</td>
</tr>
</tbody></table>
<h3 id="1-5-矩阵操作"><a href="#1-5-矩阵操作" class="headerlink" title="1.5 矩阵操作"></a>1.5 矩阵操作</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.T &#x2F; np.transpose()</td>
<td align="center">矩阵转置</td>
</tr>
<tr>
<td align="center">.dot(nd)</td>
<td align="center">矩阵点乘</td>
</tr>
<tr>
<td align="center">.trace()</td>
<td align="center">矩阵的迹（对角线之和）</td>
</tr>
<tr>
<td align="center">np.linalg.det(nd)</td>
<td align="center">矩阵行列式</td>
</tr>
</tbody></table>
<h1 id="2-Pandas"><a href="#2-Pandas" class="headerlink" title="2. Pandas"></a>2. Pandas</h1><ul>
<li><p>Pandas 是 Python 强大、灵活的数据分析和探索工具，包含 <strong>Series、DataFrame</strong> 等高级数据结构和工具，安装Pandas可使Python中处理数据非常快速和简单。</p>
</li>
<li><p>Pandas 是 Python 的一个数据分析包，Pandas最初被用作金融数据分析工具而开发出来，因此Pandas为<strong>时间序列分析</strong>提供了很好的支持。</p>
</li>
<li><p>Pandas 是为了解决数据分析任务而创建的，Pandas 纳入了大量的库和一些标准的数据模型，提供了高效的操作大型数据集所需要的工具。Pandas 提供了大量是我们快速便捷的处理数据的函数和方法。Pandas包含了高级数据结构，以及让数据分析变得快速、简单的工具。它建立在 Numpy 之上，使得 Numpy 应用变得简单。</p>
</li>
<li><p>带有坐标轴的数据结构，支持自动或明确的数据对齐。这能防止由于数据结构没有对齐，以及处理不同来源、采用不同索引的数据而产生的常见错误。</p>
</li>
<li><p>使用Pandas更容易处理丢失数据。</p>
</li>
<li><p>官方文档：<a href="https://pandas.pydata.org/docs/">https://pandas.pydata.org/docs/</a></p>
<p>  中文文档：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>



<h3 id="2-1-导入数据"><a href="#2-1-导入数据" class="headerlink" title="2.1 导入数据"></a>2.1 导入数据</h3><p>导入数据后自动将数据转化为 <strong>DataFrame</strong> 结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pd.read_csv(file_name)					<span class="comment"># 从CSV文件中读取所有数据</span></span><br><span class="line">pd.read_table(file_name)				<span class="comment"># 从一个分隔的文本文件（如TSV）中读取所有数据</span></span><br><span class="line">pd.read_excel(file_name)				<span class="comment"># 从Excel表读取</span></span><br><span class="line">pd.read_sql(query, connectionObject)	<span class="comment"># 从SQL数据库中读取数据</span></span><br><span class="line">pd.read_json(jsonString)				<span class="comment"># 从JSON格式的字符串或URL中获取数据</span></span><br><span class="line">pd.read_clipboard()						<span class="comment"># 要获取剪贴板的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-导出文件"><a href="#2-2-导出文件" class="headerlink" title="2.2 导出文件"></a>2.2 导出文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_csv(file_name)					<span class="comment"># 将DataFrame写入CSV文件</span></span><br><span class="line">df.to_excel(file_name)					<span class="comment"># 将DataFrame写入Excel文件</span></span><br><span class="line">df.to_sql(tableName, connectionObject)	<span class="comment"># 将一个DataFrame写入一个SQL表</span></span><br><span class="line">df.to_json(file_name)					<span class="comment"># 将DataFrame写入JSON格式的文件</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-查看-DataFrame-的相关信息"><a href="#2-3-查看-DataFrame-的相关信息" class="headerlink" title="2.3 查看 DataFrame 的相关信息"></a>2.3 查看 DataFrame 的相关信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.info()		<span class="comment"># 获取所有与索引、数据类型和内存相关的信息</span></span><br><span class="line">df.head(n)		<span class="comment"># 要提取DataFrame的起始n行</span></span><br><span class="line">df.tail(n)		<span class="comment"># 要提取DataFrame中最后n行</span></span><br><span class="line">df.shape		<span class="comment"># 要提取DataFrame中可用的行数和列数</span></span><br><span class="line">df.describe()	<span class="comment"># 总结数字列的统计</span></span><br><span class="line">df.mean()		<span class="comment"># 返回所有列的平均值</span></span><br><span class="line">df.count()		<span class="comment"># 返回非空值的数量</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-数据切片"><a href="#2-4-数据切片" class="headerlink" title="2.4 数据切片"></a>2.4 数据切片</h3><ul>
<li><p><code>loc</code>：可以按照数据的行名、列名进行索引，也可以用行号、列号进行索引</p>
<p>  <strong>但是不能索引不存在的行号（列好），比如- 1</strong></p>
</li>
<li><p><code>iloc</code>：只能根据行号、列号进行索引</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按行号和列号进行切片</span></span><br><span class="line">df.iloc[:, :]					<span class="comment"># 提取所有数据</span></span><br><span class="line">df.iloc[<span class="number">0</span>]						<span class="comment"># 取第一行的数据</span></span><br><span class="line">df.iloc[:, <span class="number">0</span>]					<span class="comment"># 取第一列的数据</span></span><br><span class="line">df.iloc[<span class="number">0</span>:<span class="number">5</span>, <span class="number">2</span>:-<span class="number">1</span>]				<span class="comment"># 取第一行到第五行，第二列到倒数第一列的数据（不包括倒数第一列）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行名和列名进行切片</span></span><br><span class="line">df[<span class="string">&#x27;A&#x27;</span>] / df.A					<span class="comment"># 提取列名为A的数据</span></span><br><span class="line">df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]]					<span class="comment"># 提取列名为A和B的数据</span></span><br><span class="line">df.loc[<span class="string">&#x27;a&#x27;</span>]						<span class="comment"># 提取行名为a的数据</span></span><br><span class="line">df.loc[:, <span class="string">&#x27;A&#x27;</span>]					<span class="comment"># 提取列名为A的数据</span></span><br><span class="line">df.loc[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]]	<span class="comment"># 提取行名为a和b，列名为A和B的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按条件进行切片，提取数据所在行</span></span><br><span class="line">df[df[<span class="string">&#x27;A&#x27;</span>] == <span class="number">0</span>] / df.loc[df[<span class="string">&#x27;A&#x27;</span>] == <span class="number">0</span>]							<span class="comment"># 提取A列中数据等于0的行</span></span><br><span class="line">df[(df.A == <span class="number">0</span>)&amp;(df.B == <span class="number">2</span>)] / df.loc[(df.A == <span class="number">0</span>)&amp;(df.B == <span class="number">2</span>)]	<span class="comment"># 多条件筛选</span></span><br><span class="line">data[data[<span class="string">&#x27;A&#x27;</span>].isin([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])]									<span class="comment"># 提取A列数据在[0,1,2]中的行</span></span><br><span class="line">df[~df[<span class="string">&#x27;A&#x27;</span>].isin(a)]											<span class="comment"># 按条件去除某一列</span></span><br><span class="line"></span><br><span class="line">df.query(expr)				<span class="comment"># 根据布尔值查找满足条件的行，expr是一个字符串形式的布尔表达式</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-数据操作"><a href="#2-5-数据操作" class="headerlink" title="2.5 数据操作"></a>2.5 数据操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.rename(columns = <span class="keyword">lambda</span> x: x + <span class="string">&#x27;1&#x27;</span>)			<span class="comment"># 同时重命名所有列</span></span><br><span class="line">df.rename(columns = &#123;<span class="string">&#x27;oldName&#x27;</span>: <span class="string">&#x27;newName&#x27;</span>&#125;)		<span class="comment"># 选择性地重命名列</span></span><br><span class="line">df.rename(index = <span class="keyword">lambda</span> x: x + <span class="number">1</span>)				<span class="comment"># 重命名所有的索引</span></span><br><span class="line">df.columns = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]					<span class="comment"># 按顺序重命名列</span></span><br><span class="line">df.isnull()										<span class="comment"># 检查是否存在空值，相应地返回一个布尔型数组</span></span><br><span class="line">df.notnull()									<span class="comment"># 与上一条相反</span></span><br><span class="line">df.dropna()										<span class="comment"># 删除所有包含空的行</span></span><br><span class="line">df.dropna(axis=<span class="number">1</span>)								<span class="comment"># 删除所有包含空的列</span></span><br><span class="line">df.fillna(n)									<span class="comment"># 用n代替每个空值</span></span><br><span class="line">ser.astype(<span class="built_in">float</span>)								<span class="comment"># 将series的所有数据类型转换为浮点数</span></span><br><span class="line"></span><br><span class="line">df1.append(df2)									<span class="comment"># 将df2的行添加到df1的末尾</span></span><br><span class="line">pd.concat([df1,df2],axis=<span class="number">1</span>)						<span class="comment"># 将df2的列添加到df1的末尾</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-分组、排序"><a href="#2-6-分组、排序" class="headerlink" title="2.6 分组、排序"></a>2.6 分组、排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby(colm)						<span class="comment"># 返回列值的groupby对象</span></span><br><span class="line">df.groupby([colm1, colm2])				<span class="comment"># 返回多列值的groupby对象</span></span><br><span class="line">df.sort_values(colm1)					<span class="comment"># 按升序排序（按列）</span></span><br><span class="line">df.sort_values(colm2, ascending=<span class="literal">False</span>)	<span class="comment"># 要按降序排序（按列）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-绘图"><a href="#2-7-绘图" class="headerlink" title="2.7 绘图"></a>2.7 绘图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line">display(df)</span><br><span class="line">df.plot(kind=<span class="string">&quot;line&quot;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="3-Matplotlib"><a href="#3-Matplotlib" class="headerlink" title="3. Matplotlib"></a>3. Matplotlib</h1><ul>
<li><p>Matplotlib是强大的数据可视化工具和作图库，是主要用于绘制数据图表的Python库，提供了绘制各类可视化图形的命令字库、简单的接口，可以方便用户轻松掌握图形的格式，绘制各类可视化图形。</p>
</li>
<li><p>Matplotlib是Python的一个可视化模块，他能方便的只做线条图、饼图、柱状图以及其他专业图形。<br>  使用Matplotlib，可以定制所做图表的任一方面。他支持所有操作系统下不同的GUI后端，并且可以将图形输出为常见的矢量图和图形测试，如PDF SVG JPG PNG BMP GIF.通过数据绘图，我们可以将枯燥的数字转化成人们容易接收的图表。</p>
</li>
<li><p>Matplotlib是基于Numpy的一套Python包，这个包提供了吩咐的数据绘图工具，主要用于绘制一些统计图形。<br>  Matplotlib有一套允许定制各种属性的默认设置，可以控制Matplotlib中的每一个默认属性：图像大小、每英寸点数、线宽、色彩和样式、子图、坐标轴、网个属性、文字和文字属性。</p>
</li>
<li><p>官方文档：<a href="https://matplotlib.org/contents.html">https://matplotlib.org/contents.html</a></p>
<p>  中文文档：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<h3 id="3-1-设置中文字体"><a href="#3-1-设置中文字体" class="headerlink" title="3.1 设置中文字体"></a>3.1 设置中文字体</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="comment"># 设置图形中的字体为 黑体</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;SimHei&quot;</span></span><br><span class="line"><span class="comment"># 将 unicode 负号改为 ASCII 字符集的负号</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-常用局部设置"><a href="#3-2-常用局部设置" class="headerlink" title="3.2 常用局部设置"></a>3.2 常用局部设置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xticks / yticks 设置或获取坐标轴的数值刻度。(不传参数就是获取)</span></span><br><span class="line"><span class="comment"># 第一个参数，设置值，第二个参数可以不传，是标签，不传标签，就显示值</span></span><br><span class="line"><span class="comment"># rotation: 设置旋转度数</span></span><br><span class="line">plt.xticks([<span class="number">0</span>, <span class="number">60</span>, <span class="number">80</span>, <span class="number">100</span>], [<span class="string">&quot;开始&quot;</span>, <span class="string">&quot;及格&quot;</span>, <span class="string">&quot;良好&quot;</span>, <span class="string">&quot;卓越&quot;</span>], rotation = <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的标题,及标题位置</span></span><br><span class="line">plt.title(<span class="string">&quot;设置图形的标题&quot;</span>, y=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴与y轴显示的标签内容。</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;部门&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;销售量&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取绘图支持的所有样式。</span></span><br><span class="line">plt.style.available</span><br><span class="line"><span class="comment"># 设置绘图使用的样式。</span></span><br><span class="line">plt.style.use(<span class="string">&quot;ggplot&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图列</span></span><br><span class="line"><span class="comment"># loc: 指定图例显示的位置。默认为best。可以是int，string与元组类型。</span></span><br><span class="line"><span class="comment"># frameon: 指定图列是否有边框，默认为True</span></span><br><span class="line"><span class="comment"># ncol：设置图例列数</span></span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>, frameon=<span class="literal">False</span>, title=<span class="string">&quot;图例说明&quot;</span>, ncol=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的透明度</span></span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>], alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-设置绘图区域"><a href="#3-3-设置绘图区域" class="headerlink" title="3.3 设置绘图区域"></a>3.3 设置绘图区域</h3><p>隐式的创建了绘图区域：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot()</span><br><span class="line">plt.line()				<span class="comment"># 线型图</span></span><br><span class="line">plt.bar()				<span class="comment"># 柱状图</span></span><br><span class="line">plt.barh()				<span class="comment"># 条形图</span></span><br><span class="line">plt.hist()				<span class="comment"># 直方图</span></span><br><span class="line">plt.kde/density()		<span class="comment"># 核密度图</span></span><br><span class="line">plt.pie()				<span class="comment"># 饼图</span></span><br><span class="line">plt.box()				<span class="comment"># 箱线图</span></span><br><span class="line">plt.area()				<span class="comment"># 面积图</span></span><br></pre></td></tr></table></figure>

<p>显式的创建了绘图区域：</p>
<ul>
<li><p><code>add_subplot</code>：需要先创建画布对象，然后在画布对象上，创建绘图区域</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = plt.figure(figsize=(<span class="number">5</span>, <span class="number">5</span>))				<span class="comment"># 创建画布对象,可以通过参数设置画布大小（英寸）</span></span><br><span class="line"><span class="comment"># 也可以用 f.set_size_inches((7, 7)) 进行画布大小的设置</span></span><br><span class="line">ax = f.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>) 				<span class="comment"># 创建绘图区域 一行两列第一个</span></span><br><span class="line">ax.plot(x, y)								<span class="comment"># 绘图</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>subplot</code>：隐式创建画布对象，可以直接创建绘图区域</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(x, y)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>subplots </code>：可以同时创建多个子绘图区域 </p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该方法会返回一个元组，元组具有两个元素(figure, 所有的子绘图区域构成的整体【类型不定】)</span></span><br><span class="line"><span class="comment"># 参数 sharex/sharey，共享所有绘图区域的坐标轴，方便对比(默认是自己按照自己的扩展)</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)	<span class="comment"># 行、列、是否共享坐标轴</span></span><br><span class="line">ax[<span class="number">0</span>] = plot(x1, y1)</span><br><span class="line">ax[<span class="number">2</span>] = plot(x2, y2)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-4-开始绘图"><a href="#3-4-开始绘图" class="headerlink" title="3.4 开始绘图"></a>3.4 开始绘图</h3><ul>
<li><p>折线图 <code>plt.plot()</code></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 折线图，适合展现 数据的趋势和增加变化</span></span><br><span class="line"><span class="comment"># 可以传入 x 和 y 的数值，也可以只传入 y 的值，x 自动生成</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line"><span class="comment"># c：设置线的颜色</span></span><br><span class="line"><span class="comment"># ls：设置线的形状</span></span><br><span class="line"><span class="comment"># lw：线宽</span></span><br><span class="line"><span class="comment"># marker：点标记</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以一次性画多条线，分别指定颜色，标记与线条类型。</span></span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">2</span>, -<span class="number">2</span>, <span class="number">4</span>], <span class="string">&quot;g*--&quot;</span>, [<span class="number">15</span>, <span class="number">17</span>], [-<span class="number">8</span>, <span class="number">6</span>], <span class="string">&quot;r&gt;-&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>柱状图、条形图 <code>plt.bar() / plt.barh()</code></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 柱形图，条形图，适合呈现数据的大小对比（传入标签值和每个标签值对应的数值）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> alpha---透明度，1代表不透明，0代表全透明。</span></span><br><span class="line"><span class="string"> width---柱子的宽度</span></span><br><span class="line"><span class="string"> color---柱状图填充的颜色，可采取的颜色同上</span></span><br><span class="line"><span class="string"> edgecolor---图形边缘的颜色，可采取的颜色同上</span></span><br><span class="line"><span class="string"> label---图像的标签</span></span><br><span class="line"><span class="string"> linewidth---边缘的宽度</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">plt.bar([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>], [<span class="number">50</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">20</span>])</span><br><span class="line"><span class="comment"># 条形图</span></span><br><span class="line">plt.barh([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>], [<span class="number">50</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">20</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>饼图 <code>plt.pie()</code></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 适合呈现数据的大小对比</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> lablels---每一块的标签</span></span><br><span class="line"><span class="string"> explode---每一块离中心的距离</span></span><br><span class="line"><span class="string"> startangle---起始绘制角度,默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起</span></span><br><span class="line"><span class="string"> shadow---是否有阴影</span></span><br><span class="line"><span class="string"> labeldistance---label绘制位置,相对于半径的比例, 如&lt;1则绘制在饼图内侧</span></span><br><span class="line"><span class="string"> autopct---显示精度</span></span><br><span class="line"><span class="string"> pctdistance---类似于labeldistance,指定autopct的位置刻度</span></span><br><span class="line"><span class="string"> radius---控制饼图的半径</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">plt.pie([<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>], </span><br><span class="line">        labels=[<span class="string">&quot;A部门&quot;</span>, <span class="string">&quot;B部门&quot;</span>, <span class="string">&quot;C部门&quot;</span>, <span class="string">&quot;D部门&quot;</span>],</span><br><span class="line">        shadow=<span class="literal">True</span>,autopct=<span class="string">&quot;%.2f%%&quot;</span>, </span><br><span class="line">        explode=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>散点图 <code>plt.scatter()</code></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 散点图（气泡图）使用与显示数据的分布状态，可以用来比较（对比）数据维度之间的关系。</span></span><br><span class="line">plt.scatter(x, y, marker=<span class="string">&quot;o&quot;</span>, s=<span class="number">10</span>, color=<span class="string">&quot;green&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点的颜色与大小可以统一设置，也可以分别设置每个点的大小与颜色。</span></span><br><span class="line">s = np.random.randint(<span class="number">10</span>, <span class="number">100</span>, size=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># colors = [&quot;r&quot;, &quot;g&quot;, &quot;b&quot;, &quot;y&quot;]</span></span><br><span class="line">colors = np.random.choice(colors, size=<span class="number">100</span>)</span><br><span class="line">plt.scatter(x, y, s=s, color=colors)</span><br></pre></td></tr></table></figure>
</li>
<li><p>直方图 <code>plt.hist()</code></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> range---默认None，选择直方图显示的范围</span></span><br><span class="line"><span class="string"> bins---指定我们显示的直方图的边界</span></span><br><span class="line"><span class="string"> alpha---透明度</span></span><br><span class="line"><span class="string"> facecolor---直方图颜色</span></span><br><span class="line"><span class="string"> histtype---直方图类型，可选‘bar’, ‘barstacked’, ‘step’, ‘stepfilled’</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 默认将区间等分为十份。</span></span><br><span class="line">plt.hist(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以自行指定桶的数量。</span></span><br><span class="line">plt.hist(x, bins=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要统计的区间是不等分的，可以给bins参数传递一个数组类型。</span></span><br><span class="line"><span class="comment"># 数组中的元素指定区间的界线。</span></span><br><span class="line">plt.hist(x, bins=[<span class="number">1</span>, <span class="number">60</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>箱线图 <code>plt.boxplot()</code></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">一般用于在数据清洗过程中，进行查找异常值的时候</span></span><br><span class="line"><span class="string">能够显示离群点，离群点可能是异常值，但是不一定是异常值</span></span><br><span class="line"><span class="string">传入一系列的值，可以显示 远远高于（低于）其他值的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">x 指定要绘制箱线图的数据；</span></span><br><span class="line"><span class="string">vert 是否需要将箱线图垂直摆放</span></span><br><span class="line"><span class="string">patch_artist 是否填充箱体的颜色；</span></span><br><span class="line"><span class="string">boxprops 设置箱体的属性，如边框色，填充色等；boxprops：color箱体边框色，facecolor箱体填充色；</span></span><br><span class="line"><span class="string">showmeans 是否显示均值</span></span><br><span class="line"><span class="string">meanline 是否用线的形式表示均值</span></span><br><span class="line"><span class="string">labels 为箱线图添加标签</span></span><br><span class="line"><span class="string">widths 指定箱线图的宽度</span></span><br><span class="line"><span class="string">positions 指定箱线图的位置</span></span><br><span class="line"><span class="string">flierprops 设置异常值的属性</span></span><br><span class="line"><span class="string">notch 是否是凹口的形式展现箱线图</span></span><br><span class="line"><span class="string">showcaps 是否显示箱线图顶端和末端的两条线</span></span><br><span class="line"><span class="string">showbox 是否显示箱线图的箱体</span></span><br><span class="line"><span class="string">sym 指定异常点的形状</span></span><br><span class="line"><span class="string">showfliers 是否显示异常值</span></span><br><span class="line"><span class="string">whis 指定上下须与上下四分位的距离</span></span><br><span class="line"><span class="string">medianprops 设置中位数的属性</span></span><br><span class="line"><span class="string">meanprops 设置均值的属性</span></span><br><span class="line"><span class="string">capprops 设置箱线图顶端和末端线条的属性</span></span><br><span class="line"><span class="string">whiskerprops 设置须的属性</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">plt.boxplot([<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">100</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>灰度图 <code>plt.imshow()</code></p>
   <img src="【机器学习】Python数据分析常用库/image-20210210214902804.png" alt="image-20210210214902804" style="zoom:80%;" />

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)	<span class="comment"># 图像为灰色</span></span><br><span class="line">plt.colorbar()					<span class="comment"># 绘制颜色条</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-图的背景线"><a href="#3-5-图的背景线" class="headerlink" title="3.5 图的背景线"></a>3.5 图的背景线</h3><ul>
<li><code>plt.grid()</code> 设置横&#x2F;竖格线<ul>
<li><code>axis</code>选择方向 x, y, both 格线与刻度间隔设置相关</li>
<li><code>color</code> 同plot设置</li>
<li><code>linestyle</code> 同plot设置</li>
<li><code>linewidth</code>同plot设置</li>
</ul>
</li>
<li><code>plt.axhline()</code> <code>plt.axvline()</code> 在某个坐标轴位置绘制线条 或者<code>ax.axhline()</code><ul>
<li><code>y</code> 设置线的位置</li>
<li><code>xmin</code> 设置线的起始点 0-1 0是起点 ，1是终点</li>
<li><code>xmax</code> 设置线的终点 0-1</li>
<li><code>color</code> 颜色</li>
<li><code>alpha</code> 透明度</li>
<li><code>linewidth</code> 线的宽度</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/people/cccc-59-66">程序员阿狗</a>：<a href="https://zhuanlan.zhihu.com/p/332900875#:~:text=%E8%BF%99%E7%AF%87pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%E5%B8%AE%E5%A4%A7%E5%AE%B6%E5%9B%9E%E9%A1%BE%E4%B8%8Bpandas%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%E6%88%91%E4%BB%AC%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E6%97%B6%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82.%20%E6%96%87%E6%9C%AB%E8%BF%98%E6%9C%89pandas%E7%9A%84cheat%20sheet%EF%BC%8C%E5%B8%AE%E5%8A%A9%E4%BD%A0%E8%AE%B0%E4%BD%8F%E5%B8%B8%E8%A7%81%E7%9A%84pandas%E6%93%8D%E4%BD%9C%E3%80%82.%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB%EF%BC%9A.%20%E4%BB%8E%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE.,%E4%BB%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AF%BC%E5%87%BADataFrames.%20%E6%9F%A5%E7%9C%8BDataFrame%E4%BF%A1%E6%81%AF.%20%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AD%90%E9%9B%86.%20%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E5%91%BD%E4%BB%A4.%20%E5%88%86%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE.">十分钟学习pandas！ pandas常用操作总结！</a></p>
<p><a href="https://blog.csdn.net/qq_24499745">勿语~</a>：<a href="https://blog.csdn.net/qq_24499745/article/details/88629687">matplotlib 常用操作（精简）</a></p>
<p><a href="https://blog.csdn.net/StardustYu">Bai丁</a>：<a href="https://blog.csdn.net/StardustYu/article/details/104734294">AI小知识系列(四) Matplotlib常用操作</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】基于深度学习的异常检测概览</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="1-深度异常检测分类"><a href="#1-深度异常检测分类" class="headerlink" title="1 深度异常检测分类"></a>1 深度异常检测分类</h1><img src="【机器学习】基于深度学习的异常检测/image-20210321091534237.png" alt="image-20210321091534237" style="zoom:80%;" />

<h3 id="1-1-Deep-learning-for-feature-extraction"><a href="#1-1-Deep-learning-for-feature-extraction" class="headerlink" title="1.1 Deep learning for feature extraction"></a>1.1 Deep learning for feature extraction</h3><table>
<thead>
<tr>
<th></th>
<th>Assumptions</th>
<th>Advantages</th>
<th>Disadvantages</th>
</tr>
</thead>
<tbody><tr>
<td>Deep learning for feature extraction</td>
<td>深度学习模型提取的特征保留了有助于区分异常实例与正常实例的具有辨识性的信息</td>
<td>1. 可用大量最新和现成的深度学习模型 2. 可以提供强大的降维功能 3. 易于实现</td>
<td>1. 特征提取和异常评分脱节 2. 预训练的深度模型仅限于特定类型的数据</td>
</tr>
</tbody></table>
<h3 id="1-2-Learning-feature-representations-of-normality"><a href="#1-2-Learning-feature-representations-of-normality" class="headerlink" title="1.2 Learning feature representations of normality"></a>1.2 Learning feature representations of normality</h3><table>
<thead>
<tr>
<th></th>
<th>Assumptions</th>
<th>Advantages</th>
<th>Disadvantages</th>
</tr>
</thead>
<tbody><tr>
<td>AE（AutoEncoders）</td>
<td>正常实例比异常实例更易在被压缩的空间中重建</td>
<td>1. 简单易懂，适用于不同的数据类型 2. 可以利用多种不同类型的强大 AE 变体进行异常检测</td>
<td>1. 训练数据中的不规则性（infrequent regularities）和异常值本身的存在可能会影响所学习到的特征表示      2. 数据重建的目标函数被设计用来进行数据降维或数据压缩，而不是进行异常检测。 As a result, the resulting representations are a generic summarization of underlying regularities, which are not optimized for detecting irregularities.</td>
</tr>
<tr>
<td>GAN</td>
<td>正常实例比潜在的异常实例更好生成</td>
<td>1. GAN已经证明可以生成逼真的实例（尤其是图像数据），可以检测出在潜在空间中重建的很差的异常实例 2. 大量现有的基于GAN的模型和理论可以用于异常检测</td>
<td>1. GAN的训练会遇到诸多问题，例如无法收敛和模式崩溃（mode collapse），这会导致在训练基于GAN的异常检测模型时会遇到很大的困难 2. 生成网络可能会被误导并生成正常实例之外的数据实例，尤其是当给定数据集的真实分布较为复杂或训练数据包含异常时      3.  基于GAN的异常评分可能不是最佳的，因为建立在生成器网络之上，不是为了异常检测而是为数据生成设计的</td>
</tr>
<tr>
<td>Predictability Modeling</td>
<td>正常实例通常比异常实例更好预测</td>
<td>1. 大量序列学习技术（sequence learning techniques）可以被适应并结合到该方法中                        2. 可以学习多种不同的时间和空间依赖（temporal and spatial dependencies）</td>
<td>1. 该方法仅限于序列数据（sequence data）的异常检测 2. 序列预测会花费较多的时间 3. 异常检测的结果并不是最优的，因为他的根本目标是进行序列预测而不是异常检测</td>
</tr>
<tr>
<td>Self-supervise Classification</td>
<td>与异常实例相比，正常实例与自监督分类器的一致性更高</td>
<td>1. 在无监督和半监督学习中的表现都很好                              2. Anomaly scoring is grounded by some intrinsic properties of gradient magnitude and its updating.</td>
<td>1. 特征转换操作通常依赖于数据，变换操作仅适用于图像数据 2. 尽管以端到端的方式训练分类模型，但是基于一致性的异常分数是是来源于分类分数而不是优化中的集成模块，因此结果不是最优的</td>
</tr>
<tr>
<td>Distance-based Measure</td>
<td>通常异常实例分布在原离其邻居的地方</td>
<td>1. 基于距离的异常检测简单明了，并且在文献中有丰富的理论支持 2. 在低维空间中工作，可以有效地处理无法被传统的基于距离的异常检测算法处理的高维数据 3. 他们能够学习专门为自己量身定做的特征表示</td>
<td>1. 涉及到大量的计算 2. 可以受到基于距离的异常检测算法固有弱点的限制</td>
</tr>
<tr>
<td>One-class Classification-based Measure（OC）</td>
<td>所有的正常实例都来自于单个（抽象）实例，可以通过一个紧凑（compact）模型概括，异常不属于该模型</td>
<td>1. 在文献中对 OC -based 方法进行了充分的研究并且为 deep OC-based 方法提供了坚实的根基 2. The representation learning 和 OC 分类模型可以被统一起来，去学习量身定做和更加优化的特征表示      3. 免于用户自己手动选择合适的内核功能（kernel functions）</td>
<td>1. 在正常实例中具有复杂分布的数据集可能使模型失效                                                 2. The detection performance is dependent on the one-class classification-based anomaly measures</td>
</tr>
<tr>
<td>Clustering-based Measure</td>
<td>正常实例比异常实例对集群具有更高的依从性（adherence）</td>
<td>1. 有许深度聚类方法和理论可以用来支持异常检测 2. 与传统的基于聚类的方法相比，基于深度聚类的方法会学习专门优化特征，这些形式比原始数据更易发现异常，特别是在处理复杂数据时</td>
<td>1. 异常检测的结果严重依赖于聚类的结果 2. 聚类过程中可能会因为训练数据出现污染而产生偏差</td>
</tr>
</tbody></table>
<h3 id="1-3-End-to-end-Anomaly-Score-Learning"><a href="#1-3-End-to-end-Anomaly-Score-Learning" class="headerlink" title="1.3 End-to-end Anomaly Score Learning"></a>1.3 End-to-end Anomaly Score Learning</h3><table>
<thead>
<tr>
<th></th>
<th>Assumptions</th>
<th>Advantages</th>
<th>Disadvantages</th>
</tr>
</thead>
<tbody><tr>
<td>Ranking Models</td>
<td>There exists an observable ordinal variable that captures some data abnormality.</td>
<td>1. 可以使用调整后的损失函数直接优化异常分数     2. They are generally free from the definitions of anomalies by imposing a weak assumption of the ordinal order between anomaly and normal instances 3. 这种方法可以建立在诸如学习排名等领域的成熟排名技术的理论基础之上</td>
<td>1. 需要某种形式的标记过的异常 2. 由于模型专门用于检测少数标记过的异常，因此可能无法推广到一些与标记异常有不同特征的未被发现的异常上</td>
</tr>
<tr>
<td>Prior-driven Model</td>
<td>The imposed prior captures the underlying (ab)normality of the dataset</td>
<td>1. 可以在给定先验（given prior）条件下直接优化异常分数 2. 提供了一个灵活的框架，可以将不同的优先级分布合并到异常分数学习中 3. 先验（the prior）也可以得到比其他方法更具解释性的异常分数</td>
<td>1. 很难设计一个普遍适用于不同异常检测应用场景的先验 2. 不能很好地适应基础分布则模型的工作效率较低</td>
</tr>
<tr>
<td>Softmax Likelihood Models</td>
<td>得到正常实例是高概率时间而得到异常实例是低概率事件</td>
<td>可以将不同类型的交互方式合并到异常分数学习过程中</td>
<td>1. 交互的计算可能非常昂贵 2. 异常分数学习在很大程度上取决于反面样本（negative samples）生成的质量</td>
</tr>
<tr>
<td>End-to-end            One-class Classification</td>
<td>1. 近似异常的实例可以被有效的合成         2. 所有的正常实例都可以被一个单分类模型概况</td>
<td>1. 异常分类模型被以端到端的方式对抗式的优化    2. 有丰富的理论支持</td>
<td>1. 难以保证所生成的参考实例与未知异常十分相似  2. GAN 的不稳定性会导致异常分类性能不稳定 3. 仅限于半监督异常检测场景</td>
</tr>
</tbody></table>
<blockquote>
<p>参考自 <a href="https://arxiv.org/pdf/2007.02500.pdf">Deep Learning for Anomaly Detection: A Review</a></p>
</blockquote>
<h1 id="2-深度异常检测模型基础"><a href="#2-深度异常检测模型基础" class="headerlink" title="2 深度异常检测模型基础"></a>2 深度异常检测模型基础</h1><table>
<thead>
<tr>
<th>模型</th>
<th>描述</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>AE（AutoEncoder）</td>
<td>AE 重构输入数据来表示多个隐藏层中的数据，从而有效学习身份函数（identity function）。当在正常数据中训练 AE 时，AE 无法重构异常数据样本，因此会产生较大的重构误差（reconstruction error），产生高残留误差的样本数据被认为是异常值。</td>
<td>Semi-supervised，Un-supervised</td>
</tr>
<tr>
<td>RBM（Restricted Boltzmann Machine）</td>
<td>一种可通过输入数据集学习概率分布的随机生成神经网络</td>
<td>Semi-supervised</td>
</tr>
<tr>
<td>DBN（Deep Belief Networks）</td>
<td>使用 DBN 进行异常检测的假设是，RBM 被用作带有反向传播算法的定向编码-解码网络。</td>
<td>Semi-supervised</td>
</tr>
<tr>
<td>AAE（Adversarial AutoEncoder）</td>
<td>我们都知道AE需要把一个真实分布映射成隐层的 z，AAE 在此加上对抗思想来优化这个 z</td>
<td>Semi-supervised ，Un-supervised</td>
</tr>
<tr>
<td>CNN-Relief，CNN-SVM</td>
<td></td>
<td>Semi-supervised</td>
</tr>
<tr>
<td>CNN</td>
<td>CNN 能够从具有复杂结构的高维数据中提取复杂的隐藏特征，使其能够在序列和图像检测中用作特征提取器。</td>
<td>Semi-supervised</td>
</tr>
<tr>
<td>RNN</td>
<td>RNN可以获得时序数据的特征，但是随着时间步长的增加，获取时序数据的特征也会越来越困难。</td>
<td>Semi-supervised ，Un-supervised</td>
</tr>
<tr>
<td>GAN</td>
<td>学习精确的数据分布以便生成具有变化的新数据点。</td>
<td>Semi-supervised ，Un-supervised</td>
</tr>
<tr>
<td>CorGAN（Corrupted GAN）</td>
<td></td>
<td>Semi-supervised</td>
</tr>
<tr>
<td>AE-OCSVM，AE-SVM</td>
<td></td>
<td>Hybrid</td>
</tr>
<tr>
<td>DBN-SVDD，AE-SVDD（Support Vector Data Description）</td>
<td></td>
<td>Hybrid</td>
</tr>
<tr>
<td>DNN-SVM</td>
<td></td>
<td>Hybrid</td>
</tr>
<tr>
<td>DAE-KNN，DBN-Random Forest，CNN-Relief，CNN-SVM</td>
<td></td>
<td>Hybrid</td>
</tr>
<tr>
<td>AE-CNN，AE-DBN</td>
<td></td>
<td>Hybrid</td>
</tr>
<tr>
<td>AE-KNN</td>
<td></td>
<td>Hybrid</td>
</tr>
<tr>
<td>CNN-LSTM-SVM</td>
<td></td>
<td>Hybrid</td>
</tr>
<tr>
<td>RNN-CSI</td>
<td></td>
<td>Hybrid</td>
</tr>
<tr>
<td>CAE-OCSVM</td>
<td></td>
<td>Hybrid</td>
</tr>
<tr>
<td>LSTM（Long Short  Term Memory Networks）</td>
<td>是 RNN 的一种特殊类型，可以存储先前时间步长信息</td>
<td>Un-supervised</td>
</tr>
<tr>
<td>STN（Spatial Transformer Networks）</td>
<td>STN 包含结合了 CNN 和 LSTM 的深层神经网络体系结构用以提取时空特征。时间特征（通过LSTM在近时间点之间的建模相关性）和空间特征（通过 CNN 的局部空间相关性建模）可以有效的检测异常值。</td>
<td>Un-supervised</td>
</tr>
</tbody></table>
<blockquote>
<p>参考自 <a href="https://arxiv.org/pdf/1901.03407.pdf">Deep learning for anomaly detection: A survey</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>OD</tag>
        <tag>机器学习</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】异常检测文献阅读：基于K-Means的IForest</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8EK-Means%E7%9A%84IForest/</url>
    <content><![CDATA[<blockquote>
<p>本文梳理论文 《K-Means-based isolation forest》</p>
<p>希望通过梳理这篇论文理清思路，以便获得启发</p>
<p>论文地址：<a href="https://www.sciencedirect.com/science/article/pii/S0950705120301064#tbl1">https://www.sciencedirect.com/science/article/pii/S0950705120301064#tbl1</a></p>
</blockquote>
<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h1><p>异常处理是数据科学领域中的重要问题，然而现有的异常检测模型还都有待提高：</p>
<ul>
<li>不够高效</li>
<li>只能应用于单一领域</li>
<li>以非直觉（nonintuitive）的方式运行</li>
</ul>
<p>在这篇论文中，我们对经典的 <strong>Isolation Forest</strong> 进行了分析，并且在它的基础上提出了<strong>基于 K-Means 的 IFoest</strong></p>
<p>该方法的优点：</p>
<ul>
<li>高效检测各种类型的异常值</li>
<li>使用户<strong>直观</strong>确定所分析数据集中<strong>单个样本的异常分数</strong></li>
<li>能够在决策树构件的步骤中拟合数据</li>
</ul>
<h1 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2 预备知识"></a>2 预备知识</h1><h2 id="2-1-K-Means"><a href="#2-1-K-Means" class="headerlink" title="2.1 K-Means"></a>2.1 K-Means</h2><h3 id="2-1-1-算法描述："><a href="#2-1-1-算法描述：" class="headerlink" title="2.1.1 算法描述："></a>2.1.1 算法描述：</h3><p>k-means 算法是无监督学习领域最为经典的算法之一。</p>
<p>在数据中<strong>选取多个点作为初始化的样本中心</strong>，所有样本<strong>选择距离自己最近的样本中心</strong>进行聚类，并在新生成的类中依据类中样本间的距离<strong>重新选择</strong>样本的样本中心，选择好新的样本中心后再根据所有样本到新样本中心的距离<strong>生成新的类</strong>，依此循环往复，直到达到某一限定条件（迭代次数、最小误差变化等）。</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/v2-371e88c867d1015d65cbab831a7542c5_b.webp" alt="img" style="zoom: 50%;" />

<p> K-means 算法步骤为：</p>
<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8EK-Means%E7%9A%84IForest/image-20210409145534589.png" alt="image-20210409145534589"></p>
<h3 id="2-1-2-算法优化"><a href="#2-1-2-算法优化" class="headerlink" title="2.1.2 算法优化"></a>2.1.2 算法优化</h3><p>由于生成类的数量 k 需要我们自己选定，所以需要一些选定 k 值的方法（手肘法、Gap statistic 方法）</p>
<p>本论文中使用<strong>手肘法</strong>选择 k 值：</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409150602616.png" alt="image-20210409150602616" style="zoom:80%;" />

<p>本图中 Y 轴是样本距离之和，X 轴是 k 值，可以看出 k &#x3D; 3 是拐点，故选择 3 作为 k 值</p>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/78798251">https://zhuanlan.zhihu.com/p/78798251</a></p>
</blockquote>
<h2 id="2-2-Isolation-Forest"><a href="#2-2-Isolation-Forest" class="headerlink" title="2.2 Isolation Forest"></a>2.2 Isolation Forest</h2><p>专家门在数据挖掘时通常会列出一些在<strong>异常检测领域比较高效的算法</strong>，<strong>Isolation Forest</strong> 几乎每次都会位列其中。</p>
<p>隔离森林通过<strong>随机选取属性与属性对应的值</strong>对所有数据进行切分，切分后得到两部分数据分别放入左右子树中，对左右子树继续进行上述操作，直到数据不能再分或树高达到上限高度，一棵 <strong>Isolation Tree</strong> 就构建成功了。</p>
<p>直观上，正常点通过多次切分也还是在同一层中，而异常点在切分的过程中更易被切分出去，所以异常点所在树的深度并不深，以此就能分离出异常点来。</p>
<p>我们可以<strong>依据某个点所在树的深度</strong>计算其异常分数值，树越浅，异常分数越高。</p>
<p>通过<strong>随机采样</strong>选取多组数据构建多棵 ITree，就能构建出一个完整的 <strong>Isolation Forest</strong>。</p>
<p>对某个点在各个树中的异常分数求平均，就能得到该点总的异常分数。</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409152651542.png" alt="image-20210409152651542" style="zoom:80%;" />

<h1 id="3-基于-K-Means-的-Isolation-Forest"><a href="#3-基于-K-Means-的-Isolation-Forest" class="headerlink" title="3 基于 K-Means 的 Isolation Forest"></a>3 基于 K-Means 的 Isolation Forest</h1><h2 id="3-1-思想"><a href="#3-1-思想" class="headerlink" title="3.1 思想"></a>3.1 思想</h2><p>根据 IForest 中给出的图示我们可以看出，在对平面中的 x、y 交替划分了 10 次之后，我们分离出了红点。</p>
<p>可以注意到，无论这个点在是否接近分割区域的边界，最终的分割次数始终为 10（10 这个值最后被我们传入异常分数计算公式来计算异常分数）。这个方法是严格二分的，与分割点有关，因此异常分数与分割次数严管相关。</p>
<p>另外也可以注意到，该方法对直观上观察到的簇（clusters）不敏感。</p>
<p>因此我们可以对方法进行改进：<strong>对每次取得的属性对应的值进行 K-Means 聚类</strong>，得到的多个簇作为子节点重复之前的操作。</p>
<p>一棵树的叶子节点数取决于训练阶段数据集子分区中存在的最佳聚类数（也就是上文中通过手肘法决定的 k 值）。</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409160335732.png" alt="image-20210409160335732" style="zoom:80%;" />

<h2 id="3-2-具体算法"><a href="#3-2-具体算法" class="headerlink" title="3.2 具体算法"></a>3.2 具体算法</h2><ol>
<li>训练的初始阶段与经典的 IForest 相似，随机选取一个属性 <code>q</code>；</li>
<li>使用 K-means 将属性 <code>q</code> 中所有值划分为 k 个簇（k 值由手肘法选定）；</li>
<li>划分得到的 k 个簇作为根节点的叶子节点</li>
<li>对于每一个叶子节点，可以重复上述操作</li>
</ol>
<h2 id="3-3-异常分数的计算"><a href="#3-3-异常分数的计算" class="headerlink" title="3.3 异常分数的计算"></a>3.3 异常分数的计算</h2><p><strong>每次分割后得到的异常分数：</strong></p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409160426672.png" alt="image-20210409160426672" style="zoom:80%;" />

<ul>
<li>c_q：簇的中心点</li>
<li>c_l ：簇的边界</li>
<li>x    ：需要计算异常分数的点</li>
<li>d(x, y)：x 到 y 的距离</li>
</ul>
<p><strong>最终得分是每个数据在每次分割后得异常分数之和：</strong></p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409161001668.png" alt="image-20210409161001668" style="zoom:80%;" />

<h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h1><p>选用 NYC taxi trip data 数据集进行测试</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409164837084.png" alt="image-20210409164837084" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409164903853.png" alt="image-20210409164903853" style="zoom:80%;" />

<p>各数据集中 IForest 与 K-Means-based IF 执行时间效率对比：</p>
<img src="【机器学习】异常检测文献阅读：基于K-Means的IForest/image-20210409165015495.png" alt="image-20210409165015495" style="zoom:80%;" />]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>OD</tag>
        <tag>机器学习</tag>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】异常检测文献阅读：IsolationForest拓展</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AIsolationForest%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<blockquote>
<p>本文梳理基于 Isolation Forest（IF）的若干拓展算法</p>
<p>关于 IF 的相关知识我在之前的文章<a href="http://www.wxshhh.com/2021/01/20/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91NLP%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95%E7%AF%87/">【机器学习】异常检测文献阅读：关键算法篇 </a>中进行了梳理</p>
<ul>
<li><p>Extended Isolation Forest</p>
<p>  论文地址：<a href="https://ieeexplore.ieee.org/document/8888179">https://ieeexplore.ieee.org/document/8888179</a></p>
<p>  GitHub：<a href="https://github.com/sahandha/eif">https://github.com/sahandha/eif</a></p>
</li>
<li><p>Rotated Isolation Forest</p>
<p>  论文地址：<a href="https://ieeexplore.ieee.org/document/9177718">https://ieeexplore.ieee.org/document/9177718</a></p>
</li>
<li><p>Fuzzy Set-Based Isolation Forest</p>
<p>  论文地址：<a href="https://ieeexplore.ieee.org/document/9177718">https://ieeexplore.ieee.org/document/9177718</a></p>
</li>
<li><p>Efficient Anomaly Detection by Isolation Using Nearest Neighbour Ensemble</p>
<p>  论文地址：<a href="https://ieeexplore.ieee.org/document/7022664">https://ieeexplore.ieee.org/document/7022664</a></p>
</li>
</ul>
</blockquote>
<h1 id="1-Extended-Isolation-Forest（EIF）"><a href="#1-Extended-Isolation-Forest（EIF）" class="headerlink" title="1 Extended Isolation Forest（EIF）"></a>1 Extended Isolation Forest（EIF）</h1><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>原有的算法 IF 利用了异常数据总是<strong>少而与众不同的特点</strong>，通过一次次的<strong>随机分割数据</strong>建立隔离森林来分离出异常值，足够<strong>直观</strong>且<strong>高效</strong>。</p>
<p>然而分割数据的方式是每次分割是个数据的某一单一维度上进行的，所以每次运行的结果总会出现一定的偏差。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210248189.png" alt="image-20210419210248189" style="zoom:80%;" />

<p>通过 <strong>正态数据分布的异常分数图</strong> 可以看出，异常分数总是随着到某一数据中心的距离的增加而增加，IF单纯的从某一维度对数据切割，总会存在偏差。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210219580.png" alt="image-20210419210219580" style="zoom:80%;" />

<p>同样对于两簇正态分布的数据，使用 IF 不断选取单一维度进行切割，不难发现在数据右上角与左下角也会产生异常分数较低的簇（gohst clusters）（实际上这些位置的点应该为异常点）。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210425081.png" alt="image-20210419210425081" style="zoom:80%;" />

<p>对于正弦波形也是同理。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210159784.png" alt="image-20210419210159784" style="zoom:80%;" />

<p>试想我们如果可以<strong>斜着切割数据</strong>，那么就可以有效弥补这一不足。</p>
<p>在 EIF 中，对 IF 中的数据分割方式进行了改进，来弥补原有算法的缺陷。</p>
<p>改进的方法中，EIF 使用了一个拥有随机斜度（slopes）的超平面来对数据进行切割，该超平面不与坐标轴平行。</p>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419210548911.png" alt="image-20210419210548911" style="zoom:80%;" />

<h3 id="1-2-算法描述"><a href="#1-2-算法描述" class="headerlink" title="1.2 算法描述"></a>1.2 算法描述</h3><p>Isolation Forest 分支切口（branchs cuts）的信息：</p>
<ol>
<li>一个随机选取的特征或坐标</li>
<li>一个来自于该特征的随机值</li>
</ol>
<p>Extended Isolation Forest 分支切口信息：</p>
<ol>
<li>一个分支切口的随机斜度（slope）</li>
<li>一个在数据集可用值范围内随机选择的截距（intercept）</li>
</ol>
<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AIsolationForest%E6%8B%93%E5%B1%95/image-20210429204912315.png" alt="image-20210429204912315"></p>
<blockquote>
<p>二维空间如此，高维空间（N 维）也是同理，只不过分支切口变味了一个 N -1 维的超平面</p>
<p>这些超平面同样被一个随机正交向量和一个随机截距点所确定，如二维情况类似</p>
</blockquote>
<h3 id="1-3-算法实现"><a href="#1-3-算法实现" class="headerlink" title="1.3 算法实现"></a>1.3 算法实现</h3><img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205349794.png" alt="image-20210420205349794" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205412696.png" alt="image-20210420205412696" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205437388.png" alt="image-20210420205437388" style="zoom:80%;" />

<h3 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h3><img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419214517225.png" alt="image-20210419214517225" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210419214532878.png" alt="image-20210419214532878" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205557800.png" alt="image-20210420205557800" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205633002.png" alt="image-20210420205633002" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210420205650795.png" alt="image-20210420205650795" style="zoom:80%;" />



<h1 id="2-Fuzzy-Set-Based-Isolation-Forest（FSBIS）"><a href="#2-Fuzzy-Set-Based-Isolation-Forest（FSBIS）" class="headerlink" title="2 Fuzzy Set-Based Isolation Forest（FSBIS）"></a>2 Fuzzy Set-Based Isolation Forest（FSBIS）</h1><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><a href="https://ieeexplore.ieee.org/document/9177718">文章</a>在原有算法 IF 的基础上，提出通过对记录的属性的隶属度（membership）进行划分从而构建森林。</p>
<p>其中，隶属度是根据到样本中心（middle of the cluster）的距离（也就是属性的平均值）来确定的。</p>
<p>优点：</p>
<ul>
<li>直观</li>
<li>返回异常值的隶属度几乎为零</li>
<li>以返回异常程度的方式构造的函数不需要使用复杂的标准化公式</li>
<li>运行时间并不比经典 IF 多，在某些情况下甚至短于经典 IF</li>
</ul>
<h3 id="2-2-算法描述"><a href="#2-2-算法描述" class="headerlink" title="2.2 算法描述"></a>2.2 算法描述</h3><p>对于经典 IF 相对复杂的建树过程，FSBIS 提出了如下改进</p>
<ol>
<li><p>在经典 IF 的第一阶段中，我们会从过滤后的簇（cluster）中所选择的属性的所有值中确定<strong>平均值</strong> <strong>m</strong>，这个值会被存在相应的节点上</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TODO 平均值m的具体确定方法？</span><br></pre></td></tr></table></figure>

<p> we always determine the average value of <em>m</em> from all the values of the chosen attribute located in the filtered cluster.</p>
</li>
<li><p>通过公式计算出已经构建好的簇的隶属度</p>
<p> <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AIsolationForest%E6%8B%93%E5%B1%95/image-20210429204937140.png" alt="image-20210429204937140"></p>
</li>
<li><p>最终，异常分数是每个节点所有隶属度之和</p>
</li>
</ol>
<h3 id="2-3-算法实例"><a href="#2-3-算法实例" class="headerlink" title="2.3 算法实例"></a>2.3 算法实例</h3><img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422202750238.png" alt="image-20210422202750238" style="zoom:80%;" /> 

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">如上图所示，我们要计算异常分数的点是 （x， y） = （<span class="number">0.7</span>， <span class="number">0.6</span>）</span><br><span class="line"></span><br><span class="line">第一次划分：x = <span class="number">0.5</span>，过滤后得到黄色区域</span><br><span class="line"></span><br><span class="line">黄色区域中心点 center <span class="comment">#1 在 x = 0.8 处</span></span><br><span class="line"></span><br><span class="line">故隶属度：p1 = <span class="number">1</span> - (<span class="number">0.8</span> - <span class="number">0.7</span>) / (<span class="number">0.8</span> - <span class="number">0.5</span>) = <span class="number">2</span>/<span class="number">3</span></span><br><span class="line"></span><br><span class="line">第二次划分：y = <span class="number">0.7</span>，过滤后得到红色区域</span><br><span class="line"></span><br><span class="line">红色区域中心点 center <span class="comment">#2 在 y = 0.3处</span></span><br><span class="line"></span><br><span class="line">故隶属度：p2 = <span class="number">1</span> - (<span class="number">0.6</span> - <span class="number">0.3</span>) / (<span class="number">0.7</span> - <span class="number">0.3</span>) = <span class="number">1</span>/<span class="number">4</span></span><br><span class="line"></span><br><span class="line">第三次划分：x = <span class="number">0.75</span>，过滤后得到绿色区域</span><br><span class="line"></span><br><span class="line">划分至绿色区域后，只剩下目标点，其隶属度不需要计算，因为明显是 <span class="number">1</span></span><br><span class="line"></span><br><span class="line">最后该点的异常分数 <span class="number">2</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">4</span> = <span class="number">11</span>/<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>构建的二叉树如下所示：</p>
<p>​                                                   <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422204718182.png" alt="image-20210422204718182" style="zoom: 50%;" /> </p>
<h3 id="2-4-算法实现"><a href="#2-4-算法实现" class="headerlink" title="2.4 算法实现"></a>2.4 算法实现</h3><img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422205159551.png" alt="image-20210422205159551" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422205241318.png" alt="image-20210422205241318" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422205159551.png" alt="image-20210422205159551" style="zoom:80%;" />

<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210422205241318.png" alt="image-20210422205241318" style="zoom:80%;" />



<h1 id="3-Efficient-Anomaly-Detection-by-Isolation-Using-Nearest-Neighbour-Ensemble"><a href="#3-Efficient-Anomaly-Detection-by-Isolation-Using-Nearest-Neighbour-Ensemble" class="headerlink" title="3 Efficient Anomaly Detection by Isolation Using Nearest Neighbour Ensemble"></a>3 Efficient Anomaly Detection by Isolation Using Nearest Neighbour Ensemble</h1><p>Advantage:</p>
<ul>
<li>Compared with some nearest neighbour-based method, the proposed method has <strong>linear time complexity</strong> and <strong>constant space complexity</strong>.</li>
<li>Compared with tree-based isolation method iForest, the proposed isolation method overcomes three weaknesses of iForest<ul>
<li>Its inability to <strong>detect local anomalies</strong></li>
<li>anomalies with <strong>a low number of relevant</strong> attributes</li>
<li>anomalies that are surrounded by normal instances</li>
</ul>
</li>
</ul>
<p>Two important challenging:</p>
<ul>
<li>the requirement of low computational cost</li>
<li>the susceptibility to issues in high-dimensional datasets</li>
</ul>
<p>How to operate:</p>
<ul>
<li>it partitions the data space into regions using a subsample and determines an isolation score for each region</li>
<li>each region is defined with a centre represented by an instance from the subsample; and its boundary is defined by the distance to the nearest neighbour of the instance at the centre.</li>
</ul>
<p>The intuition behind iNNE:</p>
<ul>
<li>an anomaly can be expected to be far from its nearest neighbour</li>
</ul>
<p>Some definations:</p>
<ul>
<li><p>Definition 1</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525210727558.png" alt="image-20210525210727558" style="zoom:80%;" />
</li>
<li><p>Definition 2</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525210817030.png" alt="image-20210525210817030" style="zoom:80%;" />
</li>
<li><p>Definition 3</p>
</li>
</ul>
<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525211202981.png" alt="image-20210525211202981" style="zoom:80%;" />



<img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525211517695.png" alt="image-20210525211517695" style="zoom:80%;" />

<ul>
<li><p>Defination 4</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525211555777.png" alt="image-20210525211555777" style="zoom:80%;" />

<p>  Where <em>β</em> is a user defined threshold.</p>
</li>
<li><p>Defination 5</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525211913605.png" alt="image-20210525211913605" style="zoom:80%;" />
</li>
<li><p>Defination 6</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525212137950.png" alt="image-20210525212137950" style="zoom:80%;" />
</li>
<li><p>Defination 7</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525212209132.png" alt="image-20210525212209132" style="zoom:80%;" />
</li>
<li><p>Defination 8</p>
  <img src="【机器学习】异常检测文献阅读：IsolationForest拓展/image-20210525212230930.png" alt="image-20210525212230930" style="zoom:80%;" /></li>
</ul>
<p>$$\begin{pmatrix} 1&#x2F;\sqrt{2} &amp; 1&#x2F;\sqrt{2} \ -1&#x2F;\sqrt{2} &amp; 1&#x2F;\sqrt{2} \end{pmatrix} \begin{pmatrix} 1 &amp; 2 &amp; 3 \ 1 &amp; 2 &amp; 3 \end{pmatrix} &#x3D; \begin{pmatrix} 2&#x2F;\sqrt{2} &amp; 4&#x2F;\sqrt{2} &amp; 6&#x2F;\sqrt{2} \ 0 &amp; 0 &amp; 0 \end{pmatrix}$$</p>
<p>$$\begin{pmatrix} 1&#x2F;\sqrt{2} &amp; 1&#x2F;\sqrt{2} \ -1&#x2F;\sqrt{2} &amp; 1&#x2F;\sqrt{2} \end{pmatrix} \begin{pmatrix} 3 \ 2 \end{pmatrix} &#x3D; \begin{pmatrix} 5&#x2F;\sqrt{2} \ -1&#x2F;\sqrt{2} \end{pmatrix}$$</p>
<p>$$\begin{pmatrix} p_1 \ p_2 \ \vdots \ p_R \end{pmatrix} \begin{pmatrix} a_1 &amp; a_2 &amp; \cdots &amp; a_M \end{pmatrix} &#x3D; \begin{pmatrix} p_1a_1 &amp; p_1a_2 &amp; \cdots &amp; p_1a_M \ p_2a_1 &amp; p_2a_2 &amp; \cdots &amp; p_2a_M \ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ p_Ra_1 &amp; p_Ra_2 &amp; \cdots &amp; p_Ra_M \end{pmatrix}$$</p>
<p>$$\begin{pmatrix} 1 &amp; 1 &amp; 2 &amp; 4 &amp; 2 \ 1 &amp; 3 &amp; 3 &amp; 4 &amp; 4 \end{pmatrix}$$</p>
<p>$$\begin{pmatrix} -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \ -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \end{pmatrix}$$</p>
<p>$$Var(a)&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^m{(a_i-\mu)^2}$$</p>
<p>$$Cov(a,b)&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^m{a_ib_i}$$</p>
<p>$$X&#x3D;\begin{pmatrix} a_1 &amp; a_2 &amp; \cdots &amp; a_m \ b_1 &amp; b_2 &amp; \cdots &amp; b_m \end{pmatrix}$$</p>
<p>$$\frac{1}{m}XX^\mathsf{T}&#x3D;\begin{pmatrix} \frac{1}{m}\sum_{i&#x3D;1}^m{a_i^2} &amp; \frac{1}{m}\sum_{i&#x3D;1}^m{a_ib_i} \ \frac{1}{m}\sum_{i&#x3D;1}^m{a_ib_i} &amp; \frac{1}{m}\sum_{i&#x3D;1}^m{b_i^2} \end{pmatrix}$$</p>
<p>$$\begin{array}{l l l} D &amp; &#x3D; &amp; \frac{1}{m}YY^\mathsf{T} \ &amp; &#x3D; &amp; \frac{1}{m}(PX)(PX)^\mathsf{T} \ &amp; &#x3D; &amp; \frac{1}{m}PXX^\mathsf{T}P^\mathsf{T} \ &amp; &#x3D; &amp; P(\frac{1}{m}XX^\mathsf{T})P^\mathsf{T} \ &amp; &#x3D; &amp; PCP^\mathsf{T} \end{array}$$</p>
<p>$$E&#x3D;\begin{pmatrix} e_1 &amp; e_2 &amp; \cdots &amp; e_n \end{pmatrix}$$</p>
<p>$$E^\mathsf{T}CE&#x3D;\Lambda&#x3D;\begin{pmatrix} \lambda_1 &amp; &amp; &amp; \ &amp; \lambda_2 &amp; &amp; \ &amp; &amp; \ddots &amp; \ &amp; &amp; &amp; \lambda_n \end{pmatrix}$$</p>
<p>$$P&#x3D;E^\mathsf{T}$$</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>OD</tag>
        <tag>机器学习</tag>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】异常检测：PyOD库中的算法</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%EF%BC%9APyOD%E5%BA%93%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-PyOD概览"><a href="#一-PyOD概览" class="headerlink" title="一. PyOD概览"></a>一. PyOD概览</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>PyOD 是一个全面的、可扩展的 Python 工具包，用于检测多变量数据中的异常对象，是当下最流行的Python异常检测工具库。</p>
<p>这一检测过程通常被称为<strong>离群点检测或异常检测</strong>。</p>
<p>PyOD 库包含了超过 30 种异常检测算法，具体常用算法如下：</p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">缩写</th>
<th align="center">全称</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线性模式</td>
<td align="center">PCA</td>
<td align="center">Principal Component Analysis</td>
</tr>
<tr>
<td align="center">线性模型</td>
<td align="center">MCD</td>
<td align="center">Minimum Covariance Determinant</td>
</tr>
<tr>
<td align="center">线性模型</td>
<td align="center">OCSVM</td>
<td align="center">One-Class Support Vector Machines</td>
</tr>
<tr>
<td align="center">基于近邻</td>
<td align="center">LOF</td>
<td align="center">Local Outlier Factor</td>
</tr>
<tr>
<td align="center">基于近邻</td>
<td align="center">kNN</td>
<td align="center">k Nearest Neighbors</td>
</tr>
<tr>
<td align="center">基于近邻</td>
<td align="center">HBOS</td>
<td align="center">Histogram-based Outlier Score</td>
</tr>
<tr>
<td align="center">基于概率</td>
<td align="center">ABOD</td>
<td align="center">Angle-Based Outlier Detection</td>
</tr>
<tr>
<td align="center">异常集成</td>
<td align="center">IForest</td>
<td align="center">Isolation Forest</td>
</tr>
<tr>
<td align="center">异常集成</td>
<td align="center"></td>
<td align="center">Feature Bagging</td>
</tr>
</tbody></table>
<ul>
<li><strong>Github地址:</strong> <a href="https://link.zhihu.com/?target=https://github.com/yzhao062/pyod">pyod</a></li>
<li><strong>文档与API介绍（英文）</strong>: <a href="https://link.zhihu.com/?target=https://pyod.readthedocs.io/en/latest/">Welcome to PyOD documentation!</a></li>
<li><strong>Jupyter Notebook示例（notebooks文件夹）</strong>: <a href="https://link.zhihu.com/?target=https://mybinder.org/v2/gh/yzhao062/pyod/master">Binder (beta)</a></li>
</ul>
<h3 id="2-API与属性"><a href="#2-API与属性" class="headerlink" title="2. API与属性"></a>2. API与属性</h3><p>以下函数均属于包 <code>pyod.models.base.BaseDetector</code></p>
<ul>
<li><p><code>fit(X)</code>： 用数据 X 来“训练&#x2F;拟合”检测器 clf。（ 在非监督学习中，不需要 y 值）</p>
</li>
<li><p><code>decision_function(X)</code>：可以通过该函数来预测未知数据的异常程度，返回值为原始分数，分数越高，异常程度越高。</p>
</li>
<li><p><code>predict(X)</code>： 可以通过该函数来预测未知数据的异常标签，返X回值为二分类标签（0为正常点，1为异常点）</p>
</li>
<li><p><code>predict_proba()</code>：在检测器clf被fit后，预测未知数据的异常概率，返回该点是异常点概率</p>
</li>
<li><p><code>fit_predict(X)</code>： 训练模型并且预测一个特殊的样本是否是异常值</p>
</li>
<li><p><code>fit_predict_score()</code>：训练检测器，预测位置数据的异常标签，并且根据预定义的度量标准评估模型的分数</p>
</li>
<li><p><code>decision_scores_</code>：训练集的异常分数，分数越高表示异常程度越高. </p>
</li>
<li><p><code>labels_</code>：0 表示正常值，1 表示异常值</p>
</li>
</ul>
<h1 id="二、具体算法"><a href="#二、具体算法" class="headerlink" title="二、具体算法"></a>二、具体算法</h1><h3 id="1-PCA"><a href="#1-PCA" class="headerlink" title="1. PCA"></a>1. PCA</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200924092132102.png" alt="image-20200924092132102" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>PCA(Principal Component Analysis)，即<strong>主成分分析方法</strong>，是一种使用最广泛的<strong>数据降维算法</strong>。PCA 的主要思想是<strong>将 n 维特征映射到 k 维上</strong>，这 k 维是全新的正交特征也被称为主成分，是在原有 n 维特征的基础上重新构造出来的 k 维特征。PCA 的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。</p>
<p>其中，第一个新坐标轴选择是<strong>原始数据中方差最大</strong>的方向，第二个新坐标轴选取是<strong>与第一个坐标轴正交的平面中使得方差最大</strong>的，第三个轴是<strong>与第 1, 2 个轴正交的平面中方差最大</strong>的。依次类推，可以得到n个这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面 k 个坐标轴中，后面的坐标轴所含的方差几乎为 0。于是，我们可以忽略余下的坐标轴，只保留前面 k 个含有绝大部分方差的坐标轴。<strong>事实上，这相当于只保留包含绝大部分方差的维度特征，而忽略包含方差几乎为 0 的特征维度，实现对数据特征的降维处理。</strong></p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.pca <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span>  <span class="comment"># 异常值占比</span></span><br><span class="line">    n_train = <span class="number">200</span>  <span class="comment"># 训练集大小</span></span><br><span class="line">    n_test = <span class="number">100</span>  <span class="comment"># 测试集大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生产样本数据</span></span><br><span class="line">    X_train, X_test, y_train, y_test = \</span><br><span class="line">        generate_data(n_train=n_train,</span><br><span class="line">                      n_test=n_test,</span><br><span class="line">                      n_features=<span class="number">20</span>,</span><br><span class="line">                      contamination=contamination,</span><br><span class="line">                      random_state=<span class="number">42</span>,</span><br><span class="line">                      behaviour=<span class="string">&quot;new&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练 PCA 检测器</span></span><br><span class="line">    clf_name = <span class="string">&#x27;PCA&#x27;</span></span><br><span class="line">    clf = PCA(n_components=<span class="number">3</span>)</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得训练集的预测标签和异常分数</span></span><br><span class="line">    y_train_pred = clf.labels_  <span class="comment"># (0: 正常, 1: 异常)</span></span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得测试集的预测结果</span></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评估并且打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果可视化</span></span><br><span class="line">    <span class="comment"># 注意，为了实现可视化，原始维度必须是 2 维</span></span><br><span class="line">    <span class="comment"># visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span></span><br><span class="line">    <span class="comment">#           y_test_pred, show_figure=True, save_figure=False)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924100919300.png" alt="image-20200924100919300" style="zoom:80%;" />

<h3 id="2-MCD"><a href="#2-MCD" class="headerlink" title="2. MCD"></a>2. MCD</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200924101935248.png" alt="image-20200924101935248" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>一种鲁棒性很强的位置和分布估计算法，并且可以通过FAST-MCD方法高效计算。</p>
<p>具体原理可参考：<a href="https://zhuanlan.zhihu.com/p/62146814">异常检测算法之-MCD（Minimum Covariance Determinant）</a></p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.mcd <span class="keyword">import</span> MCD</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span>  <span class="comment"># 异常值占比</span></span><br><span class="line">    n_train = <span class="number">200</span>  <span class="comment"># 训练集大小</span></span><br><span class="line">    n_test = <span class="number">100</span>  <span class="comment"># 测试集大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生产样本数据</span></span><br><span class="line">    X_train, X_test, y_train, y_test = \</span><br><span class="line">        generate_data(n_train=n_train,</span><br><span class="line">                      n_test=n_test,</span><br><span class="line">                      n_features=<span class="number">2</span>,	</span><br><span class="line">                      contamination=contamination,</span><br><span class="line">                      random_state=<span class="number">42</span>,</span><br><span class="line">                      behaviour=<span class="string">&quot;new&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练 MCD 检测器</span></span><br><span class="line">    clf_name = <span class="string">&#x27;MCD&#x27;</span></span><br><span class="line">    clf = MCD()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得训练集的预测标签和异常分数</span></span><br><span class="line">    y_train_pred = clf.labels_  <span class="comment"># (0: 正常, 1: 异常)</span></span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得测试集的预测结果</span></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评估并且打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果可视化</span></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">               y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924102617552.png" alt="image-20200924102617552" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924102750477.png" alt="image-20200924102750477" style="zoom: 50%;" />

<h3 id="3-OCSVM"><a href="#3-OCSVM" class="headerlink" title="3. OCSVM"></a>3. OCSVM</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200924102911438.png" alt="image-20200924102911438" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>是对 sk-learn 中 one-class SVM 类的封装</p>
<p>详情可参考：<a href="https://www.cnblogs.com/wj-1314/p/10701708.html">Python机器学习笔记：One Class SVM</a></p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.ocsvm <span class="keyword">import</span> OCSVM</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span>  <span class="comment"># 异常值占比</span></span><br><span class="line">    n_train = <span class="number">200</span>  <span class="comment"># 训练集大小</span></span><br><span class="line">    n_test = <span class="number">100</span>  <span class="comment"># 测试集大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产样本数据</span></span><br><span class="line">X_train, X_test, y_train, y_test = \</span><br><span class="line">    generate_data(n_train=n_train,</span><br><span class="line">                  n_test=n_test,</span><br><span class="line">                  n_features=<span class="number">2</span>,	</span><br><span class="line">                  contamination=contamination,</span><br><span class="line">                  random_state=<span class="number">42</span>,</span><br><span class="line">                  behaviour=<span class="string">&quot;new&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练 OCSVM 检测器</span></span><br><span class="line">clf_name = <span class="string">&#x27;OCSVM&#x27;</span></span><br><span class="line">clf = OCSVM()</span><br><span class="line">clf.fit(X_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得训练集的预测标签和异常分数</span></span><br><span class="line">y_train_pred = clf.labels_  <span class="comment"># (0: 正常, 1: 异常)</span></span><br><span class="line">y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得测试集的预测结果</span></span><br><span class="line">y_test_pred = clf.predict(X_test)</span><br><span class="line">y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估并且打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果可视化</span></span><br><span class="line">visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">           y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924164659935.png" alt="image-20200924164659935" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200924164726149.png" alt="image-20200924164726149" style="zoom: 50%;" />



<h3 id="4-LOF"><a href="#4-LOF" class="headerlink" title="4. LOF"></a>4. LOF</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200926113655703.png" alt="image-20200926113655703" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>LOF（Local Outlier Factor），即局部异常因子算法，同样是对 sk-learn 中 LOF 类的封装</p>
<p>LOF 通过计算一个数值 score 来反映一个样本的异常程度。这个数值的大致意思是：一个<strong>样本点周围的样本点</strong>所处位置的<strong>平均密度</strong>比上<strong>该样本点</strong>所在位置的<strong>密度</strong>。比值比 1 越大，则该点所在位置的密度比其周围样本所在位置的密度越小，这个点就越有可能是异常点。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.lof <span class="keyword">import</span> LOF</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span>  <span class="comment"># 异常值占比</span></span><br><span class="line">    n_train = <span class="number">200</span>  <span class="comment"># 训练集大小</span></span><br><span class="line">    n_test = <span class="number">100</span>  <span class="comment"># 测试集大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产样本数据</span></span><br><span class="line">X_train, X_test, y_train, y_test = \</span><br><span class="line">    generate_data(n_train=n_train,</span><br><span class="line">                  n_test=n_test,</span><br><span class="line">                  n_features=<span class="number">2</span>,	</span><br><span class="line">                  contamination=contamination,</span><br><span class="line">                  random_state=<span class="number">42</span>,</span><br><span class="line">                  behaviour=<span class="string">&quot;new&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练 LOF 检测器</span></span><br><span class="line">clf_name = <span class="string">&#x27;LOF&#x27;</span></span><br><span class="line">clf = LOF()</span><br><span class="line">clf.fit(X_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得训练集的预测标签和异常分数</span></span><br><span class="line">y_train_pred = clf.labels_  <span class="comment"># (0: 正常, 1: 异常)</span></span><br><span class="line">y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得测试集的预测结果</span></span><br><span class="line">y_test_pred = clf.predict(X_test)</span><br><span class="line">y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估并且打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果可视化</span></span><br><span class="line">visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">           y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200926115949002.png" alt="image-20200926115949002" style="zoom: 80%;" />



<img src="【机器学习】异常检测：PyOD库中的算法/image-20200926120007794.png" alt="image-20200926120007794" style="zoom:50%;" />



<h3 id="5-kNN"><a href="#5-kNN" class="headerlink" title="5. kNN"></a>5. kNN</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927081652658.png" alt="image-20200927081652658" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>kNN（K-NearestNeighbor），即 K 近邻算法，是一种基本的<strong>有监督式分类和回归算法</strong>。</p>
<p>K 近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例<strong>最邻近</strong>的K个实例，<strong>这K个实例的多数属于某个类</strong>，就把该输入实例分类到这个类中。</p>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927082708545.png" alt="image-20200927082708545" style="zoom:80%;" />

<p>如图，要将绿色原点归类：</p>
<ol>
<li>K &lt;&#x3D; 3 ：红色三角形</li>
<li>K &gt; 3：蓝色方块</li>
</ol>
<p>在实际使用中，K 值的选取既不能过大，也不能过小</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.knn <span class="keyword">import</span> KNN</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;KNN&#x27;</span></span><br><span class="line">    clf = KNN()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927083506477.png" alt="image-20200927083506477" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927083444614.png" alt="image-20200927083444614" style="zoom:50%;" />



<h3 id="6-HBOS"><a href="#6-HBOS" class="headerlink" title="6. HBOS"></a>6. HBOS</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927091752222.png" alt="image-20200927091752222" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>HBOS（Histogram-based outlier score），即基于直方图的异常检测算法。</p>
<p>它假设每个维度独立并在每个维度上划分 n 个区间，每个区间所对应的异常值取决于密度。密度越高，异常值越低，因此也可以看成是一种假设维度独立的密度检测。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.hbos <span class="keyword">import</span> HBOS</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;HBOS&#x27;</span></span><br><span class="line">    clf = HBOS()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927092426760.png" alt="image-20200927092426760" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927092459169.png" alt="image-20200927092459169" style="zoom: 50%;" />



<h3 id="7-ABOD"><a href="#7-ABOD" class="headerlink" title="7. ABOD"></a>7. ABOD</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927093058529.png" alt="image-20200927093058529" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>ABOD（Angle-base Outlier Detection），在该算法中，对于一个样本，它的加权余弦分数对所有邻居的方差可以作为离群分数。</p>
<p>在<strong>高维空间</strong>中，<strong>角度比距离更具有可参考性</strong>（维度灾难）：</p>
<ul>
<li>O 点为离群点，则其他点在 O 点的<strong>同一方向</strong>上</li>
<li>O 点不是离群点，则其他点在 O 点的<strong>各个方向</strong>上</li>
</ul>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927093752466.png" alt="image-20200927093752466" style="zoom:80%;" />

<p>给定一点 P，它与全体样本中的任意两点 x、y 所成角度的构成下图：</p>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927094853516.png" alt="image-20200927094853516" style="zoom:80%;" />

<p>可知<strong>所成角度的绝对值越小则该点越有可能为离群点</strong>，也就是说图像中红点数据代表离群点而蓝点数据代表正常点</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.abod <span class="keyword">import</span> ABOD</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;ABOD&#x27;</span></span><br><span class="line">    clf = ABOD()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927095418659.png" alt="image-20200927095418659" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927095516422.png" alt="image-20200927095516422" style="zoom:50%;" />



<h3 id="8-IForest"><a href="#8-IForest" class="headerlink" title="8. IForest"></a>8. IForest</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927095714193.png" alt="image-20200927095714193" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p><code>pyod.models.iforest.IForest</code> 是对 sk-learn 中 <code>Isolation Forest</code> 的封装。</p>
<p>类似于RandomForest，IsolationForest 通过<strong>随机选择一个特征</strong>，然后在所选特征的最大值和最小值之间<strong>随机选择一个分割值</strong>来隔离观察结果。</p>
<p>由于递归分区可以用树结构来表示，因此分离一个样本所需的分裂次数等于从根节点到终止节点的路径长度。这条路径的长度，在这些随机树的森林上的平均值，是一种正态性的度量，也是我们的决策函数。<strong>随机分区为异常的值生成明显更短的路径</strong>。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.iforest <span class="keyword">import</span> IForest</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;IForest&#x27;</span></span><br><span class="line">    clf = IForest()</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927101132163.png" alt="image-20200927101132163" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927101156937.png" alt="image-20200927101156937" style="zoom: 50%;" />



<h3 id="9-feature-bagging"><a href="#9-feature-bagging" class="headerlink" title="9. feature_bagging"></a>9. feature_bagging</h3> <img src="【机器学习】异常检测：PyOD库中的算法/image-20200927105513335.png" alt="image-20200927105513335" style="zoom:80%;" />

<blockquote>
<p>简介</p>
</blockquote>
<p>Feature bagging 检测器是一种 元估计器（meta estimator），它在数据集的各个子样本上匹配大量的基础检测器（base detectors），并使用<strong>平均或其他组合方法</strong>来提高预测精度和控制过拟合。子样本的大小始终与原始输入样本的大小相同，但特征是从一半的特征随机抽样到全部特征。<strong>默认情况下，LOF用作基础估计器。</strong>但是，任何估计器都可以用作基础估计器，如 kNN 和 ABOD。</p>
<p>Feature bagging 首先通过<strong>随机选择特征子集</strong>来构造 n 个子样本，这会引起基本估计量的多样性。 最后，通过平均&#x2F;取所有基本检测器的最大值来生成预测分数。</p>
<blockquote>
<p>示例代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyod.models.feature_bagging <span class="keyword">import</span> FeatureBagging</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> generate_data</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">from</span> pyod.utils.example <span class="keyword">import</span> visualize</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    contamination = <span class="number">0.1</span></span><br><span class="line">    n_train = <span class="number">200</span></span><br><span class="line">    n_test = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    X_train, y_train, X_test, y_test = generate_data(n_train=n_train,</span><br><span class="line">                                                     n_test=n_test,</span><br><span class="line">                                                     n_features=<span class="number">2</span>,</span><br><span class="line">                                                     contamination=contamination,</span><br><span class="line">                                                     random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    clf_name = <span class="string">&#x27;FeatureBagging&#x27;</span></span><br><span class="line">    clf = FeatureBagging(check_estimator=<span class="literal">False</span>)</span><br><span class="line">    clf.fit(X_train)</span><br><span class="line"></span><br><span class="line">    y_train_pred = clf.labels_</span><br><span class="line">    y_train_scores = clf.decision_scores_</span><br><span class="line"></span><br><span class="line">    y_test_pred = clf.predict(X_test)</span><br><span class="line">    y_test_scores = clf.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate and print the results</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_train, y_train_scores)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nOn Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(clf_name, y_test, y_test_scores)</span><br><span class="line"></span><br><span class="line">    visualize(clf_name, X_train, y_train, X_test, y_test, y_train_pred,</span><br><span class="line">              y_test_pred, show_figure=<span class="literal">True</span>, save_figure=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927110718875.png" alt="image-20200927110718875" style="zoom:80%;" />

<img src="【机器学习】异常检测：PyOD库中的算法/image-20200927110700780.png" alt="image-20200927110700780" style="zoom:50%;" />





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p>PyOD 官方文档：<a href="https://pyod.readthedocs.io/en/latest/index.html#">https://pyod.readthedocs.io/en/latest/index.html#</a></p>
</li>
<li><p>（知乎）微调：<a href="https://zhuanlan.zhihu.com/p/58313521">https://zhuanlan.zhihu.com/p/58313521</a></p>
</li>
<li><p>（知乎）忆臻：<a href="https://zhuanlan.zhihu.com/p/25994179">https://zhuanlan.zhihu.com/p/25994179</a></p>
</li>
<li><p>shaoyue1234：<a href="https://blog.csdn.net/shaoyue1234/article/details/102537709">异常检测——ABOD（angle-based outlier detection）</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>异常检测</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习光速入门】</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在正式开始做 “异常新闻检测” 的科研训练之前，需要机器学习、深度学习有一定基础</p>
<p>为此，打算先做一个快速入门，在对所学知识有一定了解之后，再回头补一些基础的理论性较强的知识</p>
<p>该笔记作于 《2018年3天快速入门python机器学习【黑马程序员】》的观看学习过程中</p>
<h1 id="一、特征工程"><a href="#一、特征工程" class="headerlink" title="一、特征工程"></a>一、特征工程</h1><h3 id="0-梗概"><a href="#0-梗概" class="headerlink" title="0. 梗概"></a>0. 梗概</h3><img src="【机器学习飞速入门】/image-20200718165205103.png" alt="image-20200718165205103"  />

<img src="【机器学习飞速入门】/image-20200718165144638.png" alt="image-20200718165144638"  />



<h3 id="1-sklearn"><a href="#1-sklearn" class="headerlink" title="1. sklearn"></a>1. sklearn</h3><p>Scikit learn 也简称 <a href="https://link.jianshu.com/?t=http://scikit-learn.org/stable/">sklearn</a>, 是机器学习领域当中最知名的 python 模块之一。</p>
<ul>
<li>简单高效的数据挖掘和数据分析工具</li>
<li>可供大家在各种环境中重复使用</li>
<li>建立在 NumPy ，SciPy 和 matplotlib 上</li>
<li>开源，可商业使用 - BSD许可证</li>
</ul>
<blockquote>
<p><code>Scikit-learn</code> is an open source machine learning library that supports supervised and unsupervised learning. It also provides various tools for model fitting, data preprocessing, model selection and evaluation, and many other utilities.</p>
</blockquote>
<p>sklearn包含的内容：</p>
<ul>
<li><p>Classification 分类</p>
</li>
<li><p>Regression 回归</p>
</li>
<li><p>Clustering 非监督分类</p>
</li>
<li><p>Dimensionality reduction 数据降维</p>
</li>
<li><p>Model Selection 模型选择</p>
</li>
<li><p>Preprocessing 数据预处理</p>
</li>
</ul>
<img src="【机器学习飞速入门】/image-20200715172312712.png" alt="image-20200715172312712" style="zoom:67%;" />



<h3 id="2-数据集"><a href="#2-数据集" class="headerlink" title="2. 数据集"></a>2. 数据集</h3><p>sklearn 提供了用来学习的多种数据集：</p>
<ul>
<li>自带的小数据集（packaged dataset）：sklearn.datasets.load_<name></li>
<li>可在线下载的数据集（Downloaded Dataset）：sklearn.datasets.fetch_<name></li>
<li>计算机生成的数据集（Generated Dataset）：sklearn.datasets.make_<name></li>
<li>svmlight&#x2F;libsvm格式的数据集:sklearn.datasets.load_svmlight_file(…)</li>
<li>从买了data.org在线下载获取的数据集:sklearn.datasets.fetch_mldata(…)</li>
</ul>
<p>数据集返回结果：</p>
<img src="【机器学习飞速入门】/image-20200715173156243.png" alt="image-20200715173156243" style="zoom:67%;" />



<p>以自带的小数据集 <strong>鸢尾花数据集</strong> 为例演示数据集的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datasets_demo</span>():</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸢尾花数据集:\n&quot;</span>,iris)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看数据集描述:\n&quot;</span>,iris[<span class="string">&quot;DESCR&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值的名字:\n&quot;</span>,iris.feature_names)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值:\n&quot;</span>,iris.data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值形状:\n&quot;</span>,iris.data.shape)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    datasets_demo()</span><br></pre></td></tr></table></figure>

<p><strong>这里要注意不要把所有的数据集都拿来训练一个模型，还一个留一部分用来验证，于是有了数据集的划分</strong></p>
<p>数据集划分：</p>
<ul>
<li><p>机器学习一般的数据集会划分为两个部分：<strong>训练数据、测试数据</strong></p>
</li>
<li><p>划分比例：</p>
<ul>
<li>训练集：70%  80% 75%</li>
<li>测试集：30%  20% 30%</li>
</ul>
</li>
</ul>
<img src="【机器学习飞速入门】/image-20200715175248929.png" alt="image-20200715175248929" style="zoom:67%;" />



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets  <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datasets_demo</span>():</span><br><span class="line">    <span class="comment">#获取数据集</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸢尾花数据集:\n&quot;</span>,iris)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看数据集描述:\n&quot;</span>,iris[<span class="string">&quot;DESCR&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值的名字:\n&quot;</span>,iris.feature_names)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值:\n&quot;</span>,iris.data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查看特征值形状:\n&quot;</span>,iris.data.shape)</span><br><span class="line">    <span class="comment">#数据集的划分</span></span><br><span class="line">    x_train,x_test,y_train,y_test = train_test_split(iris.data,iris.target,test_size=<span class="number">0.2</span>,random_state=<span class="number">22</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练集的特征值:\n&quot;</span>,x_train,x_train.shape)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试集的特征值:\n&quot;</span>,x_test,x_test.shape)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    datasets_demo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-特征工程简介"><a href="#3-特征工程简介" class="headerlink" title="3. 特征工程简介"></a>3. 特征工程简介</h3><p>业界广泛流传：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</p>
<p>特征工程是使用<strong>专业背景知识和技巧处理数据</strong>，<strong>使得特征能在机器学习算法上发挥更好的作用的过程</strong>，<strong>会直接影响机器学习效果。</strong></p>
<p>特征工程内容：</p>
<ul>
<li>特征抽取</li>
<li>特征预处理</li>
<li>特征降维</li>
</ul>
<h3 id="4-特征抽取"><a href="#4-特征抽取" class="headerlink" title="4. 特征抽取"></a>4. 特征抽取</h3><p>特征抽取：将任意数据（文本或图像）转化为用于机器学习的数字特征</p>
<p>分类：</p>
<ul>
<li>字典特征抽取（特征离散化）</li>
<li>文本特征抽取</li>
<li>图像特征抽取（深度学习中使用）</li>
</ul>
<p>使用的 API ：<code>sklearn.feature_extraction</code></p>
<h4 id="1）字典特征提取"><a href="#1）字典特征提取" class="headerlink" title="1）字典特征提取"></a>1）字典特征提取</h4><p>简介：</p>
<img src="【机器学习飞速入门】/image-20200715180318408.png" alt="image-20200715180318408" style="zoom:67%;" />

<p>实例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dict_demo</span>():</span><br><span class="line">    data = [&#123;<span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;temperature&#x27;</span>:<span class="number">100</span>&#125;,&#123;<span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;temperature&#x27;</span>:<span class="number">60</span>&#125;,&#123;<span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;深圳&#x27;</span>,<span class="string">&#x27;temperature&#x27;</span>:<span class="number">30</span>&#125;]</span><br><span class="line">    <span class="comment">#实例一个转换器类</span></span><br><span class="line">    transfer = DictVectorizer(sparse=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment">#调用fit_transform（）</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new:\n&quot;</span>,data_new)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;特征名称:\n&quot;</span>,transfer.get_feature_names())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dict_demo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<ul>
<li><p><code>sparse = False</code>：</p>
  <img src="【机器学习飞速入门】/image-20200715180612908.png" alt="image-20200715180612908" style="zoom:67%;" />
</li>
<li><p><code>sparse = True</code>：</p>
  <img src="【机器学习飞速入门】/image-20200715180641344.png" alt="image-20200715180641344" style="zoom:67%;" /></li>
</ul>
<h4 id="2）文本特征提取"><a href="#2）文本特征提取" class="headerlink" title="2）文本特征提取"></a>2）文本特征提取</h4><p>简介：</p>
<img src="【机器学习飞速入门】/image-20200715180752889.png" alt="image-20200715180752889" style="zoom:67%;" />

<h5 id="英文文本分词："><a href="#英文文本分词：" class="headerlink" title="英文文本分词："></a>英文文本分词：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_demo</span>():</span><br><span class="line">    data = &#123;<span class="string">&quot;Life is short,i like like python&quot;</span>,<span class="string">&quot;Life is too long,i dislike python&quot;</span>&#125;</span><br><span class="line">    <span class="comment">#实例化一个转化器</span></span><br><span class="line">    transfer = CountVectorizer()</span><br><span class="line">    <span class="comment">#调用transform</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new:\n&quot;</span>,data_new.toarray())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    count_demo()</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200715180925250.png" alt="image-20200715180925250"></p>
<h5 id="中文文本分词："><a href="#中文文本分词：" class="headerlink" title="中文文本分词："></a>中文文本分词：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_word</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="built_in">list</span>(jieba.cut(text)))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_chinese_demo</span>():</span><br><span class="line">    data = [<span class="string">&quot;在北上广深，软考证书可以混个工作居住证，也是一项大的积分落户筹码。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;升职加薪必备，很多企业人力资源会以此作为审核晋升的条件。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;简历上浓彩重抹一笔，毕竟是国家人力部、工信部承认的IT高级人才。&quot;</span>]</span><br><span class="line">    data_new=[]</span><br><span class="line">    <span class="keyword">for</span> sent <span class="keyword">in</span> data:</span><br><span class="line">        data_new.append(cut_word(sent))</span><br><span class="line">    <span class="comment">#实例化一个转化器</span></span><br><span class="line">    transfer = CountVectorizer()</span><br><span class="line">    <span class="comment">#调用transform</span></span><br><span class="line">    data_final = transfer.fit_transform(data_new)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;转化后结果:\n&quot;</span>,data_final.toarray())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;特征名字:\n&quot;</span>,transfer.get_feature_names())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    count_chinese_demo()</span><br></pre></td></tr></table></figure>

<img src="【机器学习飞速入门】/image-20200715181700533.png" alt="image-20200715181700533" style="zoom:67%;" />



<p>上述方法会出现一些 “可以”、“很多” 等与主题无关紧要的特征，会印象我们对结果的判断，不够完善，此时我们引入 <strong>Tf-idf 文本特征提取</strong>方法 </p>
<h5 id="Tf-idf-文本特征提取："><a href="#Tf-idf-文本特征提取：" class="headerlink" title="Tf-idf 文本特征提取："></a>Tf-idf 文本特征提取：</h5><p>简介：</p>
<ul>
<li><p>TF-IDF的主要思想是:如果某个词或短语在一篇文章中出现的概率高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。</p>
</li>
<li><p>TF-IDF作用:用以评估-字词对于一个文件集或一个语料库中的其中一份文件的重要程度。</p>
</li>
</ul>
<img src="【机器学习飞速入门】/image-20200715182239136.png" alt="image-20200715182239136" style="zoom:67%;" />

<p>api：</p>
<img src="【机器学习飞速入门】/image-20200715182310569.png" alt="image-20200715182310569" style="zoom:67%;" />

<p>使用方法与上面提到的中文文本分词方法大体一致，只是将转换器换为：<code>TfidfVectorizer()</code></p>
<h3 id="5-特征预处理"><a href="#5-特征预处理" class="headerlink" title="5. 特征预处理"></a>5. 特征预处理</h3><img src="【机器学习飞速入门】/image-20200715182740495.png" alt="image-20200715182740495" style="zoom:67%;" />

<p><strong>特征预处理</strong>就是通过一些转化函数将特征数据转换成<strong>更加适合算法模型的特征数据过程</strong>（<strong>无量纲化</strong>处理）</p>
<p>特征的单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级，容易影响(支配)目标结果，使得一些算法无法学习到其它的特征</p>
<p>包括内容：归一化、标准化</p>
<p>使用的 api ：<code>sklearn.preprocessing</code></p>
<h4 id="1）归一化"><a href="#1）归一化" class="headerlink" title="1）归一化"></a>1）归一化</h4><p>通过对原始数据进行变换把数据映射到(默认为[0,1])之间</p>
<img src="【机器学习飞速入门】/image-20200715183155497.png" alt="image-20200715183155497" style="zoom:67%;" />

<p>api：</p>
<img src="【机器学习飞速入门】/image-20200715183210002.png" alt="image-20200715183210002" style="zoom:67%;" />

<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minmax_demo</span>():</span><br><span class="line">    data = pd.read_csv(<span class="string">&quot;dating.txt&quot;</span>)</span><br><span class="line">    data = data.iloc[:,:<span class="number">3</span>]  <span class="comment">#只取数据前三列</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data=\n&quot;</span>,data)</span><br><span class="line">    transfer = MinMaxScaler() <span class="comment">#默认0-1</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new=\n&quot;</span>,data_new)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    minmax_demo()</span><br></pre></td></tr></table></figure>

<img src="【机器学习飞速入门】/image-20200715183245714.png" alt="image-20200715183245714" style="zoom:67%;" />

<p>归一化鲁棒性（最大值最小值容易受异常点影响）较差，<strong>只适合传统精确小数据场景</strong></p>
<h4 id="2）标准化"><a href="#2）标准化" class="headerlink" title="2）标准化"></a>2）标准化</h4><img src="【机器学习飞速入门】/image-20200715183530348.png" alt="image-20200715183530348" style="zoom:67%;" />

<p>api：</p>
<img src="【机器学习飞速入门】/image-20200715183605810.png" alt="image-20200715183605810" style="zoom:67%;" />

<p>使用方法与上面提到的<strong>归一化</strong>方法大体一致，只是将转换器换为：<code>StandardScaler()</code></p>
<h3 id="6-特征降维"><a href="#6-特征降维" class="headerlink" title="6. 特征降维"></a>6. 特征降维</h3><img src="【机器学习飞速入门】/image-20200715183831598.png" alt="image-20200715183831598" style="zoom:67%;" />

<p>降维两种方式：</p>
<ul>
<li>特征选择</li>
<li>主成分分析</li>
</ul>
<h4 id="1）特征选择"><a href="#1）特征选择" class="headerlink" title="1）特征选择"></a>1）特征选择</h4><p>数据中包含<strong>冗余或相关变量</strong>(或称特征、属性、指标等)，旨在从原有特征中找出<strong>主要特征</strong>。</p>
<p>方法：</p>
<img src="【机器学习飞速入门】/image-20200715184212364.png" alt="image-20200715184212364" style="zoom:67%;" />

<p>使用的模块： <code>sklearn-feature.selection</code></p>
<h5 id="低方差特征过滤"><a href="#低方差特征过滤" class="headerlink" title="低方差特征过滤"></a>低方差特征过滤</h5><p>删除低方差（衡量随机变量或一组数据时<strong>离散程度的度量</strong>，低方差说明数据相近）一些特征。</p>
<p>api：</p>
<img src="【机器学习飞速入门】/image-20200716162726579.png" alt="image-20200716162726579" style="zoom:67%;" />

<h5 id="高相关系数过滤"><a href="#高相关系数过滤" class="headerlink" title="高相关系数过滤"></a>高相关系数过滤</h5><p>相关关系是一种非确定性的关系，相关系数是研究变量之间<strong>线性相关</strong>程度的量。</p>
<img src="【机器学习飞速入门】/image-20200716163333534.png" alt="image-20200716163333534" style="zoom: 33%;" />

 <img src="【机器学习飞速入门】/image-20200716163349396.png" alt="image-20200716163349396" style="zoom:67%;" />

<p>api：</p>
<img src="【机器学习飞速入门】/image-20200716163534685.png" alt="image-20200716163534685" style="zoom:67%;" />



<img src="【机器学习飞速入门】/image-20200716163616901.png" alt="image-20200716163616901" style="zoom:67%;" />



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码总结</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">variance_demo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    过滤低方差特征</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1、获取数据</span></span><br><span class="line">    data = pd.read_csv(<span class="string">&quot;factor_returns.csv&quot;</span>)</span><br><span class="line">    data = data.iloc[:, <span class="number">1</span>:-<span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data:\n&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、实例化一个转换器类</span></span><br><span class="line">    transfer = VarianceThreshold(threshold=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3、调用fit_transform</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new:\n&quot;</span>, data_new, data_new.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算某两个变量之间的相关系数</span></span><br><span class="line">    r1 = pearsonr(data[<span class="string">&quot;pe_ratio&quot;</span>], data[<span class="string">&quot;pb_ratio&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;相关系数：\n&quot;</span>, r1)</span><br><span class="line">    r2 = pearsonr(data[<span class="string">&#x27;revenue&#x27;</span>], data[<span class="string">&#x27;total_expense&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;revenue与total_expense之间的相关性：\n&quot;</span>, r2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h4 id="2）-主成分分析（PCA）"><a href="#2）-主成分分析（PCA）" class="headerlink" title="2） 主成分分析（PCA）"></a>2） 主成分分析（PCA）</h4><ul>
<li><p>定义：<strong>高维数据转化为低维数据的过程</strong>，在此过程中可能会舍弃原有数据、创造新的变量。</p>
</li>
<li><p>作用：尽可能<strong>降低原数据的维数</strong>，同时尽量<strong>保证数据损失较少</strong>。</p>
</li>
<li><p>简单示例：</p>
<ol>
<li>三维物体的二维特征</li>
</ol>
<p>  <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200718164344152.png" alt="image-20200718164344152"></p>
<ol start="2">
<li><p>将给定一组坐标降维</p>
 <img src="【机器学习飞速入门】/image-20200718164455771.png" alt="image-20200718164455771" style="zoom:67%;" />

 <img src="【机器学习飞速入门】/image-20200718164514052.png" alt="image-20200718164514052" style="zoom:67%;" />

 <img src="【机器学习飞速入门】/image-20200718164540852.png" alt="image-20200718164540852" style="zoom:67%;" /></li>
</ol>
</li>
</ul>
<p>​															<img src="【机器学习飞速入门】/image-20200718164554187.png" alt="image-20200718164554187" style="zoom:67%;" /></p>
<ul>
<li><p>API</p>
  <img src="【机器学习飞速入门】/image-20200718164644648.png" alt="image-20200718164644648" style="zoom:67%;" />
</li>
<li><p>实例：</p>
  <img src="【机器学习飞速入门】/image-20200718164725784.png" alt="image-20200718164725784" style="zoom:67%;" />

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition  <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pca_demo</span>():</span><br><span class="line">    data = [[<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">8</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>]]</span><br><span class="line">    transfer = PCA(n_components=<span class="number">2</span>) <span class="comment">#降维成两个特征</span></span><br><span class="line">    data_new = transfer.fit_transform(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data_new:\n&quot;</span>,data_new)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pca_demo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200718164750676.png" alt="image-20200718164750676"></p>
<p>  成功将四维坐标降为二维！</p>
</li>
</ul>
<h1 id="二、分类算法"><a href="#二、分类算法" class="headerlink" title="二、分类算法"></a>二、分类算法</h1><h3 id="0-梗概-1"><a href="#0-梗概-1" class="headerlink" title="0. 梗概"></a>0. 梗概</h3><p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721173457106.png" alt="image-20200721173457106"></p>
<h3 id="1-转换器和估计器"><a href="#1-转换器和估计器" class="headerlink" title="1. 转换器和估计器"></a>1. 转换器和估计器</h3><h4 id="1）转换器"><a href="#1）转换器" class="headerlink" title="1）转换器"></a>1）转换器</h4><p>​	我们把<strong>特征工程的接口</strong>称为转换器</p>
<p>转换器的调用方法：</p>
<ul>
<li><code>fit_transform</code>：<code>fit</code> 和 <code>transform</code> 的结合</li>
<li><code>fit</code>：计算每一列的平均值和标准差</li>
<li><code>transform</code>：<code>(x - mean) / std</code>（进行最终的计算）</li>
</ul>
<h4 id="2）估计器"><a href="#2）估计器" class="headerlink" title="2）估计器"></a>2）估计器</h4><p>估计器是一类<strong>实现了算法的 API</strong></p>
<ol>
<li><p>用于<strong>分类</strong>的估计器</p>
<ul>
<li>sklearn.neighbors    K-近邻算法</li>
<li>sklearn.naive_bayes    朴素贝叶斯  </li>
<li>sklearn.linear_model.LogisticRegression    逻辑回归</li>
<li>sklearn.tree    决策树和随机森林</li>
</ul>
</li>
<li><p>用于<strong>回归</strong>的估计器</p>
<ul>
<li><p>sklearn.linear_model.LinearRegression    线性回归</p>
</li>
<li><p>sklearn.linear_model.Ridge    岭回归</p>
</li>
</ul>
</li>
<li><p>用于<strong>无监督学习</strong>的估计器</p>
<ul>
<li>sklearn.cluster.KMeans    聚类</li>
</ul>
</li>
</ol>
<p>估计器工作流程：</p>
<img src="【机器学习飞速入门】/image-20200721164812435.png" alt="image-20200721164812435" style="zoom:67%;" />





<h3 id="2-K-近邻算法（KNN-算法）"><a href="#2-K-近邻算法（KNN-算法）" class="headerlink" title="2. K-近邻算法（KNN 算法）"></a>2. K-近邻算法（KNN 算法）</h3><p>核心思想：<strong>根据你的邻居来判断你的类别！</strong></p>
<p>给定一个训练集，对新输入的实例，在训练集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，我们就把该输入实例分为这个类。</p>
<img src="【机器学习飞速入门】/image-20200721165450099.png" alt="image-20200721165450099" style="zoom:67%;" />

<p>基本要素：</p>
<ul>
<li>距离度量方法<ul>
<li>欧氏距离	<img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721165649451.png" alt="image-20200721165649451"></li>
<li>曼哈顿距离    <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721165701626.png" alt="image-20200721165701626"></li>
<li>闵可夫斯基距离    <img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721165755462.png" alt="image-20200721165755462"></li>
</ul>
</li>
<li>K值<ul>
<li>过小：容易受到异常数据的影响</li>
<li>过大：容易受到样本不均衡的影响</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span>  train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span>  StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">案例：使用 KNN 算法对鸢尾花集进行分类</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knn_iris</span>():</span><br><span class="line">    <span class="comment"># 1.获取数据</span></span><br><span class="line">    iris  = load_iris()</span><br><span class="line">    <span class="comment"># 2.划分数据集</span></span><br><span class="line">    x_train,x_test,y_train,y_test = train_test_split(iris.data,iris.target,random_state=<span class="number">22</span>)</span><br><span class="line">    <span class="comment"># 3.特征工程:标准化</span></span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.fit_transform(x_test)</span><br><span class="line">    <span class="comment"># 4.KNN算法预估器</span></span><br><span class="line">    estimator = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">    estimator.fit(x_train,y_train)</span><br><span class="line">    <span class="comment"># 5.模型评估</span></span><br><span class="line">    <span class="comment">#方法1：直接比对真实值和预测值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_predict:\n&quot;</span>,y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值:\n&quot;</span>,y_test == y_predict)</span><br><span class="line">    <span class="comment">#方法2:计算准确率</span></span><br><span class="line">    score = estimator.score(x_test,y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准确率为:\n&quot;</span>,score)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    knn_iris()</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721171101873.png" alt="image-20200721171101873"></p>
<h3 id="3-朴素贝叶斯算法"><a href="#3-朴素贝叶斯算法" class="headerlink" title="3. 朴素贝叶斯算法"></a>3. 朴素贝叶斯算法</h3><h4 id="1）贝叶斯公式"><a href="#1）贝叶斯公式" class="headerlink" title="1）贝叶斯公式"></a>1）贝叶斯公式</h4><p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721170331093.png" alt="image-20200721170331093"></p>
<ul>
<li>W：给定文档的特征值</li>
<li>C：文档类别</li>
</ul>
<h4 id="2）拉普拉斯平滑系数"><a href="#2）拉普拉斯平滑系数" class="headerlink" title="2）拉普拉斯平滑系数"></a>2）拉普拉斯平滑系数</h4><p>目的：防止计算出的分类概率为0</p>
<img src="【机器学习飞速入门】/image-20200721170612675.png" alt="image-20200721170612675" style="zoom:67%;" />

<h4 id="3）朴素贝叶斯"><a href="#3）朴素贝叶斯" class="headerlink" title="3）朴素贝叶斯"></a>3）朴素贝叶斯</h4><ul>
<li>朴素：假定各个事件相互独立</li>
<li>贝叶斯：贝叶斯公式</li>
</ul>
<p>API ：<code>sklearn.naive_bayes.MultinomialNB(alpha = 1.0)</code></p>
<ul>
<li>朴素贝叶斯分类</li>
<li>alpha：拉普拉斯平滑系数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_20newsgroups</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用朴素贝叶斯算法对新闻进行分类</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nb_news</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1）获取数据</span></span><br><span class="line">    news = fetch_20newsgroups(subset=<span class="string">&quot;all&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2）划分数据集</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(news.data, news.target)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3）特征工程：文本特征抽取-tfidf</span></span><br><span class="line">    transfer = TfidfVectorizer()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.transform(x_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4）朴素贝叶斯算法预估器流程</span></span><br><span class="line">    estimator = MultinomialNB()</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5）模型评估</span></span><br><span class="line">    <span class="comment"># 方法1：直接比对真实值和预测值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_predict:\n&quot;</span>, y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值:\n&quot;</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法2：计算准确率</span></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准确率为：\n&quot;</span>, score)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nb_news()</span><br></pre></td></tr></table></figure>

<img src="【机器学习飞速入门】/image-20200721172243905.png" alt="image-20200721172243905" style="zoom: 80%;" />



<h3 id="4-决策树"><a href="#4-决策树" class="headerlink" title="4. 决策树"></a>4. 决策树</h3><img src="【机器学习飞速入门】/image-20200721172449868.png" alt="image-20200721172449868" style="zoom:67%;" />

<p>上图是一棵结构简单的决策树，用于预测贷款用户是否具有偿还贷款的能力。贷款用户主要具备三个属性：是否拥有房产，是否结婚，平均月收入。每一个内部节点都表示一个属性条件判断，叶子节点表示贷款用户是否具有偿还能力。例如：用户甲没有房产，没有结婚，月收入 5K。通过决策树的根节点判断，用户甲符合右边分支 (拥有房产为”否”)；再判断是否结婚，用户甲符合左边分支 (是否结婚为否)；然后判断月收入是否大于 4k，用户甲符合左边分支 (月收入大于 4K)，该用户落在”可以偿还”的叶子节点上。所以预测用户甲具备偿还贷款能力。</p>
<p><strong>通过信息增益找到最⾼效的决策顺序。</strong></p>
<p>API：</p>
<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721172921450.png" alt="image-20200721172921450"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, export_graphviz</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用决策树对鸢尾花进行分类</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decision_iris</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1）获取数据集</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2）划分数据集</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3）决策树预估器</span></span><br><span class="line">    estimator = DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4）模型评估</span></span><br><span class="line">    <span class="comment"># 方法1：直接比对真实值和预测值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_predict:\n&quot;</span>, y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值:\n&quot;</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法2：计算准确率</span></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准确率为：\n&quot;</span>, score)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可视化决策树</span></span><br><span class="line">    export_graphviz(estimator, out_file=<span class="string">&quot;iris_tree.dot&quot;</span>, feature_names=iris.feature_names)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    decision_iris()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A3%9E%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/image-20200721173119603.png" alt="image-20200721173119603"></p>
<h3 id="5-随机森林"><a href="#5-随机森林" class="headerlink" title="5. 随机森林"></a>5. 随机森林</h3><img src="【机器学习飞速入门】/image-20200721173201773.png" alt="image-20200721173201773" style="zoom:67%;" />

<p>API：</p>
<img src="【机器学习飞速入门】/image-20200721173217939.png" alt="image-20200721173217939" style="zoom:67%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用随机森林实现泰坦尼克号实例</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randomForest_demo</span>():</span><br><span class="line">    <span class="comment"># 1、获取数据</span></span><br><span class="line">    path = <span class="string">&quot;http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic.txt&quot;</span></span><br><span class="line">    titanic = pd.read_csv(path)</span><br><span class="line">    <span class="comment"># 筛选特征值和目标值</span></span><br><span class="line">    x = titanic[[<span class="string">&quot;pclass&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>]]</span><br><span class="line">    y = titanic[<span class="string">&quot;survived&quot;</span>]</span><br><span class="line">    <span class="comment"># 2、数据处理</span></span><br><span class="line">    <span class="comment"># 1）缺失值处理</span></span><br><span class="line">    x[<span class="string">&quot;age&quot;</span>].fillna(x[<span class="string">&quot;age&quot;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 2) 转换成字典</span></span><br><span class="line">    x = x.to_dict(orient=<span class="string">&quot;records&quot;</span>)</span><br><span class="line">    <span class="comment"># 3、数据集划分</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">22</span>)</span><br><span class="line">    <span class="comment"># 4、字典特征抽取</span></span><br><span class="line">    transfer = DictVectorizer()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.transform(x_test)</span><br><span class="line">    <span class="comment">#随机森林预估器</span></span><br><span class="line">    estimator = RandomForestClassifier()</span><br><span class="line">    <span class="comment"># 加入网格搜索与交叉验证</span></span><br><span class="line">    <span class="comment"># 参数准备</span></span><br><span class="line">    param_dict = &#123;<span class="string">&quot;n_estimators&quot;</span>: [<span class="number">120</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">800</span>, <span class="number">1200</span>], <span class="string">&quot;max_depth&quot;</span>: [<span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">30</span>]&#125;</span><br><span class="line">    estimator = GridSearchCV(estimator, param_grid=param_dict, cv=<span class="number">3</span>)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5）模型评估</span></span><br><span class="line">    <span class="comment"># 方法1：直接比对真实值和预测值</span></span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_predict:\n&quot;</span>, y_predict)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值:\n&quot;</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法2：计算准确率</span></span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准确率为：\n&quot;</span>, score)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最佳参数：best_params_</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最佳参数：\n&quot;</span>, estimator.best_params_)</span><br><span class="line">    <span class="comment"># 最佳结果：best_score_</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最佳结果：\n&quot;</span>, estimator.best_score_)</span><br><span class="line">    <span class="comment"># 最佳估计器：best_estimator_</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最佳估计器:\n&quot;</span>, estimator.best_estimator_)</span><br><span class="line">    <span class="comment"># 交叉验证结果：cv_results_</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;交叉验证结果:\n&quot;</span>, estimator.cv_results_)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    randomForest_demo()</span><br></pre></td></tr></table></figure>





<h1 id="三、回归与聚类算法"><a href="#三、回归与聚类算法" class="headerlink" title="三、回归与聚类算法"></a>三、回归与聚类算法</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>黑马程序员：<a href="https://www.bilibili.com/video/BV1nt411r7tj?t=38&p=16">https://www.bilibili.com/video/BV1nt411r7tj?t=38&amp;p=16</a></li>
<li>sklearn 中文文档：<a href="http://www.scikitlearn.com.cn/">http://www.scikitlearn.com.cn/</a></li>
<li>隔壁郑同学：<a href="https://blog.csdn.net/weixin_44517301/article/details/88405939">https://blog.csdn.net/weixin_44517301/article/details/88405939</a></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】2021异常检测顶会论文一览</title>
    <url>/2023/03/01/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E9%A1%B6%E4%BC%9A%E8%AE%BA%E6%96%87%E4%B8%80%E8%A7%88/</url>
    <content><![CDATA[<blockquote>
<p>本文整理了 <strong>2021</strong> 年AAAI、ICML等顶会收录的异常检测领域的论文</p>
<p><a href="https://www.paperdigest.org/">论文整合网站 paperdigest</a></p>
<p><a href="https://aaai.org/Conferences/AAAI-21/wp-content/uploads/2020/12/AAAI-21_Accepted-Paper-List.Main_.Technical.Track_.pdf">AAAI 2021 Accepted-Paper-List</a></p>
<p><a href="https://icml.cc/Conferences/2021/AcceptedPapersInitial">ICML 2021 Accepted-Paper-List</a></p>
<p><a href="https://openreview.net/group?id=ICLR.cc/2021/Conference#oral-presentations">ICLR 2021 Accepted-Paper-List</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>paper</th>
<th>source</th>
<th>author</th>
</tr>
</thead>
<tbody><tr>
<td>LREN: Low-Rank Embedded Network for Sample-Free Hyperspectral Anomaly Detection</td>
<td>AAAI</td>
<td><em>Kai Jiang, Weiying Xie, Jie Lei, Tao Jiang, Yunsong Li</em></td>
</tr>
<tr>
<td>GAN Ensemble for Anomaly Detection</td>
<td>AAAI</td>
<td><em>Xiaohui Chen, Xu Han, Liping Liu</em></td>
</tr>
<tr>
<td>Anomaly Attribution with Likelihood Compensation</td>
<td>AAAI</td>
<td><em>Tsuyoshi Ide, Amit Dhurandhar, Jiri Navratil, Moninder Singh, Naoki Abe</em></td>
</tr>
<tr>
<td>Regularizing Attention Networks for Anomaly Detection in Visual Question Answering</td>
<td>AAAI</td>
<td><em>Regularizing Attention Networks for Anomaly Detection in Visual Question Answering</em></td>
</tr>
<tr>
<td>Appearance-Motion Memory Consistency Network for Video Anomaly Detection</td>
<td>AAAI</td>
<td><em>Ruichu Cai, Hao Zhang, Wen Liu, Shenghua Gao, Zhifeng Hao</em></td>
</tr>
<tr>
<td>Learning Semantic Context from Normal Samples for Unsupervised Anomaly Detection</td>
<td>AAAI</td>
<td><em>Xudong Yan, Huaidong Zhang, Xuemiao Xu, Xiaowei Hu, Pheng-Ann Heng</em></td>
</tr>
<tr>
<td>Graph Neural Network-Based Anomaly Detection in Multivariate Time Series</td>
<td>AAAI</td>
<td><em>Ailin Deng, Bryan Hooi</em></td>
</tr>
<tr>
<td>Time Series Anomaly Detection with Multiresolution Ensemble Decoding</td>
<td>AAAI</td>
<td><em>Lifeng Shen, Zhongzhong Yu, Qianli Ma, James Tin-Yau Kwok</em></td>
</tr>
<tr>
<td>Window Loss for Abnormal Finding Classification and Localization in X-Ray Image with Point-Base Annotat</td>
<td>AAAI</td>
<td><em>Xinyu Zhang, Yirui Wang, Chi Tung Cheng, Le Lu, Adam P Harrison, Jing Xiao, ChienHung Liao, Shun  Miao</em></td>
</tr>
<tr>
<td>Graph Neural Network to Dilute Outliers for Refactoring Monolith Application</td>
<td>AAAI</td>
<td><em>Utkarsh Desai, Sambaran Bandyopadhyay, Srikanth Tamilselvam</em></td>
</tr>
<tr>
<td>Accelerated Combinatorial Search for Outlier Detection with Provable Bound on Sub-Optimality</td>
<td>AAAI</td>
<td><em>Guihong Wan, Haim Schweitzer</em></td>
</tr>
<tr>
<td>Neighborhood Consensus Networks for Unsupervised Multi-View Outlier Detection</td>
<td>AAAI</td>
<td><em>Li Cheng, Yijie Wang, Xinwang Liu</em></td>
</tr>
<tr>
<td>Outlier Impact Characterization for Time Series Data</td>
<td>AAAI</td>
<td><em>Jianbo Li, Lecheng Zheng, Yada Zhu, Jingrui He</em></td>
</tr>
<tr>
<td>Near-Optimal Entrywise Anomaly Detection for Low-Rank Matrices with Sub-Exponential Noise</td>
<td>ICML</td>
<td><em>Vivek Farias (MIT) , Andrew Li (Carnegie Mellon University) ,Tianyi Peng (MIT)</em></td>
</tr>
<tr>
<td>Transfer-Based Semantic Anomaly Detection</td>
<td>ICML</td>
<td><em>Lucas Deecke (University of Edinburgh) , Lukas Ruff (Aignostics) , Robert Vandermeulen (TU Berlin) , Hakan Bilen (University of Edinburgh)</em></td>
</tr>
<tr>
<td>Neural Transformation Learning for Deep Anomaly Detection Beyond Images</td>
<td>ICML</td>
<td><em>Chen Qiu (TU Kaiserslautern&#x2F;Bosch Center for Artificial Intelligence) , Timo Pfrommer (Bosch Center for Artificial Intelligence) , Marius Kloft (TU Kaiserslautern) , Stephan Mandt (University of California, Irivine) , Maja Rudolph (BCAI)</em></td>
</tr>
<tr>
<td>Event Outlier Detection in Continuous Time</td>
<td>ICML</td>
<td><em>Siqi Liu (Borealis AI) , Milos Hauskrecht (University of Pittsburgh)</em></td>
</tr>
<tr>
<td>Outlier-Robust Optimal Transport</td>
<td>ICML</td>
<td><em>Debarghya Mukherjee (University of Michigan) , Aritra Guha (Duke University) , Justin Solomon (MIT) , Yuekai Sun (University of Michigan) , Mikhail Yurochkin (IBM Research AI)</em></td>
</tr>
<tr>
<td>DORO: Distributional and Outlier Robust Optimization</td>
<td>ICML</td>
<td><em>Runtian Zhai (Carnegie Mellon University) , Chen Dan (Carnegie Mellon University) , Zico Kolter (Carnegie Mellon University &#x2F; Bosch Center for AI) , Pradeep Ravikumar (Carnegie Mellon University)</em></td>
</tr>
<tr>
<td><a href="https://openreview.net/forum?id=v5gjXpmR8J">SSD: A Unified Framework for Self-Supervised Outlier Detection</a></td>
<td>ICLR</td>
<td><em><a href="https://openreview.net/profile?id=~Vikash_Sehwag1">Vikash Sehwag</a>, <a href="https://openreview.net/profile?id=~Mung_Chiang2">Mung Chiang</a>, <a href="https://openreview.net/profile?id=~Prateek_Mittal1">Prateek Mittal</a></em></td>
</tr>
<tr>
<td><a href="https://www.aclweb.org/anthology/2021.naacl-main.25">DATE: Detecting Anomalies in Text Via Self-Supervision of Transformers</a></td>
<td>NAACL</td>
<td><em><a href="https://www.paperdigest.org/expert/?name=andrei_manolache">Andrei Manolache</a>, <a href="https://www.paperdigest.org/expert/?name=florin_brad">Florin Brad</a>, <a href="https://www.paperdigest.org/expert/?name=elena_burceanu">Elena Burceanu</a></em></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>NLP</tag>
        <tag>异常检测</tag>
      </tags>
  </entry>
  <entry>
    <title>【考研】数据结构知识点总结</title>
    <url>/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><ol>
<li><p><code>节点数 n = 所有节点度（degree） + 1</code></p>
</li>
<li><p>二叉树中：<code>n = n0 + n1 + n2</code></p>
</li>
<li><p><code>n2 = n0 + 1</code></p>
</li>
<li><p>树的路径长度：树根到每个节点的路径长度的总和</p>
</li>
<li><p>中序遍历 + 前序&#x2F;后序&#x2F;层序  ——》 构建一颗树</p>
</li>
<li><p>n 个节点二叉树的空指针域个数：<code>n + 1</code></p>
</li>
<li><p><strong>前序遍历</strong>结果与<strong>中序遍历</strong>结果<strong>相同</strong>：非叶子节点<strong>只有右子树</strong></p>
<p> <strong>前序遍历</strong>结果与<strong>后序遍历</strong>结果<strong>相反</strong>：高度等于节点数（所有节点度为 1）</p>
</li>
<li><p>树的<strong>先根遍历</strong>与二叉树（森林）的<strong>先序遍历</strong>结果相同</p>
<p> 树的<strong>后根遍历</strong>与二叉树（森林）的<strong>中序遍历</strong>结果相同</p>
</li>
<li><p>平衡二叉树调整不平衡</p>
<ul>
<li>LL：右旋</li>
<li>RR：左旋</li>
<li>LR：左旋、右旋</li>
<li>RL：右旋、左旋</li>
</ul>
</li>
<li><p>高为 h 的平衡二叉树最少有几个节点：<br>$$<br>h_n &#x3D; h_(n-1) + h_(n-2) + 1<br>$$</p>
</li>
</ol>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【考研】考研冲冲冲！</title>
    <url>/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%80%83%E7%A0%94%E5%A5%8B%E6%96%97%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%81/</url>
    <content><![CDATA[<h1 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h1><blockquote>
<p>十月计划</p>
<p><strong>数学</strong></p>
<table>
<thead>
<tr>
<th align="left">时限</th>
<th>具体内容</th>
<th>计划日期</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数二真题</td>
<td>结束十七堂课或者在十七堂课还没更新的时候刷<br />从 21 年真题练手<br />先做奇数年：11、13、15、19<br />再做偶数年：12、14、16、20<br />一遍过后二刷，针对<strong>重点题和错题</strong><br />留 17（简单）、18（难）两年最后模拟<br />再之后可以参考张宇&#x2F;李正元真题解析进行三刷</td>
<td>每天一篇，月底前近十年全部刷完</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">武忠祥十七堂课</td>
<td>做完卷子以后，针对错题较多的专题，看武忠祥十七堂课进行查漏补缺</td>
<td>做完真题后视情况看</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">每日一题</td>
<td></td>
<td>抽空就做</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>408</strong></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>具体内容</th>
<th>计划日期</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>OS 三轮</td>
<td>边部充思维导图，边过第三轮单科书</td>
<td>十号之前解决</td>
<td></td>
</tr>
<tr>
<td>计组三轮</td>
<td>同上</td>
<td>一天 1 ~ 2 小节，25 号之前解决</td>
<td></td>
</tr>
<tr>
<td>DS 三轮</td>
<td>同上</td>
<td>过快一点，月底拿下</td>
<td></td>
</tr>
</tbody></table>
<p>英语</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>具体内容</th>
<th>计划日期计划日期</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>单词词组</td>
<td>每天单词&#x2F;词组 x 400，过完这轮词组继续过单词</td>
<td>一直背到考研前</td>
<td></td>
</tr>
<tr>
<td>英二真题</td>
<td>一天 1~2 篇阅读或完型或七选五和翻译</td>
<td>3 ~ 4 天一套，先做着</td>
<td></td>
</tr>
<tr>
<td>作文</td>
<td>看王江涛作文书</td>
<td>月底前开始准备</td>
<td></td>
</tr>
</tbody></table>
<p>政治</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>具体内容</th>
<th>计划日期</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>毛中特强化</td>
<td>一天 1 ~ 2 小节</td>
<td>25 号左右结束</td>
<td></td>
</tr>
<tr>
<td>思修强化</td>
<td>同上</td>
<td>月底争取结束</td>
<td></td>
</tr>
<tr>
<td>小程序</td>
<td>边看课边做小程序</td>
<td>跟强化课同步</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h1 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h1><blockquote>
<p>九月总结：</p>
<ul>
<li><p>数学</p>
<ol>
<li>回顾线代讲义 √</li>
<li>660 线代（比较简单，快快刷完） √</li>
<li>880 综合题（基础题错题软件原因之前做的丢了，880 大题还是挺有难度，还有好多题只是做完了但是感觉还没有吃透）  √</li>
<li>每日一题 （冲刺 120 分里有些题还是挺好的，需要抽空回顾） √</li>
<li>高数辅导讲义例题回顾了差不多一半，后面的没坚持下去</li>
</ol>
</li>
<li><p>408</p>
<ol>
<li>OS 二轮 √</li>
<li>计组和 OS 知识点总结 没抽出空做（可能是懒） ×</li>
<li>计网 差不多按计划结束 √</li>
<li>王道强化：计网、OS √</li>
<li>每日一题 云记把原来记录丢了以后就没再坚持 ×</li>
</ol>
</li>
<li><p>英语</p>
<ol>
<li><p>每日单词，一直有坚持 √</p>
</li>
<li><p>真题，英一做到 16 年，之后再没做，转做了英二（除了作文其他都刷）</p>
</li>
</ol>
</li>
<li><p>政治</p>
<ol>
<li>马原强化（学的有点快，知识点还是有点模糊） √</li>
<li>史纲强化（要记得东西好多，好多都没记住） √</li>
<li>刷对应小程序 √</li>
</ol>
</li>
</ul>
<p>整体上按计划稳步推进！</p>
</blockquote>
<blockquote>
<p>九月计划：</p>
<ul>
<li>数学（早上 8：00 ~ 12：00）<ol>
<li>回顾复盘线代讲义知识点和例题（3 ~ 5 天）</li>
<li>660 线代部分（3 ~ 5 天）</li>
<li>补完 660 线代部分以后开始刷 880（按上个月计划刷基础篇错题和重点题和综合篇的题）</li>
<li>每天留一个小时做每日一题以及回顾高数讲义例题</li>
</ol>
</li>
<li>408（下午 2：00 ~ 5&#x2F;6：00）<ol>
<li>OS 二轮（还剩 5 小节， 差不多 3 ~ 5 天拿下）</li>
<li>计组知识点总结（剩第二章、第三章、第四章）</li>
<li>过完 OS 二轮、计组知识点整理好以后，开始计网（共约30小节，一天 2 ~ 3 小节，20 号之前解决）</li>
<li>剩下的时间整理各科笔记，再抽空看看王道强化课</li>
<li>坚持每日一题</li>
</ol>
</li>
<li>英语<ul>
<li>每天 300 个单词</li>
<li>真题每天一篇 + 看唐迟讲解，月底差不多过完英一第一轮</li>
</ul>
</li>
<li>政治（晚上八点以后）<ul>
<li>徐涛强化班 马原每天 2 ~ 3 课</li>
<li>政治刷题小程序刷响应的题</li>
</ul>
</li>
</ul>
<p>九月，冲冲冲！</p>
</blockquote>
<h3 id="9-13-10-3"><a href="#9-13-10-3" class="headerlink" title="9.13 ~ 10.3"></a>9.13 ~ 10.3</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>880 所有章节综合题部分全部刷完</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>计网二轮过完</li>
<li>计网强化课（传输层、网络层大题）</li>
<li>操作系统大题（进程同步与互斥、页式存储管理与虚拟存储器、文件系统大题）</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>每天单词 x 400</li>
<li>真题 英二 2015、2014、2013</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>徐涛 马原强化班 + 小程序 1000 题 结束</li>
<li>徐涛 史纲强化班 + 小程序 1000 题 结束</li>
</ol>
<h3 id="9-10、9-11、9-12"><a href="#9-10、9-11、9-12" class="headerlink" title="9.10、9.11、9.12"></a>9.10、9.11、9.12</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 剩下线代部分全部做完</li>
<li>880 重点题 第一章 函数、极限、连续</li>
<li>每日一题 函数</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>计网</p>
<ul>
<li><p>3.4 流量控制和可靠传输</p>
<ul>
<li>滑动窗口：停等协议、后退 N 帧协议、选择重传协议</li>
</ul>
</li>
<li><p>3.5 介质访问控制</p>
<ul>
<li>信道划分：FDM、TDM、WDM、CDM</li>
<li>随机访问：ALOHA 协议、CSMA 协议、CSMA&#x2F;CD 协议、CSMA&#x2F;CA 协议</li>
<li>轮询访问</li>
</ul>
</li>
<li><p>3.6 局域网</p>
<ul>
<li><p>局域网概念</p>
</li>
<li><p>以太网 和 IEEE 802.3</p>
</li>
<li><p>WLAN 和 IEEE 802.11</p>
</li>
<li><p>令牌环网 和 IEEE 802.5</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>每日一题</p>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 300 x 3</li>
<li>真题<ul>
<li>2015Text4</li>
<li>2016Text1</li>
<li>2016Text2</li>
</ul>
</li>
</ol>
<h3 id="9-8、9-9"><a href="#9-8、9-9" class="headerlink" title="9.8、9.9"></a>9.8、9.9</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 线代部分：308 ~ 390</li>
<li>每日一题：二重积分</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>计算机网络二轮<ul>
<li>2.1 通信基础、2.2 介质传输、2.3 物理层设备、3.1 链路层功能、3.2 组帧、3.3 差错控制</li>
</ul>
</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 300 x 2</li>
<li>真题 <ul>
<li>2015Text2 能否在没有逮捕令的情况下搜查嫌犯手机内容（错两个）</li>
<li>2015Text3 自然杂志新添加了统计审查（错一个）</li>
</ul>
</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>徐涛强化班 唯物史观刚开始<ul>
<li>社会存在</li>
<li>社会意识</li>
</ul>
</li>
<li>小程序刷 1000 题</li>
</ol>
<h3 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 线代部分：276 ~ 307</li>
<li>每日一题：二重积分</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>计算机网络二轮<ul>
<li>1.1 计算机网络概念</li>
<li>1.2 计算机网络体系与参考模型</li>
</ul>
</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 300</li>
<li>真题 2015Text1 一个例子给王室成员的警示（错一个）</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li><p>小程序刷 1000 题</p>
</li>
<li><p>徐涛强化 三小节</p>
<ul>
<li>认识</li>
<li>实践</li>
<li>真理与价值</li>
</ul>
</li>
</ol>
<h3 id="9-6"><a href="#9-6" class="headerlink" title="9.6"></a>9.6</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>回顾线代辅导讲义<ul>
<li>矩阵</li>
</ul>
</li>
<li>每日一题</li>
<li>回顾高数笔记</li>
</ol>
<p>明天起开始刷 660 线代部分<del>和 880 的高数部分</del></p>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>操作系统二轮<ul>
<li>5.2 IO 核心子系统</li>
</ul>
</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 200</li>
<li>真题 2014Text4 缺乏文学素养的教育和 “问题的核心” （错一个）</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>小程序刷题</li>
<li>徐涛马原强化<ul>
<li><strong>认识的来源：实践</strong></li>
<li>认识的本质</li>
<li>认识的过程</li>
<li>认识的规律</li>
</ul>
</li>
</ol>
<h3 id="9-4、9-5"><a href="#9-4、9-5" class="headerlink" title="9.4、9.5"></a>9.4、9.5</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>回顾线代辅导讲义<ul>
<li>行列式</li>
<li>矩阵</li>
</ul>
</li>
<li>回顾高数辅导讲义<ul>
<li>微分方程解法</li>
</ul>
</li>
<li>每日一题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>操作系统二轮 5.1 IO 概述</p>
</li>
<li><p>每日一题</p>
</li>
<li><p>计组知识点总结</p>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 200 x 2</li>
<li>真题<ul>
<li>2014 Text2 新设立的一些企业家资助的科学奖项（错两个）</li>
<li>2014 Text3 美国法律专业的问题和解决方法（错一个）</li>
</ul>
</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>徐涛马原强化课<ul>
<li>12 质量互变规律<ul>
<li>质、量、度</li>
<li>质变、量变</li>
</ul>
</li>
<li>13 否定之否定<ul>
<li>自我否定</li>
<li>扬弃</li>
<li>两次否定</li>
<li>螺旋上升</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="9-1、9-2、9-3"><a href="#9-1、9-2、9-3" class="headerlink" title="9.1、9.2、9.3"></a>9.1、9.2、9.3</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>回顾线代辅导讲义例题</li>
<li>每日一题</li>
<li>回顾高数辅导讲义例题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>OS 4.1 文件系统基础、4.2 文件系统实现（文件这一章有难度）</li>
<li>每日一题</li>
<li>王道操作系统强化课第一节（暂时感觉用处不大，还是继续啃王道书吧）</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 300 x 3</li>
<li>真题<ul>
<li>2013 Text3 人类光明的前途（错一个）</li>
<li>2013 Text4 亚利桑那州法案违反联邦权威（错一个，近十年 top3 难）</li>
<li>2014 Text1 对失业者领取救济金设限（错两个）</li>
</ul>
</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>马原徐涛强化<ul>
<li>总论和哲学基本问题</li>
<li>唯物论——物质观</li>
<li>唯物论——意识观</li>
<li>辩证法的两大总特征</li>
<li>辩证法五队范畴</li>
</ul>
</li>
<li>小程序断断续续刷题</li>
</ol>
<h1 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h1><blockquote>
<p>八月总结：</p>
<ul>
<li>数学<ul>
<li>600 刷完：√</li>
<li>660 复盘：×</li>
<li>坚持每日一题：√</li>
<li>线性代数强化（十讲）：√</li>
<li>回顾强化班高数辅导讲义例题：√</li>
</ul>
</li>
<li>408<ul>
<li>计组二轮：√</li>
<li>计组笔记：整理中</li>
<li>OS 二轮：复习中，已过半</li>
<li>每日一题：√</li>
</ul>
</li>
<li>英语<ul>
<li>每日单词：√ （6240&#x2F;6642，差不多结束）</li>
<li>阅读真题：√ （到 2013年Text2）</li>
</ul>
</li>
</ul>
<p>总体按计划稳步推进，但是效率还是不够高，浪费了很多时间</p>
<ul>
<li>早起以后光看新闻热搜了！</li>
<li>睡太迟或者没睡着导致第二天没状态，还要补觉</li>
<li>浪费很多时间在刷 知乎 和 b站上</li>
</ul>
</blockquote>
<blockquote>
<p>八月计划：</p>
<ul>
<li><p>数学（每天 4 - 5 个小时）</p>
<ol>
<li><p>八月中下旬（20号之前）刷完 660</p>
</li>
<li><p>20 号左右进行一次 660 的复盘整理，之后开始刷 880（重做画星号的题，同时做还没做的题）</p>
<p> （计划有变，880 先放一放，先把线代强化过了，预计十天解决）</p>
</li>
<li><p>坚持每日一题</p>
</li>
<li><p>刷题同时回顾强化班讲的例题</p>
</li>
</ol>
</li>
<li><p>408 （每天 3 - 4 个小时）</p>
<ol>
<li>计组约 20 小节，每天过 1 - 2 小节，月中下旬结束计组二轮复习。（复习过程中整理计组笔记）</li>
<li>计组复习结束后开始操作系统二轮复习，操作系统约 20 小节，同样每天 1 - 2 小节，在看计组中相对应的章节时回顾计组的内容。（同样边复习边整理笔记）</li>
<li>坚持刷每日一题。</li>
</ol>
</li>
<li><p>英语</p>
<ol>
<li>单词每天 300 个，差不多月底过完这一轮。</li>
<li>英一阅读真题每天一篇，看完后看唐迟视频或者自己翻译原文，到月底差不多进行到 2014 年。</li>
</ol>
</li>
</ul>
<p>每周周末坚持进行周末复盘！</p>
<p>八月，冲冲冲！</p>
</blockquote>
<h3 id="8-30"><a href="#8-30" class="headerlink" title="8.30"></a>8.30</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>线性代数强化 第八讲<ul>
<li>线性方程公共解的两种题型</li>
<li>线性方程同解<ul>
<li>$r(A)&#x3D;r(B)$</li>
<li>$AA^Tx&#x3D;0$ 与 $Ax&#x3D;0$ 通解</li>
</ul>
</li>
<li>方程组的应用<ul>
<li>$AX&#x3D;B$，求 $X$</li>
</ul>
</li>
<li>特征值和特征向量的求法（具体和抽象两种）<ul>
<li>三角矩阵：$λ_i&#x3D;a_{ii}$</li>
<li>$r(A)&#x3D;1$：$λ_1&#x3D;tr(A),λ_i&#x3D;0 \ (i≠1)$</li>
</ul>
</li>
<li>矩阵 $A$ 的特征值及其逆、伴随矩阵等等的特征值之间的关系</li>
</ul>
</li>
<li>每日一题</li>
<li>回顾高数辅导讲义<ul>
<li>定积分相关证明题<ul>
<li>$f(x)&#x3D;\int_0^x f^&#96;(t)dt$</li>
<li>拉格朗日</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>每日一题</li>
<li>操作系统二轮 3.2 虚拟内存管理<ul>
<li>请求分页管理方式（页表机制、缺页中断机构、地址变换机构）</li>
<li><strong>页面置换算法</strong><ul>
<li>OPT</li>
<li>FIFO</li>
<li>LRU（选择题技巧）</li>
<li>CLOCK</li>
</ul>
</li>
<li>页面分配策略<ul>
<li>固定分配局部置换</li>
<li>可变分配全局置换</li>
<li>可变分配局部置换（最优）</li>
</ul>
</li>
<li>抖动</li>
<li><strong>地址翻译</strong>（<strong>重中之重</strong>）</li>
</ul>
</li>
<li>计组笔记整理 3.7 虚拟存储器（与 OS 对应整理）</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 300</li>
<li>2013Text1 对快速消费产业的批评（全 √）<ul>
<li>否定 + 比较级 &#x3D; 最高级</li>
<li>dirt-cheap 非常便宜</li>
<li>feverish 发烧的，<strong>极度兴奋的，狂热的</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>政治</p>
</blockquote>
<ol>
<li>小程序刷题：马原和史纲 day1</li>
</ol>
<h3 id="8-25、8-26、8-27、8-28"><a href="#8-25、8-26、8-27、8-28" class="headerlink" title="8.25、8.26、8.27、8.28"></a>8.25、8.26、8.27、8.28</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>线性代数强化 第四讲~第七讲</p>
<ul>
<li><p>正交矩阵  $AA^T&#x3D;E$</p>
</li>
<li><p>向量的线性相关与线性无关证明<br>  $$<br>  k_1 \alpha_1 + k_2 \alpha_2 +…+k_s \alpha_s&#x3D;0<br>  $$</p>
<ul>
<li>同乘或重组</li>
<li>求秩</li>
<li>反证法</li>
</ul>
</li>
<li><p>线性表出（联系齐次方程组）</p>
</li>
<li><p>极大无关组</p>
</li>
<li><p>重要定理</p>
<ul>
<li><strong>部分相关，整体相关</strong></li>
<li><strong>低维无关，高维无关</strong></li>
<li><strong>多被少表多相关，少被多表少无关</strong></li>
<li>……</li>
</ul>
</li>
<li><p>向量的秩</p>
</li>
<li><p>求解齐次和非齐次线性方程组（解的结构）</p>
</li>
<li><p>有解判定定理</p>
</li>
<li><p><strong>齐次方程组基础解系线性无关向量个数</strong>：$n-r(A)$</p>
</li>
</ul>
</li>
<li><p>每日一题</p>
<ul>
<li>$\int {ln(1+e^x) \over e^x} dx$</li>
<li><strong>区间再现法</strong></li>
</ul>
</li>
<li><p>回顾高数辅导讲义</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>每日一题</li>
<li>操作系统 <ul>
<li><strong>2.3 进程同步（核心！）</strong><ul>
<li>临界资源</li>
<li>同步与互斥</li>
<li>实现临界区互斥：单标志法、双标志法先检查、双标志法后检查、Pterson 算法</li>
<li>中断屏蔽方法、硬件指令方法（TestAndSet、Swap）</li>
<li>信号量</li>
<li>管程</li>
</ul>
</li>
<li><strong>2.4 死锁（重要！）</strong><ul>
<li>概念</li>
<li>产生原因</li>
<li>产生条件（互斥条件、不剥夺条件、请求并保持条件、循环等待条件）</li>
<li>处理策略<ul>
<li>死锁预防（破坏四个死锁产生条件）</li>
<li>死锁避免（银行家算法，避开不安全序列）</li>
<li>死锁检测与解除（资源图法）</li>
</ul>
</li>
</ul>
</li>
<li><strong>3.1内存管理概念（核心！）重点关注页式存储管理</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 300 x 4</li>
<li>真题<ul>
<li>2011Text4 父母受名流养孩子影响而对养孩子产生误解 （错两个）</li>
<li>2012Text1 peer pressure（全对）</li>
<li>2012Text2 Entergy 公司不讲信用（错一个）</li>
<li>2012Text3 科学证明的过程（错一个）</li>
</ul>
</li>
</ol>
<h3 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>李永乐线性代数强化第三讲</p>
<ul>
<li><p>矩阵的初等变换（<strong>左行右列</strong>）</p>
</li>
<li><p>特数矩阵的 n 次方</p>
<ul>
<li>秩为一（分解成一个行向量和一个列向量相乘）</li>
<li>三角矩阵且对角线元素为零</li>
<li>相似矩阵</li>
</ul>
</li>
<li><p>伴随矩阵</p>
<ul>
<li><p>$AA^{\star}&#x3D;|A|E$</p>
</li>
<li><p>矩阵的秩与其伴随矩阵秩的关系</p>
</li>
</ul>
</li>
<li><p>可逆矩阵</p>
<ul>
<li><p>$r(A) &#x3D; n \ |A|&#x3D;0$​</p>
</li>
<li><p>单位矩阵变换</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高数辅导讲义例题回顾（不定积分的计算）</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>操作系统 2.2 处理机调度<ul>
<li>调度的概念、类型</li>
<li>调度算法的性能指标</li>
<li>典型的调度算法</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 300</li>
<li>真题 2011Text3 传统付款媒体的转变 （错 1 个，主旨题）</li>
</ol>
<h3 id="8-23"><a href="#8-23" class="headerlink" title="8.23"></a>8.23</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>李永乐线性代数强化第二讲</p>
<ul>
<li><p>证 $|A|&#x3D;0$ 的各种方法</p>
<ul>
<li>$r(A)&lt;n$</li>
<li>齐次方程组 $Ax&#x3D;0$ 有非零解</li>
<li>反证法，假设 $|A|≠0$</li>
<li>0 是 $A$ 的特征值</li>
<li>$|A|&#x3D;-|A|$（行列式是一个数）</li>
</ul>
</li>
<li><p>克拉默法则及其推论</p>
<ul>
<li>齐次方程组系数行列式不等于0 &lt;&#x3D;&gt; 方程只有零解</li>
<li>齐次方程组系数行列式等于0     &lt;&#x3D;&gt; 方程有非零解</li>
</ul>
</li>
<li><p>代数余子式求和</p>
<p>  $A_{ij}$ 的取值与 $a_{ij}$ 无关</p>
</li>
<li><p>矩阵乘法没有交换律，也不能乱消</p>
</li>
<li><p>伴随矩阵：代数余子式所构成的矩阵<br>  $$<br>  AA^{\ast}&#x3D;|A|E<br>  $$</p>
</li>
<li><p>2 阶矩阵的伴随矩阵：主对角元素互换，副对角元素变号</p>
</li>
<li><p>$A_{n\times m}, ; B_{m \times n},;AB&#x3D;O;$, 则有 $r(A)+r(B)\le m$​</p>
</li>
<li><p>n 阶分块矩阵、分块矩阵的逆</p>
</li>
<li><p>$\alpha^{T}\alpha$，$\alpha\alpha^T$​</p>
</li>
</ul>
</li>
<li><p>回顾周末做的阶段测试卷错题</p>
</li>
<li><p>回顾高数讲义，不定积分例题</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ul>
<li><p>操作系统（来到了操作系统的核心章节 进程管理）</p>
<p>  2.1 进程与线程</p>
<ul>
<li>进程的概念、特征</li>
<li>进程的状态（创建、就绪、运行、阻塞、结束）、状态切换</li>
<li>进程控制</li>
<li>进程组织、进程通信（共享存储、消息传递、管道通信）</li>
<li>线程的概念</li>
</ul>
</li>
</ul>
<blockquote>
<p>英语</p>
</blockquote>
<ul>
<li>墨墨单词 x 300</li>
<li>真题 2011Text2 高管没有找好下家的情况下跳槽（全对！）</li>
</ul>
<h3 id="8-21"><a href="#8-21" class="headerlink" title="8.21"></a>8.21</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>李永乐线性代数强化第一讲</li>
<li>高数辅导讲义例题回顾</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>操作系统 第一章 计算机系统概述</li>
<li>计组  第一章 总结</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 300</li>
<li>真题 2011Text1 纽约爱乐乐团新任指挥（错2，词汇！unpretentious）</li>
</ol>
<h3 id="8-17、8-18、8-19、8-20"><a href="#8-17、8-18、8-19、8-20" class="headerlink" title="8.17、8.18、8.19、8.20"></a>8.17、8.18、8.19、8.20</h3><blockquote>
<p>高数</p>
</blockquote>
<ol>
<li>660 541-610（660 高数部分，拿下）</li>
<li>每日一题（有空就做）</li>
<li>高数辅导讲义回顾（第二章 一元函数微分学 结束）</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>舒服计组</p>
<ul>
<li><p>第七章 IO系统 结束（计组二轮，拿下！）</p>
</li>
<li><p>整理第七章知识点</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 300 x 4</p>
</li>
<li><p>真题 2010Text1（错 2）、真题 2010Text2（错 3）、真题 2010Text3（错 2）、真题 2010Text4（错 1）</p>
<p> 真题从 2010 开始分英语一和英语二后，英语一题目难度感觉有明显的提升了（好多第一遍读不懂）</p>
</li>
</ol>
<h3 id="8-16"><a href="#8-16" class="headerlink" title="8.16"></a>8.16</h3><blockquote>
<p>高数</p>
</blockquote>
<ol>
<li><p>660 518-541 </p>
<p> 导数定义相关的题</p>
</li>
<li><p>每日一题 </p>
<p> 两道求解微分方程的题</p>
</li>
<li><p>回顾高数辅导讲义</p>
<ul>
<li><p>极值点和拐点的充分条件、必要条件</p>
</li>
<li><p>渐近线、曲率</p>
</li>
<li><p>一堆导数应用相关题目</p>
<p>  连续性、可导性、极值点、拐点、渐近线、方程的根、证明函数不等式</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>数据结构应用题</p>
<p> 用给定数组中的元素建堆，并根据堆排序从小到大输出元素</p>
</li>
<li><p>舒服计组</p>
<ul>
<li><p>6.4 总线标准</p>
<p>  ISA、EISA、、VEAS、PCI、PCI-Express、AGP、RS-232C、USB……</p>
</li>
<li><p>整理 第六章 总线 知识点</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 150</li>
<li>词根词缀 x 30min</li>
<li>真题 2009Text4 新英格兰人追求智慧（错一个）</li>
</ol>
<h3 id="8-13、8-14"><a href="#8-13、8-14" class="headerlink" title="8.13、8.14"></a>8.13、8.14</h3><blockquote>
<p>高数</p>
</blockquote>
<ol>
<li><p>660 491-517</p>
<ul>
<li><strong>函数在某点处连续不能说明在该点的去心邻域内连续</strong></li>
</ul>
</li>
<li><p>每日一题</p>
<p> 可分离变量的微分方程求通解</p>
</li>
<li><p>辅导讲义回顾</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><strong>链路层功能</strong>：物理地址寻址、数据封装成帧、流量控制、差错检验、数据的校验重发等</li>
<li><strong>RAM 引脚</strong>一般包括数据线、地址线、片选端和读写控制线</li>
</ul>
</li>
<li><p>死亡计组</p>
<ul>
<li><p>继续整理第五章知识点 √</p>
</li>
<li><p>6.1 总线概述</p>
<ul>
<li><p>总线的基本概念</p>
<p>  总线猝发性传输：在一个总线周期内传输存储地址连续的多个数据字的总线传输方式。（连续地址的数据传输时只需要传送第一个数据所在的地址）</p>
</li>
<li><p>总线的分类</p>
</li>
<li><p>总线的结构</p>
</li>
<li><p>总线的性能指标</p>
</li>
</ul>
</li>
<li><p>6.2 总线仲裁不考跳过</p>
</li>
<li><p>6.3 总线操作和定时</p>
<ul>
<li><p>总线的传输周期</p>
</li>
<li><p>同步定时方式</p>
</li>
<li><p>异步定时方式</p>
<p>  不互锁方式、半互锁方式、全互锁方式</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>单词 x 300</p>
</li>
<li><p>真题 2009Text1 新习惯的形成有利于创造力（错 1 个）</p>
<p> 真题 2009Text2 基因检测和存在的问题（错 2 个）</p>
</li>
</ol>
<h3 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 476-490<ul>
<li>用极坐标方程求旋转体表面积、体积</li>
<li>$\int {1 \over 1+sin^2x}dx$​</li>
<li><strong>遇到 $F(x)f(x)$​ 的往 ${[F^&#96;(x)]}^2$​​​ 上想</strong>，注意观察结构</li>
<li>计算计算计算！</li>
<li>$\int_0^1 x {arcsinx \over (x+1)^{1 \over 2}}dx$​</li>
</ul>
</li>
<li>回顾高数讲义<ul>
<li>连续、可导、可微的关系</li>
<li>隐函数求导公式、反函数求导公式</li>
<li>高阶导数（3 个）</li>
<li>给定极限式判断导函数是否存在类问题</li>
<li>$f(x)&#x3D;\phi(x)|x-a|$ 在 $x&#x3D;a$ 处可导的充要条件</li>
<li>函数与其绝对值函数之间可导性的关系</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>数据结构应用题</p>
<p> 求各个排序第一躺排序后的结果</p>
</li>
<li><p>死亡计组</p>
<ul>
<li>指令流水线三道大题（整体难度不打）<ul>
<li>对某单元操作后单元内的内容</li>
<li>流水线执行 n 条指令所需要的时钟周期</li>
<li>条件转移指令地址偏移量 <code>offset</code> 值的计算</li>
<li>与 Cache 相结合</li>
</ul>
</li>
<li>回顾整理第五章知识点</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 400</li>
<li>真题 2008Text4（错 2 个）</li>
</ol>
<h3 id="8-11"><a href="#8-11" class="headerlink" title="8.11"></a>8.11</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 461-475 积分和不定积分<ul>
<li>$\int {dx \over \sqrt{(x-a)(b-x)}}$​​​</li>
</ul>
</li>
<li>每日一题  抽水做工</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>每日一题</li>
<li>死亡计组<ul>
<li>5.4 控制器的功能和原理<ul>
<li>硬布线控制器</li>
<li>微程序控制器</li>
<li>二者对比</li>
</ul>
</li>
<li>5.5 指令流水线<ul>
<li>$t&#x3D;(k+n-1)*T$</li>
<li>时空图</li>
<li>资源冲突、数据冲突（旁路技术）、控制冲突</li>
<li>性能指标（吞吐率、加速比、效率）</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题 2008Text3 美国人的身高到达极限（错一个）</li>
</ol>
<h3 id="8-10"><a href="#8-10" class="headerlink" title="8.10"></a>8.10</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 446-460<ul>
<li>用泰勒展开求高阶导数</li>
<li>变上限积分想办法先换元再求导（没有条件创造条件）</li>
<li>注意细节处理！</li>
</ul>
</li>
<li>回顾 880 错题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>死亡计组 开始第五章 CPU</p>
<ul>
<li><p>5.1 CPU 的功能和基本结构</p>
<ul>
<li><p>运算器（ALU、暂存寄存器、ACC、通用寄存器组、PSW、移位器、计数器）</p>
</li>
<li><p>控制器（PC、IR、指令译码器、MAR、MDR、时序系统、微操作信号发生器）</p>
</li>
<li><p>对程序员不透明的寄存器：MAR、MDR、PC、PSW、通用寄存器组</p>
</li>
</ul>
</li>
<li><p>5.2 指令执行过程</p>
<ul>
<li>指令周期、机器周期（CPU 周期）、时钟周期</li>
<li>取指周期、间指周期、执行周期、中断周期</li>
</ul>
</li>
<li><p>5.3 数据通路的功能和基本结构 （两道大题）</p>
<ul>
<li>根据给出的要求指出指令功能及信号</li>
<li>程序员可见寄存器</li>
<li>设置暂存寄存器的目的（单总线结构）</li>
<li>三态门</li>
<li>线路连接（还是考察指令的执行流程）</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 400</p>
</li>
<li><p>真题 2008Text2 一种新的论文出版方式（错两个）</p>
<p> $In\ general\ routine\ of\ every\ day$</p>
</li>
</ol>
<h3 id="8-8"><a href="#8-8" class="headerlink" title="8.8"></a>8.8</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 426-445 正式开始 660 高数2阶<ul>
<li>用拉格朗日求极限时注意 $\xi$ 的取值，不要想当然的带 1</li>
</ul>
</li>
<li>每日一题<ul>
<li>心形线的面积</li>
<li>闸门受水压力</li>
</ul>
</li>
<li>回顾 880 错题</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<p> <code>TODO</code> 移码取相反数后什么时候会溢出？</p>
</li>
<li><p>死亡计组</p>
<ul>
<li>指令寻址的大题</li>
<li>CISC 和 RISC</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 400</li>
<li>真题 2008Text1 女性压力 （拿下！）</li>
</ol>
<h3 id="8-7"><a href="#8-7" class="headerlink" title="8.7"></a>8.7</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660 252-275 （基础篇高数部分拿下）</p>
<ul>
<li>积分区间相同，被积函数越大，积分值越大</li>
<li>$\int sec^3 \theta d\theta$​</li>
</ul>
</li>
<li><p>每日一题</p>
<p> 求曲线围成区域面积及旋转体体积</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><strong>OSI 参考模型上三层：会话层、表示层、应用层</strong></li>
</ul>
</li>
<li><p>数据结构应用题</p>
<ul>
<li><strong>二分查找判定树</strong></li>
<li>查找关键字的比较次数</li>
<li>平均查找长度</li>
</ul>
</li>
<li><p>计组</p>
<ul>
<li><p>Cache 和虚拟存储器结合的大题一道（2016真题 easy）</p>
</li>
<li><p>4.1 指令格式</p>
<ul>
<li>拓展操作码技术</li>
</ul>
</li>
<li><p>4.2 指令寻址方式</p>
<ul>
<li>各寻址方式特点</li>
<li>有效地址计算</li>
<li>区分相对寻址、基址寻址、变址寻址</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 100</li>
</ol>
<h3 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h3><p>昨天 utools 玩了半天，今天期待了好久的 fexcil 上架了，感觉又能研究半天！</p>
<blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660 234-251</p>
<ul>
<li>隐函数求导公式</li>
<li>偏导连续 &#x3D;&#x3D;》可微 &#x3D;&#x3D;》偏导存在</li>
<li>给抽象函数的问题可以优先考虑<strong>特殊函数法</strong></li>
<li>一般情况下，二元极限低次比高次为无穷，同次相比极限不存在，高次比低次极限存在</li>
</ul>
</li>
<li><p>错题回顾 880</p>
<ul>
<li>$\lim\limits_{n \to \infty}a^{1 \over n}&#x3D;1$</li>
<li>界值定理</li>
<li>数列极限类题目用夹逼定理求极限（先斩后奏）</li>
</ul>
</li>
<li><p>每日一题<br> $$<br> I&#x3D;\int_{1}^{+\infty}{dx \over e^{1+x} + e^{3-x}}<br> $$</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><p><strong>$O(n)$​ 是指执行时间与 $n^2$​ 成正比</strong></p>
</li>
<li><p>网络拓扑结构中，<strong>星型网络具有一定集中控制功能</strong>，因为端用户之间的通信必须经过中心站</p>
</li>
<li><p>十进制转二进制别忘了<strong>符号位</strong>！</p>
</li>
</ul>
</li>
<li><p>数据结构应用题 散列查找</p>
<ul>
<li>绘图画出表格，给出<strong>关键字和索引地址</strong></li>
<li><strong>装填因子</strong>：哈希表中元素个数 &#x2F; 哈希表表长</li>
<li><strong>查找不成功平均长度</strong>：从 0 到 n 每个地址都要过一遍！</li>
<li><strong>拉链法空节点不算一次查找，而线性探测法算</strong> 🧡</li>
</ul>
</li>
<li><p>死亡计组</p>
<ul>
<li><p>回顾两道 Cache 大题，新做一道</p>
<ul>
<li><strong>Cache 行标记项：有效位、脏位、替换控制位、标记位</strong></li>
</ul>
</li>
<li><p>3.7 虚拟存储器</p>
<p>  重点掌握<strong>从虚拟地址到物理地址的映射</strong>、<strong>快表的查询</strong>、<strong>物理地址在 Cache 中的划分</strong>，做了两道大题，都还ok，难度没有纯 Cache 的大</p>
<ul>
<li><p>页式虚拟存储器（页表、快表、快表-Cache多级存储系统）</p>
</li>
<li><p>段式虚拟存储器</p>
</li>
<li><p>段页式虚拟存储器</p>
</li>
<li><p>Cache 与 快表的区别</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题 2007Text4  企业重视数据安全（错 1 个）</li>
</ol>
<h3 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660 211-233</p>
<ul>
<li><p>判断给定二元函数连续、可导、可微的方法</p>
</li>
<li><p>判断二元极限是否存在（放缩、设 k）</p>
</li>
<li><p>微分算子法求特解</p>
</li>
<li><p>齐次方程<strong>线性无关特解</strong>$y_1,y_2$​，$y&#x3D;C_1y_1+C_2y_2$​</p>
</li>
</ul>
</li>
<li><p>错题回顾</p>
<ul>
<li>证明 $f(x)$ 可以写成一个奇函数和一个偶函数的和</li>
<li>多项式和的极限（定积分、夹逼定理）</li>
<li>多项式乘积的极限（取对数、夹逼定理）</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><p><strong>数据有序</strong>的顺序表中才可以用折半查找法</p>
</li>
<li><p><strong>键盘和计算机之间的通信是全双工的</strong>（显示终端代有键盘，键盘输入字符到内存，内存信息可以送到屏幕显示，两个过程可以同时进行）</p>
</li>
<li><p>一次性请求所有资源：预防死锁</p>
<p>  强占其他进程已占资源：解除死锁</p>
<p>  提高进程优先级：解除死锁</p>
<p>  采用资源分配拒绝策略（银行家算法）：避免死锁</p>
</li>
</ul>
</li>
<li><p>计组 Cache两道真题</p>
<ul>
<li>Cache 的总容量</li>
<li>xxx 对应 Cache 的行号</li>
<li>二维数组按行访问和按列访问的访问命中率</li>
<li>时钟周期、带宽</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题2007Text3（全对，拿下！）<ul>
<li>技巧<ul>
<li>有 may 的 90% √</li>
<li>有比较级的很有可能是错的</li>
</ul>
</li>
<li>词汇<ul>
<li>fair play：公平竞争</li>
<li>pink slip：解雇信、辞退信</li>
<li>outweigh：比……重要、比……有价值</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 208-210<ul>
<li><strong>曲线质心公式</strong>和<strong>封闭区域质心公式</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
</li>
<li><p>计组</p>
<p> 继续啃高速缓存，做了课后小题，但是感觉理解还是不到位（Cache 和 主存的映射）</p>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>单词 x 400</li>
</ol>
<h3 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660 191-207<ul>
<li>$F(x)&#x3D;\int_0^xf(t)dt$ 一定连续！</li>
<li>$f(x)$​ 为周期函数，$F(x)$​ 也为周期函数的充要条件是 $\int_0^Tf(x)dx&#x3D;0$​ </li>
<li>积分 $\int_{-\infty}^{+\infty}f(x)dx$ 存在判定</li>
<li>极坐标下的弧长公式</li>
</ul>
</li>
<li>武忠祥每日一题<ul>
<li>反常积分敛散性：定义、P 积分、比较法</li>
</ul>
</li>
<li>回顾高数辅导讲义例题（求极限）</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><strong>转发器</strong>实现物理层的连接，对衰弱的信号放大整形或再生，起拓展网段的作用</li>
<li><strong>网桥</strong>通过 MAC 地址寻址，<strong>路由器</strong>通过 IP 地址寻址</li>
<li>网络层以上的中继系统统称为<strong>网关</strong></li>
<li><strong>重定位</strong>是实现多道程序在内存中同时运行的基础</li>
<li>中断方式的特点：CPU 与 外设并行工作，传送与主程序串行工作</li>
</ul>
</li>
<li><p>数据结构应用题</p>
<ul>
<li>关键路径</li>
<li>Dijkstra 算法</li>
</ul>
</li>
<li><p>计组</p>
<ul>
<li><p>3.5 双端口 RAM 及多模块存储器</p>
<ul>
<li><p>双端口 RAM</p>
</li>
<li><p>多体并行存储器</p>
<p>  高位交叉编址：$t&#x3D;mT$</p>
<p>  低位交叉编址：$t&#x3D;T+(m-1)r$</p>
</li>
</ul>
</li>
<li><p>3.6 高速缓冲存储器（映射方式没弄明白，明天继续啃）</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题 2007Text2  IQ测试并不是很合理（全对，拿下！）</li>
</ol>
<h3 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660  174-190</p>
<ul>
<li><p>原函数存在定理（3 条）</p>
</li>
<li><p>$f(x)$ 在 $(a,b)$ 上可积的充分条件（3 条）——》 <strong>有无穷积不了</strong></p>
</li>
<li><p>比较定理（2 条）（<strong>可积不一定连续！</strong>）</p>
</li>
<li><p>可以记的结论：<br>  $$<br>  \int_{0}^{\pi\over2}{sinx \over x} &lt; \int_{0}^{\pi\over2}{tanx \over x} &lt; 1<br>  $$</p>
</li>
</ul>
</li>
<li><p>没顾得上每日一题和回顾高数讲义</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li>STMP 协议用于控制<strong>邮件发送及中转方式</strong>，POP3 及 IMAP 协议用于控制<strong>接受邮件</strong></li>
</ul>
</li>
<li><p>数据结构应用题</p>
<ul>
<li>图的邻接矩阵、邻接表、Prim 算法、Kruskal 算法</li>
<li>由邻接矩阵画图，并求关键路径</li>
</ul>
</li>
<li><p>计组（正式进入第三章 存储系统）</p>
<ul>
<li><p>3.1 存储器概述</p>
<ul>
<li><p>存储器分类（层次、存储介质、存取方式、信息可保存性）</p>
<p>  注意区分<strong>顺序存取存储器</strong>和<strong>直接存取存储器</strong></p>
</li>
<li><p>存储器性能指标（存储容量、单位成本、存储速度）</p>
<p>  注意区分<strong>存取时间</strong>与<strong>存取周期</strong></p>
</li>
</ul>
</li>
<li><p>3.2 存储器的层次化结构</p>
<ul>
<li><p>Cache-主存：</p>
<p>  解决 CPU 和主存速度不匹配问题，对所有程序员透明</p>
</li>
<li><p>主存辅存：</p>
<p>  解决存储容量问题，对应用程序员透明</p>
</li>
</ul>
</li>
<li><p>3.3 半导体随机存储器</p>
<ul>
<li>SRAM</li>
<li>DRAM</li>
<li>只读存储器</li>
</ul>
</li>
<li><p>3.4 主存储器与 CPU 的连接</p>
<ul>
<li>位拓展法</li>
<li>字拓展法</li>
<li>字位拓展法</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 400</li>
<li>真题 2007Text1 Pracice make perfect （错 3 个啊啊啊，中套了）</li>
</ol>
<h1 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h1><h3 id="7-30、7-31"><a href="#7-30、7-31" class="headerlink" title="7.30、7.31"></a>7.30、7.31</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660 138-173</p>
<ul>
<li><p>有界性的三个判定条件</p>
</li>
<li><p>$f(x)$ 与 $|f(x)|$ 可导性的关系</p>
</li>
<li><p>单调性判定（凹凸性）</p>
</li>
</ul>
</li>
<li><p>每日一题 x 4</p>
<ul>
<li>变积分函数能积出来就先积出来</li>
</ul>
</li>
<li><p>整理笔记</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li>两台主机建立好 TCP 连接，发送 TCP 段时返回的确认号是指期望收到的序号，如果中间有丢失，则确认号一直停留在期望收到的序号。</li>
<li>在以太网中，访问一个主机中的一个进程需要使用：IP 地址和传输层协议端口号（套接字）</li>
<li>容量 <code>64K x 8bit</code> 的意义</li>
</ul>
</li>
<li><p>数据结构应用题</p>
<ul>
<li>队列</li>
<li>BST、AVL、哈夫曼树</li>
</ul>
</li>
<li><p>计组 浮点数的表示与运算（两天时间啃下来弄明白）</p>
<ul>
<li><p>规格化浮点数目的：提高运算精度，充分利用位数的有效位数</p>
</li>
<li><p>原码规格化：</p>
<ul>
<li>正数：最大 0.111…1，最小 0.100…0</li>
<li>负数：最大 1.100…0，最小 1.111…1</li>
</ul>
</li>
<li><p>补码规格化：</p>
<ul>
<li>正数：最大 0.111…1，最小 0.100…0</li>
<li>负数：最大 1.011…1，最小 1.000…0（-1）</li>
</ul>
</li>
<li><p><strong>当浮点数基数为 2 时，原码规格化的尾数最高位一定是1，补码规格化的尾数的最高位最高位一定与符号位相反</strong></p>
</li>
<li><p><strong>当基数为 4 时，原码规格化形式尾数最高两位至少有一个 1</strong></p>
</li>
<li><p>IEEE 754（重点掌握🧡）</p>
</li>
<li><p>浮点数加减法</p>
<ol>
<li>对阶</li>
<li>尾数求和</li>
<li>规格化</li>
<li>舍入（右规和对阶）</li>
<li>溢出判断</li>
</ol>
</li>
<li><p>浮点数类型转换</p>
<p>  $char-&gt;int-&gt;long-&gt;double$ ：从前到后范围和精度都从小到大，转换过程没有损失</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ul>
<li>墨墨单词 x 350</li>
<li>真题 2006Text4 传递虚假幸福的广告遍地的时代开始涌现出消极的艺术作品</li>
</ul>
<h3 id="7-29"><a href="#7-29" class="headerlink" title="7.29"></a>7.29</h3><blockquote>
<p>数学（8：30—12：00）</p>
</blockquote>
<ol>
<li>660 121-137 函数、极限</li>
<li>武忠祥每日一题 x 2</li>
</ol>
<blockquote>
<p>408 </p>
</blockquote>
<ol>
<li>每日一题<ul>
<li>$average_access_time &#x3D; t_{cache} * p + t_{memory} * (1-p)$，其中 p 是 Cache 命中率。</li>
</ul>
</li>
<li>数据结构算法题<ul>
<li>使用时间复杂度 $O(n)$，空间复杂度 $O(1)$，完成顺序表指定元素的删除：交换删除元素与数组末尾元素的值，同时减小数组的长度（双指针）</li>
</ul>
</li>
<li>计组<ul>
<li>C 语言数据类型转换<ul>
<li>有符号数和无符号数：强制类类型转换的结果保持位值不变，<strong>仅改变了解释这些位的方式</strong>。</li>
<li>大字长变量向小字长变量：<strong>高位截断，低位赋值</strong>。</li>
<li>小字长变量向大字长变量：<strong>位值相等，高位拓展为原数字的符号位</strong>。（char 类型转 int 高位补 0）</li>
</ul>
</li>
<li>数据的存储和排列<ul>
<li>大端和小端方式</li>
<li>数据按边界对其</li>
</ul>
</li>
<li>课后习题，没来得急更正</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li>墨墨单词 x 350</li>
<li>真题 2006 Text2：莎士比亚小镇 （错 1 个）</li>
</ol>
<h3 id="7-28"><a href="#7-28" class="headerlink" title="7.28"></a>7.28</h3><blockquote>
<p>数学（8：30—12：00、2：30—3：00）</p>
</blockquote>
<ol>
<li><p>660 101-120 二重积分</p>
<ul>
<li>积分区域关于点对称的考虑把 x、y平移</li>
<li>极坐标表示的二重积分交换积分次序🧡</li>
</ul>
</li>
<li><p>武忠祥每日一题</p>
<ul>
<li><p>$\int\sqrt{1-sinx}dx &#x3D; \int\sqrt{sin^2{x \over 2}+cos^2{x \over 2}+2sin{x \over 2}cos{x \over 2}}$ （也可以直接有理化）</p>
</li>
<li><p>能换元的先换元</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>408（3：00—3：30，状态不好）</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><p>ICMP：主机与路由器之间传递控制信息。</p>
<p>  应用：PING、traceroute</p>
</li>
<li><p>SPOOLING（假脱机技术）：数据传入设备，设备忙则暂存数据，闲了再读取数据<strong>（空间换时间）</strong></p>
</li>
<li><p>虚拟存储技术：由程序的局部性原理，只将一部分程序调入内存，需要时再调入需要部分的程序。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 350</p>
</li>
<li><p>英语真题 2006 Text1（错 1 个，再读加搜词后改正）</p>
</li>
</ol>
<h3 id="7-27"><a href="#7-27" class="headerlink" title="7.27"></a>7.27</h3><blockquote>
<p> 数学（8：30 — 12：00、14：00—15：00）</p>
</blockquote>
<ol>
<li><p>660 85-100 多元函数微分学</p>
</li>
<li><p>武忠祥每日一题 x 2</p>
<ul>
<li>$ln(1+\sqrt{1+x^2})$ 、$ln {1-x \over 1+x}$ 、$e^x-1 \over e^x + 1$ 都是奇函数</li>
</ul>
</li>
<li><p>整理高数讲义知识点和题目</p>
</li>
</ol>
<blockquote>
<p>408（15：00—18：30）</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><strong>虚电路服务的目的地址仅在建立连接的时候使用</strong>，建立连接之后每个分组用长度较短的虚电路号</li>
<li>最佳置换算法（OPT）是指缺页率最小的算法，因为过于理想无法实现，仅用于与其他算法作比较</li>
</ul>
</li>
<li><p>数据结构应用题整理</p>
</li>
<li><p>计组</p>
<ul>
<li><p>2.1 数制与码制</p>
</li>
<li><p>2.2 定点数的表示与运算</p>
<p>  只看了定点数的表示、移位运算、加减运算，乘除考的不多且比较麻烦，暂时不打算看，留到最后吧</p>
<p>  <img src="/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%80%83%E7%A0%94%E5%A5%8B%E6%96%97%E6%97%A5%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%81/image-20210801162714005.png" alt="image-20210801162714005"></p>
<ul>
<li><strong>移码就是补码符号位不变其他位取反</strong></li>
<li><strong>逻辑位移都添0</strong></li>
<li><strong>算术位移原码添0，反码添1，补码左移添0，右移添1</strong></li>
<li>补码顶点加减运算判断溢出：<strong>单符号位、双符号位、一符号位一进位</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语 （20：40—22：00）</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 300</p>
</li>
<li><p>英语真题 2005 Text4（错 1 个）</p>
</li>
</ol>
<h3 id="7-24"><a href="#7-24" class="headerlink" title="7.24"></a>7.24</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li><p>660  62-72 </p>
<ul>
<li><p>不定积分计算</p>
</li>
<li><p>不定积分的应用（好多东西都忘了）</p>
<p>  不定积分求旋转体体积关于 x、y 轴堆成可以用微元法分析，关于其他轴对称直接用公式：$V &#x3D; 2\pi\iint r(x,y)d\sigma$）</p>
<p>  旋转体侧面积：$S &#x3D; 2\pi\int_{a}^{b} f(x)ds$ </p>
</li>
<li><p>分段函数求积分时注意积分区间！</p>
</li>
</ul>
</li>
<li><p>武忠祥每日一题 x 4</p>
<p> $\int x^narcsinxdx$ 之类的用换元 $x&#x3D;sint$ 做起来比分部积分更好算一点</p>
</li>
<li><p>整理典型题</p>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li>每日一题<ul>
<li>后序遍历也叫做后根遍历、后续周游</li>
<li>网卡工作在<strong>物理层</strong>和<strong>数据链路层</strong>，数据链路层都是用各个网卡的MAC地址，同时网卡控制着主机对介质的访问，因此也工作在物理层</li>
<li>进程的组成成分中，<strong>共享程序段</strong>在进程运行中不可修改。</li>
</ul>
</li>
<li>数据结构二轮复习 <ul>
<li>听王道强化课数据结构应用题部分</li>
<li>整理数据结构大题应用题的相关知识点（未完待续）</li>
</ul>
</li>
<li>计组二轮复习<ul>
<li>1.2 计算机系统层次结构<ul>
<li>对某一功能，既可以用软件也可以用硬件实现，称为<strong>软硬件在逻辑上是等效的</strong></li>
<li>硬件基本组成：<strong>运算器</strong>（<strong>ALU</strong>、<strong>ACC</strong>、<strong>MQ</strong>、<strong>X</strong>、IX、BR）、<strong>存储器</strong>（<strong>MAR</strong>、<strong>MDR</strong>）、<strong>控制器</strong>（<strong>CU</strong>、<strong>IR</strong>、<strong>PC</strong>）、输入设备、输出设备</li>
<li><strong>MAR</strong> 用于寻址，位数与<strong>存储单元个数</strong>对应（<strong>与PC相等</strong>）；<strong>MDR</strong> 用于存储数据，位数与<strong>存储字长</strong>对应</li>
<li>区分 DBMS 和 DBS</li>
<li>从源程序到可执行文件：<strong>预处理阶段</strong>、<strong>编译阶段</strong>、<strong>汇编阶段</strong>、<strong>链接阶段</strong></li>
<li>计算机硬件能直接执行的语言：<strong>机器语言</strong>（only！）</li>
<li><strong>存取速度：寄存器 &gt; Cache &gt; 内存</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨单词 x 300</p>
</li>
<li><p>2005真题 text2（错 1 个）</p>
</li>
</ol>
<h3 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h3><blockquote>
<p>数学</p>
</blockquote>
<ol>
<li>660  46-61  不定积分计算出大问题，好多手法都忘了，而且计算也垮，导致做题效率很低<ul>
<li>常用的一些换元（看见复杂根号直接换  t，还有各种根号平方换三角函数 ）</li>
<li>注意！三角函数定积分的一些结论不定积分不能乱用！</li>
<li>分子分母次数相差较多的可以考虑上下同乘 x 的某一次方</li>
</ul>
</li>
</ol>
<blockquote>
<p>408</p>
</blockquote>
<ol>
<li><p>每日一题</p>
<ul>
<li><p>采用哪种传输方式，由网络负责差错控制和流量控制，分组按顺序递交？            （虚电路分组交换）</p>
</li>
<li><p>操作系统两个最主要特性：并发性和共享性</p>
</li>
<li><p>周期挪用：是指利用 CPU 不访问存储器的周期来实现 DMA 操作，此时DMA可以使用总线而不用通知 CPU 也不会妨碍 CPU 工作。</p>
</li>
</ul>
</li>
<li><p>数据结构二轮复习</p>
<ul>
<li><p>8.5 归并排序和基数排序</p>
<ul>
<li>归并排序：时间复杂度 $O(nlog_2n)$ （最好最坏平均情况下都是） 空间复杂度 $O(n)$ <strong>稳定排序</strong></li>
<li>基数排序： 时间复杂度 $O(d(n+r))$  空间复杂度 $O(r)$  <strong>稳定排序</strong></li>
</ul>
</li>
<li><p>8.6 各种内部排序算法比较及应用</p>
<img src="【考研】考研奋斗日程记录！/image-20210725000312710.png" alt="image-20210725000312710"  />

<p>  <strong>算法稳定性：插冒归基</strong></p>
</li>
<li><p>8.7 外部排序（掌握的并不好，赌他不是重点，没认真看，后面再抓）</p>
<ul>
<li>外部排序方法</li>
<li>多路平衡树与败者树</li>
<li>置换-选择排序</li>
<li>最佳归并树</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>英语</p>
</blockquote>
<ol>
<li><p>墨墨背单词 x 300</p>
</li>
<li><p>2005年真题 text1 （错 1 个）</p>
</li>
</ol>
<h3 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h3><ul>
<li><p>数学</p>
<ol>
<li><p>660 28-45</p>
<p> 极值点是 x 的取值，不是一个点!</p>
</li>
<li><p>武忠祥每日一题</p>
<ul>
<li>注意 $1&#x2F;x$ 积分是 $ln(|x|)$ ！</li>
<li>微分中值证明题遇到两个不同的中值 η 和 ζ，需要两次拉格朗日或柯西证明。</li>
</ul>
</li>
</ol>
</li>
<li><p>408</p>
<ol>
<li><p>每日一题</p>
<ul>
<li>RIP 协议基于路由选择算法，OSPF 基于链路状态算法</li>
</ul>
</li>
<li><p>数据结构二轮复习</p>
<ul>
<li><p>8.3 交换排序：</p>
<p>  冒泡排序：空间复杂度 $O(1)$ ，时间复杂度 $O(n^2)$ ，每趟排序都会有一个元素被放在最终位置上 </p>
<p>  快速排序：平均栈深度 $O(log_2(n))$ ，时间复杂度 $O(nlog_2(n))$ ，每趟排序后将 <strong>pivot</strong> 元素放在最终位置上，要求能够手写代码    最坏情况是初始序列为顺序或逆序时，时间复杂度 $O(n^2)$ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> L[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = L[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L[high] &gt;= pivot) high--;</span><br><span class="line">           L[low] = L[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L[low] &lt;= pivot) low++;</span><br><span class="line">        L[high] = L[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> L[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(L, low, high);</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="built_in">QuickSort</span>(L, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(L, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>英语</p>
<p>  背单词，久违的墨墨</p>
<p>  真题又偷懒没刷</p>
</li>
<li><p>科研训练</p>
<p>  转实操，准备啃代码</p>
</li>
</ul>
<h3 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h3><p>晚上出去玩了没总结。</p>
<h3 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h3><ul>
<li><p>数学</p>
<ul>
<li><p>二重积分课后习题大题剩余部分</p>
<ul>
<li>还是注意计算问题!</li>
<li>两个一重积分乘积的证明题，通常可以转换为二重积分的问题（把其中的一个积分中的 x 换成 y ）</li>
</ul>
</li>
<li><p>武忠祥每日一题</p>
<ul>
<li>界值定理：函数 <code>[a,b]</code>内连续，则一定存在一个 <code>c ∈ [a,b]</code>，使得 <code> m &lt; f(c) &lt; M</code></li>
<li>函数在一点 <code>a</code> 处的导数值大于0 $&#x3D;&gt;$ 左半领域小于 <code>f(a)</code>，右半领域大于 <code>f(a)</code></li>
</ul>
</li>
<li><p>660 1-9 (求极限手生了，泰勒、洛必达、等价无穷小、三步曲什么的)</p>
<p>整理错题重点题</p>
</li>
</ul>
</li>
<li><p>408</p>
<ul>
<li><p>每日一题</p>
<ul>
<li><p>二叉树</p>
<p>  总结点数 n &#x3D; n0 + n1 + n2 &#x3D; 2n0 + n1 - 1</p>
</li>
<li><p>三次握手</p>
<p>  客户端 &#x3D;&#x3D;&#x3D;&gt; 服务端：SYN&#x3D;1，scq &#x3D; x                                            <strong>（我想说）</strong></p>
<p>  服务端 &#x3D;&#x3D;&#x3D;&gt; 客户端：SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ack&#x3D;x+1     <strong>（好你说）</strong></p>
<p>  客户端 &#x3D;&#x3D;&#x3D;&gt; 服务端：ACK&#x3D;1，seq&#x3D;x + 1，ack&#x3D;y+1               <strong>（阿巴阿巴）</strong></p>
</li>
<li><p>内存划分的动态分区分配</p>
<p>  首次适应算法：空闲分区以地址递增次序链接。</p>
<p>  最佳适应算法：空闲分区按容量递增方式形成分区链。</p>
<p>  最坏适应算法：以容量递减次序链接。</p>
<p>  邻近适应算法：分配内存时从上次查找结束的位置开始继续查找。</p>
</li>
</ul>
</li>
<li><p>数据结构二轮</p>
<ul>
<li><p>7.2 顺序查找、折半查找和分块查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序查找</span></span><br><span class="line"><span class="comment">// 线性查找引入哨兵减少不必要的判断</span></span><br><span class="line">list[<span class="number">0</span>] = key; <span class="comment">//查找的关键字</span></span><br><span class="line"><span class="keyword">for</span>(i = len; list[i] != key; i--);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  ASL(succ) = (n + 1) / 2</span></span><br><span class="line"><span class="comment">  ASL(fail) = n + 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch</span><span class="params">(SeqList L, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, h = L.Length - <span class="number">1</span>, mid;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">      mid = (l + h) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (L.data[mid] = key) </span><br><span class="line">          <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(L.data[mid] &gt; k)</span><br><span class="line">          h = mid - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  分块查找：</span></span><br><span class="line"><span class="comment">  分成 √n 块，块间和块内查找可以顺序也可以二分</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>7.3 B树和B+树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* B树</span></span><br><span class="line"><span class="comment">  1.每个节点最多有 m 颗子树，m-1 个关键字</span></span><br><span class="line"><span class="comment">  2.若不只有根节点一个节点，则根节点至少有两颗子树</span></span><br><span class="line"><span class="comment">  3.除根节点外的非叶子节点至少有 向上取整 (m/2)  颗子树</span></span><br><span class="line"><span class="comment">  4.叶子节点出现在同一层且不带信息，可以看作是查找失败的节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  插入：超过 m - 1 个关键字就裂开，从 向上取整(m/2) 裂</span></span><br><span class="line"><span class="comment">  删除：看书</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* B+树</span></span><br><span class="line"><span class="comment">  大体同B树，但是记录全在叶子节点上，叶子节点用链表串联可以进行顺序查找，非叶子节点都起索引的      作用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>英语</p>
<ul>
<li><p>单词新词全部背完，等剩下的一百多次复习完就转墨墨了，钱还是要花的</p>
</li>
<li><p>翻译真题：整体感觉难度不高，可以先放一放，先集中精力做做阅读这样子</p>
</li>
</ul>
</li>
<li><p>科研训练</p>
<p>  继续啃文献做笔记。图和各种深度学习技术相结合：AE、GCN、GAN…</p>
</li>
</ul>
<h3 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h3><ul>
<li><p>数学</p>
<p>  二重积分课后习题大题部分（运算还存在很大问题，很多题不是没思路是计算不对，要么丢了符号要么就是计算发放选择的不好）</p>
<p>  武忠祥每日一题（两道用单调性证明不等式的题目）</p>
</li>
<li><p>408</p>
<ul>
<li><p>王道每日一题</p>
<ul>
<li>执行IO指令、系统调用、修改页表的操作都需要切换到内核态进行，而对通用寄存器的清零，可以在用户态进行，也可以在内核态进行</li>
<li>计时器定时查询总线仲裁方式下，若每一次从头计数，则设备号小的优先级高，若每次计数从上一次计数的终点开始，则每个设备使用总线的机会均等</li>
</ul>
</li>
<li><p>数据结构二轮 6.4 图的应用剩下的知识点及课后习题</p>
<ul>
<li><p>最小生成树</p>
<p>  Prim算法：从初始节点开始每次找路径最短的（大致） $O(V^2)$</p>
<p>  Kruskal算法：从所有边里选最小的（大致）  $O(ElogE)$</p>
</li>
<li><p>最短路径</p>
<p>  最短路径一定是简单路径！</p>
<p>  Dijkstra算法：每次找到一个最短的（大致），不适用于负权值</p>
<p>  Floyd算法：方阵存储最短路径，可以求负权值的边，但是不能有带负权值的边组成的回路</p>
</li>
<li><p>有向无环图描述公共子式（乘法提公因子）</p>
</li>
<li><p>拓扑排序（AOV网）</p>
<p>  1.每个顶点只出现一次                         2.如果A在B前则不存在A-&gt;B的路径</p>
</li>
<li><p>关键路径（AOE网）</p>
<p>  影响工程进度的路径，增加或减少长度 <strong>可能</strong> 会决定总的花销（如果是多条关键路径则多条得一起变才行）</p>
<p>  ve、vl、e、l、l - e</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>英语</p>
<ul>
<li><p>单词 两三百</p>
</li>
<li><p>阅读 2004 Text4</p>
</li>
</ul>
</li>
<li><p>科研训练</p>
<p>  刚开始读文献然后被打断（ft）</p>
</li>
</ul>
<blockquote>
<p>由于课设、期末考试各种原因，搁置考研十天左右</p>
<p>放暑假回家，正式开始暑期学习</p>
<p>7.11 - 7.17 偷懒没记，总结一下 </p>
<ul>
<li><p>稳步推进高数，基本快结束了强化课的内容、讲义习题以及课后习题，同时更近武忠祥每日一题还有b站up主整理的一些秒杀技巧</p>
</li>
<li><p>专业课开始复习第二轮，还是从数据结构开始，速度比一轮快了很多，选择题准确率也比一轮高了不少，课后的大题的真题部分也开始做了（计划跟进王道暑假大题强化课）</p>
</li>
<li><p>单词也有认真背，英语真题也开始做了，由于每天留给英语时间不多，所以从2004年的真题开始每天只做一篇阅读理解及其精度</p>
</li>
<li><p>科研训练，换了下手方向，转向基于图的异常检测</p>
</li>
</ul>
<p>总体学习效率还是小低，会被很多东西分心，争取慢慢找回状态！</p>
<p>重视回顾！重视回顾！重视回顾！</p>
<p>​    <strong>楞冲！！！</strong></p>
</blockquote>
<h1 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h1><h3 id="6-28"><a href="#6-28" class="headerlink" title="6.28"></a>6.28</h3><ul>
<li><p>数学</p>
<ul>
<li>武忠祥十六讲  第五章第二节 偏导数与全微分的计算</li>
<li>每日一题</li>
</ul>
</li>
<li><p>408</p>
<p>  计网 复习思维导图 网络层</p>
<p>  数据结构 （二轮复习昨天开始）</p>
<ul>
<li>链表回顾 课后选择、真题大题</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 300</p>
</li>
</ul>
<h3 id="6-17-6-27"><a href="#6-17-6-27" class="headerlink" title="6.17 ~ 6.27"></a>6.17 ~ 6.27</h3><ul>
<li><p>数学</p>
<ul>
<li>武忠祥十五讲 </li>
<li>高数辅导讲义课后习题</li>
<li>武忠祥每日一题</li>
</ul>
</li>
<li><p>408</p>
<p>  计网</p>
<ul>
<li>第六章 网络层</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 40 ~ 60%</p>
</li>
</ul>
<h3 id="6-5-6-17"><a href="#6-5-6-17" class="headerlink" title="6.5 ~ 6.17"></a>6.5 ~ 6.17</h3><ul>
<li><p>数学</p>
<ul>
<li>武忠祥九讲 ~ 十四讲</li>
<li>高数辅导讲义课后题</li>
</ul>
</li>
<li><p>408</p>
<p>  计网</p>
<ul>
<li><p>第二章 物理层</p>
</li>
<li><p>第三章 数据链路层 🎈</p>
</li>
<li><p>第四层 网络层 🎈</p>
</li>
<li><p>第五章 传输层</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 0 ~ 40%</p>
</li>
</ul>
<h3 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h3><ul>
<li><p>数学</p>
<p>  武忠祥第九讲</p>
<ul>
<li><p>不等式证明：单调性、最值、L、泰勒、凹凸性</p>
</li>
<li><p>微分中值定理证明</p>
<ul>
<li>分析法</li>
<li>微分方程法</li>
<li>记住一个常用通用结论</li>
</ul>
<p>武忠祥每日一题 x 2</p>
</li>
</ul>
</li>
<li><p>408</p>
<p>  计网 </p>
<p>  1.2 计算机网络体系结构与参考模型</p>
<ul>
<li><p>协议、接口、服务的区别与联系</p>
</li>
<li><p>OSI 参考模型（七层）</p>
</li>
<li><p>TCP&#x2F;IP 模型（四层）</p>
<p>2.1 通信基础单科书部分</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h3><ul>
<li><p>数学</p>
<p>  武忠祥第七讲 导数的应用</p>
<ul>
<li><p>微分中值定理（四个）</p>
</li>
<li><p>极值（一、二、<strong>三</strong>充分条件）</p>
</li>
<li><p>斜渐近线的特殊求法</p>
<p>武忠祥 每日一题 x 2</p>
</li>
</ul>
</li>
<li><p>408</p>
<p>  计网 1.1 概述部分</p>
<p>  数据结构 LC每日一题</p>
</li>
<li><p>英语 </p>
<p>  单词 x 250</p>
</li>
</ul>
<h1 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h1><h3 id="5-28-6-2"><a href="#5-28-6-2" class="headerlink" title="5.28 - 6.2"></a>5.28 - 6.2</h3><p>复习专业课考试，抽空看高数</p>
<h3 id="5-27"><a href="#5-27" class="headerlink" title="5.27"></a>5.27</h3><ul>
<li><p>数学</p>
<p>  课后习题 x 30</p>
</li>
<li><p>408</p>
<p>  操作系统 回顾</p>
</li>
<li><p>英语</p>
<p>  单词 x 300</p>
</li>
</ul>
<h3 id="5-26"><a href="#5-26" class="headerlink" title="5.26"></a>5.26</h3><ul>
<li><p>数学</p>
<p>  回顾昨天的例题</p>
<p>  武忠祥第四讲 后半部分</p>
<ul>
<li>连续与间断</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 5.2 IO 核心子系统</p>
<ul>
<li><p>高速缓存与缓冲区</p>
<p>  （引入缓冲区的目的、缓冲区的分类、<strong>单缓冲区和双缓冲区的处理时间计算</strong>（重点））</p>
</li>
<li><p>设备分配数据结构</p>
<p>  （DCT、COCT、CHCT、SDT 之间的运作关系）</p>
</li>
<li><p><strong>SPOOLing 技术（掌握的还不是很好）</strong></p>
<p>  目的：缓解 CPU 和 IO 设备的速度差异</p>
<p>  必须要有多道程序技术支持</p>
<p>  组成：输入井和输出井（外存）、输入缓冲区和输出缓冲区（内存）、输入进程、输出进程</p>
<p>  通俗的讲就是，如果设备被占用，就把数据暂存一下，等设备空闲了就把数据输入到设备中</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 x 300</p>
</li>
</ul>
<h3 id="5-25"><a href="#5-25" class="headerlink" title="5.25"></a>5.25</h3><ul>
<li><p>数学</p>
<p>  武忠祥第四讲 前半部分</p>
<ul>
<li><p>确定极限中的参数</p>
</li>
<li><p>无穷小量比较（对阶比较好用）</p>
<p>每日一题 x 2</p>
</li>
<li><p>1 - cosx的 a 次方 ~ a&#x2F;2 * x的平方</p>
</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 5.1 IO 管理概述</p>
<ul>
<li>IO 控制方式</li>
<li>IO 子系统层次结构</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 x 300</p>
</li>
<li><p>科研训练</p>
<p>  啃文献：<a href="https://ieeexplore.ieee.org/document/7022664">Efficient Anomaly Detection by Isolation Using Nearest Neighbour Ensemble | IEEE Conference Publication | IEEE Xplore</a></p>
</li>
</ul>
<h3 id="5-24"><a href="#5-24" class="headerlink" title="5.24"></a>5.24</h3><ul>
<li><p>数学</p>
<p>  武忠祥第四讲 （预习加正课）</p>
<ul>
<li><p>数列极限，用<strong>洛必达前先改成函数极限再求</strong></p>
</li>
<li><p><strong>n 项和数列极限</strong>： </p>
<pre><code>  1. 夹逼定理   **次量级**  
   2. 定积分定义  **同量级**
</code></pre>
</li>
<li><p>n 项连乘求极限</p>
</li>
<li><p><strong>根据递推关系求极限 （重难点，很有可能出今年最难的一道题）</strong></p>
<p>每日一题 x 2</p>
</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 4.3 磁盘组织与管理</p>
<ul>
<li>磁盘的结构</li>
<li>磁盘的一些时间参数计算（寻找时间、旋转延迟时间、传输时间）</li>
<li>磁盘调度算法<ul>
<li>先来先服务（FCFS）</li>
<li>最短寻找时间（SSTF）</li>
<li>扫描算法（SCAN）</li>
<li>循环扫描（C-SCAN）</li>
</ul>
</li>
<li>磁盘管理（磁盘初始化、引导块、坏块）</li>
</ul>
</li>
<li><p>英语</p>
<p>  墨墨单词 x 300</p>
</li>
</ul>
<h3 id="5-23"><a href="#5-23" class="headerlink" title="5.23"></a>5.23</h3><ul>
<li><p>数学</p>
<p>  武忠祥 第三讲回顾（例题）</p>
<p>  每日一题 x 2</p>
</li>
<li><p>408</p>
<p>  操作系统 文件系统实现 课后题、整理思维框图</p>
</li>
<li><p>英语</p>
<p>  单词单词</p>
</li>
</ul>
<h3 id="5-22"><a href="#5-22" class="headerlink" title="5.22"></a>5.22</h3><ul>
<li><p>数学</p>
<p>  武忠祥 强化班3 </p>
<p>  各种极限求法</p>
</li>
<li><p>408</p>
<p>  操作系统 4.2文件系统实现</p>
</li>
<li><p>英语</p>
<p>  单词</p>
</li>
</ul>
<h3 id="5-21"><a href="#5-21" class="headerlink" title="5.21"></a>5.21</h3><ul>
<li><p>数学</p>
<p>  武忠祥 强化班2</p>
</li>
<li><p>408</p>
<p>  操作系统 4.1 文件系统基础</p>
<ul>
<li><p>文件的打开与关闭</p>
</li>
<li><p>文件的逻辑结构</p>
<p>  流式文件</p>
<p>  记录式文件</p>
<ul>
<li>顺序文件</li>
<li>索引文件</li>
<li>索引顺序文件</li>
<li>直接文件或散列文件</li>
</ul>
</li>
<li><p>目录结构</p>
<ul>
<li>单极目录结构</li>
<li>两级目录结构</li>
<li>多级目录结构（树形目录结构）</li>
<li>无环图目录结构</li>
</ul>
</li>
<li><p>文件控制块</p>
</li>
<li><p>索引节点</p>
</li>
<li><p>文件共享</p>
</li>
<li><p>文件保护</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-20"><a href="#5-20" class="headerlink" title="5.20"></a>5.20</h3><ul>
<li><p>数学</p>
<p>  武忠祥 强化班1</p>
<ul>
<li>原函数奇（偶）函数 &#x3D;&#x3D;&gt; 导函数偶（奇）函数。<strong>反过来不一定对</strong>。</li>
<li>开区间有界 &#x3D;&#x3D;&gt; 两端点处极限存在</li>
<li>导函数开区间有界 &#x3D;&#x3D;&gt; 原函数开区间有界</li>
<li>极限保号性，区分 f(x) &gt; f(x0) 和 f(x) 在区间内单调递增</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 3.2 虚拟内存管理</p>
<ul>
<li><p>虚拟存储器大小由计算机地址结构决定</p>
</li>
<li><p>虚拟内存技术建立在非连续分配基础之上</p>
</li>
<li><p>FIFO 是唯一会导致 Belady 现象的页面置换算法</p>
</li>
<li><p>外存分为对换区和文件区</p>
</li>
<li><p>抖动</p>
</li>
<li><p>TODO 大题地址翻译 （P202）</p>
<p>LeetCode 每日一题</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  每日单词</p>
</li>
</ul>
<h3 id="5-13-5-19"><a href="#5-13-5-19" class="headerlink" title="5.13 - 5.19"></a>5.13 - 5.19</h3><p>复习测试技术，准备考试</p>
<p>武忠祥每日一题坚持在做</p>
<p>背单词</p>
<h3 id="5-12"><a href="#5-12" class="headerlink" title="5.12"></a>5.12</h3><ul>
<li><p>数学</p>
<p>  李林880 相似矩阵解答题（部分）</p>
<p>  武忠祥每日一题 x 2</p>
<ul>
<li>两道都是拉格朗日中值定理求极限</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 3.1 内存管理概念课后习题</p>
<ul>
<li>链接完成重定位，形成逻辑地址</li>
<li>动态重定位是在作业的执行过程中进行的</li>
<li>分页系统是给操作系统用的，对用户透明</li>
<li>重定位存储管理方式，整个系统设置一个重定位寄存器</li>
<li>程序如何分段是在用户编程时决定的</li>
<li>页式管理系统所划分的页面大小必须相同</li>
<li>逻辑地址按页分配，物理地址按块分配</li>
<li>区分页、页地址结构、页表项、段、段地址结构、段表项</li>
</ul>
</li>
<li><p>英语</p>
<p>单词单词！</p>
</li>
</ul>
<h3 id="5-11"><a href="#5-11" class="headerlink" title="5.11"></a>5.11</h3><ul>
<li><p>数学</p>
<p>  李林880 线性方程组解答题 相似矩阵选填</p>
<p>  两种含参方程求参数值：行列式、增广矩阵</p>
<p>  武忠祥每日一题 x 2</p>
<ul>
<li>常见极限 x - ln（x + 1）</li>
<li>拉格朗日中值定理求极限</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 3.1 内存管理概念</p>
<ul>
<li>程序执行过程（编译、链接、装入）</li>
<li>连续分配（单一连续分配、固定分区分配、动态分区分配）</li>
<li>非连续分配（页式存储管理、块式存储管理、块页式）</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
</li>
</ul>
<h3 id="5-10"><a href="#5-10" class="headerlink" title="5.10"></a>5.10</h3><ul>
<li><p>数学</p>
<p>  李林880 向量解答题 线性方程组选填</p>
<p>  武忠祥每日一题 x 2</p>
<ul>
<li>常见极限 x - sinx、tanx - x</li>
<li>极限等价代换的条件是 x 趋向于 0 而不能等于 0</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 3.1 内存管理概念（王道视频）</p>
</li>
<li><p>英语<br>  单词！</p>
</li>
</ul>
<h3 id="5-9"><a href="#5-9" class="headerlink" title="5.9"></a>5.9</h3><ul>
<li><p>数学</p>
<p>  李林880 矩阵解答题 向量填空题、选择题</p>
</li>
<li><p>408</p>
<p>  操作系统 2.4 死锁</p>
</li>
<li><p>英语</p>
<p>  不背单词 + 墨墨单词</p>
</li>
</ul>
<h3 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h3><ul>
<li><p>数学</p>
<p>  李林880 行列式 基础题 填空、解答</p>
<p>  武忠祥每日一题 x 2</p>
</li>
<li><p>408</p>
<p>  操作系统 2.3 进程同步</p>
<ul>
<li>临界资源</li>
<li>同步与互斥</li>
<li>信号量</li>
<li>生产者-消费者问题、读者-写者问题</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 不背复习 + 墨墨新学</p>
</li>
</ul>
<h3 id="5-6"><a href="#5-6" class="headerlink" title="5.6"></a>5.6</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 线性代数 二次型</p>
<ul>
<li><p>标准二次型和规范二次型</p>
</li>
<li><p>普通二次型到标准二次型的转换</p>
</li>
<li><p>惯性系数</p>
</li>
<li><p>矩阵的合同</p>
<p>武忠祥每日一题 x 2</p>
<p>李林880 行列式 基础题 选择填空</p>
</li>
</ul>
</li>
<li><p>408</p>
<p>  操作系统 2.2 处理机调度</p>
</li>
<li><p>英语</p>
<p>  复习不背单词 x 200</p>
<p>  新学墨墨单词 x 250</p>
</li>
</ul>
<h3 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 线性代数 特征值与特征向量</p>
<p>  武忠祥每日一题 x 2</p>
</li>
<li><p>408</p>
<p>  操作系统 2.1 进程管理</p>
<p>  数据结构 讲题顺带回顾了</p>
<ul>
<li>堆栈实现四则运算</li>
<li>二叉平衡树</li>
<li>散列表</li>
<li>克鲁斯卡尔和普利姆算法</li>
<li>迪杰斯特拉算法</li>
<li>快速排序</li>
</ul>
</li>
<li><p>英语</p>
<p>  复习不背单词</p>
<p>  新学墨墨单词</p>
</li>
</ul>
<h3 id="5-1-5-2-5-3-5-4"><a href="#5-1-5-2-5-3-5-4" class="headerlink" title="5.1 5.2 5.3 5.4"></a>5.1 5.2 5.3 5.4</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 线性代数 行列式、矩阵、向量、线性方程组</p>
</li>
<li><p>408</p>
<p>  操作系统 概述</p>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
</li>
</ul>
<blockquote>
<p>另外服务器到期，又花了不少的时间倒腾服务器的事情</p>
</blockquote>
<h1 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h1><h3 id="4-30"><a href="#4-30" class="headerlink" title="4.30"></a>4.30</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 二重积分</p>
<p>  武忠祥基础班 二重积分</p>
</li>
</ul>
<h3 id="4-29"><a href="#4-29" class="headerlink" title="4.29"></a>4.29</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 不定积分 + 定积分</p>
<p>  武忠祥基础班 不定积分 + 定积分</p>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li><p>回顾整理知识框架</p>
<p>  第四章 指令、第五章 CPU</p>
</li>
<li><p>数据结构</p>
<p>  LeetCode 每日一题</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  复习单词！</p>
</li>
</ul>
<h3 id="4-27"><a href="#4-27" class="headerlink" title="4.27"></a>4.27</h3><ul>
<li><p>数学</p>
<p>  武忠祥 多元函数微分学查漏补缺</p>
<ul>
<li><p>多元函数关系树形图</p>
</li>
<li><p>多元函数求导后求值，可以先带无关变量进去简化计算</p>
<p>李永乐全书 不定积分</p>
<p>武忠祥 每日一题</p>
</li>
</ul>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li><p>回顾整理知识框架</p>
<p>  第一章、第二章、第三章</p>
<p>数据结构</p>
</li>
<li><p>LeetCode每日一题</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
<p>  不背单词 恋词5500 学完!（不知道复习要复习多久）</p>
</li>
</ul>
<h3 id="4-26"><a href="#4-26" class="headerlink" title="4.26"></a>4.26</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 多元函数微分学 + 不定积分</p>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li>7.4 I&#x2F;O方式 中断、DMA</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
</li>
</ul>
<h3 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 多元函数微分学例题</p>
</li>
<li><p>计组</p>
<ul>
<li>7.3 I&#x2F;O接口</li>
<li>7.4 I&#x2F;O方式 程序查询方式</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词单词！</p>
</li>
</ul>
<h3 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h3><ul>
<li><p>数学</p>
<p>  李林880 第六章 微分方程 剩余填空及解答题</p>
<p>  李永乐全书 微分方程例题</p>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li><p>7.2 外部设备</p>
<ul>
<li>VRAM 容量及带宽</li>
<li>磁盘的传输速率及平均存取时间</li>
</ul>
</li>
<li><p>数据结构回顾 冒泡排序</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  复习单词 354个</p>
</li>
</ul>
<h3 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h3><ul>
<li><p>数学</p>
<p>  李永乐全书 微分方程例题</p>
<p>  李林880 第五章二重积分 解答题剩余部分 第六章 微分方程 选择题 部分填空题</p>
<p>  <strong>计算计算计算！</strong></p>
</li>
<li><p>408</p>
<p>  计组</p>
<ul>
<li>6.3 操作和定时</li>
<li>6.4 总线标准</li>
<li>7.1 I&#x2F;O 系统基本概念</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 547个</p>
</li>
</ul>
<h3 id="4-22"><a href="#4-22" class="headerlink" title="4.22"></a>4.22</h3><ul>
<li><p>数学</p>
<p>  李林880 第五章 二重积分 填空剩余部分、解答题（极坐标系的二重积分）</p>
</li>
<li><p>408</p>
<p>  计组 第六章 总线</p>
</li>
<li><p>英语</p>
<p>  单词 复习 + 新学200</p>
</li>
<li><p>科研训练</p>
<p>  FSBIF 整理</p>
</li>
</ul>
<h3 id="4-21"><a href="#4-21" class="headerlink" title="4.21"></a>4.21</h3><ul>
<li><p>数学</p>
<p>  李林880 第四章 多元函数微分学 基础题解答题部分</p>
<p>  ​                    第五章 二重积分 选择填空部分 （<strong>变积分限</strong>）</p>
</li>
<li><p>408</p>
<p>  计组 5.5 指令流水线 </p>
<ul>
<li>数据相关、资源冲突、条件转移</li>
<li>吞吐率、加速比、效率</li>
<li>超标量流水线技术、超流水线技术</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 复习 + 新学200</p>
</li>
<li><p>科研训练</p>
<p>  Fuzzy Set-Based IF</p>
</li>
</ul>
<blockquote>
<p>重拾</p>
</blockquote>
<h3 id="4-20"><a href="#4-20" class="headerlink" title="4.20"></a>4.20</h3><ul>
<li><p>数学</p>
<p>  李林880 第四章 多元函数微分学 基础题</p>
</li>
<li><p>408</p>
<p>  计组  5.4 控制器的功能和原理</p>
<ul>
<li>控制器的结构和功能 CU、PC、IR</li>
<li>硬布线控制器、微程序控制器</li>
</ul>
</li>
<li><p>英语</p>
<p>  单词 复习 + 新学200</p>
</li>
</ul>
<h1 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h1><h3 id="3-18"><a href="#3-18" class="headerlink" title="3.18"></a>3.18</h3><ul>
<li><p>数学</p>
<p>  线性代数强化班第三次课</p>
<ul>
<li>矩阵运算</li>
<li>伴随矩阵</li>
<li>可逆矩阵</li>
<li>矩阵的 n 次方</li>
</ul>
</li>
<li><p>408</p>
<ul>
<li>散列表</li>
<li>插入排序</li>
</ul>
</li>
</ul>
<h3 id="3-17"><a href="#3-17" class="headerlink" title="3.17"></a>3.17</h3><ul>
<li><p>数学</p>
<p>  线性代数强化班第二次课</p>
</li>
<li><p>408</p>
<ul>
<li><p>查找概念</p>
</li>
<li><p>顺序查找</p>
</li>
<li><p>折半查找（二分查找）</p>
</li>
<li><p>分块查找</p>
</li>
<li><p>B树、B+树</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-16"><a href="#3-16" class="headerlink" title="3.16"></a>3.16</h3><ul>
<li><p>数学</p>
<p>  线性代数强化班第一次课</p>
</li>
<li><p>408</p>
<p>  6.4 图的应用</p>
<ul>
<li><p>最短路径：Floyd算法（动态规划）</p>
</li>
<li><p>拓扑排序</p>
</li>
<li><p>关键路径</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-15"><a href="#3-15" class="headerlink" title="3.15"></a>3.15</h3><ul>
<li><p>数学</p>
<p>  线代第一章：行列式</p>
</li>
<li><p>408</p>
<p>  6.3 图的遍历</p>
<ul>
<li><p>BFS</p>
</li>
<li><p>DFS</p>
<p>6.4 图的应用</p>
</li>
<li><p>最小生成树：BFS、Prim 算法、Kruskal 算法</p>
</li>
<li><p>最短路径：Dijkstra 算法</p>
</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-14"><a href="#3-14" class="headerlink" title="3.14"></a>3.14</h3><ul>
<li><p>数学</p>
<p>  无</p>
</li>
<li><p>408</p>
<p>  6.1 图的基本概念</p>
<p>  6.2 图的存储操作</p>
<ul>
<li>邻接矩阵法</li>
<li>邻接表法</li>
<li>十字链表</li>
<li>邻接多重表</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-12"><a href="#3-12" class="headerlink" title="3.12"></a>3.12</h3><ul>
<li><p>数学</p>
<p>  回顾高数笔记</p>
</li>
<li><p>408</p>
<p>  5.5 树的应用</p>
<ul>
<li>二叉排序树</li>
<li>平衡二叉树</li>
<li>哈夫曼树和哈夫曼编码</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-11"><a href="#3-11" class="headerlink" title="3.11"></a>3.11</h3><ul>
<li><p>数学</p>
<p>  汤家凤基础班——第七章重积分</p>
</li>
<li><p>408</p>
<p>  5.4 树和森林</p>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-10"><a href="#3-10" class="headerlink" title="3.10"></a>3.10</h3><ul>
<li><p>数学</p>
<p>  接力题典1800——微分方程</p>
</li>
<li><p>408</p>
<p>  5.2 二叉树的性质</p>
<p>  5.3 二叉树的遍历(前序、中序、后序、层序)、线索化二叉树</p>
</li>
<li><p>英语</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h3><ul>
<li><p>数学</p>
<p>  汤家凤基础班——第六章微分方程</p>
</li>
<li><p>408</p>
<p>  5.1 树的定义王道视频及对应习题</p>
</li>
<li><p>英语</p>
<p>  经济学人 1 篇</p>
<p>  不背单词</p>
</li>
</ul>
<h3 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h3><ul>
<li><p>数学</p>
<p>  接力题典1800 第六章入门部分</p>
</li>
<li><p>408</p>
<p>  串</p>
<ul>
<li>字符串</li>
<li><strong>字符串的匹配（暴力搜索和KMP）</strong></li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词：50个</p>
</li>
</ul>
<h3 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h3><ul>
<li><p>数学</p>
<p>  接力题典1800 第五章入门部分</p>
</li>
<li><p>408</p>
<p>  特殊矩阵</p>
<ul>
<li>对称矩阵</li>
<li>上（下）三角矩阵</li>
<li>三对角线矩阵</li>
<li>稀疏矩阵</li>
</ul>
</li>
<li><p>英语</p>
<p>  不背单词：50个</p>
</li>
</ul>
<h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><ul>
<li><p>数学</p>
<p>  书到了！</p>
<p>  汤家凤基础班第六章所有视频</p>
</li>
<li><p>408</p>
<p>  无</p>
</li>
<li><p>英语</p>
<p>  不背单词：100个</p>
</li>
</ul>
<h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><ul>
<li><p>数学</p>
<p>  书还没有来，继续做前几章的习题</p>
</li>
<li><p>408</p>
<p>  浙大慕课二叉树的例题（求深度、求是否对称）</p>
<p>  BST</p>
</li>
<li><p>英语</p>
<p>  不背单词：160个</p>
</li>
</ul>
<h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>莫名其妙头疼睡了一天，可能是，学的太厉害了？</p>
<h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><p>返校归来打起精神继续开始！</p>
<ul>
<li>数学<ul>
<li>由于书还没有邮到，所有先停一停做做前几章笔记里的列题</li>
</ul>
</li>
<li>408<ul>
<li>树的建立、遍历，书还没有来~</li>
</ul>
</li>
<li>英语<ul>
<li>不背单词：5组</li>
</ul>
</li>
</ul>
<h1 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h1><h3 id="2-18"><a href="#2-18" class="headerlink" title="2.18"></a>2.18</h3><ul>
<li>数学<ul>
<li>接力题典1800 第五章 入门训练1-10</li>
</ul>
</li>
<li>墨墨单词：100个</li>
</ul>
<h3 id="2-17"><a href="#2-17" class="headerlink" title="2.17"></a>2.17</h3><ul>
<li>数学<ul>
<li>汤家凤高数基础班 29、30<ul>
<li>型三 定积分计算</li>
<li>型四 几何应用</li>
</ul>
</li>
</ul>
</li>
<li>看老师去了~</li>
</ul>
<h3 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h3><ul>
<li>数学（3h44min）<ul>
<li>汤家凤高数基础班  26、27、28<ul>
<li>奇（偶）函数、周期函数的定积分</li>
<li><strong>广义积分</strong>（反常积分）</li>
<li>几何应用：面积、体积</li>
<li>两种题型：概念与性质题、变积分限问题</li>
</ul>
</li>
</ul>
</li>
<li>408<ul>
<li>c++实现栈、顺序队列、链表队列</li>
<li>LeetCode每日一题</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
<li>刘晓燕</li>
</ul>
</li>
</ul>
<h3 id="2-15"><a href="#2-15" class="headerlink" title="2.15"></a>2.15</h3><ul>
<li>数学（4h55min）<ul>
<li>接力题典1800 第四章收尾</li>
<li>汤家凤高数基础班 23、24、25<ul>
<li>定积分的定义</li>
<li>定积分的一般性质</li>
<li>N-L 公式</li>
<li>定积分积分法</li>
</ul>
</li>
</ul>
</li>
<li>408<ul>
<li>数据结构王道单科书队列课后选择题</li>
</ul>
</li>
<li>英语：<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-14"><a href="#2-14" class="headerlink" title="2.14"></a>2.14</h3><ul>
<li>数学<ul>
<li>汤家凤基础班 21、22（不定积分剩下的部分）<ul>
<li>两种换元积分法（硬换、无理函数转有理函数）</li>
<li>平方和差还原（画三角形）</li>
<li>分部积分法的六种情形</li>
<li>有理函数的不定积分（真分式、假分式）</li>
</ul>
</li>
<li>接力题典1800 第四章入门部分（还留了些小尾巴）</li>
</ul>
</li>
<li>408<ul>
<li>数据结构王道单科书栈课后选择题</li>
<li>了解 C++ 基础语法</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-13"><a href="#2-13" class="headerlink" title="2.13"></a>2.13</h3><ul>
<li>数学<ul>
<li>汤家凤寒假专题三、四<ul>
<li>积分中值定理（开区间）</li>
<li>积分中值定理的推广（闭区间）</li>
</ul>
</li>
<li>汤家凤基础班 20 （不定积分第一小节）<ul>
<li>常用不定积分公式</li>
<li>还原法求不定积分</li>
</ul>
</li>
</ul>
</li>
<li>408<ul>
<li>LeetCode 每日一题</li>
<li>CASPP</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-12"><a href="#2-12" class="headerlink" title="2.12"></a>2.12</h3><ul>
<li>数学<ul>
<li>汤家凤基础班第三章剩下的题型</li>
<li>接力题典1800 第三章入门部分</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h3><ul>
<li>数学<ul>
<li>汤家凤基础班第二章题型</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><ul>
<li>数学<ul>
<li>汤家凤基础课18-19</li>
<li>接力题典1800  1-11题</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><ul>
<li>数学（5*45min）<ul>
<li>汤家凤基础课15-18</li>
</ul>
</li>
<li>408（3*45min）<ul>
<li>浙大MOOC 链表部分</li>
<li>王道第二章链表习题</li>
<li>手敲链表增删改查代码</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
<li>田静每日长难句</li>
</ul>
</li>
</ul>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><ul>
<li>数学（4*45min）<ul>
<li>汤家凤基础课13-14（讲义还没到，效率小低）</li>
</ul>
</li>
<li>408（3*45min）<ul>
<li>王道第二章线性表视频1-4</li>
<li>王道第二章线性表习题，线性表顺序表示部分的全部选择题</li>
<li>手敲顺序表增删改查代码，顺便把VSCode C语言环境配好</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
<li>田静每日长难句</li>
</ul>
</li>
</ul>
<h1 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h1><h3 id="1-30"><a href="#1-30" class="headerlink" title="1.30"></a>1.30</h3><ul>
<li>数学<ul>
<li>接力题典1800导数与微分入门练习：1-17</li>
</ul>
</li>
<li>英语<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
<h3 id="1-31"><a href="#1-31" class="headerlink" title="1.31"></a>1.31</h3><ul>
<li><p>数学（4*45min）</p>
<ul>
<li><p>汤家凤寒假专题（二）</p>
</li>
<li><p>汤家凤基础课 11-12</p>
</li>
</ul>
</li>
<li><p>408（2*45min）</p>
<ul>
<li>王道第一章概论全部视频</li>
<li>王道教材第一章习题全部选择题</li>
</ul>
</li>
<li><p>英语</p>
<ul>
<li>墨墨单词：100个</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>【考研】计算机组成原理知识点梳理</title>
    <url>/2023/03/01/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章用于梳理 408 中最硬核的一门课——<strong>计算机组成原理</strong> 的知识点</p>
<p>便于之后与以后回顾</p>
<p>参考：王道单科书《计算机组成原理考研复习指导》未标明出处的图片等资源均取自书中</p>
<p>缺的内容会慢慢补上</p>
</blockquote>
<h1 id="总知识点框架"><a href="#总知识点框架" class="headerlink" title="总知识点框架"></a>总知识点框架</h1><img src="【考研】计算机组成原理知识点梳理/image-20210812170915865.png" alt="image-20210812170915865"  />

<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h3 id="考纲及章节框架"><a href="#考纲及章节框架" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210821164230591.png" alt="image-20210821164230591" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210821164813184.png" alt="image-20210821164813184" style="zoom:80%;" />

<h3 id="1-1-计算机系统层次结构"><a href="#1-1-计算机系统层次结构" class="headerlink" title="1.1 计算机系统层次结构"></a>1.1 计算机系统层次结构</h3><blockquote>
<h4 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h4></blockquote>
<p>硬件系统和软件系统共同构成了一个完整的计算机系统</p>
<ul>
<li>硬件是计算机系统中实际物理装置的总称</li>
<li>软件是指在硬件上运行的程序和相关数据及文档</li>
</ul>
<p>软件的效率表征计算机系统性能的好坏，而软件性能的发挥离不开硬件的支持</p>
<p><strong>软硬件在逻辑上等效：对某一功能既可以用软件实现又可以用硬件实现</strong></p>
<blockquote>
<h4 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h4></blockquote>
<p><strong>1. 冯·诺依曼机</strong></p>
<p>冯·诺依曼提出“存储程序”的思想，“<strong>存储程序</strong>”的思想奠定了现代计算机的基本结构</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210821165957258.png" alt="image-20210821165957258" style="zoom:80%;" />

<p>冯·诺依曼机的特点：</p>
<ol>
<li>计算机系统由 <strong>运算器、控制器、存储器、输入设备、输出设备</strong> 组成</li>
<li>指令和数据同等地位，并可以按地址寻访</li>
<li>指令数据均由<strong>二进制</strong>码组成</li>
<li>指令由 <strong>操做码和地址码</strong> 组成</li>
<li><strong>指令在存储器内顺序存放</strong></li>
<li><strong>早期</strong>冯·诺依曼机以 <strong>运算器</strong> 为中心（<strong>现代计算机已发展为以 存储器 为中心</strong>）</li>
</ol>
<p><strong>2. 计算机功能部件</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210821170025973.png" alt="image-20210821170025973" style="zoom:80%;" />

<ol>
<li><p>输入设备</p>
<p> 键盘、鼠标、扫描仪、摄像机……</p>
</li>
<li><p>输出设备</p>
<p> 显示器、打印机……</p>
</li>
<li><p>存储器</p>
<ul>
<li><p>主存（内存）：CPU 能够直接访问的存储器</p>
<p>  主存按存储单元的地址进行存取，这种存取方式称为 <strong>按地址存取方式</strong></p>
<ul>
<li><p><strong>MAR</strong>：用于寻址，<strong>其位数对应存储单元个数</strong></p>
</li>
<li><p><strong>MDR</strong>：用于要从存储器中读写的信息，<strong>其位数与存储字长相等</strong>，一般为字节的二次幂的整数倍</p>
</li>
</ul>
</li>
<li><p>辅存（外存）：必须将信息调入主存后才能被 CPU 访问</p>
</li>
</ul>
</li>
<li><p>运算器：计算机执行部件，用于进行逻辑和算术运算</p>
<ul>
<li>算术逻辑单元 ALU</li>
<li><strong>累加器 ACC</strong>、<strong>乘商寄存器 MQ</strong>、<strong>操作数寄存器 X</strong>、变址寄存器 IX、基址寄存器 BR</li>
<li>程序状态寄存器 PSW：存放 ALU 运算的标志和处理及的状态信息，如是否溢出、有无进位借位等</li>
</ul>
</li>
<li><p>控制器：CPU 的指挥中心</p>
<ul>
<li>程序计数器 PC：<strong>存放当前欲执行的指令地址</strong>，可以自动加一，与 MAR 之间有之间通路</li>
<li>指令寄存器 IR：存放当前指令，内容来自 MDR</li>
<li>控制单元 CU</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="计算机软件分类"><a href="#计算机软件分类" class="headerlink" title="计算机软件分类"></a>计算机软件分类</h4></blockquote>
<ul>
<li><p>系统软件</p>
<p>  <strong>操作系统 OS</strong>、<strong>数据库管理系统 DBMS</strong>、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序……</p>
</li>
<li><p>应用软件</p>
<p>  各种高级语言、数据处理程序……</p>
</li>
</ul>
<p>三个级别的语言：机器语言、汇编语言、高级语言</p>
<blockquote>
<h4 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h4></blockquote>
<p><strong>1. 工作过程</strong></p>
<ol>
<li>源程序和数据<strong>装入</strong>主存</li>
<li>源程序<strong>转换</strong>成 .exe</li>
<li>.exe 文件首地址开始逐条<strong>执行指令</strong></li>
</ol>
<p><strong>2. 从源程序到可执行文件</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210821172103005.png" alt="image-20210821172103005" style="zoom:80%;" />

<ol>
<li>预处理阶段：对字符 # 开头的命令进行处理</li>
<li>编译阶段：生成一个汇编语言源程序</li>
<li>汇编阶段：汇编器将汇编语言源程序翻译成机器语言</li>
<li>链接阶段：链接器将多个可重定位目标文件和标准库函数合并为一个 .exe 文件</li>
</ol>
<blockquote>
<h4 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h4></blockquote>
<img src="【考研】计算机组成原理知识点梳理/image-20210821172612547.png" alt="image-20210821172612547" style="zoom:80%;" />

<blockquote>
<p>Note：</p>
<ol>
<li><p><strong>相联存储器既可以按地址存取，也可以按内容存取</strong></p>
</li>
<li><p>冯·诺依曼机的基本工作方式：<strong>控制流驱动方式</strong></p>
</li>
<li><p>在现代计算机中，MAR、MDR、Cache 均是存在于 CPU 中的</p>
</li>
<li><p>运算器和控制器集成到同一个芯片上，称为 CPU</p>
<p> CPU 和主存共同构成主机</p>
</li>
<li><p>区分 DBMS 和 DBS</p>
<ul>
<li>DBMS：位于用户和操作系统之间的数据管理软件，是<strong>系统软件</strong></li>
<li>DBS：计算机系统引入数据库后的系统，是应用软件</li>
</ul>
</li>
<li><p><strong>CPU 存取速度比较：寄存器 &gt; Cache &gt; 内存</strong></p>
</li>
<li><p>编译程序和解释程序</p>
<ul>
<li>编译程序：先完整编译后再运行程序</li>
<li>一句一句翻译且边翻译边执行，速度慢于编译程序</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="1-2-计算机的性能指标"><a href="#1-2-计算机的性能指标" class="headerlink" title="1.2 计算机的性能指标"></a>1.2 计算机的性能指标</h3><blockquote>
<h4 id="计算机的主要性能指标"><a href="#计算机的主要性能指标" class="headerlink" title="计算机的主要性能指标"></a>计算机的主要性能指标</h4></blockquote>
<ol>
<li><p>机器字长：计算机进行一次整数运算所能处理的二进制数据的位数</p>
<p> <strong>一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高</strong></p>
</li>
<li><p>数据通路带宽：数据总线一次能并行传送数据的位数</p>
</li>
<li><p>主存容量：贮存所能存储的最大容量</p>
<p> 通常以字节来衡量，也可以用 <strong>字数 x 字长</strong>（512K x 16b）</p>
</li>
<li><p>运算速度</p>
<ul>
<li><p>吞吐量和响应时间</p>
<ul>
<li><p>吞吐量：单位时间内处理请求的数量</p>
<p>  <strong>系统的吞吐量主要取决于主存的存储周期</strong></p>
</li>
<li><p>响应时间：用户发出请求到系统做出响应获得结果所需时间</p>
<p>  通常包括：CPU 时间和 等待时间</p>
</li>
</ul>
</li>
<li><p>主频和 CPU 时钟周期</p>
<ul>
<li>CPU 时钟周期：<strong>CPU 中最小的时间单位</strong>，是主频的倒数</li>
<li>主频：对于同一型号的计算机，主频越高，完成指令的而一个执行步骤所用时间越短，指令执行速度越快</li>
</ul>
</li>
<li><p>CPI（Clock cycle Per Instruction）：执行一条指令所需要的时钟周期数（是一个平均值）</p>
</li>
<li><p>CPU 执行时间：<code>CPU 执行时间 = CPU 时钟周期数 / 主频 = (指令条数 x CPI) / 主频</code></p>
<p>  主要取决于：主频、CPI、指令条数，三者是相互制约的</p>
</li>
<li><p>MIPS（Million Instructions Per Second）</p>
</li>
<li><p>MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS：每秒执行 xxx 次浮点数运算</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h4></blockquote>
<ol>
<li>系列机：具有相同体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列</li>
<li>兼容：计算机软件或硬件的通用性</li>
<li>软件可移植性</li>
<li>固件：将程序固定在 ROM 中组成的部件，性能介于硬件和软件之间</li>
</ol>
<h1 id="第二章-数据表示与运算"><a href="#第二章-数据表示与运算" class="headerlink" title="第二章 数据表示与运算"></a>第二章 数据表示与运算</h1><h3 id="考纲及章节框架-1"><a href="#考纲及章节框架-1" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210824174123026.png" alt="image-20210824174123026" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210824173920136.png" alt="image-20210824173920136" style="zoom:80%;" />

<h3 id="2-1-数制与码制"><a href="#2-1-数制与码制" class="headerlink" title="2.1 数制与码制"></a>2.1 数制与码制</h3><blockquote>
<p>进位计数值</p>
</blockquote>
<p><strong>1. 计算机内部使用二进制编码的原因</strong></p>
<ul>
<li>二进制只有两种状态，易于用物理器件表示，制造成本低</li>
<li>二进制位 1 和 0 正好与逻辑值“真”和“假”对应</li>
<li>二进制的编码和运算都很简单，通过逻辑门电路能方便实现算术运算</li>
</ul>
<p><strong>2. 二进制与十进制的转换</strong></p>
<ul>
<li><p>十进制转二进制</p>
<ul>
<li><p>整数部分：除基取余法（取得余数为最高位）</p>
   <img src="【考研】计算机组成原理知识点梳理/image-20210824175151391.png" alt="image-20210824175151391" style="zoom:80%;" />
</li>
<li><p>小数部分：乘基取整法（取得余数为最低位）</p>
   <img src="【考研】计算机组成原理知识点梳理/image-20210824175210854.png" alt="image-20210824175210854" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>其他进制转化都比较简单，就不再赘述</p>
</li>
</ul>
<blockquote>
<p>真值机器数</p>
</blockquote>
<p>真值是日常生活中使用的数，是机器数所代表的实际值。</p>
<p>计算机中通过原码、补码等表示的数为机器数</p>
<blockquote>
<p>字符与字符串</p>
</blockquote>
<p><strong>1. ASCII 码</strong></p>
<p>ASCII码：国际上普遍采用的 <strong>7位二进制编码</strong>（每个字节的最高位保持为 0， 可用于传输时的奇偶校验），总共表示 <strong>128 个字符</strong></p>
<p><strong>2. 汉字的表示和编码</strong></p>
<p>1981 年实施的国家标准 GB2312-1980 中，每个编码用两个字节表示</p>
<p>2000 年公布的国家标准 GB 18030 中，编码标准采用 1B、2B、4B</p>
<p>汉字的编码包括：输入编码、汉字内码、汉字字形码</p>
<blockquote>
<p>Note：</p>
<ol>
<li>0<del>9 的 ASCII 码值位 48（011 0000）</del> 57（011 1001），去掉高三位正好是二进制形式的 0~9</li>
</ol>
</blockquote>
<h1 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h1><h3 id="考纲及章节框架-2"><a href="#考纲及章节框架-2" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210830172925330.png" alt="image-20210830172925330" style="zoom:80%;" />

<p><img src="/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/image-20210830173825963.png" alt="image-20210830173825963"></p>
<h3 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h3><blockquote>
<h4 id="3-1-1-存储器的分类"><a href="#3-1-1-存储器的分类" class="headerlink" title="3.1.1 存储器的分类"></a>3.1.1 存储器的分类</h4></blockquote>
<p><strong>1. 按作用层次分</strong></p>
<ul>
<li>主存储器<ul>
<li>CPU 可以随机进行访问</li>
<li>可以和 Cache 及辅存交换数据</li>
<li><strong>容量小、存取速度快、每位价格较高</strong></li>
</ul>
</li>
<li>辅助存储器<ul>
<li>存放暂时不用或需要永久保存的数据</li>
<li><strong>不能与 CPU 直接交换信息</strong></li>
<li><strong>容量极大、存取速度慢、单位成本低</strong></li>
</ul>
</li>
<li>高速缓冲存储器<ul>
<li>位于主存与 CPU 之间</li>
<li>存取速度与 CPU 相匹配，<strong>存储容量小、价格高</strong></li>
<li><strong>通常制作在 CPU 中</strong></li>
</ul>
</li>
</ul>
<p><strong>2. 按存储介质分</strong></p>
<ul>
<li>磁表面存储器（磁带、磁盘）</li>
<li>磁芯存储器半导体存储器（MOS 型存储器、双极存储器）</li>
<li>光存储器（光盘）</li>
</ul>
<p><strong>3. 按存取方式分</strong></p>
<ul>
<li>随机存储器（RAM）<ul>
<li>可随机存取</li>
<li>读写方便灵活</li>
<li>用作主存或高速缓存</li>
</ul>
</li>
<li>只读存储器（ROM）<ul>
<li>只能<strong>随机读入</strong>而不能写入</li>
<li>存放固定程序、常数等</li>
<li>与 RAM 共同作为主存的一部分，统一构成主存地址域</li>
</ul>
</li>
<li>串行访问存储器<ul>
<li>顺序存取存储器（如磁带，只能按某种顺序存取）</li>
<li>直接存取存储器（如磁盘、光盘，7.2节会详细讲到）</li>
</ul>
</li>
</ul>
<p><strong>4. 按信息可保存性分</strong></p>
<ul>
<li>易失性存储器（RAM）</li>
<li>非易失性存储器（ROM、磁表面存储器、光存储器）</li>
</ul>
<blockquote>
<h4 id="3-1-2-存储器性能指标"><a href="#3-1-2-存储器性能指标" class="headerlink" title="3.1.2 存储器性能指标"></a>3.1.2 存储器性能指标</h4></blockquote>
<p><strong>1. 存储容量</strong></p>
<p><code>存储容量 = 存储字数 x 存储字长（1M x 8bit）</code></p>
<p><strong>2. 单位成本</strong></p>
<p><strong>3. 存储速度</strong></p>
<p><code>数据传输率 = 数据宽度 / 存储周期</code></p>
<ul>
<li>存取时间</li>
<li>存取周期</li>
<li>主存带宽：每秒从主存进出信息的<strong>最大数量</strong>（B&#x2F;s、b&#x2F;s）</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>CD-ROM 是只读光盘，只能进行串行存取，不能随机存取</p>
</li>
<li><p><strong>存取时间与存取周期</strong></p>
<p> 存取周期大于存取时间，因为存储器在读写操作后需要一段恢复时间，存取周期 &#x3D; 存取时间 + 恢复时间</p>
</li>
</ol>
</blockquote>
<h3 id="3-2-存储器的层次结构"><a href="#3-2-存储器的层次结构" class="headerlink" title="3.2 存储器的层次结构"></a>3.2 存储器的层次结构</h3><blockquote>
<h4 id="3-2-1-多级存储系统"><a href="#3-2-1-多级存储系统" class="headerlink" title="3.2.1 多级存储系统"></a>3.2.1 多级存储系统</h4></blockquote>
<p>主要思想：上一层的存储器作为低一层存储器的高速缓存</p>
<ul>
<li>Cache—主存：解决 CPU 和主存速度不匹配的问题</li>
<li>主存—辅存：解决存储系统容量问题</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210904171805582.png" alt="image-20210904171805582" style="zoom:80%;" />

<blockquote>
<p>Note：</p>
<ol>
<li><strong>主存和 Cache</strong> 之间的数据调动由<strong>硬件</strong>完成，对<strong>所有程序员透明</strong></li>
<li><strong>主存与辅存</strong>之间的数据调动由<strong>硬件和 OS</strong> 共同完成，对<strong>应用程序员透明</strong></li>
</ol>
</blockquote>
<h3 id="3-3-半导体随机存储器（🚩）"><a href="#3-3-半导体随机存储器（🚩）" class="headerlink" title="3.3 半导体随机存储器（🚩）"></a>3.3 半导体随机存储器（🚩）</h3><blockquote>
<h4 id="3-3-1-SRAM-和-DRAM"><a href="#3-3-1-SRAM-和-DRAM" class="headerlink" title="3.3.1 SRAM 和 DRAM"></a>3.3.1 SRAM 和 DRAM</h4></blockquote>
<img src="【考研】计算机组成原理知识点梳理/image-20210904172436726.png" alt="image-20210904172436726" style="zoom:80%;" />

<blockquote>
<h4 id="3-3-2-只读存储器"><a href="#3-3-2-只读存储器" class="headerlink" title="3.3.2 只读存储器"></a>3.3.2 只读存储器</h4></blockquote>
<p><strong>1. ROM 特点</strong></p>
<ul>
<li>ROM 支持<strong>随机存取</strong></li>
<li>结构简单，位密度高</li>
<li>具有非易失性，可靠性高</li>
</ul>
<p><strong>2. ROM 类型</strong></p>
<ul>
<li>掩模式只读存储器（MROM）：可靠性高、集成度高、价格便宜；<strong>灵活性差</strong>（写入后内容无法改变）</li>
<li>一次可编程只读存储器（PROM）：<strong>允许</strong>用户利用专门设备<strong>写入程序</strong>，但<strong>只能写一次</strong></li>
<li>可擦除可编程只读存储器（EPROM）：可以进行<strong>编程</strong>也可以对内容进行<strong>擦除</strong>（电擦除和紫外擦除），但是<strong>编程次数有限</strong>，且写入时间过长，故不能替代 RAM</li>
<li>闪速存储器（FLash Memory）：即可在不加电的情况下长期保存，又能在线进行<strong>快速擦除与重写</strong>，擦除重写速度块；价格便宜、集成度高</li>
<li>固态硬盘（SSD）：由<strong>控制单元</strong>和<strong>存储单元</strong>组成，保留了闪存<strong>长期保存信息、擦除重写快</strong>的特性，读写速度快、功耗低，但是<strong>贵</strong></li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>DRAM 电荷只能维持 1~2ms，故需要不断刷新，将原来的内容重新<strong>读入</strong></p>
<ul>
<li>集中刷新：找一个大片时间进行刷新，刷新时候存储器停止工作，故存在 <strong>访存死区</strong></li>
<li>分散刷新：每行的刷新分散到各个工作周期中，不存在访存死区，但是效率低下</li>
<li>异步刷新：综合前两种方法，既可以<strong>缩短死时间</strong>，又可以充分利用最大刷新间隔的特点</li>
</ul>
</li>
<li><p>DRAM 刷新对 CPU 透明，不依赖于外部的访问</p>
</li>
<li><p><strong>DRAM 刷新单位是行</strong>，由芯片内部自行生成行地址</p>
</li>
<li><p>注意区分<strong>易失性存储器</strong>和<strong>刷新</strong>的区别</p>
</li>
<li><p><strong>RAM 引脚数：地址线个数 + 数据线个数 + 片选端 + RW 控制</strong></p>
<p> 容量为 1024 x 8bit 的SRAM，除电源和接地端外芯片引脚数最小为：10 + 8 + 1 + 1 &#x3D; 20</p>
</li>
</ol>
</blockquote>
<h3 id="3-4-主存储器与-CPU-的连接"><a href="#3-4-主存储器与-CPU-的连接" class="headerlink" title="3.4 主存储器与 CPU 的连接"></a>3.4 主存储器与 CPU 的连接</h3><blockquote>
<h4 id="3-4-1-连接原理"><a href="#3-4-1-连接原理" class="headerlink" title="3.4.1 连接原理"></a>3.4.1 连接原理</h4></blockquote>
<p>主存储器通过<strong>数据总线</strong>、<strong>地址总线</strong>、<strong>控制总线</strong>与 CPU 连接</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210905164141904.png" alt="image-20210905164141904" style="zoom:80%;" />

<blockquote>
<h4 id="3-4-2-主存容量的扩展"><a href="#3-4-2-主存容量的扩展" class="headerlink" title="3.4.2 主存容量的扩展"></a>3.4.2 主存容量的扩展</h4></blockquote>
<p><strong>1. 位扩展法</strong></p>
<p>8 个 <code>8K x 1bit</code> 的 RAM 芯片组成 <code>8K x 8bit</code> 的存储器：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210905164527963.png" alt="image-20210905164527963" style="zoom:80%;" />

<p><strong>2. 字扩展法</strong></p>
<p>4 片 <code>16K x 8bit</code> 的 RAM 芯片组成 <code>64K x 8bit</code>  的存储器：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210905164803945.png" alt="image-20210905164803945" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210905164845569.png" alt="image-20210905164845569" style="zoom:80%;" />

<p><strong>3. 字位同时扩展法</strong></p>
<p>8 片 <code>16K x 4bit</code> 的 RAM 芯片组成 <code>64K x 8bit</code> 的存储器</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210905165028231.png" alt="image-20210905165028231" style="zoom:80%;" />

<blockquote>
<h4 id="3-4-3-存储芯片的地址分配和片选"><a href="#3-4-3-存储芯片的地址分配和片选" class="headerlink" title="3.4.3 存储芯片的地址分配和片选"></a>3.4.3 存储芯片的地址分配和片选</h4></blockquote>
<ul>
<li>线选法</li>
<li>译码片选法</li>
</ul>
<h3 id="3-5-双端口-RAM-和多模块存储器"><a href="#3-5-双端口-RAM-和多模块存储器" class="headerlink" title="3.5 双端口 RAM 和多模块存储器"></a>3.5 双端口 RAM 和多模块存储器</h3><h3 id="3-6-高速缓存（Cache）"><a href="#3-6-高速缓存（Cache）" class="headerlink" title="3.6 高速缓存（Cache）"></a>3.6 高速缓存（Cache）</h3><h3 id="3-7-虚拟存储器"><a href="#3-7-虚拟存储器" class="headerlink" title="3.7 虚拟存储器"></a>3.7 虚拟存储器</h3><p>是对 OS 第三章 内存管理的简单描述，详细去看 OS</p>
<blockquote>
<h4 id="虚拟存储器基本概念"><a href="#虚拟存储器基本概念" class="headerlink" title="虚拟存储器基本概念"></a>虚拟存储器基本概念</h4></blockquote>
<ul>
<li><p>主机和联机工作的辅存共同构成了虚拟存储器</p>
<p>  <strong>虚拟存储器将主存和辅存的地址空间统一编址</strong>，形成一个庞大的地址空间，用户可以自由编程而不必在乎实际的主存容量和程序在主存中的实际存放位置。</p>
</li>
<li><p>对于<strong>应用程序员</strong>而言，<strong>虚拟存储器是透明的</strong></p>
</li>
<li><p>虚拟存储器具有<strong>主存的速度</strong>和<strong>辅存的容量</strong>，提高了存储系统性价比</p>
</li>
</ul>
<blockquote>
<h4 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h4></blockquote>
<ul>
<li>页式虚拟存储器：以页为基本单位的虚拟存储器</li>
<li>虚拟地址分为两段：<strong>虚页号</strong>、<strong>页内地址</strong></li>
<li><strong>虚拟地址到物理地址的转换由页表完成</strong></li>
<li>页表是一张存放<strong>虚页号</strong>和<strong>实页号</strong>的对照表，<strong>一般长久保存在内存中</strong></li>
</ul>
<p><strong>1.页表</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210830174922664.png" alt="image-20210830174922664" style="zoom:80%;" />

<p>几个特殊位：</p>
<ul>
<li>有效位（装入位）：表示对应页面是否在主存中</li>
<li>脏位（修改位）：表示页面是否被修改过</li>
<li>引用位（使用位）：配合页面替换算法使用</li>
</ul>
<p>虚拟地址到物理地址的地址变换过程：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210830175354607.png" alt="image-20210830175354607" style="zoom:80%;" />

<ol>
<li>根据虚拟页号找到对应的页表项</li>
<li>通过装入位判断是否被装入内存<ul>
<li><code>装入位 == 1</code>：拼接所查到的<strong>物理页号</strong>及虚拟地址的<strong>页内地址</strong>部分，形成物理地址</li>
<li><code>装入位 == 0</code>：产生缺页中断</li>
</ul>
</li>
</ol>
<p>优缺点：</p>
<ul>
<li>优点：页面长度固定，页表简单，调入方便</li>
<li>缺点：<ul>
<li>程序不会正好是页面的整数倍，最后一页的零头无法利用而造成浪费</li>
<li>页不是逻辑独立实体，处理、保护和共享不如段式存储器方便</li>
</ul>
</li>
</ul>
<p><strong>2. 快表（TLB）</strong></p>
<p>使用页表机制后每次获取数据都<strong>需要访问两次主存</strong>，效率大大降低，故考虑引入<strong>由高速缓冲器组成的快表</strong></p>
<p>快表通常采用全相联或组相联方式</p>
<p>TLB 标记的内容在<strong>全相联方式</strong>下就是该页表项对应的<strong>虚页号</strong>；<strong>组相联方式</strong>下对应虚页号的高位部分，而虚页号的低位部分用于选择 TLB组 的组索引</p>
<p><strong>3. 具有 TLB 和 Cache 的多级存储系统</strong></p>
<ul>
<li>TLB 和 Cache 访问过程如下图所示：</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210901154828530.png" alt="image-20210901154828530" style="zoom:80%;" />

<ul>
<li>访问过程框图：</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210901155032709.png" alt="image-20210901155032709" style="zoom:80%;" />

<blockquote>
<h4 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h4></blockquote>
<ul>
<li><p>段式虚拟存储器中的<strong>段是按程序的逻辑结构划分的</strong></p>
</li>
<li><p>虚拟地址分为：<strong>段号</strong>、<strong>段内地址</strong></p>
</li>
<li><p>段表每行记录包括：<strong>段号</strong>、<strong>装入位</strong>、<strong>段起点</strong>、<strong>段长</strong>等</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210901161128878.png" alt="image-20210901161128878" style="zoom:80%;" />
</li>
<li><p>优点</p>
<ul>
<li>段的分界与程序的自然分界对应，具有逻辑独立性</li>
<li>易于编译、管理、修改、保护</li>
<li>便于多道程序共享</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>段长可变，分配空间不便</li>
<li>容易在段内留下碎片，不好利用从而造成浪费</li>
</ul>
</li>
</ul>
<blockquote>
<p>段页式虚拟存储器</p>
</blockquote>
<ul>
<li><p>段页式虚拟存储器：先将程序按逻辑分段，再将各段划分为固定大小的页</p>
<p>  主存空间也划分为大小相等的页，程序对调以页为传送基本单位</p>
</li>
<li><p><strong>每个程序对应一个段表，每个段对应一个页表</strong></p>
</li>
<li><p>段长为页长整数倍，段的起点是某一页的起点</p>
</li>
<li><p>虚地址分为：<strong>段号</strong>、<strong>段内页号</strong>、<strong>页内地址</strong></p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210901161630658.png" alt="image-20210901161630658" style="zoom:80%;" />
</li>
<li><p>优点</p>
<ul>
<li>兼具页式和段式存储器的优点</li>
<li>可以按段实现共享和保护</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>地址变换过程中，需要两次查表，系统开销大</li>
</ul>
</li>
</ul>
<blockquote>
<p>虚拟存储器与 Cache 比较 </p>
</blockquote>
<ul>
<li><p>相同</p>
<ul>
<li>目标都是提高系统性能</li>
<li>都把数据划分为小数据块</li>
<li>都有<strong>地址映射</strong>、<strong>替换算法</strong>、<strong>更新策略</strong></li>
<li>都<strong>依据程序的局部性原理</strong>，应用快速缓存的思想</li>
</ul>
</li>
<li><p>不同</p>
<table>
<thead>
<tr>
<th align="center">Cache</th>
<th align="center">虚拟存储器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主要解决<strong>系统速度</strong></td>
<td align="center">主要解决主存容量</td>
</tr>
<tr>
<td align="center">全硬件实现，是硬件存储器<br />对程序员透明</td>
<td align="center">由 OS 和硬件共同实现，是逻辑上的存储器<br />对系统程序员不透明，对应用程序员透明</td>
</tr>
<tr>
<td align="center">不命中影响较小</td>
<td align="center">不命中影响较大（需要访问磁盘）</td>
</tr>
<tr>
<td align="center">不命中时主存与 CPU 可以直接通信</td>
<td align="center">不命中时，只能由硬盘调入主存，而不能直接和 CPU 通信</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li>Cache 和 虚拟存储器都是由 DRAM组成</li>
<li>CPU 访存的三种缺失：<ul>
<li>TLB 缺失</li>
<li>Cache 缺失</li>
<li>缺页</li>
</ul>
</li>
<li>页式存储器地址空间是一维的，而段式存储器地址空间是二维的</li>
</ol>
</blockquote>
<h1 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h1><h1 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h1><h3 id="考纲及章节框架-3"><a href="#考纲及章节框架-3" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210812173325315.png" alt="image-20210812173325315" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210812174119586.png" alt="image-20210812174119586" style="zoom:80%;" />

<h3 id="5-1-CPU的功能和基本结构"><a href="#5-1-CPU的功能和基本结构" class="headerlink" title="5.1 CPU的功能和基本结构"></a>5.1 CPU的功能和基本结构</h3><blockquote>
<h4 id="CPU-的功能"><a href="#CPU-的功能" class="headerlink" title="CPU 的功能"></a>CPU 的功能</h4></blockquote>
<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>时间控制</li>
<li>数据加工</li>
<li>中断处理</li>
</ul>
<blockquote>
<h4 id="CPU-的基本结构"><a href="#CPU-的基本结构" class="headerlink" title="CPU 的基本结构"></a>CPU 的基本结构</h4></blockquote>
<p>CPU 由<strong>运算器</strong>和<strong>控制器</strong>组成。</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210812180436053.png" alt="image-20210812180436053" style="zoom:80%;" />

<p>（图源自：<a href="https://blog.csdn.net/chen1083376511/article/details/81941318">计算机组成原理（4）-中央处理器CPU_妖小谦-CSDN博客_cpu组成</a>）</p>
<ul>
<li>运算器：<strong>算术逻辑单元（ALU）</strong>、暂存寄存器、<strong>累加寄存器（ACC）</strong>、<strong>通用寄存器组</strong>、程序状态寄存器（PSW）、移位器、计数器（CT）<ul>
<li>暂存寄存器：<strong>对应用程序员透明</strong></li>
<li><strong>ACC</strong>：可以作为加法运算的一个输入端</li>
<li>通用寄存器组：AX、BX、CX、DX、<strong>SP（堆栈指针，用于指示栈顶地址）</strong></li>
<li><strong>PSW</strong>：溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）</li>
</ul>
</li>
<li>控制器：<strong>程序计数器（PC）</strong>、<strong>IR</strong>、指令译码器、<strong>存储器地址寄存器（MAR）</strong>、<strong>存储器数据寄存器（MDR）</strong>、时序系统、微操作信号发生器<ul>
<li>PC：用于指出<strong>下一条指令在主存中的地址</strong>，程序顺序执行故 <strong>PC 有自增功能</strong>。</li>
<li>IR：保存当前正在执行的指令</li>
<li>MAR：存放要访问的主存地址单元</li>
<li>MDR：存放向主存中存入或读出的数据</li>
<li>微操作信号发生器：根据 IR、PSW 及时序信号，产生控制整个计算机系统的控制信号</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>用户可见寄存器（不透明）：通用寄存器组、PSW</p>
<p> 用户不可见寄存器（透明）：MAR、MDR、IR、暂存寄存器</p>
</li>
<li><p><strong>PC 位数 &#x3D; MAR 位数</strong>，取决于存储容量</p>
<p> <strong>MDR 位数 &#x3D; 机器字长</strong></p>
<p> <strong>IR 位数取决于指令字长</strong></p>
</li>
<li><p>条件转移所依据的条件来自：PSW</p>
</li>
<li><p>n 位 CPU，n 指 <strong>数据总线位数</strong></p>
</li>
<li><p><strong>指令译码</strong>是对指令的<strong>操做码字段</strong>进行译码</p>
</li>
</ol>
</blockquote>
<h3 id="5-2-指令执行过程"><a href="#5-2-指令执行过程" class="headerlink" title="5.2 指令执行过程"></a>5.2 指令执行过程</h3><blockquote>
<h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4></blockquote>
<p>指令周期：从主存中取出并执行一条指令的时间称为指令周期</p>
<ul>
<li>若干个<strong>时钟周期</strong>构成一个<strong>机器周期（既为CPU 周期，一般等于存取周期）</strong></li>
<li>若干个<strong>机器周期</strong>构成一个<strong>指令周期</strong></li>
</ul>
<p>三者之间的关系如下图所示：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210813151204811.png" alt="image-20210813151204811" style="zoom:80%;" />

<p>整个指令周期包括：<strong>取指周期、间指周期、执行周期和中断周期</strong>四个机器周期。</p>
<p>四个工作周期都有 CPU 访存，只是访存目的不同。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">取指周期</th>
<th align="left">间指周期</th>
<th align="left">执行周期</th>
<th align="left">中断周期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">任务</td>
<td align="left">根据 PC 中的内容从主存中<strong>取出指令代码并放在 IR 中</strong></td>
<td align="left"><strong>取操作数的有效地址</strong></td>
<td align="left">不同指令执行周期任务不同</td>
<td align="left">处理中断请求</td>
</tr>
<tr>
<td align="center">访存目的</td>
<td align="left">取指令</td>
<td align="left">取有效地址</td>
<td align="left">取操作数</td>
<td align="left">保存程序断点</td>
</tr>
<tr>
<td align="center">数据流向</td>
<td align="left">1. PC–&gt;MAR–&gt;地址总线–&gt;主存<br />2. CU发出控制信号–&gt;控制总线–&gt;主存<br />3. 指令–&gt;数据总线–&gt;MDR–&gt;IR<br />4. CU发出命令–&gt;PC + 1</td>
<td align="left">1. Ad(IR)–&gt;MAR–&gt;地址总线–&gt;主存<br />2. CU发出读命令–&gt;控制总线–&gt;主存<br />3. 主存–&gt;数据总线–&gt;MDR</td>
<td align="left"></td>
<td align="left">1. CU控制SP-1–&gt;MAR–&gt;地址总线–&gt;主存<br />2. CU发出写命令–&gt;控制总线–&gt;主存<br />3. PC–&gt;MDR–&gt;数据总线–&gt;主存</td>
</tr>
<tr>
<td align="center">图示</td>
<td align="left"><img src="【考研】计算机组成原理知识点梳理/image-20210813152550821.png" alt="image-20210813152550821" style="zoom:80%;" /></td>
<td align="left"><img src="【考研】计算机组成原理知识点梳理/image-20210813152607016.png" alt="image-20210813152607016" style="zoom:80%;" /></td>
<td align="left"></td>
<td align="left"><img src="【考研】计算机组成原理知识点梳理/image-20210813152626969.png" alt="image-20210813152626969" style="zoom:80%;" /></td>
</tr>
</tbody></table>
<blockquote>
<h4 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h4></blockquote>
<ul>
<li>单指令周期</li>
<li>多指令周期</li>
<li>指令流水线</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>中断周期的进栈操作是 SP - 1，因为计算机中的堆栈都是向低地址增加的</p>
</li>
<li><p>进栈操作时先修改栈顶指针后存入数据</p>
</li>
<li><p>存取周期：连续执行两读&#x2F;写操作中间间隔的最小时间</p>
<p> 指令周期：主存中取出一条指令并执行所用的时间</p>
</li>
<li><p>取指周期是<strong>从主存中取出指令字</strong>，PC 会给出指令在主存中的位置</p>
</li>
<li><p>通常把通过一次总线事务访问一次主存或 IO 的时间定位机器周期</p>
</li>
<li><p><strong>指令字长等于存储字长的前提下，取指周期等于机器周期</strong>（一次就可以把整条指令取出）</p>
<p> 指令字长和机器字长没有任何关系</p>
</li>
</ol>
</blockquote>
<h3 id="5-3-数据通路的功能和基本结构（🚩）"><a href="#5-3-数据通路的功能和基本结构（🚩）" class="headerlink" title="5.3 数据通路的功能和基本结构（🚩）"></a>5.3 数据通路的功能和基本结构（🚩）</h3><blockquote>
<h4 id="概念及功能"><a href="#概念及功能" class="headerlink" title="概念及功能"></a>概念及功能</h4></blockquote>
<p>数据通路：数据在功能部件之间传送的道路</p>
<p>数据通路的功能：实现CPU内部的 <strong>运算器与寄存器</strong> 及 <strong>寄存器与寄存器</strong> 之间的数据交换</p>
<blockquote>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4></blockquote>
<ul>
<li><p>CPU 内部单总线方式</p>
<p>  结构简单，但是<strong>数据传输存在较多冲突，性能较低</strong></p>
</li>
<li><p>CPU 内部三总线方式</p>
<p>  同时在多个总线上传输不同数据，<strong>提高效率</strong></p>
</li>
<li><p>专用数据通路方式</p>
<p>  依据指令执行过程中的数据和地址的流动方向安排连接线路，避免共享总线，<strong>性能高，但是硬件量大</strong></p>
</li>
</ul>
<blockquote>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4></blockquote>
<ul>
<li><p>寄存器与寄存器之间：把 PC 内容送到 MAR</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC--&gt;BUS</span><br><span class="line">BUS--&gt;MAR</span><br></pre></td></tr></table></figure>
</li>
<li><p>主存与 CPU 之间：CPU 从主存中读取指令</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC--&gt;BUS--&gt;MAR</span><br><span class="line">1--&gt;R					// CU 发出读命令</span><br><span class="line">MEM(MAR)--&gt;MDR</span><br><span class="line">MDR--&gt;BUS--&gt;IR</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行算术或逻辑运算：取操作数和 ACC 中的内容相加</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ad(IR)--&gt;BUS--&gt;MAR</span><br><span class="line">1--&gt;R</span><br><span class="line">MEM--&gt;数据线--&gt;MDR</span><br><span class="line">MDR--&gt;BUS--&gt;Y			// 数据放入暂存寄存器中</span><br><span class="line">(ACC)+(Y)--&gt;Z</span><br><span class="line">Z--&gt;ACC</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>Note:</p>
<ol>
<li><p><strong>暂存寄存器 Y</strong>：执行算术逻辑操作时，由于 <strong>ALU 本身没有内部存储功能的组合电路</strong>，因此执行加法运算时，先将一个操作数放入暂存寄存器 Y 中保存，再将另一个数经总线直接送到 ALU 的另一端</p>
</li>
<li><p>内部总线：CPU 内部连接各寄存器及运算部件之间的总线（<strong>使用内部总线，实现简单，性能较低，冲突较多</strong>）</p>
<p> 系统总线：是指同一台计算机系统的各个部件间互相连接的总线</p>
</li>
<li><p><strong>单周期处理器不能使用单总线结构数据通路</strong>，因为单总线数据通路一个时钟周期只允许一次操作，无法完成指令的所有操作</p>
</li>
</ol>
</blockquote>
<h3 id="5-4-控制器的功能和工作原理"><a href="#5-4-控制器的功能和工作原理" class="headerlink" title="5.4 控制器的功能和工作原理"></a>5.4 控制器的功能和工作原理</h3><blockquote>
<h4 id="结构和功能"><a href="#结构和功能" class="headerlink" title="结构和功能"></a>结构和功能</h4></blockquote>
<p>计算机硬件系统和控制器部件的组成如下图所示</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210813161710249.png" alt="image-20210813161710249" style="zoom:80%;" />

<p>控制器的主要功能：</p>
<ul>
<li>从主存中<strong>取出一条指令</strong>，并<strong>指出下一条指令</strong>在主存中的位置</li>
<li>对指令进行译码和测试，<strong>产生相应的操作控制信号</strong>，以便启动规定动作</li>
<li>指挥并<strong>控制</strong> CPU、主存、IO 设备之间的<strong>数据流动方向</strong></li>
</ul>
<p>分类：</p>
<ul>
<li>硬布线控制器（不是重点不展开介绍了）</li>
<li>微程序控制器</li>
</ul>
<blockquote>
<h4 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h4></blockquote>
<p>微程序控制器<strong>采用存储逻辑实现</strong>，就是<strong>把微操作信号代码化</strong>，使每<strong>条机器指令转化成为一段微程序</strong>并<strong>存入一个专门的存储器中</strong>（控制存储器 CM）</p>
<p><strong>1. 一些概念：</strong></p>
<ul>
<li><p>微命令与微操作：微操作是计算机中最基本、不可再分解的操作。微命令是构成控制序列的最小单位。</p>
<p>  微操作与微命令是一一对应的。<strong>微命令是微操作的控制信号，微操作是微命令的执行过程</strong></p>
</li>
<li><p>微指令：若干微命令的集合，一条微指令通常包含<strong>微操作码字段（操作控制字段）</strong>和<strong>微地址码字段（顺序控制字段）</strong></p>
<ul>
<li>微操作码字段：产生某一步操作所需要的各种操作控制信号</li>
<li><strong>微地址码字段：控制产生下一条要执行的微指令地址字段</strong></li>
</ul>
</li>
<li><p>微周期：从控制存储器内读取一条微指令并执行相应微操作所需的时间</p>
</li>
<li><p>主存储器与控制存储器：</p>
<ul>
<li><strong>主存储器</strong>用于存放程序和数据，<strong>位于 CPU 外部，用 RAM 实现</strong></li>
<li><strong>控制存储器</strong>用于存放微程序，<strong>位于 CPU 内部，用 ROM 实现</strong></li>
</ul>
</li>
<li><p>程序与微程序：</p>
<ul>
<li>程序是指令的有序集合，用于完成特定功能</li>
<li>一条指令的功能是由一个微程序来实现的</li>
</ul>
</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210813171409025.png" alt="image-20210813171409025" style="zoom:80%;" />

<p><strong>2. 微程序控制器的基本组成：</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210813172047563.png" alt="image-20210813172047563" style="zoom:80%;" />

<ul>
<li>控制存储器（CM）：核心部件，用于存放指令对应的微程序</li>
<li>微指令寄存器（CMDR&#x2F;μIR）：存放从 CM 中取出的微指令</li>
<li>微地址形成部件</li>
<li>微地址寄存器（CMAR）</li>
</ul>
<p><strong>3. 微指令的编码方式</strong></p>
<ul>
<li><p>直接编码：微指令的微命令字段每位代表一个微命令</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210813173616533.png" alt="image-20210813173616533" style="zoom:80%;" />

<ul>
<li><p>优点：简单、直观，执行速度快，操作并行性好</p>
</li>
<li><p>缺点：微指令字长过长，造成 CM 容量极大</p>
</li>
</ul>
</li>
<li><p>字段直接编码方式：把微命令字段分成若干小段，把<strong>互斥性微命令组合放在同一字段中，把相容性微命令组合 放在不同字段中</strong>，每个字段独立编码</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210813173641726.png" alt="image-20210813173641726" style="zoom:80%;" />

<ul>
<li>优点：缩短指令字长</li>
<li>缺点：比直接编码方式慢</li>
<li>小段中的信息位不能太多，一般每个小段还留出一个状态表示本字段不发出任何微命令（如 000）</li>
</ul>
</li>
<li><p>字段间接编码：一个字段的微命令需要由另一个字段的某些微命令来解释（作为字段直接编码方式的辅助）</p>
</li>
</ul>
<p><strong>4. 微指令的地址形成方式</strong></p>
<ul>
<li>直接由微指令的下地址字段指出</li>
<li>根据机器指令操作码形成</li>
</ul>
<p><strong>5. 微指令的格式</strong></p>
<ul>
<li>水平型微指令：<strong>微程序短</strong>，执行速度快；<strong>微指令长</strong>，编写微程序较为麻烦</li>
<li>垂直型微指令：<strong>微指令短</strong>，便于编写微程序；<strong>微程序长</strong>，工作效率低</li>
<li>混合型微指令：在垂直型的基础上增加不复杂的并行操作</li>
</ul>
<blockquote>
<h4 id="硬布线控制器与微程序控制器对比"><a href="#硬布线控制器与微程序控制器对比" class="headerlink" title="硬布线控制器与微程序控制器对比"></a>硬布线控制器与微程序控制器对比</h4></blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">硬布线控制器</th>
<th align="center">微程序控制器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">工作原理</td>
<td align="center">微操作信号由组合逻辑电路根据当前指令码、状态和时序即时产生</td>
<td align="center">微操作信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td>
</tr>
<tr>
<td align="center">执行速度</td>
<td align="center">快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">规整性</td>
<td align="center">不规整</td>
<td align="center">规整</td>
</tr>
<tr>
<td align="center">应用场合</td>
<td align="center">RISC CPU</td>
<td align="center">CISC CPU</td>
</tr>
<tr>
<td align="center">易扩展性</td>
<td align="center">不易扩展</td>
<td align="center">易扩展</td>
</tr>
</tbody></table>
<blockquote>
<p>Note：</p>
<ol>
<li><p>在组合逻辑控制器（硬布线控制器）中也存在微命令与微操作的概念</p>
</li>
<li><p>对程序员来说，<strong>微程序的结构和功能都是透明的</strong></p>
</li>
<li><p>控制存储器中的微程序个数：机器指令数 + 对应取指、间指和中断周期等共用的微程序个数</p>
<p> 若指令系统中有 <strong>n 种机器指令</strong>，则 <strong>CM 中的微程序数至少是 n + 1</strong>（1 位公共取指微程序）</p>
</li>
<li><p>实现动态微程序设计可采用：可擦除可编程只读存储器（EPROM）</p>
</li>
<li><p>组合逻辑控制器种，微操作控制信号形成主要与 <strong>指令译码信号和时钟</strong> 有关</p>
</li>
<li><p>微程序的入口地址：机器指令的操做码字段</p>
</li>
<li><p>微指令结构设计所追求的目标：</p>
<ul>
<li>提高微程序的执行速度</li>
<li>提供程序设计的灵活性</li>
<li>缩短指令的长度</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="5-5-指令流水线（🚩）"><a href="#5-5-指令流水线（🚩）" class="headerlink" title="5.5 指令流水线（🚩）"></a>5.5 指令流水线（🚩）</h3><blockquote>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4></blockquote>
<p>采用流水线技术<strong>只需要增加少量硬件</strong>就能把计算机的<strong>运算速度提升几倍</strong>，是计算机中普遍使用的一种<strong>并行处理技术</strong>。</p>
<p><strong>1. 指令执行阶段</strong></p>
<p>我们把一条指令的执行过程大致划分为三个阶段：<strong>取指、分析、执行</strong></p>
<ul>
<li>取指：根据 PC 内容访问主存取出指令送至 IR</li>
<li>分析：对指令操做码进行译码，按照给定的寻址方式和地址形成操作数的有效地址 EA，并根据 EA 取出操作数</li>
<li>执行：依据指令操做码完成指定功能，并将运算结果写入寄存器或主存中</li>
</ul>
<p><strong>2. 指令执行方式</strong></p>
<p>指令可采用两种方式执行：<strong>顺序执行、流水线执行</strong>（假设指令三个阶段花费时间相同，均为 t）</p>
<ul>
<li><p>顺序执行：就是按照指令顺序一条一条执行指令</p>
<p>  <strong>执行 n 条指令用时：$T&#x3D;3nt$​​</strong></p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210814152645275.png" alt="image-20210814152645275" style="zoom:80%;" />
</li>
<li><p>流水线执行：为了充分利用各功能部件，不让他们闲着摸🐟，在第一条指令执行完取指操作后就开始执行第二条指令的取指操作，后面指令依次这样进行</p>
<p>  <strong>执行 n 条指令用时：$T&#x3D;(3+n-1)t&#x3D;(n+2)t$​​</strong> （第一条指令运行结束后每经过 t 时间完成一条指令的运行）</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210814152701535.png" alt="image-20210814152701535" style="zoom:80%;" /></li>
</ul>
<p><strong>3. 流水线设计原则</strong></p>
<ul>
<li>指令流水段个数以最复杂指令所用的功能段个数为准</li>
<li>流水线的长度以最复杂的操作所花的时间为准</li>
</ul>
<p><strong>4. 指令集特征（为了实现流水线功能）</strong></p>
<ul>
<li>指令长度一致</li>
<li>指令格式规整，保证源寄存器位置相同</li>
<li>采用 <code>Load/Store</code> 指令访存</li>
<li>数据和指令对齐放置</li>
</ul>
<p><strong>5. 流水线的表示方法：时空图</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210814154021116.png" alt="image-20210814154021116" style="zoom:80%;" />

<blockquote>
<h4 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h4></blockquote>
<p><strong>流水线冲突（冒险）</strong>：指令流水线可能会因为一些情况而受到阻碍或停顿</p>
<ol>
<li><p><strong>资源冲突</strong>：多条指令同时征用同一硬件资源</p>
<p> 解决方法：1）后一条指令暂停一个时钟周期    2）数据与指令存储器分离</p>
</li>
<li><p><strong>数据冲突</strong>：下一条指令用到当前指令的计算结果</p>
<p> 分类：</p>
<ol>
<li>写后读相关（RAW）     </li>
<li>读后写相关（WAR）    </li>
<li>写后写相关（WAW）</li>
</ol>
<p> 解决方法：</p>
<ol>
<li>将后面指令暂停一到几个周期。（硬件阻塞&#x2F;软件插入“NOP”）</li>
<li>设置相关专用通路（数据旁路技术）</li>
<li>指令编译优化，调整指令执行顺序</li>
</ol>
</li>
<li><p><strong>控制冲突</strong>：执行转移、调用、返回等指令时修改 PC 的值造成断流</p>
<p> 解决办法：</p>
<ol>
<li>分支预测，尽早生成转移目标地址</li>
<li>预测转移成功和不成功两个控制流方向上的目标指令</li>
<li>加快和提前形成条件码</li>
<li>提高转移方向猜准率</li>
</ol>
</li>
</ol>
<blockquote>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4></blockquote>
<ol>
<li><p><strong>吞吐率</strong>：单位时间内流水线所完成的任务数量<br> $$<br> TP&#x3D;{n\over T_k} \\<br> TP&#x3D;{n \over (k+n-1)t}<br> $$<br> $n$​ 是任务数量，$T_k$​ 是处理完 $n$​ 个任务所用时间，$k$​​ 是流水线级数，$t$​​ 是一个流水线功能段处理时间</p>
</li>
<li><p><strong>加速比</strong>：不使用流水线与使用流水线所用时间之比<br> $$<br> S&#x3D;{T_0 \over T_k} \ \<br> S&#x3D;{kn \over k+n-1}<br> $$</p>
</li>
<li><p><strong>效率</strong>：设备利用率（时空图上，n 个任务有效面积与整个矩形面积之比）</p>
</li>
</ol>
<p><img src="/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/image-20210814161324557.png" alt="image-20210814161324557"></p>
<blockquote>
<h4 id="超标量流水线"><a href="#超标量流水线" class="headerlink" title="超标量流水线"></a>超标量流水线</h4></blockquote>
<ol>
<li><p>超标量流水线技术（<strong>空间换时间</strong>）</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210814161643985.png" alt="image-20210814161643985" style="zoom:80%;" />
</li>
<li><p>超流水线技术</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210814161656646.png" alt="image-20210814161656646" style="zoom:80%;" />
</li>
<li><p>超长指令字</p>
<p> 将多条能并行操作的指令组成一条具有多个操作码字段的超长指令字</p>
</li>
</ol>
<blockquote>
<p>Note：</p>
<ol>
<li><p>k 级流水线执行 n 条指令用时：$T &#x3D; (k+n-1)t$​</p>
</li>
<li><p>流水线并不能缩短一条指令的执行时间，但是整体而言，可以大大增加指令执行的吞吐率</p>
</li>
<li><p>Cache 缺失也会造成流水线阻塞</p>
</li>
<li><p>RISC、CISC 机器都有流水线 CPU</p>
</li>
<li><p>超标量流水线技术不能缩短流水线功能段的处理时间</p>
</li>
<li><p>指令流水线数据通路：</p>
<p> 不包含生成控制信号的控制部件</p>
<p> 包含 ALU、通用寄存器组</p>
<p> 由组合逻辑电路和时序逻辑电路组合而成</p>
</li>
<li><p>流水段越多，执行指令越快？</p>
<ul>
<li>流水段缓冲之间的额外开销增大</li>
<li>流水段间控制逻辑变多变复杂</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h1><h3 id="考纲及章节框架-4"><a href="#考纲及章节框架-4" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210816154332708.png" alt="image-20210816154332708" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210816155043489.png" alt="image-20210816155043489" style="zoom:80%;" />

<h3 id="6-1-总线概述"><a href="#6-1-总线概述" class="headerlink" title="6.1 总线概述"></a>6.1 总线概述</h3><blockquote>
<h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4></blockquote>
<p><strong>总线</strong>是一组能够为多个部件 <strong>分时共享</strong> 的公共信息传输线（更好的解决 IO 设备与主机之间连接的灵活性问题）</p>
<ul>
<li><p>分时：同一时刻只允许一个部件向总线发送信息</p>
</li>
<li><p>共享：总线上挂接多个部件，各部件之间可以通过总线分时共享信息</p>
<p>  🚩 某一时刻只允许<strong>一个部件</strong>向总线<strong>发送信息</strong>，但<strong>多个部件</strong>可以同时从总线上<strong>接受相同的信息</strong>！</p>
</li>
</ul>
<p>主设备与从设备：</p>
<ul>
<li>主设备：获得总线控制权的设备（只能有一个！）</li>
<li>从设备：被主设备访问，相应各种命令（可以有多个）</li>
</ul>
<p>总线特性：</p>
<ul>
<li><strong>机械特性</strong>：尺寸、形状</li>
<li><strong>电气特性</strong>：传输方向、有效电平范围</li>
<li><strong>功能特性</strong>：每根传输线的功能</li>
<li><strong>时间特性</strong>：信号和时序的关系</li>
</ul>
<p>引入总线系统的好处：</p>
<ul>
<li>简化系统结构</li>
<li>减少连线数目，便于布线，提高系统可靠性</li>
<li>便于接口设计</li>
<li>便于系统拓展，易于实现模块化</li>
<li>便于设备的软件设计</li>
<li>便于故障维修，降低成本</li>
</ul>
<p>🚩 <strong>总线的猝发传输方式</strong>：在<strong>一个总线周期</strong>内传输<strong>地址连续</strong>的<strong>多个数据字</strong>的总线传输方式（地址连续的数据只用传输第一个数据的地址）</p>
<blockquote>
<h4 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h4></blockquote>
<ol>
<li><p>片内总线</p>
</li>
<li><p>系统总线（本章主角）</p>
<ul>
<li>数据总线：🚩 <strong>双向传输总线，位数与机器字长、存储字长有关</strong></li>
<li>地址总线：🚩 <strong>单向传输总线，位数与主存地址空间大小有关</strong></li>
<li>控制总线</li>
</ul>
</li>
<li><p>通信总线</p>
<p> 计算机系统之间或计算机系统与其它系统之间传送信息的总线，也叫 外部总线</p>
</li>
</ol>
<blockquote>
<h4 id="系统总线的结构"><a href="#系统总线的结构" class="headerlink" title="系统总线的结构"></a>系统总线的结构</h4></blockquote>
<ol>
<li><p>单总线结构</p>
<p> CPU、主存、IO 设备都挂在一组总线上</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210816161653311.png" alt="image-20210816161653311" style="zoom:80%;" />

<ul>
<li>优点：结构简单、成本低、易于接入新设备</li>
<li>缺点：带宽低、负载重、多个部件只能争用一条总线、不支持并发传送</li>
</ul>
</li>
<li><p>双总线结构</p>
<p> 一条是 <strong>主存总线</strong>，另一条是 <strong>IO 总线</strong>（用于多个外部设备与<strong>通道</strong>之间的数据传输）</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210816162006058.png" alt="image-20210816162006058" style="zoom:80%;" />

<ul>
<li>优点：将低速 IO 设备从单总线上分离出来，实现了存储器总线和 IO 总线的分离</li>
<li>缺点：需要增加通道等硬件设备</li>
</ul>
</li>
<li><p>三总线结构</p>
<p> 用 主存总线、IO 总线、DMA 总线 这三条独立的总线来构成信息通道</p>
 <img src="【考研】计算机组成原理知识点梳理/image-20210816162226275.png" alt="image-20210816162226275" style="zoom:80%;" />

<ul>
<li>优点：提高 IO 设备性能，使响应更快速，提高系统吞吐量</li>
<li>缺点：系统工作效率低下</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4></blockquote>
<ol>
<li><p>总线传输周期：一次总线操作所用时间，通常由若干总线时钟周期组成，也叫 总线周期</p>
</li>
<li><p>总线时钟周期：机器的时钟周期</p>
</li>
<li><p>总线工作频率：总线周期的倒数</p>
</li>
<li><p>总线时钟频率：总线时钟周期的倒数</p>
</li>
<li><p>总线宽度：总线上能同时传输数据的位数</p>
</li>
<li><p>总线带宽：单位时间上总线可传输的位数。</p>
<p> 🚩 总线带宽 &#x3D; 总线工作频率 x (总线宽度 &#x2F; 8) B&#x2F;s</p>
</li>
<li><p>总线复用：一种信号线在不同的时间传输不同的信息，从而节省空间成本</p>
</li>
<li><p>信号线数：数据总线、地址总线、控制总线线数的总和</p>
</li>
</ol>
<blockquote>
<p>Note：</p>
<ol>
<li>单总线结构并不是指只有一根信号线</li>
<li>握手信号属于控制信号，不可能出现在数据线上，而指令、操作数、中断类型号等则有可能出现在数据线上</li>
<li>主存通过 <strong>总线的类型</strong> 来识别信息是地址还是数据</li>
</ol>
</blockquote>
<h3 id="6-2-总线操作和定时"><a href="#6-2-总线操作和定时" class="headerlink" title="6.2 总线操作和定时"></a>6.2 总线操作和定时</h3><blockquote>
<h4 id="总线传输阶段"><a href="#总线传输阶段" class="headerlink" title="总线传输阶段"></a>总线传输阶段</h4></blockquote>
<ol>
<li>申请分配阶段</li>
<li>寻址阶段</li>
<li>传输阶段</li>
<li>结束阶段</li>
</ol>
<blockquote>
<h4 id="🚩-同步定时方式"><a href="#🚩-同步定时方式" class="headerlink" title="🚩 同步定时方式"></a>🚩 同步定时方式</h4></blockquote>
<p>同步定时方式：采用一个统一的时钟信号来协调发送和接受双方的传送定时关系</p>
<p>优缺点：</p>
<ul>
<li>优点：传送速度快；具有较高的传输速率；总线控制逻辑简单</li>
<li>缺点：主从设备强制同步，不能及时进行数据通信的有效性检验，<strong>可靠性查</strong></li>
</ul>
<p>适用情况：</p>
<ul>
<li>总线长度较短</li>
<li>总线所连接各部件存取时间比较接近</li>
</ul>
<blockquote>
<h4 id="🚩-异步定时方式"><a href="#🚩-异步定时方式" class="headerlink" title="🚩 异步定时方式"></a>🚩 异步定时方式</h4></blockquote>
<p>异步定时方式：跟 TCP 建立连接有点类似，采用握手的方式来确定信息是否被成功接收</p>
<p>优缺点：</p>
<ul>
<li>优点：总线周期长度可变，能保证两个工作速度相差很大的设备之间进行可靠的信息交换</li>
<li>缺点：实现起来复杂，速度比同步方式慢</li>
</ul>
<p>分类：</p>
<ul>
<li>不互锁方式</li>
<li>半互锁方式</li>
<li>全互锁方式</li>
</ul>
<img src="【考研】计算机组成原理知识点梳理/image-20210816164508038.png" alt="image-20210816164508038" style="zoom:80%;" />

<h3 id="6-3-总线标准"><a href="#6-3-总线标准" class="headerlink" title="6.3 总线标准"></a>6.3 总线标准</h3><p>常见总线标准有：ISA、EISA、VESA、PCI、PCI-Express、AGP、RS-232C、USB</p>
<p>区分标准：总线宽度、带宽、时钟频率、寻址能力、是否支持猝发传送</p>
<table>
<thead>
<tr>
<th align="center">总线标准</th>
<th align="center">串行&#x2F;并行</th>
<th align="center">局部&#x2F;系统</th>
<th align="center">特性</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ISA</strong></td>
<td align="center">并行</td>
<td align="center">系统</td>
<td align="center"><strong>最早出现</strong>的微型计算机系统总线</td>
</tr>
<tr>
<td align="center"><strong>ISAE</strong></td>
<td align="center">并行</td>
<td align="center">系统</td>
<td align="center">ISA 的拓展，对 ISA兼容</td>
</tr>
<tr>
<td align="center">V(Video)ESA</td>
<td align="center">并行</td>
<td align="center">局部</td>
<td align="center">针对<strong>多媒体 PC</strong> 要求高速传送活动图像的大量数据</td>
</tr>
<tr>
<td align="center"><strong>PCI</strong></td>
<td align="center">并行</td>
<td align="center">局部</td>
<td align="center">专为高度集成的<strong>外围设备、扩充插板、处理器&#x2F;存储器</strong>系统设计<br />常用的PCI适配器：<strong>显卡、声卡、网卡</strong><br />PCI 总线支持<strong>即插即用</strong><br />PCI 总线可以<strong>通过桥连接</strong>，实现多层 PCI 总线<br />半同步总线</td>
</tr>
<tr>
<td align="center"><strong>PCI-Express</strong></td>
<td align="center">并行</td>
<td align="center">局部</td>
<td align="center"><strong>最新</strong>的总线接口标准，将最终<strong>统一</strong>总线标准</td>
</tr>
<tr>
<td align="center">AGP</td>
<td align="center"></td>
<td align="center">局部</td>
<td align="center">一种<strong>视频接口</strong>标准，用于连接主存和图形存储器<br />用于<strong>传输视频和三维图形数据</strong></td>
</tr>
<tr>
<td align="center">RS-232C</td>
<td align="center">串行</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>USB</strong></td>
<td align="center">串行</td>
<td align="center"></td>
<td align="center">连接外部设备的 IO 总线<br /><strong>即插即用、热插拔</strong><br />连接力强</td>
</tr>
<tr>
<td align="center">PCMCIA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">用于<strong>笔记本</strong>的接口标准，可以<strong>即插即用</strong></td>
</tr>
<tr>
<td align="center">IDE</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">更准确的称为 ATA，是 IDE接口磁盘驱动器接口<br /><strong>硬盘、光驱</strong>通过 IDE 接口与主板连接</td>
</tr>
<tr>
<td align="center">SCSI</td>
<td align="center"></td>
<td align="center">系统</td>
<td align="center">用于计算机和<strong>智能设备</strong>之间的独立处理器标准</td>
</tr>
<tr>
<td align="center">SATA</td>
<td align="center">串行</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>Note： </p>
<ol>
<li><p>局部总线不和系统共享统一时钟</p>
<p> 采用局部总线可以节省系统带宽</p>
</li>
</ol>
</blockquote>
<h1 id="第七章-输出输出系统"><a href="#第七章-输出输出系统" class="headerlink" title="第七章 输出输出系统"></a>第七章 输出输出系统</h1><h3 id="考纲及章节框架-5"><a href="#考纲及章节框架-5" class="headerlink" title="考纲及章节框架"></a>考纲及章节框架</h3><img src="【考研】计算机组成原理知识点梳理/image-20210819162539834.png" alt="image-20210819162539834" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210819163324437.png" alt="image-20210819163324437" style="zoom:80%;" />

<h3 id="7-1-IO-系统基本概念"><a href="#7-1-IO-系统基本概念" class="headerlink" title="7.1 IO 系统基本概念"></a>7.1 IO 系统基本概念</h3><blockquote>
<h4 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h4></blockquote>
<p>基本概念：</p>
<ul>
<li>外部设备</li>
<li>接口：外设与主机之间传输数据时进行协调工作的逻辑部件</li>
<li>输入设备</li>
<li>输出设备</li>
<li>外存设备：除内存及 CPU 缓存等外的存储器</li>
</ul>
<p>IO 系统：由 <strong>IO 硬件</strong>和 <strong>IO 软件</strong>组成</p>
<ul>
<li><p>IO 软件：包括驱动程序、用户程序、管理程序、升级补丁等</p>
<p>  通常采用 <strong>IO 指令</strong>和<strong>通道指令</strong>来实现 CPU 与 IO设备的数据交换</p>
</li>
<li><p>IO 硬件：包括外设、设备控制器、IO 总线等</p>
<p>  <strong>通过设备控制器来控制 IO 设备的具体动作；通过 IO 接口与主机相连</strong></p>
</li>
</ul>
<blockquote>
<h4 id="IO-控制方式"><a href="#IO-控制方式" class="headerlink" title="IO 控制方式"></a>IO 控制方式</h4></blockquote>
<ul>
<li>程序查询方式</li>
<li>程序中断方式</li>
<li>DMA 方式</li>
<li>通道方式</li>
</ul>
<p>别急，后面会进行详细介绍！</p>
<blockquote>
<p>Note：</p>
<ol>
<li>IO 设备通过 <strong>设备控制器</strong> 与主版的系统总线相<strong>连</strong></li>
<li><strong>通道程序存放在主存中！</strong></li>
</ol>
</blockquote>
<h3 id="7-2-外部设备"><a href="#7-2-外部设备" class="headerlink" title="7.2 外部设备"></a>7.2 外部设备</h3><blockquote>
<h4 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h4></blockquote>
<ol>
<li><p>键盘</p>
<p> 通常以矩阵形式排列按键，每个键相当于一个开关</p>
</li>
<li><p>鼠标</p>
<p> 常用的定位输入设备，鼠标在平面上移动时，底部传感器把运动的方向和距离检测出来</p>
</li>
</ol>
<blockquote>
<h4 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h4></blockquote>
<ol>
<li><p>显示器</p>
<p> <strong>参数：</strong></p>
<ul>
<li><p>屏幕大小：对角线的长度</p>
</li>
<li><p>分辨率：所能表示像素点的个数（1024 x 768）</p>
</li>
<li><p>灰度级：控制颜色或亮暗（8位、16位）</p>
</li>
<li><p>刷新频率：人在刷新频率大于 30Hz 时才不会感到闪烁，一般屏幕为 60-120Hz</p>
</li>
<li><p>显示存储器（VRAM）：为了不断提高刷新图像的信号，必须把一帧图像信息存储着 VRAM 中</p>
<p>  <strong>注意 VRAM 容量和 VRAM 带宽的计算！</strong></p>
</li>
</ul>
<p> <strong>分类：</strong></p>
<ul>
<li>阴极射线管显示器（CRT）</li>
<li>液晶显示器（LCD）：体积小、重量轻、省电、无辐射、绿色环保、画面柔和、不伤眼</li>
<li>发光二极管显示器（LED）：与 LCD 相比，在亮度、功耗、可视角度、刷新速率等方面更具优势</li>
</ul>
</li>
<li><p>打印机</p>
<p> 按工作原理分为：击打式和非击打式；按工作方式分为：点阵打印机、针式打印机、喷墨打印机、激光打印机等</p>
<ul>
<li>针式打印机：擅长<strong>多层复写打印</strong>，工作原理简单，造价低廉，耗材便宜，但是分辨率和速度不够高</li>
<li>喷墨打印机：噪声小，可实现高质量彩印，打印速度较快，但是防水性差</li>
<li>激光打印机：打印质量高、速度快、噪声小、处理能力强，但耗材多、价格贵、对纸张要求高</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="🚩-外存储器"><a href="#🚩-外存储器" class="headerlink" title="🚩 外存储器"></a>🚩 外存储器</h4></blockquote>
<p>计算机的外存主要使用<strong>磁表面存储器</strong>（磁盘、磁带、磁鼓）</p>
<p>磁表面存储器优点：</p>
<ol>
<li>容量大、价格低</li>
<li>记录介质可以重复使用</li>
<li>记录信息可长久保存（甚至能脱机存档）</li>
<li>非破坏性读出</li>
</ol>
<p>磁表面存储器缺点：存取速度慢，机械结构复杂，对工作环境要求高</p>
<p><strong>1. 磁盘存储器</strong></p>
<p>一块磁盘有若干个<strong>记录面</strong>，一个记录面有若干个<strong>磁道</strong>，一个磁道有若干个<strong>扇区</strong></p>
<p><strong>扇区也称块，是磁盘读写的最小单位，即磁盘按块存取</strong></p>
<p>其结构如下图所示</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210819170645048.png" alt="image-20210819170645048" style="zoom:80%;" />

<img src="【考研】计算机组成原理知识点梳理/image-20210819170630870.png" alt="image-20210819170630870" style="zoom:80%;" />

<p>磁盘的性能指标：</p>
<ul>
<li><p>磁盘的容量：有格式化与非格式化之分，格式化之后磁盘容量减小。</p>
</li>
<li><p>记录密度：通常以道密度、位密度、面密度（前两个的乘积）表示</p>
</li>
<li><p><strong>平均存取时间</strong>：由<strong>寻道时间</strong>、<strong>旋转延迟时间</strong>（旋转半周用时）、<strong>传输时间</strong>三部分构成</p>
</li>
<li><p>数据传输率：设磁盘转数 $r$ 转&#x2F;秒，每条磁道容量 $N$ 字节，则数据传输率：<br>  $$<br>  D_r&#x3D; rN<br>  $$</p>
</li>
</ul>
<p>磁盘地址：</p>
<table>
<thead>
<tr>
<th align="center">驱动器号</th>
<th align="center">柱面（磁道）号</th>
<th align="center">盘面号</th>
<th align="center">扇区号</th>
</tr>
</thead>
</table>
<p>磁盘工作过程：寻址、读盘、写盘（每个操作对应一个控制字）</p>
<p><strong>2. 磁盘阵列</strong></p>
<p>RAID（廉价冗余磁盘阵列）是指将多个独立的物理磁盘组成一个逻辑盘，<strong>数据在多个物理盘上分割交叉存储、并行访问</strong>，具有更好的存储性能、可靠性、安全性</p>
<p>RAID 通过<strong>同时使用多个磁盘</strong>提高了传输率；通过<strong>多个磁盘上并行存取</strong>来大幅提高存储系统的数据吞吐量；通过<strong>镜像功能</strong>提高了安全可靠性；通过<strong>数据校验</strong>提供了容错能力。</p>
<p><strong>3. 固态硬盘</strong></p>
<p>高性能 Flash Memory（贵）</p>
<blockquote>
<p>Note：</p>
<ol>
<li>硬盘属于机械式部件，其<strong>读写操作是串行的</strong></li>
<li>计算机中<strong>汉字内码</strong>在主存中占 <strong>2B</strong></li>
</ol>
</blockquote>
<h3 id="7-3-IO-接口"><a href="#7-3-IO-接口" class="headerlink" title="7.3 IO 接口"></a>7.3 IO 接口</h3><p>IO 接口（IO 控制器）是主机和外设之间的交界面，通过接口可以实现主机与外设之间的信息交换</p>
<blockquote>
<h4 id="IO-接口的功能"><a href="#IO-接口的功能" class="headerlink" title="IO 接口的功能"></a>IO 接口的功能</h4></blockquote>
<ol>
<li>实现主机和外设的通信联络控制：解决主机与外设时序配合问题</li>
<li>进行地址译码和设备选择</li>
<li><strong>实现数据缓冲</strong>：接口必须设置<strong>数据缓冲寄存器</strong>来暂存数据从而消除 CPU 与外设之间的速度差异</li>
<li>信号格式转换</li>
<li>传送控制命令和状态信息</li>
</ol>
<blockquote>
<h4 id="IO-接口基本结构"><a href="#IO-接口基本结构" class="headerlink" title="IO 接口基本结构"></a>IO 接口基本结构</h4></blockquote>
<img src="【考研】计算机组成原理知识点梳理/image-20210819172906637.png" alt="image-20210819172906637" style="zoom:80%;" />

<p><strong>数据线传送的信息：</strong></p>
<ul>
<li>数据缓冲寄存器与内存或 CPU 寄存器之间的<strong>数据</strong></li>
<li>接口和设备的<strong>状态信息</strong></li>
<li>CPU 对外设的<strong>控制命令</strong></li>
</ul>
<p><strong>地址线传送的信息：</strong></p>
<ul>
<li>要访问的 IO 接口中的<strong>寄存器的地址</strong></li>
</ul>
<p><strong>IO 指令：</strong></p>
<ul>
<li><strong>对数据缓冲寄存器、状态&#x2F;控制寄存器的访问操作</strong>是通过相应的 IO 指令来完成的。</li>
<li><strong>IO 指令只能在操作系统内核的底层 IO 软件中使用，是一种特权指令</strong></li>
</ul>
<blockquote>
<h4 id="IO-接口的类型"><a href="#IO-接口的类型" class="headerlink" title="IO 接口的类型"></a>IO 接口的类型</h4></blockquote>
<ol>
<li>并行接口、串行接口</li>
<li>程序查询接口、中断接口、DMA 接口</li>
<li>可编程接口、不可编程接口</li>
</ol>
<blockquote>
<h4 id="IO-端口及其编址"><a href="#IO-端口及其编址" class="headerlink" title="IO 端口及其编址"></a>IO 端口及其编址</h4></blockquote>
<p>IO 端口：接口电路中可以被 CPU 直接访问的寄存器，有：数据端口（读写）、状态端口（读）、控制端口（写）</p>
<p>对 IO 端口的编址分为 <strong>与存储器统一编址</strong> 和 <strong>独立编址</strong></p>
<ul>
<li>统一编址（存储器映射方式）：用统一的访存指令访问 IO 端口<ul>
<li>优点：操作灵活、方便，使端口有较大的编址空间</li>
<li>缺点：端口占用存储器地址，使内存容量变小，且执行速度慢</li>
</ul>
</li>
<li>独立编址（IO 映射方式）：设置专门的 IO 指令来访问 IO 端口<ul>
<li>优点：程序编制清晰、便于理解</li>
<li>缺点：指令少，一般只能对端口进行传送操作，增加了控制复杂性</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note：</p>
<ol>
<li><p>端口：接口电路中可以进行读写的寄存器</p>
<p> 接口：若干端口加上相应的控制逻辑</p>
</li>
<li><p>IO 总线上的<strong>数据线</strong>传送的信号包括：</p>
<ul>
<li>IO 接口中的<strong>命令字</strong></li>
<li>IO 接口中的<strong>状态字</strong></li>
<li><strong>中断类型号</strong></li>
<li>数据缓冲寄存器与 内存&#x2F; CPU 交换的<strong>数据</strong></li>
</ul>
</li>
<li><p>统一编址的情况下，区分存储单元和 IO 设备靠 <strong>不同的地址码</strong></p>
</li>
</ol>
</blockquote>
<h3 id="7-4-IO-方式（🚩）"><a href="#7-4-IO-方式（🚩）" class="headerlink" title="7.4 IO 方式（🚩）"></a>7.4 IO 方式（🚩）</h3><p>常用的 IO 方式有：程序查询、程序中断、DMA、通道（前两种更依赖于 CPU 中程序指令的执行）</p>
<blockquote>
<h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4></blockquote>
<p><strong>1. 概念</strong></p>
<p>信息的交换完全由主机执行程序来实现，程序查询方式接口中设置一个<strong>数据缓冲寄存器（数据端口）</strong>和一个<strong>设备状态寄存器（状态端口）</strong></p>
<p>主机进行 IO 操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步是进行数据传送还是等待</p>
<p>具体流程如下图所示：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210820154756237.png" alt="image-20210820154756237" style="zoom:80%;" />

<p><strong>2. 特性</strong></p>
<ul>
<li><p>主要特点：是 <strong>CPU 有踏步等待的现象，CPU 与 IO 串行工作</strong></p>
</li>
<li><p>优点：接口设计简单，设备量小</p>
</li>
<li><p>缺点：CPU 要花费时间查询和等待，且在一段时间内只能和一台设备交换信息，效率巨低</p>
</li>
</ul>
<blockquote>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4></blockquote>
<p><strong>1. 异常</strong></p>
<p>异常是 <strong>CPU 内部异常</strong>引起的意外事件，分为<strong>硬故障中断</strong>和<strong>程序性异常</strong></p>
<ul>
<li><p>硬故障中断：电源掉电、存储线路出错……</p>
</li>
<li><p><strong>程序性异常</strong>（软中断）：除零异常、溢出、断点、单步跟踪、非法指令、栈溢出、地址越界、缺页、分时系统中的时间片中断、用户态到核心态的切换……</p>
</li>
</ul>
<p>根据报告方式和返回方式不同，内部异常可分为：<strong>故障（Fault）、自陷（Trap）、终止（Abort）</strong></p>
<ul>
<li><p><strong>故障</strong>：指令启动后、结束前被检测到的异常事件</p>
<p>  如：非法操做码、缺段&#x2F;缺页（解决故障后可以回到断点）、除数为零（必须终止进程的执行）……</p>
</li>
<li><p><strong>自馅</strong>：预先安排的一种异常</p>
<p>  如：80x86 中用于调试的断点、系统调用指令、条件自馅指令……</p>
</li>
<li><p><strong>终止</strong>：发生了计算机无法继续执行的硬件故障（不由特定指令产生，而是<strong>随机发生</strong>）</p>
<p>  如：电源掉电、线路故障……</p>
</li>
</ul>
<p><strong>2. 中断</strong>（外部）</p>
<p>外中断来自 CPU 外部，是与 CPU 执行指令无关的事件引起的中断</p>
<p>如：</p>
<ul>
<li>IO 设备发出的 IO 中断（键盘输入、打印机缺纸）</li>
<li>外部信号中断（用户按 Esc 键）</li>
<li>定时器引起的时钟中断</li>
</ul>
<p>中断与异常的区别：</p>
<ul>
<li><p>异常是由<strong>特定指令</strong>在执行过程中产生的；</p>
<p>  中断不和任何指令相关联，也不阻止任何指令的完成</p>
</li>
<li><p>异常的<strong>检测是由 CPU 完成</strong>的，不必通过某个外部信号通知 CPU；</p>
<p>  中断是 CPU 必须通过总线获取<strong>中断源的标识信息</strong>，才能获知那个设备发生了何种中断</p>
</li>
</ul>
<p>程序中断的作用：</p>
<ul>
<li><strong>实现 CPU 和 IO 设备并行工作</strong></li>
<li>处理硬件故障和软件错误</li>
<li>实现人机交互</li>
<li>实现多道程序、分时操作</li>
<li>实现应用程序和操作系统（管态程序）的切换</li>
<li>……</li>
</ul>
<p>程序中断方式示意图：</p>
<img src="【考研】计算机组成原理知识点梳理/image-20210820162159261.png" alt="image-20210820162159261" style="zoom:80%;" />

<p>🚩 程序中断方式工作流程：</p>
<ol>
<li><p>中断请求</p>
<ul>
<li>中断源：请求 CPU 终端的设备或事件，一台计算机允许有多个中断源</li>
<li>内中断皆为不可屏蔽中断</li>
<li>通过 INTR 信号线发出的外中断是可屏蔽中断，通过 NMI 信号发出的是不可屏蔽中断</li>
<li>不可屏蔽中断的处理优先级最高</li>
</ul>
</li>
<li><p>中断判优</p>
<ul>
<li>硬件故障中断 &gt; 软件中断</li>
<li>不可屏蔽中断 &gt; 可屏蔽中断</li>
<li><strong>DMA 请求 &gt; IO 设备传送的中断请求</strong></li>
<li><strong>高速设备 &gt; 低速设备</strong></li>
<li><strong>输入设备 &gt; 输出设备</strong></li>
<li>实时设备 &gt; 普通设备</li>
</ul>
</li>
<li><p>CPU 响应中断的条件</p>
<ul>
<li>中断源有中断请求</li>
<li>CPU 允许中断及开中断</li>
<li>一条指令执行完毕，没有更加紧迫的任务</li>
</ul>
</li>
<li><p>中断响应 🚩</p>
<ul>
<li><p>中断隐指令：CPU 响应中断后经过一些硬件直接实现的操作后才会转去执行终端服务子程序，这些操作称为中断隐指令</p>
<p>  中断隐指令<strong>不是真正的指令</strong>（没有指令码），是一种<strong>不能为用户使用</strong>的特殊指令，包括操作：</p>
<ul>
<li>关中断</li>
<li>保存断点</li>
<li>引出中断服务子程序</li>
</ul>
</li>
</ul>
</li>
<li><p>中断向量 🚩</p>
<ul>
<li>中断向量：中断服务子程序的入口地址</li>
<li>中断向量地址：中断服务子程序入口地址的地址</li>
</ul>
</li>
<li><p>中断处理过程 🚩</p>
<ol>
<li><p>关中断</p>
</li>
<li><p>保存断点</p>
</li>
<li><p>引出中断服务程序</p>
<p> 有两种方法寻址中断服务程序入口地址：硬件向量法、软件查询法</p>
<ul>
<li><p>硬件向量法：通过硬件产生中断向量地址，再由中断向量地址找到中断服务程序的入口地址</p>
<p>  （实际上产生的是中断类型号，而中断类信号指出中断向量存放的地址）</p>
</li>
<li><p>软件查询法：用软件编程的方法寻找入口地址</p>
</li>
</ul>
</li>
<li><p>保存现场和屏蔽字</p>
<ul>
<li><strong>现场是指用户可见的工作寄存器内容</strong></li>
<li><strong>现场和断点</strong><ul>
<li>现场信息因为用指令可以直接访问，所以通常在中断服务程序中通过指令把他们保存到栈中，<strong>由软件实现</strong></li>
<li>断点信息由 CPU 中断响应开始时自动保存到栈或专门寄存器中，<strong>由硬件实现</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>开中断</p>
<p> 实现中断嵌套</p>
</li>
<li><p>执行中断服务程序</p>
</li>
<li><p>关中断</p>
</li>
<li><p>恢复现场和屏蔽字</p>
</li>
<li><p>开中断、中断返回</p>
</li>
</ol>
 <img src="【考研】计算机组成原理知识点梳理/image-20210820165223815.png" alt="image-20210820165223815" style="zoom:80%;" />

<p> 多重中断和中断屏蔽技术</p>
<ul>
<li><p>中断屏蔽技术：主要用于多重中断</p>
  <img src="【考研】计算机组成原理知识点梳理/image-20210820170803256.png" alt="image-20210820170803256" style="zoom:80%;" />
</li>
<li><p>实现多重中断必须满足：</p>
<ul>
<li>在中断服务程序中提前设置开中断</li>
<li>优先级别高的中断源有权中断优先级别低的中断源</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h4></blockquote>
<p><strong>1. 概述</strong></p>
<p>采用 DMA 方式时，DMA 控制器获得总线的控制权后 DMA 控制器负责数据传输，而 CPU 可以干自己的事情去，<strong>是一种完全由硬件进行成组信息传送的控制方式，CPU 与外设并行工作</strong></p>
<p>由于数据不经过 CPU，也就<strong>不需要繁琐的保护、恢复现场等操作</strong>，适用于磁盘机、磁带机等高速设备大批量数据传送</p>
<p>在 DMA 方式中，<strong>中断的作用仅限于故障和正常传送结束时的处理</strong></p>
<p><strong>2. DMA 方式的特点</strong></p>
<ul>
<li><p><strong>IO 与主机并行工作，程序和传送并行工作</strong></p>
</li>
<li><p>主存既可以被 CPU 访问，也可以被外设访问</p>
</li>
<li><p>主存地址的确定、传送数据的计数等都是<strong>由硬件电路直接实现</strong></p>
</li>
<li><p>主存中要开辟专用的缓冲区</p>
</li>
<li><p>传送前要通过程序进行<strong>预处理</strong>，结束后要通过中断方式进行<strong>后处理</strong></p>
</li>
</ul>
<p><strong>3. DMA 控制器的组成</strong></p>
<p>DMA 方式中对数据传送进行控制的硬件称为 <strong>DMA控制器</strong></p>
<img src="【考研】计算机组成原理知识点梳理/image-20210820172357474.png" alt="image-20210820172357474" style="zoom:80%;" />

<p>在 DMA 传送过程中，DMA 控制器接管 CPU 的数据、地址、控制总线，CPU 的主存控制信号被禁用</p>
<p><strong>3. DMA 传送方式</strong></p>
<ol>
<li><p>停止 CPU 访存：使 CPU 脱离总线，停止访问主存</p>
</li>
<li><p>周期挪用（周期窃取）：CPU 暂时放弃总线占用权，让 IO 线访存，结束后再释放总线给 CPU</p>
<ul>
<li>IO 访存优先级高于 CPU 访存优先级，因为 IO 不立即访存可能就会丢失数据</li>
<li>IO 设备挪用 CPU 几个存取周期，传送玩一个数据后立即释放总线，是一种单字传送方式</li>
</ul>
</li>
<li><p>DMA 与 CPU 交替访存</p>
<p> 前半周期 DMA 访存，后半周 CPU 访存</p>
</li>
</ol>
<p><strong>4. DMA 传送过程</strong></p>
<ol>
<li><p>预处理</p>
<p> CPU 测试 IO 设备状态，设置一些 DMA 控制器有关寄存器的参数。IO 准备好后，<strong>IO 向 DMA 控制器发送 DMA 请求</strong>，由 <strong>DMA 控制器向 CPU 发送总线使用请求</strong></p>
</li>
<li><p>数据传送</p>
<p> 可以以<strong>字&#x2F;字节</strong>为基本单位，也可以以<strong>数据块</strong>为基本单位。数据传送阶段完全由 DMA 控制器控制</p>
</li>
<li><p>后处理</p>
<p> DMA 控制器向 CPU 发送中断请求，CPU 校验数据传送是否出错等</p>
</li>
</ol>
<blockquote>
<p>DMA 方式与中断方式区别</p>
</blockquote>
<ol>
<li><p>中断方式程序切换时需要<strong>保护和恢复现场</strong></p>
<p> DMA 方式除了预处理和后处理，其他时候不占用 CPU 任何资源</p>
</li>
<li><p>中断请求的响应只能发生在每条指令执行完毕时</p>
<p> <strong>DMA 请求的响应可以发生在每个机器周期（总线事务）结束时（取指、间指、执行周期之后都可）</strong></p>
</li>
<li><p><strong>DMA 请求优先级高于中断请求优先级</strong></p>
</li>
<li><p>中断方式可以处理异常事件</p>
<p> DMA 方式仅仅用来传送数据块</p>
</li>
<li><p>从数据传送来看，中断方式靠程序传送</p>
<p> DMA 方式靠硬件传送</p>
</li>
</ol>
<blockquote>
<p>Note：</p>
<ol>
<li><p>CPU 响应中断的时间是每条<strong>指令执行阶段的结束时刻</strong></p>
</li>
<li><p>DMA 请求：设备控制器发出</p>
<p> 总线使用请求：DMA控制器发出</p>
</li>
<li><p>只有具有 DMA 接口的设备才能产生 DMA 请求</p>
</li>
<li><p>中断响应优先级由高到低：访管 &gt; 程序性 &gt; 重新启动</p>
</li>
<li><p>**机器校验中断是主存故障引起的中断 **</p>
</li>
<li><p>中断屏蔽标志可以改变：多个中断服务程序执行完的持续</p>
</li>
<li><p>中断方式特点：CPU 与外设并行工作，传送与主程序串行工作</p>
<p> DMA 方式特点：CPU 与外设并行工作，传送与主程序并行工作</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【分布式系统】6.824</title>
    <url>/2023/04/12/%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E3%80%916.824/</url>
    <content><![CDATA[<h2 id="Lecture1-Introduction"><a href="#Lecture1-Introduction" class="headerlink" title="Lecture1 - Introduction"></a>Lecture1 - Introduction</h2><blockquote>
<p>参考链接：<br><a href="http://nil.csail.mit.edu/6.824/2022/papers/mapreduce.pdf">nil.csail.mit.edu&#x2F;6.824&#x2F;2022&#x2F;papers&#x2F;mapreduce.pdf</a></p>
</blockquote>
<h3 id="为什么使用分布式系统"><a href="#为什么使用分布式系统" class="headerlink" title="为什么使用分布式系统"></a>为什么使用分布式系统</h3><ul>
<li>连接分隔开的物理机器（允许用户共享数据）</li>
<li>通过并行来提高容量（capacity）</li>
<li>容错（tolerate faults）</li>
<li>通过隔离实现安全</li>
</ul>
<h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ul>
<li>局域网（1980s）：DNS、AFS</li>
<li>数据中心随着大型网站兴起（1990s）：网页搜索、购物</li>
<li>云计算（2000s）</li>
<li>……</li>
</ul>
<h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><ul>
<li>大量并发组件</li>
<li>必须处理部分故障（某台机器宕机）</li>
<li>难于实现性能优势</li>
</ul>
<h3 id="课程结构"><a href="#课程结构" class="headerlink" title="课程结构"></a>课程结构</h3><ul>
<li>课程</li>
<li>论文</li>
<li>labs<ul>
<li>Mapreduce</li>
<li>replication using raft</li>
<li>replicated K-V service</li>
<li>sharded K-V service</li>
</ul>
</li>
</ul>
<h3 id="聚焦：基础架构"><a href="#聚焦：基础架构" class="headerlink" title="聚焦：基础架构"></a>聚焦：基础架构</h3><ul>
<li>存储</li>
<li>计算</li>
<li>通信</li>
</ul>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><ul>
<li>容错（高可用性-备份、可恢复性-日志&#x2F;事务）</li>
<li>一致性</li>
<li>性能（吞吐量、延迟）</li>
<li>实现</li>
</ul>
<h3 id="Mapreduce"><a href="#Mapreduce" class="headerlink" title="Mapreduce"></a>Mapreduce</h3><h3 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h3><ul>
<li>Q1：需要开启一个协程来不断循环监控某个共享变量，同时这个共享变量又会在其他地方修改，该如何处理？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230412193323.png"></p>
<h2 id="Lecture2-RPC-and-Threads"><a href="#Lecture2-RPC-and-Threads" class="headerlink" title="Lecture2 - RPC and Threads"></a>Lecture2 - RPC and Threads</h2><h3 id="Why-Go？"><a href="#Why-Go？" class="headerlink" title="Why Go？"></a>Why Go？</h3><ul>
<li>对线程和RPC的支持</li>
<li>好的垃圾回收机制</li>
<li>类型安全</li>
<li>简单易学</li>
<li>编译型语言，运行时开销不大</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>关心并发的原因：</p>
<ul>
<li>IO并发性</li>
<li>多核并行</li>
<li>方便：定期执行一些后台活动任务</li>
</ul>
<p>挑战：</p>
<ul>
<li>竞态条件（两个线程操作同一个资源）<ul>
<li>避免共享资源</li>
<li>加锁，让指令变成原子操作</li>
</ul>
</li>
<li>同步<br>  Channels 或者 condition variables</li>
<li>死锁</li>
</ul>
<p>Go的解决方案：</p>
<ul>
<li>channels（不共享内存时使用）</li>
<li>locks + condition variables（共享内存时使用）</li>
</ul>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><h2 id="LEC-3-GFS"><a href="#LEC-3-GFS" class="headerlink" title="LEC 3 - GFS"></a>LEC 3 - GFS</h2><blockquote>
<p>参考链接：<br><a href="http://nil.csail.mit.edu/6.824/2022/papers/gfs.pdf">nil.csail.mit.edu&#x2F;6.824&#x2F;2022&#x2F;papers&#x2F;gfs.pdf</a><br><a href="https://www.bilibili.com/video/BV1fT411c7y6">解读Google分布式文件系统GFS（合集）_哔哩哔哩_bilibili</a></p>
</blockquote>
<h3 id="为什么分布式存储实现起来很难？"><a href="#为什么分布式存储实现起来很难？" class="headerlink" title="为什么分布式存储实现起来很难？"></a>为什么分布式存储实现起来很难？</h3><p>（层层递进，又互相影响）<br>高性能 ——&gt; 在许多服务器上共享数据<br>许多服务器 ——&gt; 持续故障<br>容错 ——&gt; 主从复制<br>主从复制 ——&gt; 潜在的不一致性<br>一致性 ——&gt; 低性能</p>
<h3 id="分布式文件系统-Q-amp-A"><a href="#分布式文件系统-Q-amp-A" class="headerlink" title="分布式文件系统 Q&amp;A"></a>分布式文件系统 Q&amp;A</h3><p>单机文件系统 —(A)— 分布式文件系统 —(B)—&gt; GFS</p>
<p>A1：文件如何分散存储在多台服务器上？怎样实现动态扩缩容？</p>
<ul>
<li><em>分割存储</em></li>
<li><em>在 master 单点上增减、调整 chunk 元数据</em><br>A2：怎么知道哪一个文件存储在哪台机器上？</li>
<li><em>根据 master 元数据中文件名到 chunk 再到 chunk 位置的映射来定位具体的 chunkserver</em><br>A3：怎样保证服务器在故障时文件不损坏不丢失？</li>
<li><em>master 的 WAL 和主备、chunk的多副本</em><br>A4：使用多副本的话，如何保持副本间数据的一致性？</li>
<li>对一个 chunk 所有副本的写入顺序都是一致的。这是由控制流和数据流分离技术来实现的，控制流都是由 primary 发出，副本的写入顺序也是由 primary 到 secondary</li>
<li>使用 chunk 版本号来检测 chunk 副本是否出现过宕机，失效的副本不会再进行写入操作，master 不会再记录这个副本的信息，GC 会自动回收这些副本</li>
<li>master 定期检查 chunk 副本的 checksum 来确认其是否正确</li>
<li>GFS 推荐应用更多地使用追加来达到更高的一致性</li>
</ul>
<p>B1：怎样支持<strong>大文件</strong>存储？</p>
<ul>
<li><em>采用了更大的 chunk(64MB)，以及配套的一致性策略</em><br>B2：超多台机器的情况下，<strong>自动</strong>监控、容错与恢复？</li>
<li><em>master 的主备切换由 chubby 负责，chunk 的租约、副本位置与数量是由 master 负责</em><br>B3：怎样支持快速的<strong>顺序读</strong>和<strong>追加写</strong>？</li>
<li>总体上 GFS 是<strong>三写一读</strong>的模式，写入采用了流水线技术和数据流与控制流分离技术保证性能</li>
<li><strong>追加写对一致性的保证更简单也更高效</strong>，所以写入多采用追加写的形式</li>
<li>读取则所有副本均可读，在<strong>就近读取</strong>情况下性能会很高</li>
</ul>
<h3 id="GFS-整体架构"><a href="#GFS-整体架构" class="headerlink" title="GFS 整体架构"></a>GFS 整体架构</h3><h3 id="GFS-存储设计"><a href="#GFS-存储设计" class="headerlink" title="GFS 存储设计"></a>GFS 存储设计</h3><p>chunk 在 chunkserver 中的分布<br><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230412102750.png"></p>
<h3 id="GFS-的-master-设计"><a href="#GFS-的-master-设计" class="headerlink" title="GFS 的 master 设计"></a>GFS 的 master 设计</h3><p>管理元数据结点（master 结点）设计为单点还是多节点？</p>
<table>
<thead>
<tr>
<th></th>
<th>单中心结点</th>
<th>多中心结点（分布式中心结点）</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>实现难度低，一致性容易保证</td>
<td>实现难度极高，一致性难以保证，系统可靠性难以验证</td>
</tr>
<tr>
<td>缺点</td>
<td>单点可能会成为整个系统的瓶颈</td>
<td>不存在瓶颈，可拓展性极强</td>
</tr>
<tr>
<td>方案工作重心</td>
<td>缩减元数据，减少单 master 压力</td>
<td>设计一个分布式的元数据管理功能，验证其可靠性</td>
</tr>
</tbody></table>
<p>Google 最终选择了<strong>单主节点模式</strong>，用来存储整个文件系统的三类元数据：</p>
<ol>
<li>所有文件和 chunk 的 namespace 【持久化】</li>
<li>文件到 chunk 的映射【持久化】</li>
<li>每个 chunk 的位置【不持久化】（master 重启时从各个 chunkserver 处收集 chunk 位置）</li>
</ol>
<p>GFS 读取文件的简单过程：<br>文件名 ——&gt; 获取文件对应的所有 chunk 名 ——&gt; 获取所有的 chunk 的位置 ——&gt; 依次到对应的 chunkserver 中读取 chunk</p>
<p>GFS 采取一些措施来确保 master 不会成为系统瓶颈：</p>
<ol>
<li>GFS 所有数据流都不经过 master，而是直接由 client 和 chunkserver 交互（<strong>数据流和控制流分离</strong>）</li>
<li>GFS 的 client 会<strong>缓存 master 中的元数据</strong>，在大部分情况下，都无需访问 master</li>
<li>为了避免 master 的<strong>内存</strong>成为系统的瓶颈，GFS 采用了一些手段来节省 master 的内存（增大 chunk 的大小、对元数据进行定制化压缩——元数据小于64bit）</li>
</ol>
<blockquote>
<p>时至今日，大部分分布式系统还是会倾向于选择单个中心节点，因为单点瓶颈不像想象中那么难解决，非中心节点的实现难度也不如想象中那么可控</p>
</blockquote>
<h3 id="GFS-高可用设计"><a href="#GFS-高可用设计" class="headerlink" title="GFS 高可用设计"></a>GFS 高可用设计</h3><p><strong>数据的高可用和结点的高可用可以看作是一致的</strong></p>
<h4 id="Master-的高可用设计（元数据的高可用设计）"><a href="#Master-的高可用设计（元数据的高可用设计）" class="headerlink" title="Master 的高可用设计（元数据的高可用设计）"></a>Master 的高可用设计（元数据的高可用设计）</h4><ul>
<li>master 的三类元数据中， <strong>namespace 和文件 chunk 的对应关系</strong>必须持久化（因为这些数据只存在 master 中）</li>
<li>GFS 有<strong>两个 master</strong>，正在使用的称为 primary master，还有一个 shadow master 作为备份使用</li>
<li>master 正常运行时，对元数据的所有修改，都要<strong>先记录日志</strong>（WAL，write ahead log），<strong>后修改真正的内存中的元数据</strong></li>
<li>primary master 会实时向 shadow master 同步 WAL，<strong>只有 shadow master 同步日志完成，元数据的修改才算成功</strong></li>
</ul>
<p>修改过程：<br>新增的元数据日志写入本地磁盘 ——&gt; 把 WAL 传给 shadow master ——&gt; 得到反馈后正式修改 primary master 元数据</p>
<p>如何实现自动切换？<br>如果 master 宕机，会通过 Google 的 Chubby 算法（本质上是共识算法）来识别并切换到 shadow master（切换是秒级的）<br>master 的高可用机制就和 <strong>MySQL 的主备机制</strong>非常像</p>
<h4 id="chunk-的高可用设计（文件数据的高可用设计）"><a href="#chunk-的高可用设计（文件数据的高可用设计）" class="headerlink" title="chunk 的高可用设计（文件数据的高可用设计）"></a>chunk 的高可用设计（文件数据的高可用设计）</h4><p>文件被拆分为一个个 chunk 来存储，<strong>每个 chunk 都有三个副本</strong>。因此，文件数据的高可用是以 chunk 为维度来保持的。</p>
<ul>
<li><p>GFS 中，对一个 chunk 的每次写入，必须<strong>确保在三个副本中都写入完成</strong>，才视为写入完成</p>
</li>
<li><p>一个 chunk 的所有副本都会具有完整的数据</p>
</li>
<li><p>如果一个 chunkserver 宕机，其他两个副本仍然保存着这个 chunk 的数据</p>
</li>
<li><p>如果宕机的这个副本在一段时间后仍然没有恢复，那么 master 就可以在另外一个 chunkserver 中重建一个副本，从而始终把 chunk 的副本数目维持在 3 个（可以设置） </p>
</li>
<li><p>GFS 维持每个 chunk 的<strong>校验和</strong>，读取时可以通过校验和进行校验，如果校验不匹配，chunkserver 会反馈给 master 处理，master 会选择其他副本进行读取，并重建此 chunk 副本</p>
</li>
<li><p>为了减少对 master 的压力，GFS 采用了一种<strong>租约（lease）机制</strong>，把文件的读写权限下放给某一个 chunk 副本</p>
</li>
<li><p>master 可以把租约授权给某个 chunk 副本（primary），在租约生效的一段时间内（60s），对这个 chunk 的<strong>写操作直接由这个副本负责</strong></p>
</li>
<li><p>租约的主备<strong>只决定控制流走向，不影响数据流</strong></p>
</li>
</ul>
<p>chunk 副本的放置也很关键，GFS 中有三种情况需要 master 发起副本创建：</p>
<ul>
<li><strong>新建 chunk</strong></li>
<li><strong>chunk 副本复制</strong>：发现副本所在的 chunkserver 宕机，导致 chunk 副本数小于预期值，新增一个 chunk 副本</li>
<li><strong>负载均衡</strong>：master 定期对 chunkserver 进行监控，如果发现某个 chunkserver 的负载过高，则把这个 chunk 副本搬迁到别的 chunkserver 中（创建新的删除旧的）</li>
</ul>
<p>master 对副本位置的选择策略：</p>
<ul>
<li>新副本所在的 chunkserver <strong>资源利用率较低</strong></li>
<li>新副本所在的 chunkserver <strong>最近创建的 chunk 副本不多</strong>（防止 chunkserver 瞬间增加大量副本成为热点）</li>
<li>chunk 的<strong>其他副本不能在同一机架</strong>（机架&#x2F;机房级别的高可用）</li>
</ul>
<h3 id="GFS-的读写流程"><a href="#GFS-的读写流程" class="headerlink" title="GFS 的读写流程"></a>GFS 的读写流程</h3><h4 id="GFS-的写入"><a href="#GFS-的写入" class="headerlink" title="GFS 的写入"></a>GFS 的写入</h4><ul>
<li>写入时要在三个副本都完成写入后才能返回写入结果</li>
<li>采用两个非常先进的技术：<ul>
<li><strong>流水线技术</strong><br>  与流水线技术对应的是普通的<strong>主备同步</strong>，数据从 Client 到主，再从主到备这样单向流动</li>
<li><strong>数据流与控制流分离技术</strong>？<br>  Client 会把文件数据发往离自己最近的一个副本，无论它是否是 primary（持有租约），这个副本在接收到数据后，立刻向其他副本转发（边接受边转发），这样就控制了数据流的流向，节省了网络传输代价。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230412201804.png"></p>
<p>GFS 写入流程：<br>1 &amp; 2、Client 向 Master 询问要写入的 chunk 的租约在那个 chunkserver 上（Primary Replica），以及其他副本（Secondary Replicas）的位置（通常 Client 中就直接有缓存）<br>3：Client 将数据推送到所有副本上，这一步骤会用到流水线技术，就近写入且写入数据流唯一（只是将数据推送到副本 chunkserver 上，还没有正式写入）<br>4、确认所有副本都收到数据后，Client 发送正式写入的请求到 Primary Replica，Primary Replica 接收到这个请求后，会对 Chunk 上的所有操作排序，然后按照这个顺序执行写入（Primary Replica 唯一确定写入顺序，保证副本一致性）<br>5、Primary Replica 将 Chunk 写入顺序同步给 Secondary Replica（此时，在 Primary Replica 上的写入已经成功）<br>6、Secondary Replica 将写入结果返回给 Primary Replica<br>7、Primary Replica 返回写入结果给 Client</p>
<ul>
<li>所有副本写入成功：Client 确认写入完成</li>
<li>部分 Secondary Replica 写入失败&#x2F;无响应：Client 认为写入失败，从 <code>3</code> 开始重新执行<br>如果一个写入操作涉及到多个 Chunk，Client 会把它们分成多个写入来执行。</li>
</ul>
<h4 id="GFS-的读取"><a href="#GFS-的读取" class="headerlink" title="GFS 的读取"></a>GFS 的读取</h4><p><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230412210129.png"></p>
<p>1、Client 收到读取一个文件请求后，首先查看自身缓存中是否有此文件的元数据信息，如果没有，则请求 Master 获取元数据信息并存储在自身缓存中<br>2、Client 计算文件偏移量对应的 chunk<br>3、Client 向离自身最近的 chunkserver 发送请求（如果此时发现 chunkserver 中没有自己所需要的 chunk，说明 Client 缓存失效，重新请求 Master 获取最新的元数据）<br>4、读取时进行 chunk 校验和的确认，校验和不一致则选择其他副本进行读取<br>5、Client 返回应用读取结果</p>
<h3 id="GFS-的一致性模型"><a href="#GFS-的一致性模型" class="headerlink" title="GFS 的一致性模型"></a>GFS 的一致性模型</h3><h4 id="GFS-对文件系统的分层"><a href="#GFS-对文件系统的分层" class="headerlink" title="GFS 对文件系统的分层"></a>GFS 对文件系统的分层</h4><ul>
<li>consistent：一致的（无论在哪个副本读取，读到结果都一样）</li>
<li>defined：已定义的（文件发生了修改操作后，读取是一致的，且 Client 可以看到最新修改的内容，在 consistent 基础上还能与用户最新写入保持一致）</li>
<li>inconsistent：不一致的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wxshhh/hexo_gallery/main/gallery/20230412211816.png"></p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
